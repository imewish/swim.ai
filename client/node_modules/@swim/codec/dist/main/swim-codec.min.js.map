{"version":3,"sources":["../../main/Tag.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/Mark.ts","../../main/Span.ts","../../main/InputException.ts","../../main/OutputSettings.ts","../../main/OutputException.ts","../../main/Output.ts","../../main/Input.ts","../../main/StringInput.ts","../../main/StringOutput.ts","../../main/WriterException.ts","../../main/Writer.ts","../../main/StringWriter.ts","../../main/Unicode.ts","../../main/Format.ts","../../main/InputSettings.ts","../../main/InputBuffer.ts","../../main/OutputBuffer.ts","../../main/OutputStyle.ts","../../main/Base10.ts","../../main/Diagnostic.ts","../../main/ParserException.ts","../../main/Parser.ts","../../main/UtfErrorMode.ts","../../main/Uint8ArrayOutput.ts","../../main/ByteOutputUint8Array.ts","../../main/ByteOutput.ts","../../main/Binary.ts","../../main/Base16.ts","../../main/Utf8DecodedOutput.ts","../../main/Utf8EncodedOutput.ts","../../main/Utf8.ts","../../main/Base10NumberParser.ts","../../main/Base10IntegerWriter.ts","../../main/Base16Parser.ts","../../main/Base16Writer.ts","../../main/Base16IntegerWriter.ts","../../main/Base64.ts","../../main/Base64Parser.ts","../../main/Base64Writer.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","Mark","offset","line","column","note","_this","_super","call","_offset","_line","_column","_note","min","that","max","start","end","union","Tag","Span","from","_start","_end","Error","toString","shift","mark","at","equals","hashCode","_hashSeed","Murmur3","seed","mash","mix","hash","display","output","Format","displayNumber","write","debug","debugNumber","debugString","zero","_zero","tmp","InputException","message","OutputSettings","lineSeparator","isPretty","isStyled","_lineSeparator","_isPretty","_isStyled","copy","canEqual","standard","_standard","pretty","_pretty","styled","_styled","prettyStyled","_prettyStyled","fromAny","settings","OutputException","Output","writeln","string","object","flush","push","tokens","_i","arguments","length","n","i","trap","clone","full","value","_full","OutputFull","done","_done","OutputDone","error","OutputError","_value","_settings","isCont","isFull","isDone","isError","isPart","tokenOrString","bind","_error","Input","empty","id","InputSettings","_empty","InputEmpty","InputDone","InputError","_id","_mark","isEmpty","head","step","seek","StringInput","index","_string","_index","_isPart","c","codePointAt","charCodeAt","offsetByCodePoints","StringOutput","token","String","fromCharCode","u","concat","WriterException","Writer","feed","input","fork","condition","asDone","asError","andThen","WriterAndThen","WriterDone","WriterError","_output","pull","tail","_head","_tail","StringWriter","_input","Unicode","stringInput","stringOutput","stringWriter","writeString","isAlpha","isSpace","isNewline","isWhitespace","notOutput","isFinite","Math","floor","abs","digits","x","debugChar","character","encodeHex","require","os","EOL","prefix","precision","exponential","toExponential","exponentIndex","indexOf","exponent","slice","NaN","power","scaled","pow","s","trimTrailingZeros","toFixed","Prefixes","i1","i0","duration","millis","separator","weeks","days","hours","minutes","seconds","isStripped","_isStrict","stripped","_stripped","InputBuffer","_emptyBuffer","InputBufferEmpty","_doneBuffer","InputBufferDone","InputBufferError","limit","capacity","remaining","has","get","set","OutputBuffer","_fullBuffer","OutputBufferFull","OutputBufferDone","OutputBufferError","OutputStyle","reset","bold","faint","black","red","green","yellow","blue","magenta","cyan","gray","blackBold","redBold","greenBold","yellowBold","blueBold","magentaBold","cyanBold","grayBold","Base10","isDigit","decodeDigit","encodeDigit","countDigits","size","integerParser","NumberParser","parseInteger","parse","decimalParser","parseDecimal","numberParser","parseNumber","integerWriter","IntegerWriter","writeInteger","Diagnostic","tag","severity","cause","_tag","_severity","_message","_cause","lineDigits","displayDiagnostic","Severity","source","unexpected","expected","contextLines","displayMessage","displayAnchor","next","displayContext","formatSeverity","label","displayLineLeadArrow","displayLineLead","displayCause","causeOrder","Objects","equal","displayLineLeadEllipsis","displayLines","displayNote","startLine","endLine","consumeLineText","displayLine","displayLineComment","displaySingleLine","displayStartLine","displayEndLine","displayMidLine","displayLineLeadNumber","i_1","displayLineText","i_2","comment","displayLineLeadComment","padding","level","FATAL_LEVEL","ALERT_LEVEL","ERROR_LEVEL","WARNING_LEVEL","NOTE_LEVEL","INFO_LEVEL","DEBUG_LEVEL","TRACE_LEVEL","ParserException","diagnostic","Parser","ParserDone","ParserError","UtfErrorMode","isFatal","isReplacement","replacementChar","fatal","_fatal","UtfFatalErrorMode","fatalNonZero","_fatalNonZero","replacement","_replacement","UtfReplacementErrorMode","replacementNonZero","_replacementNonZero","isNonZero","_isNonZero","_replacementChar","Uint8ArrayOutput","array","_array","_limit","Uint8Array","buffer","ByteOutputUint8Array","toUint8Array","cloneArray","_size","ByteOutput","oldArray","newArray","expand","TypeError","Binary","outputBuffer","uint8ArrayOutput","initialCapacity","Base16","alphabet","_alphabet","uint8ArrayWriter","writeUint8Array","width","writeIntegerLiteral","writeLiteral","lowercase","_lowercase","uppercase","_uppercase","writeQuantum","c1","c2","y","parser","parseUint8Array","Utf8DecodedOutput","errorMode","c3","have","_errorMode","_c1","_c2","_c3","_have","c4","invalid","Utf8EncodedOutput","_c4","Utf8","sizeOf","decodedOutput","encodedOutput","decodedString","Base10NumberParser","sign","mode","_sign","_mode","_step","Base10DecimalParser","newValue","Base10IntegerWriter","Base16Parser","_p","Base16Writer","base16","_base16","undefined","Base16IntegerWriter","_width","Base64","z","w","isPadded","Base64Standard","_standardUnpadded","url","_url","Base64Url","_urlUnpadded","_isPadded","Base64Parser","base64","q","r","_base64","_q","_r","Base64Writer"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/codec/dist/main/swim-codec.min.js","sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode} from \"@swim/util\";\nimport {Mark} from \"./Mark\";\nimport {Span} from \"./Span\";\nimport {Output} from \"./Output\";\nimport {Display} from \"./Display\";\nimport {Debug} from \"./Debug\";\nimport {Format} from \"./Format\";\n\n/**\n * Description of a source location.  Tags are used to annotate input sources,\n * particularly for [[Diagnostic diagnostic]] purposes.  A [[Mark]] tag\n * annotates a source position.  A [[Span]] tag annotate a source range.\n *\n * @see [[Diagnostic]]\n */\nexport abstract class Tag implements Display, Debug, HashCode {\n  /**\n   * Returns the first source position covered by this `Tag`.\n   */\n  abstract start(): Mark;\n\n  /**\n   * Returns the last source position covered by this `Tag`.\n   */\n  abstract end(): Mark;\n\n  /**\n   * Returns a `Tag` that includes all source locations covered by\n   * both this tag, and `that` tag.\n   */\n  abstract union(that: Tag): Tag;\n\n  /**\n   * Returns the position of this `Tag` relative to the given `mark`.\n   */\n  abstract shift(mark: Mark): Tag;\n\n  abstract display(output: Output): void;\n\n  abstract debug(output: Output): void;\n\n  abstract equals(that: unknown): boolean;\n\n  abstract hashCode(): number;\n\n  // Forward type declarations\n  /** @hidden */\n  static Mark: typeof Mark; // defined by Mark\n  /** @hidden */\n  static Span: typeof Span; // defined by Span\n  /** @hidden */\n  static Format: typeof Format; // defined by Format\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Tag} from \"./Tag\";\nimport {Output} from \"./Output\";\n\n/**\n * Description of a source position, identified by byte offset, line, and\n * column number, with an optional note.\n */\nexport class Mark extends Tag {\n  /** @hidden */\n  readonly _offset: number;\n  /** @hidden */\n  readonly _line: number;\n  /** @hidden */\n  readonly _column: number;\n  /** @hidden */\n  readonly _note: string | null;\n\n  /** @hidden */\n  constructor(offset: number, line: number, column: number, note: string | null) {\n    super();\n    this._offset = offset;\n    this._line = line;\n    this._column = column;\n    this._note = note;\n  }\n\n  /**\n   * Returns the zero-based byte offset of this position.\n   */\n  offset(): number {\n    return this._offset;\n  }\n\n  /**\n   * Returns the one-based line number of this position.\n   */\n  line(): number {\n    return this._line;\n  }\n\n  /**\n   * Returns the one-based column number of this position.\n   */\n  column(): number {\n    return this._column;\n  }\n\n  /**\n   * Returns the note attached to the marked position, or `null` if this\n   * position has no attached note.\n   */\n  note(): string | null {\n    return this._note;\n  }\n\n  /**\n   * Returns `this` position, if its byte offset is less than or equal to\n   * `that` position; otherwise returns `that` position.\n   */\n  min(that: Mark): Mark {\n    if (this._offset <= that._offset) {\n      return this;\n    } else {\n      return that;\n    }\n  }\n\n  /**\n   * Returns `this` position, if its byte offset is greater than or equal to\n   * `that` position; otherwise returns `that` position.\n   */\n  max(that: Mark): Mark {\n    if (this._offset >= that._offset) {\n      return this;\n    } else {\n      return that;\n    }\n  }\n\n  start(): Mark {\n    return this;\n  }\n\n  end(): Mark {\n    return this;\n  }\n\n  union(that: Tag): Tag {\n    if (that instanceof Mark) {\n      if (this._offset === that._offset && this._line === that._line\n          && this._column === that._column) {\n        return this;\n      } else {\n        return Tag.Span.from(this, that);\n      }\n    } else if (that instanceof Tag.Span) {\n      const start = this.min(that._start);\n      const end = this.max(that._end);\n      if (start === that._start && end === that._end) {\n        return that;\n      } else {\n        return Tag.Span.from(start, end);\n      }\n    }\n    throw new Error(that.toString());\n  }\n\n  shift(mark: Mark): Mark {\n    const offset = this._offset + (this._offset - mark._offset);\n    const line = this._line + (this._line - mark._line);\n    let column = this._column;\n    if (line === 1) {\n      column += (this._column - mark._column);\n    }\n    if (offset === this._offset && line === this._line && column === this._column) {\n      return this;\n    } else {\n      return Mark.at(offset, line, column, this._note);\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Mark) {\n      return this._offset === that._offset && this._line === that._line\n          && this._column === that._column && this._note === that._note;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (Mark._hashSeed === void 0) {\n      Mark._hashSeed = Murmur3.seed(Mark);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.mix(Mark._hashSeed,\n        this._offset), this._line), this._column), Murmur3.hash(this._note)));\n  }\n\n  display(output: Output): void {\n    Tag.Format.displayNumber(this._line, output);\n    output = output.write(58/*':'*/);\n    Tag.Format.displayNumber(this._column, output);\n    if (this._note !== null) {\n      output = output.write(58/*':'*/).write(32/*' '*/).write(this._note);\n    }\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Mark\").write(\".\").write(\"at\").write(\"(\");\n    Tag.Format.debugNumber(this._offset, output);\n    output = output.write(\", \");\n    Tag.Format.debugNumber(this._line, output);\n    output = output.write(\", \");\n    Tag.Format.debugNumber(this._column, output);\n    if (this._note !== null) {\n      output = output.write(\", \");\n      Tag.Format.debugString(this._note, output);\n    }\n    output = output.write(\")\");\n  }\n\n  toString(): string {\n    return Tag.Format.display(this);\n  }\n\n  private static _hashSeed?: number;\n  private static _zero?: Mark;\n\n  /**\n   * Returns a `Mark` at byte offset `0`, line `1`, and column `1`, with no\n   * attached note.\n   */\n  static zero(): Mark {\n    if (!Mark._zero) {\n      Mark._zero = new Mark(0, 1, 1, null);\n    }\n    return Mark._zero;\n  }\n\n  /**\n   * Returns a new `Mark` at the given zero-based byte `offset`, one-based\n   * `line` number, and one-based `column` number, with an optionally attached\n   * `note`.\n   */\n  static at(offset: number, line: number, column: number, note: string | null = null): Mark {\n    return new Mark(offset, line, column, note);\n  }\n}\nTag.Mark = Mark;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3} from \"@swim/util\";\nimport {Tag} from \"./Tag\";\nimport {Mark} from \"./Mark\";\nimport {Output} from \"./Output\";\n\n/**\n * Description of a source range, identified by a closed interval between start\n * and end [[Mark marks]].\n */\nexport class Span extends Tag {\n  /** @hidden */\n  readonly _start: Mark;\n  /** @hidden */\n  readonly _end: Mark;\n\n  /** @hidden */\n  constructor(start: Mark, end: Mark) {\n    super();\n    this._start = start;\n    this._end = end;\n  }\n\n  start(): Mark {\n    return this._start;\n  }\n\n  end(): Mark {\n    return this._end;\n  }\n\n  union(that: Tag): Tag {\n    if (that instanceof Tag.Mark) {\n      const start = this._start.min(that);\n      const end = this._end.max(that);\n      if (start === this._start && end === this._end) {\n        return this;\n      } else {\n        return Span.from(start, end);\n      }\n    } else if (that instanceof Span) {\n      const start = this._start.min(that._start);\n      const end = this._end.max(that._end);\n      if (start === this._start && end === this._end) {\n        return this;\n      } else {\n        return Span.from(start, end);\n      }\n    }\n    throw new Error(that.toString());\n  }\n\n  shift(mark: Mark): Span {\n    const start = this._start.shift(mark);\n    const end = this._end.shift(mark);\n    if (start === this._start && end === this._end) {\n      return this;\n    } else {\n      return Span.from(start, end);\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Span) {\n      return this._start.equals(that._start) && this._end.equals(that._end);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (Span._hashSeed === void 0) {\n      Span._hashSeed = Murmur3.seed(Span);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Span._hashSeed,\n        this._start.hashCode()), this._end.hashCode()));\n  }\n\n  display(output: Output): void {\n    if (this._start._note !== null) {\n      output = output.write(this._start._note).write(58/*':'*/).write(32/*' '*/);\n    }\n    Tag.Format.displayNumber(this._start._line, output);\n    output = output.write(58/*':'*/);\n    Tag.Format.displayNumber(this._start._column, output);\n    output = output.write(45/*'-'*/);\n    Tag.Format.displayNumber(this._end._line, output);\n    output = output.write(58/*':'*/);\n    Tag.Format.displayNumber(this._end._column, output);\n    if (this._end._note !== null) {\n      output = output.write(58/*':'*/).write(32/*' '*/).write(this._end._note);\n    }\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Span\").write(\".\").write(\"from\").write(\"(\");\n    this._start.debug(output);\n    output = output.write(\", \");\n    this._end.debug(output);\n    output = output.write(\")\");\n  }\n\n  toString(): string {\n    return Tag.Format.display(this);\n  }\n\n  private static _hashSeed?: number;\n\n  /**\n   * Returns a new `Span` representing the closed interval between the given\n   * `start` and `end` marks.\n   */\n  static from(start: Mark, end: Mark): Span {\n    if (start._offset > end._offset) {\n      const tmp = start;\n      start = end;\n      end = tmp;\n    }\n    return new Span(start, end);\n  }\n}\nTag.Span = Span;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when reading invalid [[Input]].\n */\nexport class InputException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = InputException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode, Murmur3} from \"@swim/util\";\nimport {Output} from \"./Output\";\nimport {Format} from \"./Format\";\nimport {Debug} from \"./Debug\";\n\n/**\n * Either an [[OutputSettings]] instance, or an [[OutputSettingsInit]] object\n * initializer.\n */\nexport type AnyOutputSettings = OutputSettings | OutputSettingsInit;\n\n/**\n * [[OutputSettings]] object initializer.\n */\nexport interface OutputSettingsInit {\n  lineSeparator?: string | null;\n  isPretty?: boolean;\n  isStyled?: boolean;\n}\n\n/**\n * [[Output]] production parameters.  `OutputSettings` provide contextual\n * configuration parameters to output producers, such as [[Writer Writers]].\n * Uses include enabling pretty printing and styling generated output.\n * Subclasses can provide additional parameters understood by specialized\n * output producers.\n */\nexport class OutputSettings implements Debug, HashCode {\n  /** @hidden */\n  readonly _lineSeparator: string;\n  /** @hidden */\n  readonly _isPretty: boolean;\n  /** @hidden */\n  readonly _isStyled: boolean;\n\n  protected constructor(lineSeparator: string, isPretty: boolean, isStyled: boolean) {\n    this._lineSeparator = lineSeparator;\n    this._isPretty = isPretty;\n    this._isStyled = isStyled;\n  }\n\n  /**\n   * Returns the code point sequence used to separate lines of text.\n   * Defaults to the operating system's line separator.\n   */\n  lineSeparator(): string;\n\n  /**\n   * Returns a copy of these settings with the given `lineSeparator`.\n   */\n  lineSeparator(lineSeparator: string | null): OutputSettings;\n\n  lineSeparator(lineSeparator?: string | null): string | OutputSettings {\n    if (lineSeparator === void 0) {\n      return this._lineSeparator;\n    } else {\n      return this.copy(lineSeparator, this._isPretty, this._isStyled);\n    }\n  }\n\n  /**\n   * Returns `true` if output producers should pretty print their output,\n   * when possible.\n   */\n  isPretty(): boolean;\n\n  /**\n   * Returns a copy of these settings with the given `isPretty` flag.\n   */\n  isPretty(isPretty: boolean): OutputSettings;\n\n  isPretty(isPretty?: boolean): boolean | OutputSettings {\n    if (isPretty === void 0) {\n      return this._isPretty;\n    } else {\n      return this.copy(this._lineSeparator, isPretty, this._isStyled);\n    }\n  }\n\n  /**\n   * Returns `true` if output producers should style their output,\n   * when possible.\n   */\n  isStyled(): boolean;\n\n  /**\n   * Returns a copy of these settings with the given `isStyled` flag.\n   */\n  isStyled(isStyled: boolean): OutputSettings;\n\n  isStyled(isStyled?: boolean): boolean | OutputSettings {\n    if (isStyled === void 0) {\n      return this._isStyled;\n    } else {\n      return this.copy(this._lineSeparator, this._isPretty, isStyled);\n    }\n  }\n\n  protected copy(lineSeparator: string | null, isPretty: boolean, isStyled: boolean): OutputSettings {\n    return OutputSettings.create(lineSeparator, isPretty, isStyled);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof OutputSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof OutputSettings) {\n      return that.canEqual(this) && this._lineSeparator === that._lineSeparator\n          && this._isPretty === that._isPretty && this._isStyled === that._isStyled;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (OutputSettings._hashSeed === void 0) {\n      OutputSettings._hashSeed = Murmur3.seed(OutputSettings);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(OutputSettings._hashSeed,\n        Murmur3.hash(this._lineSeparator)), Murmur3.hash(this._isPretty)),\n        Murmur3.hash(this._isStyled)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"OutputSettings\").write(46/*'.'*/);\n    if (!this._isPretty && !this._isStyled) {\n      output = output.write(\"standard\");\n    } else if (this._isPretty && !this._isStyled) {\n      output = output.write(\"pretty\");\n    } else if (!this._isPretty && this._isStyled) {\n      output = output.write(\"styled\");\n    } else {\n      output = output.write(\"prettyStyled\");\n    }\n    output = output.write(40/*'('*/).write(41/*')'*/);\n    if (Format.lineSeparator() !== this._lineSeparator) {\n      output = output.write(46/*'.'*/).write(\"lineSeparator\").write(40/*'('*/)\n          .display(this._lineSeparator).write(41/*')'*/);\n    }\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  private static _hashSeed?: number;\n  private static _standard?: OutputSettings;\n  private static _pretty?: OutputSettings;\n  private static _styled?: OutputSettings;\n  private static _prettyStyled?: OutputSettings;\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing disabled, and styling disabled.\n   */\n  static standard(): OutputSettings {\n    if (!OutputSettings._standard) {\n      OutputSettings._standard = new OutputSettings(Format.lineSeparator(), false, false);\n    }\n    return OutputSettings._standard;\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing enabled, and styling disabled.\n   */\n  static pretty(): OutputSettings {\n    if (!OutputSettings._pretty) {\n      OutputSettings._pretty = new OutputSettings(Format.lineSeparator(), true, false);\n    }\n    return OutputSettings._pretty;\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing disabled, and styling enabled.\n   */\n  static styled(): OutputSettings {\n    if (!OutputSettings._styled) {\n      OutputSettings._styled = new OutputSettings(Format.lineSeparator(), false, true);\n    }\n    return OutputSettings._styled;\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the system line separator,\n   * pretty printing enabled, and styling enabled.\n   */\n  static prettyStyled(): OutputSettings {\n    if (!OutputSettings._prettyStyled) {\n      OutputSettings._prettyStyled = new OutputSettings(Format.lineSeparator(), true, true);\n    }\n    return OutputSettings._prettyStyled;\n  }\n\n  /**\n   * Returns `OutputSettings` configured with the given `lineSeparator`, pretty\n   * rinting enabled if `isPretty` is `true`, and styling enabled if `isStyled`\n   * is `true`.\n   */\n  static create(lineSeparator?: string | null, isPretty?: boolean, isStyled?: boolean): OutputSettings {\n    if (typeof lineSeparator !== \"string\") {\n      lineSeparator = Format.lineSeparator();\n    }\n    if (typeof isPretty !== \"boolean\") {\n      isPretty = false;\n    }\n    if (typeof isStyled !== \"boolean\") {\n      isStyled = false;\n    }\n    if (Format.lineSeparator() === lineSeparator) {\n      if (!isPretty && !isStyled) {\n        return OutputSettings.standard();\n      } else if (isPretty && !isStyled) {\n        return OutputSettings.pretty();\n      } else if (!isPretty && isStyled) {\n        return OutputSettings.styled();\n      } else {\n        return OutputSettings.prettyStyled();\n      }\n    }\n    return new OutputSettings(lineSeparator, isPretty, isStyled);\n  }\n\n  /**\n   * Converts the loosely typed `settings` to an instance of `OutputSettings`.\n   */\n  static fromAny(settings: AnyOutputSettings | undefined): OutputSettings {\n    if (settings instanceof OutputSettings) {\n      return settings;\n    } else if (typeof settings === \"object\" && settings) {\n      return OutputSettings.create(settings.lineSeparator, settings.isPretty, settings.isStyled);\n    }\n    return OutputSettings.standard();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when writing invalid [[Output]].\n */\nexport class OutputException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = OutputException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Format} from \"./Format\";\nimport {OutputException} from \"./OutputException\";\n\n/**\n * Non-blocking token stream writer.  `Output` enables incremental,\n * interruptible writing of network protocols and data formats.\n *\n * ### Output tokens\n * Output tokens are modeled as primitive numbers, commonly representing\n * Unicode code points, or raw octets; each `Output` implementation specifies\n * the semantic type of its tokens.\n *\n * ### Output states\n * An `Output` writer is always in one of three states: _cont_​inue, _full_,\n * or _done_.  The _cont_ state indicates that the stream is ready to write a\n * single token; the _full_ state indicates that the stream is unable to write\n * additional tokens at this time, but that the stream may logically resume at\n * some point in the future; and the _done_ state indicates that the stream has\n * terminated, and that [[bind]] will return the output result.  [[isCont]]\n * returns `true` when in the _cont_ state; [[isFull]] returns `true` when in\n * the _full_ state; and [[isDone]] returns `true` when in the _done_ state.\n *\n * ### Output results\n * An `Output` writer yields a value of type `T`, obtained via the [[bind]]\n * method, representing some implementation defined result of writing the\n * output.  For example, an `Output<string>` implementation may–but is not\n * required to–yield a `string` containing all code points written to the\n * output.\n *\n * ### Non-blocking behavior\n * `Output` writers never block.  An `Output` writer that would otherwise block\n * writing additional output instead enters the _full_ state, signaling the\n * output generator to back off producing the output, but to remain prepared to\n * produce additional output in the future.  An `Output` writer enters the\n * _done_ state when it encounters the final end of its output, signaling to\n * the output generator to stop producing.\n *\n * ### Output settings\n * An output generator may alter the tokens it produces based on its `Output`\n * writer's [[settings]].  Uses include pretty printing and styling generated\n * output.  [[OutputSettings]] subclasses can provide additional parameters\n * understood by specialized output producers.\n *\n * ### Cloning\n * An `Output` writer may be [[clone cloned]] to branch the token stream in an\n * implementation specified manner.  Not all `Output` implementations support\n * cloning.\n *\n * @see [[OutputSettings]]\n * @see [[Writer]]\n */\nexport abstract class Output<T = unknown> implements Builder<number, T> {\n  /**\n   * Returns `true` when the next [[write write(number)]] will succeed.\n   * i.e. this `Output` is in the _cont_ state.\n   */\n  abstract isCont(): boolean;\n\n  /**\n   * Returns `true` when an immediate `write` will fail, but writes may succeed\n   * at some point in the future.  i.e. this `Output` is in the _full_ state.\n   */\n  abstract isFull(): boolean;\n\n  /**\n   * Returns `true` when no `write` will ever again suucced.\n   * i.e. this `Output` is in the _done_ state.\n   */\n  abstract isDone(): boolean;\n\n  /**\n   * Returns `true` when an immediate `write` will fail due to an\n   * error with the token stream. i.e. this `Output` is in the `error` state.\n   * When `true`, `trap()` will return the output error.\n   */\n  abstract isError(): boolean;\n\n  /**\n   * Returns `true` if this is a partial `Output` that will enter\n   * the `full` state when it is unable to write additional tokens.\n   */\n  abstract isPart(): boolean;\n\n  /**\n   * Returns a partial `Output` equivalent to this `Output`, if\n   * `isPart` is `true`; returns a final `Output` equivalent\n   * to this `Output` if `isPart` is `false`. The caller's reference\n   * to `this` `Output` should be replaced by the returned `Output`.\n   */\n  abstract isPart(isPart: boolean): Output<T>;\n\n  /**\n   * Writes a single `token` to the stream, if this `Output` is in the\n   * _cont_ state.\n   *\n   * @return `this`\n   * @throws [[OutputException]] if this `Output` is not in the _cont_ state.\n   */\n  abstract write(token: number): Output<T>;\n\n  /**\n   * Writes the code points of the given `string`.  Assumes this is a Unicode\n   * `Output` writer with sufficient capacity.\n   *\n   * @return `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full `string` has been written.\n   */\n  abstract write(string: string): Output<T>;\n\n  /**\n   * Writes the code points of the given `string`, followed by the code points\n   * of the `settings`' [[OutputSettings.lineSeparator line separator].\n   * Assumes this is a Unicode `Output` writer with sufficient capacity.\n   *\n   * @return `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full `string` and line separator has been written.\n   */\n  writeln(string?: string): Output<T> {\n    if (typeof string === \"string\") {\n      this.write(string);\n    }\n    return this.write(this.settings().lineSeparator());\n  }\n\n  /**\n   * Writes the code points of the human-readable [[Display]] string of the\n   * given `object`.  Assumes this is a Unicode `Output` writer with sufficient\n   * capacity.\n   *\n   * @return `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full display string has been written.\n   */\n  display(object: unknown): Output<T> {\n    Format.display(object, this);\n    return this;\n  }\n\n  /**\n   * Writes the code points of the developer-readable [[Debug]] string of the\n   * given `object`.  Assumes this is a Unicode `Output` writer with sufficient\n   * capacity.\n   *\n   * @return `this`\n   * @throws [[OutputException]] if this `Output` exits the _cont_ state before\n   *         the full debug string has been written.\n   */\n  debug(object: unknown): Output<T> {\n    Format.debug(object, this);\n    return this;\n  }\n\n  /**\n   * Writes any internally buffered state to the underlying output stream.\n   */\n  flush(): Output<T> {\n    return this;\n  }\n\n  push(...tokens: number[]): void {\n    const n = tokens.length;\n    for (let i = 0; i < n; i += 1) {\n      this.write(tokens[i]);\n    }\n  }\n\n  /**\n   * Returns the `OutputSettings` used to configure the behavior of output\n   * producers that write to this `Output`.\n   */\n  abstract settings(): OutputSettings;\n\n  /**\n   * Updates the `settings` associated with this `Output`.\n   *\n   * @return `this`\n   */\n  abstract settings(settings: AnyOutputSettings): Output<T>;\n\n  /**\n   * Returns the implementation-defined result of writing the output.\n   */\n  abstract bind(): T;\n\n  /**\n   * Returns the output error. Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws OutputException if this `Output` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new OutputException();\n  }\n\n  /**\n   * Returns an implementation-defined branch of the token stream.\n   *\n   * @throws `Error` if this `Output` writer cannot be cloned.\n   */\n  clone(): Output<T> {\n    throw new Error();\n  }\n\n  private static _full: Output<any>;\n\n  private static _done: Output<any>;\n\n  /**\n   * Return an `Output` in the _full_ state, that binds the given `value`,\n   * with the given `settings`.\n   */\n  static full<T>(value: T | null = null, settings: OutputSettings = OutputSettings.standard()): Output<T> {\n    if (value === null && settings === OutputSettings.standard()) {\n      if (!Output._full) {\n        Output._full = new OutputFull(value, OutputSettings.standard());\n      }\n      return Output._full;\n    }\n    return new OutputFull<T>(value!, settings);\n\n  }\n\n  /**\n   * Returns an `Output` in the _done_ state, that binds the given `value`,\n   * with the given `settings`.\n   */\n  static done<T>(value: T | null = null, settings: OutputSettings = OutputSettings.standard()): Output<T> {\n    if (value === null && settings === OutputSettings.standard()) {\n      if (!Output._done) {\n        Output._done = new OutputDone(value, OutputSettings.standard());\n      }\n      return Output._done;\n    }\n    return new OutputDone<T>(value!, settings);\n  }\n\n  /**\n   * Return an `Output` in the _error_ state, that binds the given `value`,\n   * with the given `settings`.\n   */\n  static error<T>(error: Error, settings: OutputSettings = OutputSettings.standard()): Output<T> {\n    return new OutputError<T>(error, settings);\n  }\n}\n\n/** @hidden */\nclass OutputFull<T> extends Output<T> {\n  /** @hidden */\n  readonly _value: T;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(value: T, settings: OutputSettings) {\n    super();\n    this._value = value;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return true;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return true;\n    } else if (isPart) {\n      return Output.done(this._value, this._settings);\n    } else {\n      return this;\n    }\n  }\n\n  write(token: number): Output<T>;\n  write(string: string): Output<T>;\n  write(tokenOrString: number | string): Output<T> {\n    return Output.error(new OutputException(\"full\"), this._settings);\n  }\n\n  writeln(string?: string): Output<T> {\n    return Output.error(new OutputException(\"full\"), this._settings);\n  }\n\n  bind(): T {\n    return this._value;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): Output<T>;\n  settings(settings?: OutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Output.full(this._value, settings);\n    }\n  }\n\n  clone(): Output<T> {\n    return this;\n  }\n}\n\n/** @hidden */\nclass OutputDone<T> extends Output<T> {\n  /** @hidden */\n  readonly _value: T;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(value: T, settings: OutputSettings) {\n    super();\n    this._value = value;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return false;\n    } else if (isPart) {\n      return this;\n    } else {\n      return Output.full(this._value, this._settings);\n    }\n  }\n\n  write(token: number): Output<T>;\n  write(string: string): Output<T>;\n  write(tokenOrString: number | string): Output<T> {\n    return Output.error(new OutputException(\"done\"), this._settings);\n  }\n\n  writeln(string?: string): Output<T> {\n    return Output.error(new OutputException(\"done\"), this._settings);\n  }\n\n  bind(): T {\n    return this._value;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): Output<T>;\n  settings(settings?: OutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Output.done(this._value, settings);\n    }\n  }\n\n  clone(): Output<T> {\n    return this;\n  }\n}\n\n/** @hidden */\nclass OutputError<T> extends Output<T> {\n  /** @hidden */\n  readonly _error: Error;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(error: Error, settings: OutputSettings) {\n    super();\n    this._error = error;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  write(token: number): Output<T>;\n  write(string: string): Output<T>;\n  write(tokenOrString: number | string): Output<T> {\n    return this;\n  }\n\n  writeln(string?: string): Output<T> {\n    return this;\n  }\n\n  bind(): T {\n    throw new OutputException();\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): Output<T>;\n  settings(settings?: OutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Output.error(this._error, settings);\n    }\n  }\n\n  clone(): Output<T> {\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Mark} from \"./Mark\";\nimport {InputException} from \"./InputException\";\nimport {AnyInputSettings, InputSettings} from \"./InputSettings\";\n\n/**\n * Non-blocking token stream reader, with single token lookahead.\n * `Input` enables incremental, interruptible parsing of network protocols and\n * data formats.\n *\n * ### Input tokens\n * Input tokens are modeled as primitive numbers, commonly representing Unicode\n * code points, or raw octets; each `Input` implementation specifies the\n * semantic type of its tokens.  The [[head]]  method peeks at the lookahead\n * token, without consuming it, and the [[step]] method advances the input to\n * the next token.\n *\n * ### Input states\n * An `Input` reader is always in one of three states: _cont_​inue, _empty_, or\n * _done_.  The _cont_ state indicates that a lookahead token is immediately\n * available; the _empty_ state indicates that no additional tokens are\n * available at this time, but that the stream may logically resume at some\n * point in the future; and the _done_ state indicates that the stream has\n * terminated.  [[isCont]] returns `true` when in the _cont_ state; [[isEmpty]]\n * returns `true` when in the _empty_ state; and [[isDone]] returns `true` when\n * in the _done_ state.\n *\n * ### Non-blocking behavior\n * `Input` readers never block.  An `Input` reader that would otherwise block\n * awaiting additional input instead enters the _empty_ state, signaling the\n * input consumer to back off processing the input, but to remain prepared to\n * process additional input in the future.  An `Input` reader enters the _done_\n * state when it encounters the final end of its input, signaling the input\n * consumer to stop processing.  [[Input.empty]] returns an `Input` reader in\n * the _empty_ state.  [[Input.done]] returns an `Input` reader in the _done_\n * state.\n *\n * ### Position tracking\n * The logical position of the lookahead token is made available via the\n * [[mark]] method, with optimized callouts for the byte [[offset]], one-based\n * [[line]] number, and one-based [[column]] in the current line.  The [[id]]\n * method returns a diagnostic identifier for the token stream.\n *\n * ### Cloning\n * An `Input` reader may be [[clone cloned]] to provide an indepently mutable\n * position into a shared token stream.  Not all `Input` implementations\n * support cloning.\n *\n * @see [[InputSettings]]\n * @see [[Parser]]\n */\nexport abstract class Input {\n  /**\n   * Returns `true` when a [[head lookahead]] token is immediately available.\n   * i.e. this `Input` is in the _cont_ state.\n   */\n  abstract isCont(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available, but\n   * additional input may be available at some point in the future.  i.e. this\n   * `Input` is in the _empty_ state.\n   */\n  abstract isEmpty(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available, and\n   * no additional input will ever become available.  i.e. this `Input` is in\n   * the _done_ state.\n   */\n  abstract isDone(): boolean;\n\n  /**\n   * Returns `true` when no lookahead token is currently available due to\n   * an error with the token stream. i.e. this `Input` is in the `error` state.\n   * When `true`, `trap()` will return the input error\n   */\n  abstract isError(): boolean;\n\n  /**\n   * Returns `true` if this is a partial `Input` will that enter\n   * the `empty` state after it consumes the last available input token.\n   */\n  abstract isPart(): boolean;\n\n   /**\n    * Returns a partial `Input` equivalent to this `Input`, if\n    * `isPart` is `true`; returns a final `Input` equivalent\n    * to this `Input` if `isPart` is `false`. The caller's reference\n    * to `this` `Input` should be replaced by the returned `Input`\n    */\n  abstract isPart(isPart: boolean): Input;\n\n  /**\n   * Returns the current lookahead token, if this `Input` is in the\n   * _cont_ state.\n   *\n   * @throws [[InputException]] if this `Input` is not in the _cont_ state.\n   */\n  abstract head(): number;\n\n  /**\n   * Advances to the next token, if this `Input` is in the _cont_ state.\n   *\n   * @throws `Error` if this `Input` is not in the _cont_ state.\n   */\n  abstract step(): Input;\n\n  /**\n   * Sets the position of this `Input` to the given `mark`.  Rewinds to the\n   * start of this `Input`, if `mark` is `undefined`.\n   *\n   * @throws [[InputException]] if this `Input` does not support seeking,\n   *         or is unable to reposition to the `mark`.\n   */\n  abstract seek(mark?: Mark): Input;\n\n  /**\n   * Returns the input error. Only guaranteed to return an error when in the\n   * _ error_ state\n   *\n   * @throws InputException if the `Input` is not the _error_state\n   */\n  trap(): Error {\n    throw new InputException();\n  }\n\n  /**\n   * Returns an object that identifies the token stream, or `null` if the\n   * stream is unidentified.\n   */\n  abstract id(): unknown | null;\n\n  /**\n   * Returns an `Input` equivalent to this `Input`, but logically identified by\n   * the given–possibly `null`–`id`.  The caller's reference to `this` `Input}`\n   * should be replaced by the returned `Input}`.\n   */\n  abstract id(id: unknown | null): Input;\n\n  /**\n   * Returns the position of the current lookahead token, relative to the start\n   * of the stream.\n   */\n  abstract mark(): Mark;\n\n  /**\n   * Returns an `Input` equivalent to this `Input`, but logically positioned at\n   * the given `mark`.  The physical position in the input stream is not\n   * modified.  The caller's reference to `this` `Input` should be replaced by\n   * the returned `Input`.\n   */\n  abstract mark(mark: Mark): Input;\n\n  /**\n   * Returns the byte offset of the current lookahead token, relative to the\n   * start of the stream.\n   */\n  offset(): number {\n    return this.mark()._offset;\n  }\n\n  /**\n   * Returns the one-based line number of the current lookahead token, relative\n   * to the start of the stream.\n   */\n  line(): number {\n    return this.mark()._line;\n  }\n\n  /**\n   * Returns the one-based column number of the current lookahead token,\n   * relative to the current line in the stream.\n   */\n  column(): number {\n    return this.mark()._column;\n  }\n\n  /**\n   * Returns the `InputSettings` used to configure the behavior of input\n   * consumers that read from this `Input`.\n   */\n  abstract settings(): InputSettings;\n\n  /**\n   * Returns a clone of this `Input` with the given `settings`.\n   *\n   * @throws `Error` if this `Input` reader cannot be cloned.\n   */\n  abstract settings(settings: AnyInputSettings): Input;\n\n  /**\n   * Returns an independently positioned view into the token stream,\n   * initialized with identical state to this `Input`.\n   *\n   * @throws `Error` if this `Input` reader cannot be cloned.\n   */\n  abstract clone(): Input;\n\n  private static _empty: Input;\n\n  private static _done: Input;\n\n  /**\n   * Returns an `Input` reader in the _empty_ state, with the given `settings`,\n   * at the `mark` position of a token stream logically identified by `id`.\n   */\n  static empty(id: unknown | null = null, mark: Mark = Mark.zero(),\n               settings: InputSettings = InputSettings.standard()): Input {\n    if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {\n      if (!Input._empty) {\n        Input._empty = new InputEmpty(null, Mark.zero(), InputSettings.standard());\n      }\n      return Input._empty;\n    }\n    return new InputEmpty(id, mark, settings);\n  }\n\n  /**\n   * Returns an `Input` reader in the _done_ state, with the given `settings`,\n   * at the `mark` position of a token stream logically identified by `id`.\n   */\n  static done(id: unknown | null = null, mark: Mark = Mark.zero(),\n              settings: InputSettings = InputSettings.standard()): Input {\n    if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {\n      if (!Input._done) {\n        Input._done = new InputDone(null, Mark.zero(), InputSettings.standard());\n      }\n      return Input._done;\n    }\n    return new InputDone(id, mark, settings);\n  }\n\n  /**\n   * Returns an `Input` in the _error_ state, with the given `settings`,\n   * at the `mark` position of a token stream logically identified by `id`.\n   */\n  static error(error: Error, id: unknown | null = null, mark: Mark = Mark.zero(),\n               settings: InputSettings = InputSettings.standard()): Input {\n    return new InputError(error, id, mark, settings);\n  }\n}\n\n/** @hidden */\nclass InputEmpty extends Input {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n\n  constructor(id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Input;\n  isPart(isPart?: boolean): boolean | Input {\n    if (isPart === void 0) {\n      return true;\n    } else if (isPart) {\n      return this;\n    } else {\n      return Input.done(this._id, this._mark, this._settings);\n    }\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(): Input {\n    const error = new InputException(\"empty step\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  seek(mark?: Mark): Input {\n    const error = new InputException(\"empty seek\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): Input;\n  id(id?: unknown | null): unknown | null | Input {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return Input.empty(id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): Input;\n  mark(mark?: Mark): Mark | Input {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return Input.empty(this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): Input;\n  settings(settings?: InputSettings): InputSettings | Input {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Input.empty(this._id, this._mark, settings);\n    }\n  }\n\n  clone(): Input {\n    return this;\n  }\n}\n\n/** @hidden */\nclass InputDone extends Input {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n\n  constructor(id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Input;\n  isPart(isPart?: boolean): boolean | Input {\n    if (isPart === void 0) {\n      return false;\n    } else if (isPart) {\n      return Input.empty(this._id, this._mark, this._settings);\n    } else {\n      return this;\n    }\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(): Input {\n    const error = new InputException(\"done step\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  seek(mark?: Mark): Input {\n    const error = new InputException(\"empty seek\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): Input;\n  id(id?: unknown | null): unknown | null | Input {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return Input.done(id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): Input;\n  mark(mark?: Mark): Mark | Input {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return Input.done(this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): Input;\n  settings(settings?: InputSettings): InputSettings | Input {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Input.done(this._id, this._mark, settings);\n    }\n  }\n\n  clone(): Input {\n    return this;\n  }\n}\n\n/** @hidden */\nclass InputError extends Input {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n  /** @hidden */\n  readonly _error: Error;\n\n  constructor(error: Error, id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._error = error;\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Input;\n  isPart(isPart?: boolean): boolean | Input {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(): Input {\n    const error = new InputException(\"error step\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  seek(mark?: Mark): Input {\n    const error = new InputException(\"error seek\");\n    return Input.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): Input;\n  id(id?: unknown | null): unknown | null | Input {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return Input.error(this._error, id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): Input;\n  mark(mark?: Mark): Mark | Input {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return Input.error(this._error, this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): Input;\n  settings(settings?: InputSettings): InputSettings | Input {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return Input.error(this._error, this._id, this._mark, settings);\n    }\n  }\n\n  clone(): Input {\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Mark} from \"./Mark\";\nimport {InputException} from \"./InputException\";\nimport {AnyInputSettings, InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\n\n/** @hidden */\nexport class StringInput extends Input {\n  /** @hidden */\n  readonly _string: string;\n  /** @hidden */\n  _id: unknown | null;\n  /** @hidden */\n  _offset: number;\n  /** @hidden */\n  _line: number;\n  /** @hidden */\n  _column: number;\n  /** @hidden */\n  _settings: InputSettings;\n  /** @hidden */\n  _index: number;\n  /** @hidden */\n  _isPart: boolean;\n\n  constructor(string: string, id: unknown | null = null, offset: number = 0,\n              line: number = 1, column: number = 1, settings: InputSettings = InputSettings.standard(),\n              index: number = 0, isPart: boolean = false) {\n    super();\n    this._string = string;\n    this._id = id;\n    this._offset = offset;\n    this._line = line;\n    this._column = column;\n    this._settings = settings;\n    this._index = index;\n    this._isPart = isPart;\n  }\n\n  isCont(): boolean {\n    return this._index < this._string.length;\n  }\n\n  isEmpty(): boolean {\n    return this._isPart && this._index >= this._string.length;\n  }\n\n  isDone(): boolean {\n    return !this._isPart && this._index >= this._string.length;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Input;\n  isPart(isPart?: boolean): boolean | Input {\n    if (isPart === void 0) {\n      return this._isPart;\n    } else {\n      this._isPart = isPart;\n      return this;\n    }\n  }\n\n  head(): number {\n    if (this._index < this._string.length) {\n      const c = this._string.codePointAt(this._index);\n      if (c !== void 0) {\n        return c;\n      } else {\n        return this._string.charCodeAt(this._index);\n      }\n    }\n    throw new InputException();\n  }\n\n  step(): Input {\n    const index = this._index;\n    if (index < this._string.length) {\n      const c = this._string.codePointAt(index);\n      this._index = this._string.offsetByCodePoints(index, 1);\n      this._offset += this._index - index;\n      if (c === 10/*'\\n'*/) {\n        this._line += 1;\n        this._column = 1;\n      } else {\n        this._column += 1;\n      }\n      return this;\n    } else {\n      const error = new InputException(\"invalid step\");\n      return Input.error(error, this._id, this.mark(), this._settings);\n    }\n  }\n\n  seek(mark?: Mark): Input {\n    if (mark !== void 0) {\n      const index = this._index + (mark._offset - this._offset);\n      if (0 <= index && index <= this._string.length) {\n        this._offset = mark._offset;\n        this._line = mark._line;\n        this._column = mark._column;\n        this._index = index;\n        return this;\n      } else {\n        const error = new InputException(\"invalid seek to \" + mark);\n        return Input.error(error, this._id, this.mark(), this._settings);\n      }\n    } else {\n      this._offset = 0;\n      this._line = 1;\n      this._column = 1;\n      this._index = 0;\n      return this;\n    }\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): Input;\n  id(id?: unknown | null): unknown | null | Input {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      this._id = id;\n      return this;\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): Input;\n  mark(mark?: Mark): Mark | Input {\n    if (mark === void 0) {\n      return Mark.at(this._offset, this._line, this._column);\n    } else {\n      this._offset = mark._offset;\n      this._line = mark._line;\n      this._column = mark._column;\n      return this;\n    }\n  }\n\n  offset(): number {\n    return this._offset;\n  }\n\n  line(): number {\n    return this._line;\n  }\n\n  column(): number {\n    return this._column;\n  }\n\n  settings(): InputSettings;\n  settings(settings: AnyInputSettings): Input;\n  settings(settings?: AnyInputSettings): InputSettings | Input {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = InputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  clone(): Input {\n    return new StringInput(this._string, this._id, this._offset, this._line,\n                           this._column, this._settings, this._index, this._isPart);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\n\n/** @hidden */\nexport class StringOutput extends Output<string> {\n  /** @hidden */\n  _string: string;\n  /** @hidden */\n  _settings: OutputSettings;\n\n  constructor(string: string, settings: OutputSettings) {\n    super();\n    this._string = string;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return true;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<string>;\n  isPart(isPart?: boolean): boolean | Output<string> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  write(token: number | string): Output<string> {\n    if (typeof token === \"number\") {\n      if ((token >= 0x0000 && token <= 0xd7ff)\n          || (token >= 0xe000 && token <= 0xffff)) { // U+0000..U+D7FF | U+E000..U+FFFF\n        token = String.fromCharCode(token);\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        const u = token - 0x10000;\n        token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));\n      } else { // invalid code point\n        token = \"\\ufffd\";\n      }\n    }\n    this._string += token;\n    return this;\n  }\n\n  writeln(string?: string): Output<string> {\n    if (string === void 0) {\n      this._string = this._string.concat(this._settings._lineSeparator);\n      return this;\n    } else {\n      this._string = this._string.concat(string).concat(this._settings._lineSeparator);\n      return this;\n    }\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<string>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<string> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = OutputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  bind(): string {\n    return this._string;\n  }\n\n  clone(): Output<string> {\n    return new StringOutput(this._string, this._settings);\n  }\n\n  toString(): string {\n    return this._string;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when a [[Writer]] attempts to write invalid syntax.\n */\nexport class WriterException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = WriterException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\n\n/**\n * Continuation of how to write subsequent [[Output]] tokens to a stream.\n * `Writer` enables efficient, interruptible writing of network protocols and\n * data formats, without intermediate buffering.\n *\n * ### Output tokens\n * A `Writer` writes tokens to an `Output` writer.  Output tokens are modeled\n * as primitive numbers, commonly representing Unicode code points, or raw\n * octets.  Each `Writer` implementation specifies the semantic type of output\n * tokens it produces.\n *\n * ### Writer states\n * A `Writer` is always in one of three states: _cont_​inue, _done_, or _error_.\n * The _cont_ state indicates that [[pull]] is ready to produce `Output`; the\n * _done_ state indicates that writing terminated successfully, and that\n * [[bind]] will return the written result; the _error_ state indicates that\n * writing terminated in failure, and that [[trap]] will return the write error.\n * `Writer` subclasses default to the _cont_ state.\n *\n * ### Feeding input\n * The [[feed]] method returns a `Writer` that represents the continuation\n * of how to write the given input object to subsequent `Output` writers.\n * `feed` can be used to specify an initial object to write, or to change\n * the object to be written.\n *\n * ### Pulling output\n * The [[pull]] method incrementally writes as much `Output` as it can, before\n * returning another `Writer` that represents the continuation of how to write\n * additional `Output`.  The `Output` passed to `pull` is only guaranteed to be\n * valid for the duration of the method call; references to the provided\n * `Output` instance must not be stored.\n *\n * ### Writer results\n * A `Writer` produces a written result of type `O`, obtained via the [[bind]]\n * method.  `bind` is only guaranteed to return a result when in the _done_\n * state; though `bind` may optionally make available partial results in other\n * states.  A failed `Writer` provides a write error via the [[trap]] method.\n * `trap` is only guaranteed to return an error when in the _error_ state.\n *\n * ### Continuations\n * A `Writer` instance represents a continuation of how to write remaining\n * `Output`.  Rather than writing a complete output in one go, a `Writer` takes\n * an `Output` chunk and returns another `Writer` instance that knows how to\n * write subsequent `Output` chunks.  This enables non-blocking, incremental\n * writing that can be interrupted whenever an `Output` writer runs out of\n * space.  A `Writer` terminates by returning a continuation in either the\n * _done_ state, or the _error_ state.  [[Writer.done]] returns a `Writer` in\n * the _done_ state.  [[Writer.error]] returns a `Writer` in the _error_ state.\n *\n * ### Forking\n * The [[fork]] method passes an out-of-band condition to a `Writer`, yielding\n * a `Writer` continuation whose behavior may be altered by the given condition.\n * For example, a console `Writer` might support a `fork` condition that changes\n * the color and style of printed text.  The types of conditions accepted by\n * `fork`, and their intended semantics, are implementation defined.\n */\nexport abstract class Writer<I = unknown, O = unknown> {\n  /**\n   * Returns `true` when [[pull]] is able to produce `Output`.  i.e. this\n   * `Writer` is in the _cont_ state.\n   */\n  isCont(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` when writing has terminated successfully, and [[bind]] will\n   * return the written result.  i.e. this `Writer` is in the _done_ state.\n   */\n  isDone(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns `true` when writing has terminated in failure, and [[trap]] will\n   * return the write error.  i.e. this `Writer` is in the _error_ state.\n   */\n  isError(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns a `Writer` that represents the continuation of how to write the\n   * given `input` object.\n   *\n   * @throws `Error` if this `Writer` does not know how to write the given\n   *         `input` object.\n   */\n  feed(input: I): Writer<I, O> {\n    throw new Error();\n  }\n\n  /**\n   * Incrementally writes as much `output` as possible, and returns another\n   * `Writer` that represents the continuation of how to write additional\n   * `Output`.  If `output` enters the _done_ state, `pull` _must_ return a\n   * terminated `Writer`, i.e. a `Writer` in the _done_ state, or in the\n   * _error_ state.  The given `output` is only guaranteed to be valid for the\n   * duration of the method call; references to `output` must not be stored.\n   */\n  abstract pull(output: Output): Writer<I, O>;\n\n  /**\n   * Returns a `Writer` continuation whose behavior may be altered by the given\n   * out-of-band `condition`.\n   */\n  fork(condition: unknown): Writer<I, O> {\n    return this;\n  }\n\n  /**\n   * Returns the written result.  Only guaranteed to return a result when in\n   * the _done_ state.\n   *\n   * @throws `Error` if this `Writer` is not in the _done_ state.\n   */\n  bind(): O {\n    throw new Error();\n  }\n\n  /**\n   * Returns the write error.  Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws `Error` if this `Writer` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new Error();\n  }\n\n  /**\n   * Casts a done `Writer` to a different input type.  A `Writer` in the _done_\n   * state can have any input type.\n   *\n   * @throws `Error` if this `Writer` is not in the _done_ state.\n   */\n  asDone<I2>(): Writer<I2, O> {\n    throw new Error();\n  }\n\n  /**\n   * Casts an errored `Writer` to different input and output types.  A `Writer`\n   * in the _error_ state can have any input type, and any output type.\n   *\n   * @throws `Error` if this `Writer` is not in the _error_ state.\n   */\n  asError<I2, O2>(): Writer<I2, O2> {\n    throw new Error();\n  }\n\n  /**\n   * Returns a `Writer` that continues writing `that` `Writer`, after it\n   * finishes writing `this` `Writer`.\n   */\n  andThen<O2>(that: Writer<I, O2>): Writer<I, O2> {\n    return new WriterAndThen<I, O2>(this, that);\n  }\n\n  private static _done?: Writer<any, any>;\n\n  /**\n   * Returns a `Writer` in the _done_ state that `bind`s an `undefined`\n   * writtern result.\n   */\n  static done<I, O>(): Writer<I, O>;\n\n  /**\n   * Returns a `Writer` in the _done_ state that `bind`s the given\n   * written `output`.\n   */\n  static done<I, O>(output: O): Writer<I, O>;\n\n  static done<I, O>(output?: O): Writer<I, O> {\n    if (output === void 0) {\n      if (!Writer._done) {\n        Writer._done = new WriterDone<any, any>(void 0);\n      }\n      return Writer._done;\n    } else {\n      return new WriterDone<I, O>(output);\n    }\n  }\n\n  /**\n   * Returns a `Writer` in the _error_ state that `trap`s the given\n   * write `error`.\n   */\n  static error<I, O>(error: Error): Writer<I, O> {\n    return new WriterError<I, O>(error);\n  }\n}\n\n/** @hidden */\nclass WriterDone<I, O> extends Writer<I, O> {\n  /** @hidden */\n  readonly _output: O;\n\n  constructor(output: O) {\n    super();\n    this._output = output;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  pull(output: Output): Writer<I, O> {\n    return this;\n  }\n\n  bind(): O {\n    return this._output;\n  }\n\n  asDone<I2>(): Writer<I2, O> {\n    return this as any;\n  }\n\n  andThen<O2>(that: Writer<I, O2>): Writer<I, O2> {\n    return that;\n  }\n}\n\n/** @hidden */\nclass WriterError<I, O> extends Writer<I, O> {\n  /** @hidden */\n  readonly _error: Error;\n\n  constructor(error: Error) {\n    super();\n    this._error = error;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  pull(output: Output): Writer<I, O> {\n    return this;\n  }\n\n  bind(): O {\n    throw this._error;\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  asError<I2, O2>(): Writer<I2, O2> {\n    return this as any;\n  }\n\n  andThen<O2>(that: Writer<I, O2>): Writer<I, O2> {\n    return this as any;\n  }\n}\n\n/** @hidden */\nclass WriterAndThen<I, O> extends Writer<I, O> {\n  /** @hidden */\n  readonly _head: Writer<I, any>;\n  /** @hidden */\n  readonly _tail: Writer<I, O>;\n\n  constructor(head: Writer<I, any>, tail: Writer<I, O>) {\n    super();\n    this._head = head;\n    this._tail = tail;\n  }\n\n  pull(output: Output): Writer<I, O> {\n    let head = this._head;\n    if (head.isCont()) {\n      head = head.pull(output);\n    }\n    if (head.isError()) {\n      return head.asError();\n    } else if (head.isDone()) {\n      return this._tail.pull(output);\n    } else {\n      return new WriterAndThen<I, O>(head, this._tail);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\n\n/** @hidden */\nexport class StringWriter<I> extends Writer<I, unknown> {\n  private readonly _value: unknown;\n  private readonly _input: string;\n  private readonly _index: number;\n\n  constructor(value: unknown, input: string, index: number = 0) {\n    super();\n    this._value = value;\n    this._input = input;\n    this._index = index;\n  }\n\n  feed(input: unknown): Writer<I, unknown> {\n    return new StringWriter(input, \"\" + input);\n  }\n\n  pull(output: Output): Writer<I, unknown> {\n    return StringWriter.write(output, this._value, this._input, this._index);\n  }\n\n  static write<I>(output: Output, value: unknown, input: string, index: number = 0): Writer<I, unknown> {\n    const length = input.length;\n    while (index < length && output.isCont()) {\n      let c = input.codePointAt(index);\n      if (c === void 0) {\n        c = input.charCodeAt(index);\n      }\n      output = output.write(c);\n      index = input.offsetByCodePoints(index, 1);\n    }\n    if (index === length) {\n      return Writer.done(value);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new StringWriter(value, input, index);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {Writer} from \"./Writer\";\nimport {StringInput} from \"./StringInput\";\nimport {StringOutput} from \"./StringOutput\";\nimport {StringWriter} from \"./StringWriter\";\n\n/**\n * Unicode code point [[Input]]/[[Output]]/[[Writer]] factory.\n *\n * The `Unicode.stringInput(...)` function returns an `Input` that reads the\n * Unicode code points of a `string`.\n *\n * The `Unicode.stringOutput(...)}` function returns an `Output` that writes\n * Unicode code points to an internal buffer, and [[Output.bind binds]] a\n * `string` containing all written code points.\n */\nexport class Unicode {\n  private constructor() {\n    // nop\n  }\n\n  static stringInput(string: string): Input {\n    return new StringInput(string);\n  }\n\n  /**\n   * Returns a new `Output` that appends Unicode code points to the given\n   * `string`, using the given output `settings`.  The returned `Output`\n   * accepts an unbounded number of code points, remaining permanently in the\n   * _cont_ state, and [[Output.bind binds]] a `string` containing the given\n   * `string`, and all appended code points.\n   */\n  static stringOutput(string?: string, settings?: AnyOutputSettings): Output<string>;\n  /**\n   * Returns a new `Output` that buffers Unicode code points, using the given\n   * output `settings`.  The returned `Output` accepts an unbounded number of\n   * code points, remaining permanently in the _cont_ state, and [[Output.bind\n   * binds]] a `string` containing all written code points.\n   */\n  static stringOutput(settings?: AnyOutputSettings): Output<string>;\n  static stringOutput(string?: string | AnyOutputSettings, settings?: AnyOutputSettings): Output<string> {\n    if (settings === void 0 && typeof string !== \"string\") {\n      settings = string;\n      string = \"\";\n    } else if (typeof string !== \"string\") {\n      string = \"\";\n    }\n    settings = OutputSettings.fromAny(settings);\n    return new StringOutput(string, settings);\n  }\n\n  static stringWriter<I>(): Writer<I, unknown>;\n  static stringWriter<I, O>(input: O): Writer<I, O>;\n  static stringWriter<I, O>(input?: O): Writer<I, unknown> {\n    if (input === void 0) {\n      return new StringWriter(void 0, \"\");\n    } else {\n      return new StringWriter(input, \"\" + input);\n    }\n  }\n\n  static writeString<I>(input: unknown, output: Output): Writer<I, unknown> {\n    return StringWriter.write(output, void 0, \"\" + input);\n  }\n\n  /** @hidden */\n  static isAlpha(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/;\n  }\n\n  /** @hidden */\n  static isSpace(c: number): boolean {\n    return c === 0x20 || c === 0x9;\n  }\n\n  /** @hidden */\n  static isNewline(c: number): boolean {\n    return c === 0xa || c === 0xd;\n  }\n\n  /** @hidden */\n  static isWhitespace(c: number): boolean {\n    return Unicode.isSpace(c) || Unicode.isNewline(c);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Tag} from \"./Tag\";\nimport {AnyOutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {Display} from \"./Display\";\nimport {Debug} from \"./Debug\";\nimport {Unicode} from \"./Unicode\";\n\n/**\n * Text format utility functions.\n */\nexport class Format {\n  private constructor() {\n  }\n\n  /**\n   * Writes the code points of the human-readable [[Display]] string for the\n   * given `object` to `output`.  Assumes `output` is a Unicode `Output` writer\n   * with sufficient capacity.  Delegates to [[Display.display]], if `object`\n   * implements `Display`; otherwise writes the result of `Object.toString`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full display string has been written.\n   */\n  static display(object: unknown, output: Output): void;\n\n  /**\n   * Returns the human-readable [[Display]] string for the givem `object`,\n   * output using the given `settings`.  Delegates to [[Display.displa]],\n   * if `object` implements `Display`; otherwise returns the result of\n   * `Object.toString`.\n   */\n  static display(object: unknown, settings?: AnyOutputSettings): string;\n\n  static display(object: unknown, output?: Output | AnyOutputSettings): void | string {\n    const notOutput = !(output instanceof Output);\n    if (object === void 0) {\n      if (output === void 0) {\n        return \"undefined\";\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"undefined\");\n      }\n    } else if (object === null) {\n      if (output === void 0) {\n        return \"null\";\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"null\");\n      }\n    } else if (typeof object === \"number\") {\n      if (output === void 0) {\n        return \"\" + object;\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        Format.displayNumber(object, output);\n      }\n    } else if (typeof object === \"string\") {\n      if (output === void 0) {\n        return object;\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(object);\n      }\n    } else if (object && typeof (object as any).display === \"function\") {\n      if (!(output instanceof Output)) {\n        output = Unicode.stringOutput(output);\n      }\n      (object as Display).display(output);\n    } else {\n      if (output === void 0) {\n        return \"\" + object;\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"\" + object);\n      }\n    }\n    if (notOutput) {\n      return output.toString();\n    }\n  }\n\n  /**\n   * Writes the code points of the developer-readable [[Debug]] string for the\n   * given `object` to `output`.  Assumes `output` is a Unicode `Output` writer\n   * with sufficient capacity.  Delegates to [[Debug.debug]], if `object`\n   * implements `Debug`; writes a JavaScript string literal, if `object` is a\n   * `string`, and writes a JavaScript number literal, if `object` is a\n   * `number`; otherwise writes the result of `Object.toString`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full debug string has been written.\n   */\n  static debug(object: unknown, output: Output): void;\n\n  /**\n   * Returns the developer-readable [[Debug]] string for the givem `object`,\n   * output using the given `settings`.  Delegates to [[Debug.debug]], if\n   * `object` implements `Debug`; returns a JavaScript string literal, if\n   * `object` is a `string`, and returns a JavaScript number literal, if\n   * `object` is a `number`; otherwise returns the result of `Object.toString`.\n   */\n  static debug(object: unknown, settings?: AnyOutputSettings): string;\n\n  static debug(object: unknown, output?: Output | AnyOutputSettings): void | string {\n    const notOutput = !(output instanceof Output);\n    if (object === void 0) {\n      if (output === void 0) {\n        return \"undefined\";\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"undefined\");\n      }\n    } else if (object === null) {\n      if (output === void 0) {\n        return \"null\";\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"null\");\n      }\n    } else if (typeof object === \"number\") {\n      if (output === void 0) {\n        return \"\" + object;\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        Format.debugNumber(object, output);\n      }\n    } else if (typeof object === \"string\") {\n      if (!(output instanceof Output)) {\n        output = Unicode.stringOutput(output);\n      }\n      Format.debugString(object, output);\n    } else if (typeof (object as any).debug === \"function\") {\n      if (!(output instanceof Output)) {\n        output = Unicode.stringOutput(output);\n      }\n      (object as Debug).debug(output);\n    } else {\n      if (output === void 0) {\n        return \"\" + object;\n      } else {\n        if (!(output instanceof Output)) {\n          output = Unicode.stringOutput(output);\n        }\n        output = output.write(\"\" + object);\n      }\n    }\n    if (notOutput) {\n      return output.toString();\n    }\n  }\n\n  /**\n   * Writes the code points of the numeric string for the given `value`\n   * to `output`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full numeric string has been written.\n   */\n  static displayNumber(value: number, output: Output): void {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      if (value < 0) {\n        output = output.write(45/*'-'*/);\n      }\n      if (value > -10 && value < 10) {\n        output = output.write(48/*'0'*/ + Math.abs(value));\n      } else {\n        const digits = new Array<number>(19);\n        let x = value;\n        let i = 18;\n        while (x) {\n          digits[i] = Math.abs((x % 10) | 0);\n          x = (x / 10) | 0;\n          i -= 1;\n        }\n        i += 1;\n        while (i < 19) {\n          output = output.write(48/*'0'*/ + digits[i]);\n          i += 1;\n        }\n      }\n    } else {\n      output = output.write(\"\" + value);\n    }\n  }\n\n  /**\n   * Writes the code points of the JavaScript numeric literal for the given\n   * `value` to `output`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full numeric literal has been written.\n   */\n  static debugNumber(value: number, output: Output): void {\n    Format.displayNumber(value, output);\n  }\n\n  /**\n   * Writes the code points of the JavaScript character literal for the given\n   * `character` to `output`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full character literal has been written.\n   */\n  static debugChar(character: number, output: Output): void {\n    output = output.write(39/*'\\''*/);\n    switch (character) {\n        case 8/*'\\b'*/: output.write(92/*'\\\\'*/).write(98/*'b'*/); break;\n        case 9/*'\\t'*/: output.write(92/*'\\\\'*/).write(116/*'t'*/); break;\n        case 10/*'\\n'*/: output.write(92/*'\\\\'*/).write(110/*'n'*/); break;\n        case 12/*'\\f'*/: output.write(92/*'\\\\'*/).write(102/*'f'*/); break;\n        case 13/*'\\r'*/: output.write(92/*'\\\\'*/).write(114/*'r'*/); break;\n        case 34/*'\\\"'*/: output.write(92/*'\\\\'*/).write(34/*'\\\"'*/); break;\n        case 39/*'\\\"'*/: output.write(92/*'\\\\'*/).write(39/*'\\''*/); break;\n        case 92/*'\\\\'*/: output.write(92/*'\\\\'*/).write(92/*'\\\\'*/); break;\n      default:\n        if (character >= 0x0000 && character <= 0x001f\n            || character >= 0x007f && character <= 0x009f) {\n          output = output.write(92/*'\\\\'*/).write(117/*'u'*/)\n            .write(Format.encodeHex(character >>> 12 & 0xf))\n            .write(Format.encodeHex(character >>>  8 & 0xf))\n            .write(Format.encodeHex(character >>>  4 & 0xf))\n            .write(Format.encodeHex(character        & 0xf));\n        } else {\n          output = output.write(character);\n        }\n    }\n    output = output.write(39/*'\\''*/);\n  }\n\n  /**\n   * Writes the code points of the JavaScript string literal for the given\n   * `string` to `output`.\n   *\n   * @throws [[OutputException]] if the `output` exits the _cont_ state before\n   *         the full string literal has been written.\n   */\n  static debugString(string: string, output: Output): void {\n    output = output.write(34/*'\\\"'*/);\n    let input = Unicode.stringInput(string);\n    while (input.isCont()) {\n      const c = input.head();\n      switch (c) {\n        case 8/*'\\b'*/: output.write(92/*'\\\\'*/).write(98/*'b'*/); break;\n        case 9/*'\\t'*/: output.write(92/*'\\\\'*/).write(116/*'t'*/); break;\n        case 10/*'\\n'*/: output.write(92/*'\\\\'*/).write(110/*'n'*/); break;\n        case 12/*'\\f'*/: output.write(92/*'\\\\'*/).write(102/*'f'*/); break;\n        case 13/*'\\r'*/: output.write(92/*'\\\\'*/).write(114/*'r'*/); break;\n        case 34/*'\\\"'*/: output.write(92/*'\\\\'*/).write(34/*'\\\"'*/); break;\n        case 92/*'\\\\'*/: output.write(92/*'\\\\'*/).write(92/*'\\\\'*/); break;\n        default:\n          if (c >= 0x0000 && c <= 0x001f || c >= 0x007f && c <= 0x009f) {\n            output = output.write(92/*'\\\\'*/).write(117/*'u'*/)\n              .write(Format.encodeHex(c >>> 12 & 0xf))\n              .write(Format.encodeHex(c >>>  8 & 0xf))\n              .write(Format.encodeHex(c >>>  4 & 0xf))\n              .write(Format.encodeHex(c        & 0xf));\n          } else {\n            output = output.write(c);\n          }\n      }\n      input = input.step();\n    }\n    output = output.write(34/*'\\\"'*/);\n  }\n\n  private static encodeHex(x: number): number {\n    if (x < 10) {\n      return 48/*'0'*/ + x;\n    } else {\n      return 65/*'A'*/ + (x - 10);\n    }\n  }\n\n  private static _lineSeparator?: string;\n\n  /**\n   * Returns the operting system specific string used to separate lines of text.\n   */\n  static lineSeparator(): string {\n    if (!Format._lineSeparator) {\n      if (typeof require === \"function\") {\n        const os = require(\"os\");\n        if (os) {\n          Format._lineSeparator = os.EOL;\n        }\n      }\n      if (!Format._lineSeparator) {\n        Format._lineSeparator = \"\\n\";\n      }\n    }\n    return Format._lineSeparator;\n  }\n\n  /** @hidden */\n  static readonly Prefixes: ReadonlyArray<string> = [\"y\", \"z\", \"a\", \"f\", \"p\", \"n\", \"µ\", \"m\", \"\", \"k\", \"M\", \"G\", \"T\", \"P\", \"E\",\" Z\", \"Y\"];\n\n  /**\n   * Returns a string representation of `value` scaled by its SI magnitude,\n   * keeping at most `precision` digits past the decimal place, appended with\n   * the appropriate SI prefix.\n   */\n  static prefix(value: number, precision: number = 1): string {\n    if (isFinite(value)) {\n      const exponential = Math.abs(value).toExponential();\n      const exponentIndex = exponential.indexOf(\"e\");\n      const exponent = exponentIndex >= 0 ? +exponential.slice(exponentIndex + 1) : NaN;\n      const power = Math.min(Math.max(-8, Math.floor(exponent / 3)), 8) * 3;\n      const scaled = Math.pow(10, -power) * value;\n      let s = Format.trimTrailingZeros(Math.abs(scaled).toFixed(precision));\n      if (scaled < 0 && +s !== 0) {\n        s = \"-\" + s;\n      }\n      s += Format.Prefixes[8 + power / 3];\n      return s;\n    } else {\n      return \"\" + value;\n    }\n  }\n\n  /** @hidden */\n  static trimTrailingZeros(s: string): string {\n    let i0 = -1;\n    let i1: number | undefined;\n    for (let i = 1, n = s.length; i < n; i += 1) {\n      const c = s.charCodeAt(i);\n      if (c === 46/*'.'*/) {\n        i0 = i; // candidate start of trailing zeros\n        i1 = i; // candidate end of trailing zeros\n      } else if (c === 48/*'0'*/) {\n        if (i0 === 0) { // if after decimal\n          i0 = i; // new candidate start of trailing zeros\n        }\n        i1 = i; // new candidate end of trailing zeros\n      } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n        if (i0 > 0) { // if non-zero digit after decimal\n          i0 = 0; // no candidate start of trailing zeros\n        }\n      } else if (i0 > 0) { // if non-numeric character after decimal\n        break; // accept current range of trailing zeros\n      }\n    }\n    if (i0 > 0) {\n      s = s.slice(0, i0) + s.slice(i1! + 1); // cut out trailing zeros\n    }\n    return s;\n  }\n\n  /**\n   * Returns a string representation of the duration represented by the given\n   * number of milliseconds.\n   */\n  static duration(millis: number, separator: string = \" \"): string {\n    if (isFinite(millis)) {\n      const SECOND = 1000;\n      const MINUTE = 60 * SECOND;\n      const HOUR = 60 * MINUTE;\n      const DAY = 24 * HOUR;\n      const WEEK = 7 * DAY;\n      let weeks: number | undefined;\n      if (millis > WEEK) {\n        weeks = Math.floor(millis / WEEK);\n        millis %= WEEK;\n      }\n      let days: number | undefined;\n      if (millis > DAY) {\n        days = Math.floor(millis / DAY);\n        millis %= DAY;\n      }\n      let hours: number | undefined;\n      if (millis > HOUR) {\n        hours = Math.floor(millis / HOUR);\n        millis %= HOUR;\n      }\n      let minutes: number | undefined;\n      if (millis > MINUTE) {\n        minutes = Math.floor(millis / MINUTE);\n        millis %= MINUTE;\n      }\n      let seconds: number | undefined;\n      if (millis > SECOND) {\n        seconds = Math.floor(millis / SECOND);\n        millis %= SECOND;\n      }\n      let s = \"\";\n      if (weeks !== void 0) {\n        s += weeks + \"w\";\n      }\n      if (days !== void 0) {\n        s += (s ? separator : \"\") + days + \"d\";\n      }\n      if (hours !== void 0) {\n        s += (s ? separator : \"\") + hours + \"h\";\n      }\n      if (minutes !== void 0) {\n        s += (s ? separator : \"\") + minutes + \"m\";\n      }\n      if (seconds !== void 0 || !millis) {\n        s += (s ? separator : \"\") + (seconds || 0) + \"s\";\n      }\n      if (millis && !s) {\n        s += millis + \"ms\";\n      }\n      return s;\n    } else {\n      return \"\" + millis;\n    }\n  }\n}\nTag.Format = Format;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode, Murmur3} from \"@swim/util\";\nimport {Output} from \"./Output\";\nimport {Format} from \"./Format\";\nimport {Debug} from \"./Debug\";\n\n/**\n * Either an [[InputSettings]] instance, or an [[InputSettingsInit]] object\n * initializer.\n */\nexport type AnyInputSettings = InputSettings | InputSettingsInit;\n\nexport interface InputSettingsInit {\n  isStripped?: boolean;\n}\n\n/**\n * [[Input]] consumption parameters.  `InputSettings` provide contextual\n * configuration parameters to input consumers, such as [[Parser Parsers]].\n */\nexport class InputSettings implements Debug, HashCode {\n  /** @hidden */\n  readonly _isStrict: boolean;\n\n  protected constructor(isStripped: boolean) {\n    this._isStrict = isStripped;\n  }\n\n  /**\n   * Returns `true` if input consumers should not include diagnostic metadata\n   * in generated output.\n   */\n  isStripped(): boolean;\n\n  /**\n   * Returns a copy of these settings with the given `isStripped` flag.\n   */\n  isStripped(isStripped: boolean): InputSettings;\n\n  isStripped(isStripped?: boolean): boolean | InputSettings {\n    if (isStripped === void 0) {\n      return this._isStrict;\n    } else {\n      return this.copy(isStripped);\n    }\n  }\n\n  protected copy(isStripped: boolean): InputSettings {\n    return InputSettings.create(isStripped);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof InputSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InputSettings) {\n      return that.canEqual(this) && this._isStrict === that._isStrict;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (InputSettings._hashSeed === void 0) {\n      InputSettings._hashSeed = Murmur3.seed(InputSettings);\n    }\n    return Murmur3.mash(Murmur3.mix(InputSettings._hashSeed,\n        Murmur3.hash(this._isStrict)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"InputSettings\").write(46/*'.'*/);\n    if (!this._isStrict) {\n      output = output.write(\"standard\");\n    } else {\n      output = output.write(\"stripped\");\n    }\n    output = output.write(40/*'('*/).write(41/*')'*/);\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  private static _hashSeed?: number;\n  private static _standard?: InputSettings;\n  private static _stripped?: InputSettings;\n\n  /**\n   * Returns `InputSettings` configured to include diagnostic metadata in\n   * generated output.\n   */\n  static standard(): InputSettings {\n    if (!InputSettings._standard) {\n      InputSettings._standard = new InputSettings(false);\n    }\n    return InputSettings._standard;\n  }\n\n  /**\n   * Returns `InputSettings` configured to not include diagnostic metadata in\n   * generated output.\n   */\n  static stripped(): InputSettings {\n    if (!InputSettings._stripped) {\n      InputSettings._stripped = new InputSettings(false);\n    }\n    return InputSettings._stripped;\n  }\n\n  /**\n   * Returns `InputSettings` configured to not include diagnostic metadata in\n   * generated output, if `isStripped` is `true`.\n   */\n  static create(isStripped?: boolean): InputSettings {\n    if (isStripped) {\n      return InputSettings.stripped();\n    }\n    return InputSettings.standard();\n  }\n\n  /**\n   * Converts the loosely typed `settings` to an instance of `InputSettings`.\n   */\n  static fromAny(settings: AnyInputSettings | undefined): InputSettings {\n    if (settings instanceof InputSettings) {\n      return settings;\n    } else if (typeof settings === \"object\" && settings) {\n       return InputSettings.create(settings.isStripped);\n    } else {\n      return InputSettings.standard();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Mark} from \"./Mark\";\nimport {InputException} from \"./InputException\";\nimport {AnyInputSettings, InputSettings} from \"./InputSettings\";\nimport {Input} from \"./Input\";\n\n/**\n * Non-blocking token stream buffer.\n */\nexport abstract class InputBuffer extends Input {\n  abstract isPart(): boolean;\n  abstract isPart(isPart: boolean): InputBuffer;\n\n  abstract index(): number;\n  abstract index(index: number): InputBuffer;\n\n  abstract limit(): number;\n  abstract limit(limit: number): InputBuffer;\n\n  abstract capacity(): number;\n\n  abstract remaining(): number;\n\n  abstract has(index: number): boolean;\n\n  abstract get(index: number): number;\n\n  abstract set(index: number, token: number): void;\n\n  abstract step(offset?: number): InputBuffer;\n\n  abstract seek(mark: Mark): InputBuffer;\n\n  abstract id(): unknown | null;\n  abstract id(id: unknown | null): InputBuffer;\n\n  abstract mark(): Mark;\n  abstract mark(mark: Mark): Input;\n\n  abstract settings(): InputSettings;\n  abstract settings(settings: AnyInputSettings): Input;\n\n  abstract clone(): InputBuffer;\n\n  private static _emptyBuffer: InputBuffer;\n\n  private static _doneBuffer: InputBuffer;\n\n  /**\n   * Returns an `InputBuffer}` in the _empty_ state.\n   */\n  static empty(id: unknown | null = null, mark: Mark = Mark.zero(),\n               settings: InputSettings = InputSettings.standard()): InputBuffer {\n    if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {\n      if (!InputBuffer._emptyBuffer) {\n        InputBuffer._emptyBuffer = new InputBufferEmpty(null, Mark.zero(), InputSettings.standard());\n      }\n      return InputBuffer._emptyBuffer;\n    }\n    return new InputBufferEmpty(id, mark, settings);\n  }\n\n  /**\n   * Returns an `InputBuffer` in the _done_ state.\n   */\n  static done(id: unknown | null = null, mark: Mark = Mark.zero(),\n              settings: InputSettings = InputSettings.standard()): InputBuffer {\n    if (id === null && mark === Mark.zero() && settings === InputSettings.standard()) {\n      if (!InputBuffer._doneBuffer) {\n        InputBuffer._doneBuffer = new InputBufferDone(null, Mark.zero(), InputSettings.standard());\n      }\n      return InputBuffer._doneBuffer;\n    }\n    return new InputBufferDone(id, mark, settings);\n  }\n\n  /**\n   * Returns an `InputBuffer` in the _error_ state, with the given input `error`.\n   */\n  static error(error: Error, id: unknown | null = null, mark: Mark = Mark.zero(),\n               settings: InputSettings = InputSettings.standard()): InputBuffer {\n    return new InputBufferError(error, id, mark, settings);\n  }\n}\n\n/** @hidden */\nclass InputBufferEmpty extends InputBuffer {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n\n  constructor(id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): InputBuffer;\n  isPart(isPart?: boolean): boolean | InputBuffer {\n    if (isPart === void 0) {\n      return true;\n    } else if (isPart) {\n      return this;\n    } else {\n      return InputBuffer.done(this._id, this._mark, this._settings);\n    }\n  }\n\n  index(): number;\n  index(index: number): InputBuffer;\n  index(index?: number): number | InputBuffer {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): InputBuffer;\n  limit(limit?: number): number | InputBuffer {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new InputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(offset?: number): InputBuffer {\n    const error = new InputException(\"empty step\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"empty seek\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): InputBuffer;\n  id(id?: unknown | null): unknown | null | InputBuffer {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return InputBuffer.empty(id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): InputBuffer;\n  mark(mark?: Mark): Mark | InputBuffer {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return InputBuffer.empty(this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): InputBuffer;\n  settings(settings?: InputSettings): InputSettings | InputBuffer {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return InputBuffer.empty(this._id, this._mark, settings);\n    }\n  }\n\n  clone(): InputBuffer {\n    return this;\n  }\n}\n\n/** @hidden */\nclass InputBufferDone extends InputBuffer {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n\n  constructor(id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): InputBuffer;\n  isPart(isPart?: boolean): boolean | InputBuffer {\n    if (isPart === void 0) {\n      return false;\n    } else if (isPart) {\n      return InputBuffer.empty(this._id, this._mark, this._settings);\n    } else {\n      return this;\n    }\n  }\n\n  index(): number;\n  index(index: number): InputBuffer;\n  index(index?: number): number | InputBuffer {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): InputBuffer;\n  limit(limit?: number): number | InputBuffer {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new InputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(offset?: number): InputBuffer {\n    const error = new InputException(\"done step\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"done seek\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): InputBuffer;\n  id(id?: unknown | null): unknown | null | InputBuffer {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return InputBuffer.done(id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): InputBuffer;\n  mark(mark?: Mark): Mark | InputBuffer {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return InputBuffer.done(this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): InputBuffer;\n  settings(settings?: InputSettings): InputSettings | InputBuffer {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return InputBuffer.done(this._id, this._mark, settings);\n    }\n  }\n\n  clone(): InputBuffer {\n    return this;\n  }\n}\n\n/** @hidden */\nclass InputBufferError extends InputBuffer {\n  /** @hidden */\n  readonly _id: unknown | null;\n  /** @hidden */\n  readonly _mark: Mark;\n  /** @hidden */\n  readonly _settings: InputSettings;\n  /** @hidden */\n  readonly _error: Error;\n\n  constructor(error: Error, id: unknown | null, mark: Mark, settings: InputSettings) {\n    super();\n    this._error = error;\n    this._id = id;\n    this._mark = mark;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): InputBuffer;\n  isPart(isPart?: boolean): boolean | InputBuffer {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  index(): number;\n  index(index: number): InputBuffer;\n  index(index?: number): number | InputBuffer {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid index\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): InputBuffer;\n  limit(limit?: number): number | InputBuffer {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      const error = new InputException(\"invalid limit\");\n      return InputBuffer.error(error, this._id, this._mark, this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new InputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new InputException();\n  }\n\n  head(): number {\n    throw new InputException();\n  }\n\n  step(offset?: number): InputBuffer {\n    const error = new InputException(\"error step\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  seek(mark: Mark): InputBuffer {\n    const error = new InputException(\"error seek\");\n    return InputBuffer.error(error, this._id, this._mark, this._settings);\n  }\n\n  id(): unknown | null;\n  id(id: unknown | null): InputBuffer;\n  id(id?: unknown | null): unknown | null | InputBuffer {\n    if (id === void 0) {\n      return this._id;\n    } else {\n      return InputBuffer.error(this._error, id, this._mark, this._settings);\n    }\n  }\n\n  mark(): Mark;\n  mark(mark: Mark): InputBuffer;\n  mark(mark?: Mark): Mark | InputBuffer {\n    if (mark === void 0) {\n      return this._mark;\n    } else {\n      return InputBuffer.error(this._error, this._id, mark, this._settings);\n    }\n  }\n\n  settings(): InputSettings;\n  settings(settings: InputSettings): InputBuffer;\n  settings(settings?: InputSettings): InputSettings | InputBuffer {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return InputBuffer.error(this._error, this._id, this._mark, settings);\n    }\n  }\n\n  clone(): InputBuffer {\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Format} from \"./Format\";\nimport {OutputException} from \"./OutputException\";\nimport {Output} from \"./Output\";\n\n/**\n * Non-blocking token stream buffer.\n */\nexport abstract class OutputBuffer<T = unknown> extends Output<T> {\n  abstract isPart(): boolean;\n  abstract isPart(isPart: boolean): OutputBuffer<T>;\n\n  abstract index(): number;\n  abstract index(index: number): OutputBuffer<T>;\n\n  abstract limit(): number;\n  abstract limit(limit: number): OutputBuffer<T>;\n\n  abstract capacity(): number;\n\n  abstract remaining(): number;\n\n  abstract has(index: number): boolean;\n\n  abstract get(index: number): number;\n\n  abstract set(index: number, token: number): void;\n\n  abstract write(token: number): OutputBuffer<T>;\n  abstract write(string: string): OutputBuffer<T>;\n\n  writeln(string?: string): OutputBuffer<T> {\n    if (typeof string === \"string\") {\n      this.write(string);\n    }\n    return this.write(this.settings().lineSeparator());\n  }\n\n  display(object: unknown): OutputBuffer<T> {\n    Format.display(object, this);\n    return this;\n  }\n\n  debug(object: unknown): OutputBuffer<T> {\n    Format.debug(object, this);\n    return this;\n  }\n\n  abstract step(offset?: number): OutputBuffer<T>;\n\n  flush(): OutputBuffer<T> {\n    return this;\n  }\n\n  abstract settings(): OutputSettings;\n  abstract settings(settings: AnyOutputSettings): Output<T>;\n\n  clone(): OutputBuffer<T> {\n    throw new Error();\n  }\n\n  private static _fullBuffer: OutputBuffer<any>;\n\n  private static _doneBuffer: OutputBuffer<any>;\n\n  /**\n   * Returns an `OutputBuffer` in the _full_ state, that binds a `null` result.\n   */\n  static full<T>(value: T | null = null, settings: OutputSettings = OutputSettings.standard()): OutputBuffer<T> {\n    if (value === null && settings === OutputSettings.standard()) {\n      if (!OutputBuffer._fullBuffer) {\n        OutputBuffer._fullBuffer = new OutputBufferFull(value, OutputSettings.standard());\n      }\n      return OutputBuffer._fullBuffer;\n    }\n    return new OutputBufferFull<T>(value!, settings);\n\n  }\n\n  /**\n   * Returns an `OutputBuffer` in the _done_ state, that binds a `null` result.\n   */\n  static done<T>(value: T | null = null, settings: OutputSettings = OutputSettings.standard()): OutputBuffer<T> {\n    if (value === null && settings === OutputSettings.standard()) {\n      if (!OutputBuffer._doneBuffer) {\n        OutputBuffer._doneBuffer = new OutputBufferDone(value, OutputSettings.standard());\n      }\n      return OutputBuffer._doneBuffer;\n    }\n    return new OutputBufferDone<T>(value!, settings);\n  }\n\n  /**\n   * Returns an `OutputBuffer` in the _error_ state, with the given output `error`.\n   */\n  static error<T>(error: Error, settings: OutputSettings = OutputSettings.standard()): OutputBuffer<T> {\n    return new OutputBufferError<T>(error, settings);\n  }\n}\n\n/** @hidden */\nclass OutputBufferFull<T> extends OutputBuffer<T> {\n  /** @hidden */\n  readonly _value: T;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(value: T, settings: OutputSettings) {\n    super();\n    this._value = value;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return true;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): OutputBuffer<T>;\n  isPart(isPart?: boolean): boolean | OutputBuffer<T> {\n    if (isPart === void 0) {\n      return true;\n    } else if (isPart) {\n      return OutputBuffer.done(this._value, this._settings);\n    } else {\n      return this;\n    }\n  }\n\n  index(): number;\n  index(index: number): OutputBuffer<T>;\n  index(index?: number): number | OutputBuffer<T> {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): OutputBuffer<T>;\n  limit(limit?: number): number | OutputBuffer<T> {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new OutputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  write(token: number): OutputBuffer<T>;\n  write(string: string): OutputBuffer<T>;\n  write(tokenOrString: number | string): OutputBuffer<T> {\n    return OutputBuffer.error(new OutputException(\"full\"), this._settings);\n  }\n\n  writeln(string?: string): OutputBuffer<T> {\n    return OutputBuffer.error(new OutputException(\"full\"), this._settings);\n  }\n\n  step(offset: number = 1): OutputBuffer<T> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid step\"), this._settings);\n    }\n  }\n\n  bind(): T {\n    return this._value;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): OutputBuffer<T>;\n  settings(settings?: OutputSettings): OutputSettings | OutputBuffer<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return OutputBuffer.full(this._value, settings);\n    }\n  }\n\n  clone(): OutputBuffer<T> {\n    return this;\n  }\n}\n\n/** @hidden */\nclass OutputBufferDone<T> extends OutputBuffer<T> {\n  /** @hidden */\n  readonly _value: T;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(value: T, settings: OutputSettings) {\n    super();\n    this._value = value;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): OutputBuffer<T>;\n  isPart(isPart?: boolean): boolean | OutputBuffer<T> {\n    if (isPart === void 0) {\n      return false;\n    } else if (isPart) {\n      return this;\n    } else {\n      return OutputBuffer.full(this._value, this._settings);\n    }\n  }\n\n  index(): number;\n  index(index: number): OutputBuffer<T>;\n  index(index?: number): number | OutputBuffer<T> {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): OutputBuffer<T>;\n  limit(limit?: number): number | OutputBuffer<T> {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new OutputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  write(token: number): OutputBuffer<T>;\n  write(string: string): OutputBuffer<T>;\n  write(tokenOrString: number | string): OutputBuffer<T> {\n    return OutputBuffer.error(new OutputException(\"done\"), this._settings);\n  }\n\n  writeln(string?: string): OutputBuffer<T> {\n    return OutputBuffer.error(new OutputException(\"done\"), this._settings);\n  }\n\n  step(offset: number = 1): OutputBuffer<T> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid step\"), this._settings);\n    }\n  }\n\n  bind(): T {\n    return this._value;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): OutputBuffer<T>;\n  settings(settings?: OutputSettings): OutputSettings | OutputBuffer<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return OutputBuffer.done(this._value, settings);\n    }\n  }\n\n  clone(): OutputBuffer<T> {\n    return this;\n  }\n}\n\n/** @hidden */\nclass OutputBufferError<T> extends OutputBuffer<T> {\n  /** @hidden */\n  readonly _error: Error;\n  /** @hidden */\n  readonly _settings: OutputSettings;\n\n  constructor(error: Error, settings: OutputSettings) {\n    super();\n    this._error = error;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): OutputBuffer<T>;\n  isPart(isPart?: boolean): boolean | OutputBuffer<T> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  index(): number;\n  index(index: number): OutputBuffer<T>;\n  index(index?: number): number | OutputBuffer<T> {\n    if (index === void 0) {\n      return 0;\n    } else if (index === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): OutputBuffer<T>;\n  limit(limit?: number): number | OutputBuffer<T> {\n    if (limit === void 0) {\n      return 0;\n    } else if (limit === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  capacity(): number {\n    return 0;\n  }\n\n  remaining(): number {\n    return 0;\n  }\n\n  has(index: number): boolean {\n    return false;\n  }\n\n  get(index: number): number {\n    throw new OutputException();\n  }\n\n  set(index: number, token: number): void {\n    throw new OutputException();\n  }\n\n  write(token: number): OutputBuffer<T>;\n  write(string: string): OutputBuffer<T>;\n  write(tokenOrString: number | string): OutputBuffer<T> {\n    return this;\n  }\n\n  writeln(string?: string): OutputBuffer<T> {\n    return this;\n  }\n\n  step(offset: number = 1): OutputBuffer<T> {\n    if (offset === 0) {\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid step\"), this._settings);\n    }\n  }\n\n  bind(): T {\n    throw new OutputException();\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: OutputSettings): OutputBuffer<T>;\n  settings(settings?: OutputSettings): OutputSettings | OutputBuffer<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      return OutputBuffer.error(this._error, settings);\n    }\n  }\n\n  clone(): OutputBuffer<T> {\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\n\n/**\n * Stylized text output utility functions.\n */\nexport class OutputStyle {\n  private constructor() {\n  }\n\n  /**\n   * Writes the ASCII reset escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static reset(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold (increased intensity) escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static bold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII faint (decreased intensity) escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static faint(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII black foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static black(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII red foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static red(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII green foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static green(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII yellow foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static yellow(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(51/*'3'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII blue foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static blue(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(52/*'4'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII magenta foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static magenta(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(53/*'5'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII cyan foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static cyan(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(54/*'6'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII gray foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static gray(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(48/*'0'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(55/*'7'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold black foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static blackBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(48/*'0'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold red foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static redBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(49/*'1'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold green foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static greenBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(50/*'2'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold yellow foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static yellowBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(51/*'3'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold blue foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static blueBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(52/*'4'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold magenta foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static magentaBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(53/*'5'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold cyan foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static cyanBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(54/*'6'*/).write(109/*'m'*/);\n    }\n  }\n\n  /**\n   * Writes the ASCII bold gray foreground color escape code to `output`,\n   * if [[OutputSettings.isStyled output.settings().isStyled()]] is `true`.\n   *\n   * @throws [[OutputException]] if `output` exits the _cont_ state before the\n   *         full escape code has been written.\n   */\n  static grayBold(output: Output) {\n    if (output.settings().isStyled()) {\n      output = output.write(27).write(91/*'['*/).write(49/*'1'*/).write(59/*';'*/)\n          .write(51/*'3'*/).write(55/*'7'*/).write(109/*'m'*/);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Writer} from \"./Writer\";\nimport {Format} from \"./Format\";\nimport {Unicode} from \"./Unicode\";\nimport {Base10NumberParser} from \"./Base10NumberParser\";\nimport {Base10IntegerWriter} from \"./Base10IntegerWriter\";\n\n/**\n * Base-10 (decimal) encoding [[Parser]]/[[Writer]] factory.\n */\nexport class Base10 {\n  private constructor() {\n    // nop\n  }\n\n  /**\n   * Returns `true` if the Unicode code point `c` is a valid base-10 digit.\n   */\n  static isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/;\n  }\n\n  /**\n   * Returns the decimal quantity between `0` (inclusive) and `10` (exclusive)\n   * represented by the base-10 digit `c`.\n   *\n   * @throws `Error` if `c` is not a valid base-10 digit.\n   */\n  static decodeDigit(c: number): number {\n    if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c - 48/*'0'*/;\n    } else {\n      const message = Unicode.stringOutput();\n      message.write(\"Invalid base-10 digit: \");\n      Format.debugChar(c, message);\n      throw new Error(message.bind());\n    }\n  }\n\n  /**\n   * Returns the Unicode code point of the base-10 digit that encodes the given\n   * decimal quantity between `0` (inclusive) and `10` (exclusive).\n   */\n  static encodeDigit(b: number): number {\n    if (b >= 0 && b <= 9) {\n      return 48/*'0'*/ + b;\n    } else {\n      throw new Error(\"\" + b);\n    }\n  }\n\n  /**\n   * Returns the number of whole decimal digits in the given absolute `value`.\n   */\n  static countDigits(value: number): number {\n    let size = 0;\n    do {\n      size += 1;\n      value = (value / 10) | 0;\n    } while (value);\n    return size;\n  }\n\n  static integerParser(): Parser<number> {\n    return new Base10.NumberParser(void 0, void 0, 0);\n  }\n\n  static parseInteger(input: Input): Parser<number> {\n    return Base10.NumberParser.parse(input, void 0, void 0, 0);\n  }\n\n  static decimalParser(): Parser<number> {\n    return new Base10.NumberParser(void 0, void 0, 1);\n  }\n\n  static parseDecimal(input: Input): Parser<number> {\n    return Base10.NumberParser.parse(input, void 0, void 0, 1);\n  }\n\n  static numberParser(): Parser<number> {\n    return new Base10.NumberParser();\n  }\n\n  static parseNumber(input: Input): Parser<number> {\n    return Base10.NumberParser.parse(input);\n  }\n\n  /**\n   * Returns a `Writer` that, when fed an input `number` value, returns a\n   * continuation that writes the base-10 (decimal) encoding of the input value.\n   */\n  static integerWriter(): Writer<number, unknown>;\n  /**\n   * Returns a `Writer` continuation that writes the base-10 (decimal) encoding\n   * of the `input` value.\n   */\n  static integerWriter(input: number): Writer<unknown, number>;\n  static integerWriter(input?: number): Writer<unknown, unknown> {\n    if (input === void 0) {\n      return new Base10.IntegerWriter(void 0, 0);\n    } else {\n      return new Base10.IntegerWriter(void 0, input);\n    }\n  }\n\n  /**\n   * Writes the base-10 (decimal) encoding of the `input` value to the `output`,\n   * returning a `Writer` continuation that knows how to write any remaining\n   * output that couldn't be immediately generated.\n   */\n  static writeInteger(input: number, output: Output): Writer<unknown, unknown> {\n    return Base10.IntegerWriter.write(output, void 0, input);\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static NumberParser: typeof Base10NumberParser; // defined by Base10NumberParser\n  /** @hidden */\n  static IntegerWriter: typeof Base10IntegerWriter; // defined by Base10IntegerWriter\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects, Severity} from \"@swim/util\";\nimport {Tag} from \"./Tag\";\nimport {Mark} from \"./Mark\";\nimport {Input} from \"./Input\";\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {OutputStyle} from \"./OutputStyle\";\nimport {Format} from \"./Format\";\nimport {Display} from \"./Display\";\nimport {Unicode} from \"./Unicode\";\nimport {Base10} from \"./Base10\";\n\n/**\n * Informational message attached to an input location.\n */\nexport class Diagnostic implements Display {\n  /** @hidden */\n  readonly _input: Input;\n  /** @hidden */\n  readonly _tag: Tag;\n  /** @hidden */\n  readonly _severity: Severity;\n  /** @hidden */\n  readonly _message: string | null;\n  /** @hidden */\n  readonly _note: string | null;\n  /** @hidden */\n  readonly _cause: Diagnostic | null;\n\n  constructor(input: Input, tag: Tag, severity: Severity, message: string | null,\n              note: string | null, cause: Diagnostic | null) {\n    this._input = input;\n    this._tag = tag;\n    this._severity = severity;\n    this._message = message;\n    this._note = note;\n    this._cause = cause;\n  }\n\n  /**\n   * Returns the `Input` source to which this diagnostic is attached.\n   */\n  input(): Input {\n    return this._input.clone();\n  }\n\n  /**\n   * Returns the annotated location `Tag` in the `input` to which this\n   * diagnostic is attached.\n   */\n  tag(): Tag {\n    return this._tag;\n  }\n\n  /**\n   * Returns the level of importance of this diagnostic.\n   */\n  severity(): Severity {\n    return this._severity;\n  }\n\n  /**\n   * Returns the help message that describes this diagnostic.\n   */\n  message(): string | null {\n    return this._message;\n  }\n\n  /**\n   * Returns an informative comment on the source context to which this\n   * diagnostic is attached.\n   */\n  note(): string | null {\n    return this._note;\n  }\n\n  /**\n   * Returns the `Diagnostic` cause of this diagnostic, forming a linked chain\n   * of diagnostics, or `null` if this diagnostic has no cause.\n   */\n  cause(): Diagnostic | null {\n    return this._cause;\n  }\n\n  private lineDigits(): number {\n    let digits = Base10.countDigits(this._tag.end().line());\n    if (this._cause !== null) {\n      digits = Math.max(digits, this._cause.lineDigits());\n    }\n    return digits;\n  }\n\n  display(output: Output): void {\n    const input = this._input.clone();\n    const start = this._tag.start();\n    const end = this._tag.end();\n    const severity = this._severity;\n    const message = this._message;\n    const note = this._note;\n    const cause = this._cause;\n    const contextLines = 2;\n    const lineDigits = this.lineDigits();\n    Diagnostic.displayDiagnostic(input, start, end, severity, message, note,\n                                 cause, contextLines, lineDigits, output);\n  }\n\n  toString(settings?: OutputSettings): string {\n    return Format.display(this, settings);\n  }\n\n  static from(input: Input, tag: Tag, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static from(input: Input, tag: Tag, severity: Severity, message: string | null,\n              diagnostic?: Diagnostic | null): Diagnostic;\n  static from(input: Input, tag: Tag, severity: Severity, message: string | null,\n              note: string | null, cause?: Diagnostic | null): Diagnostic;\n  static from(input: Input, tag: Tag, severity: Severity, message?: Diagnostic | string | null,\n              note?: Diagnostic | string | null, cause?: Diagnostic | null): Diagnostic {\n    if (message instanceof Diagnostic) {\n      cause = message;\n      note = null;\n      message = null;\n    } else if (note instanceof Diagnostic) {\n      cause = note;\n      note = null;\n    }\n    input = input.clone();\n    if (message === void 0) {\n      message = null;\n    }\n    if (note === void 0) {\n      note = null;\n    }\n    if (cause === void 0) {\n      cause = null;\n    }\n    return new Diagnostic(input, tag, severity, message, note, cause);\n  }\n\n  static message(message: string, input: Input, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static message(message: string, input: Input, severity?: Diagnostic | Severity | string | null,\n                 note?: Diagnostic | string | null, cause?: Diagnostic | null): Diagnostic {\n    if (severity === null || severity instanceof Diagnostic) {\n      cause = severity;\n      severity = void 0;\n    } else if (typeof severity === \"string\") {\n      note = severity;\n      severity = void 0;\n    }\n    if (note === null || note instanceof Diagnostic) {\n      cause = note;\n      note = void 0;\n    }\n    if (note === void 0) {\n      note = null;\n    }\n    if (severity === void 0) {\n      severity = Severity.error();\n    }\n\n    const mark = input.mark();\n    const source = input.clone();\n    source.seek();\n    return Diagnostic.from(source, mark, severity, message, note, cause);\n  }\n\n  static unexpected(input: Input, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static unexpected(input: Input, severity?: Diagnostic | Severity | string | null,\n                    note?: Diagnostic | string | null, cause?: Diagnostic | null): Diagnostic {\n    if (severity === null || severity instanceof Diagnostic) {\n      cause = severity;\n      severity = void 0;\n    } else if (typeof severity === \"string\") {\n      note = severity;\n      severity = void 0;\n    }\n    if (note === null || note instanceof Diagnostic) {\n      cause = note;\n      note = void 0;\n    }\n    if (note === void 0) {\n      note = null;\n    }\n    if (severity === void 0) {\n      severity = Severity.error();\n    }\n\n    let message;\n    if (input.isCont()) {\n      const output = Unicode.stringOutput().write(\"unexpected\").write(32/*' '*/);\n      Format.debugChar(input.head(), output);\n      message = output.bind();\n    } else {\n      message = \"unexpected end of input\";\n    }\n    const mark = input.mark();\n    const source = input.clone();\n    source.seek();\n    return Diagnostic.from(source, mark, severity, message, note, cause);\n  }\n\n  static expected(expected: string | number, input: Input, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, note: string, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity: Severity, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity?: Severity, note?: string, cause?: Diagnostic | null): Diagnostic;\n  static expected(expected: string | number, input: Input, severity?: Diagnostic | Severity | string | null,\n                  note?: Diagnostic | string | null, cause?: Diagnostic | null): Diagnostic {\n    if (severity === null || severity instanceof Diagnostic) {\n      cause = severity;\n      severity = void 0;\n    } else if (typeof severity === \"string\") {\n      note = severity;\n      severity = void 0;\n    }\n    if (note === null || note instanceof Diagnostic) {\n      cause = note;\n      note = void 0;\n    }\n    if (note === void 0) {\n      note = null;\n    }\n    if (severity === void 0) {\n      severity = Severity.error();\n    }\n\n    let output = Unicode.stringOutput().write(\"expected\").write(32/*' '*/);\n    if (typeof expected === \"number\") {\n      Format.debugChar(expected, output);\n    } else {\n      output = output.write(expected);\n    }\n    output = output.write(44/*','*/).write(32/*' '*/).write(\"but found\").write(32/*' '*/);\n    if (input.isCont()) {\n      Format.debugChar(input.head(), output);\n    } else {\n      output = output.write(\"end of input\");\n    }\n    const message = output.bind();\n    const mark = input.mark();\n    const source = input.clone();\n    source.seek();\n    return Diagnostic.from(source, mark, severity, message, note, cause);\n  }\n\n  private static displayDiagnostic(input: Input, start: Mark, end: Mark,\n                                   severity: Severity, message: string | null,\n                                   note: string | null, cause: Diagnostic | null,\n                                   contextLines: number, lineDigits: number,\n                                   output: Output): void {\n    do {\n      if (message !== null) {\n        Diagnostic.displayMessage(severity, message, output);\n        output = output.writeln();\n      }\n      Diagnostic.displayAnchor(input, start, lineDigits, output);\n      output = output.writeln();\n      const next = Diagnostic.displayContext(input, start, end, severity, note,\n                                             cause, contextLines, lineDigits, output);\n      if (next !== null) {\n        output = output.writeln();\n        input = next._input.clone();\n        start = next._tag.start();\n        end = next._tag.end();\n        severity = next._severity;\n        message = next._message;\n        note = next._note;\n        cause = next._cause;\n      } else {\n        break;\n      }\n    } while (true);\n  }\n\n  /** @hidden */\n  static displayMessage(severity: Severity, message: string | null, output: Output): void {\n    Diagnostic.formatSeverity(severity, output);\n    output = output.write(severity.label());\n    OutputStyle.reset(output);\n    OutputStyle.bold(output);\n    output = output.write(58/*':'*/);\n    if (message !== null) {\n      output = output.write(32/*' '*/).write(message);\n    }\n    OutputStyle.reset(output);\n  }\n\n  private static displayAnchor(input: Input, start: Mark, lineDigits: number,\n                               output: Output): void {\n    Diagnostic.displayLineLeadArrow(lineDigits, output);\n    output = output.write(32/*' '*/);\n    const id = input.id();\n    if (id !== null) {\n      Format.display(id, output);\n    }\n    output = output.write(58/*':'*/);\n    Format.displayNumber(start._line, output);\n    output = output.write(58/*':'*/);\n    Format.displayNumber(start._column, output);\n    output = output.writeln();\n\n    Diagnostic.displayLineLead(lineDigits, output);\n  }\n\n  private static displayCause(cause: Diagnostic, contextLines: number,\n                              lineDigits: number, output: Output): Diagnostic | null {\n    const input = cause._input.clone();\n    const start = cause._tag.start();\n    const end = cause._tag.end();\n    const severity = cause._severity;\n    const note = cause._note;\n    const next = cause._cause;\n    return Diagnostic.displayContext(input, start, end, severity, note, next,\n                                     contextLines, lineDigits, output);\n  }\n\n  private static displayContext(input: Input, start: Mark, end: Mark,\n                                severity: Severity, note: string | null,\n                                cause: Diagnostic | null, contextLines: number,\n                                lineDigits: number, output: Output): Diagnostic | null {\n    let next = cause;\n    const sameCause = cause !== null && cause._message === null\n                   && Objects.equal(input.id(), cause._input.id());\n    const causeOrder = sameCause ? (start._offset <= cause!._tag.start()._offset ? -1 : 1) : 0;\n    if (causeOrder === 1) {\n      next = Diagnostic.displayCause(cause!, contextLines, lineDigits, output);\n      output = output.writeln();\n      Diagnostic.displayLineLeadEllipsis(lineDigits, output);\n      output = output.writeln();\n    }\n    Diagnostic.displayLines(input, start, end, severity, contextLines, lineDigits, output);\n    if (note !== null) {\n      Diagnostic.displayNote(note, lineDigits, output);\n    }\n    if (causeOrder === -1) {\n      output = output.writeln();\n      Diagnostic.displayLineLeadEllipsis(lineDigits, output);\n      output = output.writeln();\n      next = Diagnostic.displayCause(cause!, contextLines, lineDigits, output);\n    }\n    return next;\n  }\n\n  private static displayLines(input: Input, start: Mark, end: Mark,\n                              severity: Severity, contextLines: number,\n                              lineDigits: number, output: Output): void {\n    const startLine = start.line();\n    const endLine = end.line();\n    let line = input.line();\n\n    while (line < startLine) {\n      Diagnostic.consumeLineText(input, line);\n      line += 1;\n    }\n\n    if (endLine - startLine > 2 * contextLines + 2) {\n      while (line <= startLine + contextLines) {\n        Diagnostic.displayLine(input, start, end, severity, line, lineDigits, output);\n        line += 1;\n      }\n      Diagnostic.displayLineLeadEllipsis(lineDigits, output);\n      output = output.write(32/*' '*/);\n      Diagnostic.formatSeverity(severity, output);\n      output = output.write(124/*'|'*/);\n      OutputStyle.reset(output);\n      output = output.writeln();\n      while (line < endLine - contextLines) {\n        Diagnostic.consumeLineText(input, line);\n        line += 1;\n      }\n    }\n\n    while (line <= endLine) {\n      Diagnostic.displayLine(input, start, end, severity, line, lineDigits, output);\n      line += 1;\n    }\n  }\n\n  private static displayNote(note: string | null, lineDigits: number, output: Output): void {\n    output = output.writeln();\n    Diagnostic.displayLineLead(lineDigits, output);\n    output = output.writeln();\n    Diagnostic.displayLineComment('note', note, lineDigits, output);\n  }\n\n  private static displayLine(input: Input, start: Mark, end: Mark,\n                             severity: Severity, line: number,\n                             lineDigits: number, output: Output): void {\n    if (start._line === line && end._line === line) {\n      Diagnostic.displaySingleLine(input, start, end, severity, line, lineDigits, output);\n    } else if (start._line === line) {\n      Diagnostic.displayStartLine(input, start, severity, line, lineDigits, output);\n    } else if (end._line === line) {\n      Diagnostic.displayEndLine(input, end, severity, line, lineDigits, output);\n    } else {\n      Diagnostic.displayMidLine(input, severity, line, lineDigits, output);\n    }\n  }\n\n  private static displaySingleLine(input: Input, start: Mark, end: Mark,\n                                   severity: Severity, line: number,\n                                   lineDigits: number, output: Output): void {\n    Diagnostic.displayLineLeadNumber(line, lineDigits, output);\n    output = output.write(32/*' '*/);\n    for (let i = 1; i < input.column(); i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    Diagnostic.displayLineText(input, line, output);\n\n    Diagnostic.displayLineLead(lineDigits, output);\n    output = output.write(32/*' '*/);\n    let i = 1;\n    while (i < start._column) {\n      output = output.write(32/*' '*/);\n      i += 1;\n    }\n    Diagnostic.formatSeverity(severity, output);\n    while (i <= end._column) {\n      output = output.write(94/*'^'*/);\n      i += 1;\n    }\n    if (end._note !== null) {\n      output = output.write(32/*' '*/).write(end._note);\n    }\n    OutputStyle.reset(output);\n  }\n\n  private static displayStartLine(input: Input, start: Mark,\n                                  severity: Severity, line: number,\n                                  lineDigits: number, output: Output): void {\n    Diagnostic.displayLineLeadNumber(line, lineDigits, output);\n    output = output.write(32/*' '*/).write(32/*' '*/).write(32/*' '*/);\n    for (let i = 1; i < input.column(); i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    Diagnostic.displayLineText(input, line, output);\n\n    Diagnostic.displayLineLead(lineDigits, output);\n    output = output.write(32/*' '*/).write(32/*' '*/);\n    Diagnostic.formatSeverity(severity, output);\n    output = output.write(95/*'_'*/);\n    let i = 1;\n    while (i < start._column) {\n      output = output.write(95/*'_'*/);\n      i += 1;\n    }\n    output = output.write(94/*'^'*/);\n    if (start._note !== null) {\n      output = output.write(32/*' '*/).write(start._note);\n    }\n    OutputStyle.reset(output);\n    output = output.writeln();\n  }\n\n  private static displayEndLine(input: Input, end: Mark,\n                                severity: Severity, line: number,\n                                lineDigits: number, output: Output): void {\n    Diagnostic.displayLineLeadNumber(line, lineDigits, output);\n    output = output.write(32/*' '*/);\n    Diagnostic.formatSeverity(severity, output);\n    output = output.write(124/*'|'*/);\n    OutputStyle.reset(output);\n    output = output.write(32/*' '*/);\n    Diagnostic.displayLineText(input, line, output);\n\n    Diagnostic.displayLineLead(lineDigits, output);\n    output = output.write(32/*' '*/);\n    Diagnostic.formatSeverity(severity, output);\n    output = output.write(124/*'|'*/).write(95/*'_'*/);\n    let i = 1;\n    while (i < end._column) {\n      output = output.write(95/*'_'*/);\n      i += 1;\n    }\n    output = output.write(94/*'^'*/);\n    if (end._note !== null) {\n      output = output.write(32/*' '*/).write(end._note);\n    }\n    OutputStyle.reset(output);\n  }\n\n  private static displayMidLine(input: Input, severity: Severity, line: number,\n                                lineDigits: number, output: Output): void {\n    Diagnostic.displayLineLeadNumber(line, lineDigits, output);\n    output = output.write(32/*' '*/);\n    Diagnostic.formatSeverity(severity, output);\n    output = output.write(124/*'|'*/);\n    OutputStyle.reset(output);\n    output = output.write(32/*' '*/);\n    Diagnostic.displayLineText(input, line, output);\n  }\n\n  private static displayLineComment(label: string, comment: string | null,\n                                    lineDigits: number, output: Output): void {\n    Diagnostic.displayLineLeadComment(lineDigits, output);\n    output = output.write(32/*' '*/);\n    OutputStyle.bold(output);\n    output = output.write(label).write(58/*':'*/);\n    OutputStyle.reset(output);\n    if (comment != null) {\n      output = output.write(32/*' '*/).write(comment);\n    }\n  }\n\n  private static displayLineLead(lineDigits: number, output: Output): void {\n    OutputStyle.blueBold(output);\n    const padding = 1 + lineDigits;\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = output.write(124/*'|'*/);\n    OutputStyle.reset(output);\n  }\n\n  private static displayLineLeadComment(lineDigits: number, output: Output): void {\n    OutputStyle.blueBold(output);\n    const padding = 1 + lineDigits;\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    output = output.write(61/*'='*/);\n    OutputStyle.reset(output);\n  }\n\n  private static displayLineLeadArrow(lineDigits: number, output: Output): void {\n    for (let i = 0; i < lineDigits; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    OutputStyle.blueBold(output);\n    output = output.write(45/*'-'*/).write(45/*'-'*/).write(62/*'>'*/);\n    OutputStyle.reset(output);\n  }\n\n  private static displayLineLeadEllipsis(lineDigits: number, output: Output): void {\n    OutputStyle.blueBold(output);\n    for (let i = 0; i < lineDigits; i += 1) {\n      output = output.write(46/*'.'*/);\n    }\n    OutputStyle.reset(output);\n    output = output.write(32/*' '*/).write(32/*' '*/);\n  }\n\n  private static displayLineLeadNumber(line: number, lineDigits: number, output: Output): void {\n    const padding = lineDigits - Base10.countDigits(line);\n    for (let i = 0; i < padding; i += 1) {\n      output = output.write(32/*' '*/);\n    }\n    OutputStyle.blueBold(output);\n    Format.displayNumber(line, output);\n    output = output.write(32/*' '*/).write(124/*'|'*/);\n    OutputStyle.reset(output);\n  }\n\n  private static displayLineText(input: Input, line: number, output: Output): void {\n    while (input.isCont() && input.line() === line) {\n      output = output.write(input.head());\n      input = input.step();\n    }\n    if (input.line() === line) {\n      output = output.writeln();\n    }\n  }\n\n  private static consumeLineText(input: Input, line: number): void {\n    while (input.isCont() && input.line() === line) {\n      input = input.step();\n    }\n  }\n\n  private static formatSeverity(severity: Severity, output: Output): void {\n    switch (severity.level()) {\n      case Severity.FATAL_LEVEL:\n      case Severity.ALERT_LEVEL:\n      case Severity.ERROR_LEVEL:\n        OutputStyle.redBold(output);\n        break;\n      case Severity.WARNING_LEVEL:\n        OutputStyle.yellowBold(output);\n        break;\n      case Severity.NOTE_LEVEL:\n        OutputStyle.greenBold(output);\n        break;\n      case Severity.INFO_LEVEL:\n        OutputStyle.cyanBold(output);\n        break;\n      case Severity.DEBUG_LEVEL:\n      case Severity.TRACE_LEVEL:\n      default:\n        OutputStyle.magentaBold(output);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\n/**\n * Thrown when a [[Parser]] parses invalid syntax.\n */\nimport {Diagnostic} from \"./Diagnostic\";\n\nexport class ParserException extends Error {\n  readonly diagnostic?: Diagnostic;\n\n  constructor(message?: Diagnostic | string) {\n    super(message instanceof Diagnostic ? message.message() || void 0 : message);\n    if (message instanceof Diagnostic) {\n      this.diagnostic = message;\n    }\n    (this as any).__proto__ = ParserException.prototype;\n  }\n\n  toString(): string {\n    if (this.diagnostic) {\n      return this.diagnostic.toString();\n    } else {\n      return super.toString();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {ParserException} from \"./ParserException\";\nimport {Diagnostic} from \"./Diagnostic\";\n\n/**\n * Continuation of how to parse subsequent [[Input]] tokens from a stream.\n * `Parser` enables efficient, interruptible parsing of network protocols and\n * data formats, without intermediate buffering.\n *\n * ### Input tokens\n * A `Parser` reads tokens from an `Input` reader.  Input tokens are modeled as\n * primitive numbers, commonly representing Unicode code points, or raw octets.\n * Each `Parser` implementation specifies the semantic type of input tokens it\n * consumes.\n *\n * ### Parser states\n * A `Parser` is always in one of three states: _cont_​inue, _done_, or _error_.\n * The _cont_ state indicates that [[feed]] is ready to consume `Input`; the\n * _done_ state indicates that parsing terminated successfully, and that\n * [[bind]] will return the parsed result; the _error_ state indicates that\n * parsing terminated in failure, and that [[trap]] will return the parse error.\n * `Parser` subclasses default to the _cont_ state.\n *\n * ### Feeding input\n * The [[feed]] method incrementally parses as much `Input` as it can, before\n * returning another `Parser` that represents the continuation of how to parse\n * additional `Input`.  The `Input` passed to `feed` is only guaranteed to be\n * valid for the duration of the method call; references to the provided `Input`\n * instance must not be stored.\n *\n * ### Parser results\n * A `Parser` produces a parsed result of type `O`, obtained via the [[bind]]\n * method.  `bind` is only guaranteed to return a result when in the _done_\n * state; though `bind` may optionally make available partial results in other\n * states.  A failed `Parser` provides a parse error via the [[trap]] method.\n * `trap` is only guaranteed to return an error when in the _error_ state.\n *\n * ### Continuations\n * A `Parser` instance represents a continuation of how to parse remaining\n * `Input`.  Rather than parsing a complete input in one go, a `Parser` takes\n * an `Input` chunk and returns another `Parser` instance that knows how to\n * parse subsequent `Input` chunks.  This enables non-blocking, incremental\n * parsing that can be interrupted whenever an `Input` reader runs out of\n * immediately available data.  A `Parser` terminates by returning a\n * continuation in either the _done_ state, or the _error_ state.\n * [[Parser.done]] returns a `Parser` in the _done_ state.  [[Parser.error]]\n * returns a `Parser` in the _error_ state.\n *\n * ### Iteratees\n * `Parser` is an [Iteratee](https://en.wikipedia.org/wiki/Iteratee).  Though\n * unlike strictly functional iteratees, a `Parser` statefully iterates over\n * its `Input`, rather than allocating an object for each incremental input\n * continutaion.  This internal mutability minimizes garbage collector memory\n * pressure, without violating the functional Iteratee abstraction, provided\n * that `feed` logically takes exclusive ownership of its `Input` when invoked,\n * and logically returns ownership of the `Input` in a state that's consistent\n * with the returned `Parser` continuation.\n *\n * ### Immutability\n * A `Parser` should be immutable.  Specifically, an invocation of `feed`\n * should not alter the behavior of future calls to `feed` on the same `Parser`\n * instance.  A `Parser` should only mutate its internal state if it's essential\n * to do so, such as for critical path performance reasons.\n *\n * ### Backtracking\n * `feed` can internally [[Input.clone clone]] its `Input`, if it might need to\n * backtrack.  Keep in mind that, because `Input` is only valid for the duration\n * of a call to `feed`, input must be internally buffered if it needs to be\n * preserved between `feed` invocations.\n *\n * ### Forking\n * The [[fork]] method passes an out-of-band condition to a `Parser`, yielding\n * a `Parser` continuation whose behavior may be altered by the given condition.\n * For example, an HTML `Parser` might `fork` an inner text parser to directly\n * parse an embedded micro format out of an HTML element, based on some\n * out-of-band schema information.  The types of conditions accepted by `fork`,\n * and their intended semantics, are implementation defined.\n */\nexport abstract class Parser<O> {\n  /**\n   * Returns `true` when [[feed]] is able to consume `Input`.  i.e. this\n   * `Parser` is in the _cont_ state.\n   */\n  isCont(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` when parsing has terminated successfully, and [[bind]] will\n   * return the parsed result.  i.e. this `Parser` is in the _done_ state.\n   */\n  isDone(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns `true` when parsing has terminated in failure, and [[trap]] will\n   * return the parse error.  i.e. this `Parser` is in the _error_ state.\n   */\n  isError(): boolean {\n    return false;\n  }\n\n  /**\n   * Incrementally parses as much `Input` as possible, and returns another\n   * `Parser` that represents the continuation of how to parse additional\n   * `Input`.  The given `input` is only guaranteed to be valid for the\n   * duration of the method call; references to `input` must not be stored.\n   */\n\n  /**\n   * Incrementally parses as much `input` as possible, and returns another\n   * `Parser` that represents the continuation of how to parse additional\n   * `Input`.  If `input` enters the _done_ state, `feed` _must_ return a\n   * terminated `Parser`, i.e. a `Parser` in the _done_ state, or in the\n   * _error_ state.  The given `input` is only guaranteed to be valid for the\n   * duration of the method call; references to `input` must not be stored.\n   */\n  abstract feed(input: Input): Parser<O>;\n\n  /**\n   * Returns a `Parser` continuation whose behavior may be altered by the\n   * given out-of-band `condition`.\n   */\n  fork(condition: unknown): Parser<O> {\n    return this;\n  }\n\n  /**\n   * Returns the parsed result.  Only guaranteed to return a result when in the\n   * _done_ state.\n   *\n   * @throws `Error` if this `Parser is not in the _done_ state.\n   */\n  bind(): O {\n    throw new Error();\n  }\n\n  /**\n   * Returns the parse error.  Only guaranteed to return an error when in the\n   * _error_ state.\n   *\n   * @throws `Error` if this `Parser` is not in the _error_ state.\n   */\n  trap(): Error {\n    throw new Error();\n  }\n\n  /**\n   * Casts an errored `Parser` to a different output type.  A `Parser` in the\n   * _error_ state can have any output type.\n   *\n   * @throws `Error` if this `Parser` is not in the _error_ state.\n   */\n  asError<O2>(): Parser<O2> {\n    throw new Error();\n  }\n\n  private static _done?: Parser<any>;\n\n  /**\n   * Returns a `Parser` in the _done_ state that `bind`s an `undefined` parsed result.\n   */\n  static done<O>(): Parser<O>;\n\n  /**\n   * Returns a `Parser` in the _done_ state that `bind`s the given parsed `output`.\n   */\n  static done<O>(output: O): Parser<O>;\n\n  static done<O>(output?: O): Parser<O> {\n    if (output === void 0) {\n      if (!Parser._done) {\n        Parser._done = new ParserDone<any>(void 0);\n      }\n      return Parser._done;\n    } else {\n      return new ParserDone<O>(output);\n    }\n  }\n\n  /**\n   * Returns a `Parser` in the _error_ state that `trap`s the given parse `error`.\n   */\n  static error<O>(error: Error | Diagnostic): Parser<O> {\n    if (error instanceof Error) {\n      return new ParserError<O>(error);\n    } else {\n      return new ParserError<O>(new ParserException(error));\n    }\n  }\n}\n\n/** @hidden */\nclass ParserDone<O> extends Parser<O> {\n  /** @hidden */\n  readonly _output: O;\n\n  constructor(output: O) {\n    super();\n    this._output = output;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return true;\n  }\n\n  feed(input: Input): Parser<O> {\n    return this;\n  }\n\n  bind(): O {\n    return this._output;\n  }\n}\n\n/** @hidden */\nclass ParserError<O> extends Parser<O> {\n  /** @hidden */\n  readonly _error: Error;\n\n  constructor(error: Error) {\n    super();\n    this._error = error;\n  }\n\n  isCont(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return true;\n  }\n\n  feed(input: Input): Parser<O> {\n    return this;\n  }\n\n  bind(): O {\n    throw this._error;\n  }\n\n  trap(): Error {\n    return this._error;\n  }\n\n  asError<O2>(): Parser<O2> {\n    return this as any;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode, Murmur3} from \"@swim/util\";\nimport {Output} from \"./Output\";\nimport {Format} from \"./Format\";\nimport {Debug} from \"./Debug\";\n\n/**\n * Unicode transformation format error handling mode.\n */\nexport abstract class UtfErrorMode implements HashCode, Debug {\n  /**\n   * Returns {@code true} if a Unicode decoding should abort with an error when\n   * an invalid code unit sequence is encountered.\n   */\n  isFatal(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns {@code true} if a Unicode decoding should substitute invalid code\n   * unit sequences with a replacement character.\n   */\n  isReplacement(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the Unicode code point of the replacement character to substitute\n   * for invalid code unit sequences.  Defaults to {@code U+FFFD}.\n   */\n  replacementChar(): number {\n    return 0xfffd;\n  }\n\n  /**\n   * Returns {@code true} if Unicode decoding should abort with an error when\n   * a {@code NUL} byte is encountered.\n   */\n  abstract isNonZero(): boolean;\n\n  /**\n   * Returns a {@code UtfErrorMode} that, if {@code isNonZero} is {@code true},\n   * aborts when Unicode decoding encounters a {@code NUL} byte.\n   */\n  abstract isNonZero(isNonZero: boolean): UtfErrorMode;\n\n  abstract equals(that: unknown): boolean;\n\n  abstract hashCode(): number;\n\n  abstract debug(output: Output): void;\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  private static _fatal?: UtfErrorMode;\n  private static _fatalNonZero?: UtfErrorMode;\n  private static _replacement?: UtfErrorMode;\n  private static _replacementNonZero?: UtfErrorMode;\n\n  /**\n   * Returns a {@code UtfErrorMode} that aborts Unicode decoding with an error\n   * when invalid code unit sequences are encountered.\n   */\n  static fatal(): UtfErrorMode {\n    if (!UtfErrorMode._fatal) {\n      UtfErrorMode._fatal = new UtfFatalErrorMode(false);\n    }\n    return UtfErrorMode._fatal;\n  }\n\n  /**\n   * Returns a {@code UtfErrorMode} that aborts Unicode decoding with an error\n   * when invalid code unit sequences, and {@code NUL} bytes, are encountered.\n   */\n  static fatalNonZero(): UtfErrorMode {\n    if (!UtfErrorMode._fatalNonZero) {\n      UtfErrorMode._fatalNonZero = new UtfFatalErrorMode(true);\n    }\n    return UtfErrorMode._fatalNonZero;\n  }\n\n  /**\n   * Returns a {@code UtfErrorMode} that substitutes invalid code unit\n   * sequences with the replacement character ({@code U+FFFD}).\n   */\n  static replacement(): UtfErrorMode;\n\n  /**\n   * Returns a {@code UtfErrorMode} that substitutes invalid code unit\n   * sequences with the given {@code replacementChar}.\n   */\n  static replacement(replacementChar: number): UtfErrorMode;\n\n  static replacement(replacementChar?: number): UtfErrorMode {\n    if (replacementChar === void 0 || replacementChar === 0xfffd) {\n      if (!UtfErrorMode._replacement) {\n        UtfErrorMode._replacement = new UtfReplacementErrorMode(0xfffd, false);\n      }\n      return UtfErrorMode._replacement;\n    } else {\n      return new UtfReplacementErrorMode(replacementChar, false);\n    }\n  }\n\n  /**\n   * Returns a {@code UtfErrorMode} that substitutes invalid code unit\n   * sequences with the replacement character ({@code U+FFFD}), and aborts\n   * decoding with an error when {@code NUL} bytes are encountered.\n   */\n  static replacementNonZero(): UtfErrorMode;\n\n  /**\n   * Returns a {@code UtfErrorMode} that substitutes invalid code unit\n   * sequences with the given {@code replacementChar}, and aborts decoding\n   * with an error when {@code NUL} bytes are encountered.\n   */\n  static replacementNonZero(replacementChar: number): UtfErrorMode;\n\n  static replacementNonZero(replacementChar?: number): UtfErrorMode {\n    if (replacementChar === void 0 || replacementChar === 0xfffd) {\n      if (!UtfErrorMode._replacementNonZero) {\n        UtfErrorMode._replacementNonZero = new UtfReplacementErrorMode(0xfffd, true);\n      }\n      return UtfErrorMode._replacementNonZero;\n    } else {\n      return new UtfReplacementErrorMode(replacementChar, true);\n    }\n  }\n}\n\n/** @hidden */\nclass UtfFatalErrorMode extends UtfErrorMode {\n  /** @hidden */\n  private readonly _isNonZero: boolean;\n\n  constructor(isNonZero: boolean) {\n    super();\n    this._isNonZero = isNonZero;\n  }\n\n  isFatal(): boolean {\n    return true;\n  }\n\n  isNonZero(): boolean;\n  isNonZero(isNonZero: boolean): UtfErrorMode;\n  isNonZero(isNonZero?: boolean): boolean | UtfErrorMode {\n    if (isNonZero === void 0) {\n      return this._isNonZero;\n    } else if (isNonZero) {\n      return UtfErrorMode.fatalNonZero();\n    } else {\n      return UtfErrorMode.fatal();\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UtfFatalErrorMode) {\n      return this._isNonZero === that._isNonZero;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (UtfFatalErrorMode._hashSeed === void 0) {\n      UtfFatalErrorMode._hashSeed = Murmur3.seed(UtfFatalErrorMode);\n    }\n    return Murmur3.mash(Murmur3.mix(UtfFatalErrorMode._hashSeed,\n        Murmur3.hash(this._isNonZero)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UtfErrorMode\").write(46/*'.'*/)\n        .write(this.isNonZero ? \"fatalNonZero\" : \"fatal\")\n        .write(40/*'('*/).write(41/*')'*/);\n  }\n\n  private static _hashSeed?: number;\n}\n\n/** @hidden */\nclass UtfReplacementErrorMode extends UtfErrorMode {\n  private readonly _replacementChar: number;\n  private readonly _isNonZero: boolean;\n\n  /** @hidden */\n  constructor(replacementChar: number, isNonZero: boolean) {\n    super();\n    this._replacementChar = replacementChar;\n    this._isNonZero = isNonZero;\n  }\n\n  isReplacement(): boolean {\n    return true;\n  }\n\n  replacementChar(): number {\n    return this._replacementChar;\n  }\n\n  isNonZero(): boolean;\n  isNonZero(isNonZero: boolean): UtfErrorMode;\n  isNonZero(isNonZero?: boolean): boolean | UtfErrorMode {\n    if (isNonZero === void 0) {\n      return this._isNonZero;\n    } else if (this._replacementChar === 0xfffd) {\n      if (isNonZero) {\n        return UtfErrorMode.replacementNonZero();\n      } else {\n        return UtfErrorMode.replacement();\n      }\n    } else {\n      return new UtfReplacementErrorMode(this._replacementChar, isNonZero);\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UtfReplacementErrorMode) {\n      return this.replacementChar === that.replacementChar\n          && this.isNonZero === that.isNonZero;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (UtfReplacementErrorMode._hashSeed === void 0) {\n      UtfReplacementErrorMode._hashSeed = Murmur3.seed(UtfReplacementErrorMode);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(UtfReplacementErrorMode._hashSeed,\n        this._replacementChar), Murmur3.hash(this._isNonZero)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UtfErrorMode\").write(46/*'.'*/)\n        .write(this._isNonZero ? \"replacementNonZero\" : \"replacement\")\n        .write(40/*'('*/);\n    if (this._replacementChar !== 0xfffd) {\n      Format.debugChar(this._replacementChar, output);\n    }\n    output = output.write(41/*')'*/);\n  }\n\n  private static _hashSeed?: number;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputException} from \"./OutputException\";\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {OutputBuffer} from \"./OutputBuffer\";\n\n/** @hidden */\nexport class Uint8ArrayOutput extends OutputBuffer<Uint8Array> {\n  /** @hidden */\n  _array: Uint8Array;\n  /** @hidden */\n  _index: number;\n  /** @hidden */\n  _limit: number;\n  /** @hidden */\n  _settings: OutputSettings;\n  /** @hidden */\n  _isPart: boolean;\n\n  constructor(array: Uint8Array, index: number, limit: number,\n              settings: OutputSettings = OutputSettings.standard(), isPart: boolean = false) {\n    super();\n    this._array = array;\n    this._index = index;\n    this._limit = limit;\n    this._settings = settings;\n    this._isPart = isPart;\n  }\n\n  isCont(): boolean {\n    return this._index < this._limit;\n  }\n\n  isFull(): boolean {\n    return this._isPart && this._index >= this._limit;\n  }\n\n  isDone(): boolean {\n    return !this._isPart && this._index >= this._limit;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): OutputBuffer<Uint8Array>;\n  isPart(isPart?: boolean): boolean | OutputBuffer<Uint8Array> {\n    if (isPart === void 0) {\n      return this._isPart;\n    } else {\n      this._isPart = isPart;\n      return this;\n    }\n  }\n\n  index(): number;\n  index(index: number): OutputBuffer<Uint8Array>;\n  index(index?: number): number | OutputBuffer<Uint8Array> {\n    if (index === void 0) {\n      return this._index;\n    } else if (0 <= index && index <= this._limit) {\n      this._index = index;\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid index\"), this._settings);\n    }\n  }\n\n  limit(): number;\n  limit(limit: number): OutputBuffer<Uint8Array>;\n  limit(limit?: number): number | OutputBuffer<Uint8Array> {\n    if (limit === void 0) {\n      return this._limit;\n    } else if (0 <= limit && limit <= this._array.length) {\n      this._limit = limit;\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid limit\"), this._settings);\n    }\n  }\n\n  capacity(): number {\n    return this._array.length;\n  }\n\n  remaining(): number {\n    return this._limit - this._index;\n  }\n\n  has(index: number): boolean {\n    return 0 <= index && index < this._limit;\n  }\n\n  get(index: number): number {\n    if (0 <= index && index < this._limit) {\n      return this._array[index];\n    } else {\n      throw new OutputException();\n    }\n  }\n\n  set(index: number, token: number): void {\n    if (0 <= index && index < this._limit) {\n      this._array[index] = token;\n    } else {\n      throw new OutputException();\n    }\n  }\n\n  write(token: number | string): OutputBuffer<Uint8Array> {\n    if (typeof token === \"number\") {\n      const index = this._index;\n      if (index < this._limit) {\n        this._array[index] = token;\n        this._index = index + 1;\n        return this;\n      } else {\n        return OutputBuffer.error(new OutputException(\"full\"), this._settings);\n      }\n    } else {\n      return OutputBuffer.error(new OutputException(\"binary output\"), this._settings);\n    }\n  }\n\n  writeln(string?: string): OutputBuffer<Uint8Array> {\n    return OutputBuffer.error(new OutputException(\"binary output\"), this._settings);\n  }\n\n  step(offset: number): OutputBuffer<Uint8Array> {\n    const index = this._index + offset;\n    if (0 <= index && index <= this._limit) {\n      this._index = index;\n      return this;\n    } else {\n      return OutputBuffer.error(new OutputException(\"invalid step\"), this._settings);\n    }\n  }\n\n  bind(): Uint8Array {\n    return new Uint8Array(this._array.buffer, 0, this._index);\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): OutputBuffer<Uint8Array>;\n  settings(settings?: AnyOutputSettings): OutputSettings | OutputBuffer<Uint8Array> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = OutputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  clone(): OutputBuffer<Uint8Array> {\n    return new Uint8ArrayOutput(this._array, this._index, this._limit, this._settings, this._isPart);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {ByteOutput} from \"./ByteOutput\";\n\n/** @hidden */\nexport class ByteOutputUint8Array extends ByteOutput<Uint8Array> {\n  constructor(array: Uint8Array | null, size: number, settings: OutputSettings) {\n    super(array, size, settings);\n  }\n\n  bind(): Uint8Array {\n    return this.toUint8Array();\n  }\n\n  clone(): Output<Uint8Array> {\n    return new ByteOutputUint8Array(this.cloneArray(), this._size, this._settings);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\n\n/** @hidden */\nexport abstract class ByteOutput<T> extends Output<T> {\n  /** @hidden */\n  _array: Uint8Array | null;\n  /** @hidden */\n  _size: number;\n  /** @hidden */\n  _settings: OutputSettings;\n\n  constructor(array: Uint8Array | null, size: number, settings: OutputSettings) {\n    super();\n    this._array = array;\n    this._size = size;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return true;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  write(b: number | string): Output<T> {\n    if (typeof b === \"number\") {\n      const n = this._size;\n      const oldArray = this._array;\n      let newArray;\n      if (oldArray === null || n + 1 > oldArray.length) {\n        newArray = new Uint8Array(ByteOutput.expand(n + 1));\n        if (oldArray !== null) {\n          newArray.set(oldArray, 0);\n        }\n        this._array = newArray;\n      } else {\n        newArray = oldArray;\n      }\n      newArray[n] = b;\n      this._size = n + 1;\n      return this;\n    } else {\n      throw new TypeError(\"\" + b);\n    }\n  }\n\n  writeln(string?: string): Output<T> {\n    throw new TypeError(\"\" + string);\n  }\n\n  toUint8Array(): Uint8Array {\n    const n = this._size;\n    const oldArray = this._array;\n    if (oldArray !== null && n === oldArray.length) {\n      return oldArray;\n    } else {\n      const newArray = new Uint8Array(n);\n      if (oldArray !== null) {\n        newArray.set(oldArray.slice(0, n), 0);\n      }\n      this._array = newArray;\n      return newArray;\n    }\n  }\n\n  cloneArray(): Uint8Array | null {\n    const oldArray = this._array;\n    if (oldArray !== null) {\n      return oldArray.slice(0, this._size);\n    } else {\n      return null;\n    }\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<T>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = OutputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {OutputBuffer} from \"./OutputBuffer\";\nimport {Uint8ArrayOutput} from \"./Uint8ArrayOutput\";\nimport {ByteOutputUint8Array} from \"./ByteOutputUint8Array\";\n\n/**\n * Byte [[Input]]/[[Output]] factory.\n *\n * The `Binary.uint8ArrayOutput(...)}` function returns an `Output` that writes\n * bytes to a growable array, and [[Output.bind binds]] a `Uint8Array`\n * containing all written bytes.\n */\nexport class Binary {\n  private constructor() {\n    // nop\n  }\n\n  static outputBuffer(array: Uint8Array, offset: number = 0, length: number = array.length): OutputBuffer<Uint8Array> {\n    return new Uint8ArrayOutput(array, offset, offset + length);\n  }\n\n  /**\n   * Returns a new `Output` that appends bytes to a growable array,\n   * pre-allocated with space for `initialCapacity` bytes, if `initialCapacity`\n   * is defined, using the given `settings`, if `settings` is defined.  The\n   * returned `Output` accepts an unbounded number of bytes, remaining\n   * permanently in the _cont_ state, and can [[Output.bind bind]] a\n   * `Uint8Array` with the current output state at any time.\n   */\n  static uint8ArrayOutput(initialCapacity?: number, settings?: AnyOutputSettings): Output<Uint8Array>;\n  /**\n   * Returns a new `Output` that appends bytes to a growable array, using the\n   * given `settings`.  The returned `Output` accepts an unbounded number of\n   * bytes, remaining permanently in the _cont_ state, and can [[Output.bind\n   * bind]] a `Uint8Array` array with the current output state at any time.\n   */\n  static uint8ArrayOutput(settings: AnyOutputSettings): Output<Uint8Array>;\n  static uint8ArrayOutput(initialCapacity?: number | AnyOutputSettings,\n                          settings?: AnyOutputSettings): Output<Uint8Array> {\n    if (settings === void 0 && typeof initialCapacity !== \"number\") {\n      settings = initialCapacity;\n      initialCapacity = void 0;\n    } else if (typeof initialCapacity !== \"number\") {\n      initialCapacity = void 0;\n    }\n    let array: Uint8Array | null;\n    if (typeof initialCapacity === \"number\") {\n      array = new Uint8Array(initialCapacity);\n    } else {\n      array = null;\n    }\n    settings = OutputSettings.fromAny(settings);\n    return new ByteOutputUint8Array(array, 0, settings);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Writer} from \"./Writer\";\nimport {Format} from \"./Format\";\nimport {Unicode} from \"./Unicode\";\nimport {Binary} from \"./Binary\";\nimport {Base16Parser} from \"./Base16Parser\";\nimport {Base16Writer} from \"./Base16Writer\";\nimport {Base16IntegerWriter} from \"./Base16IntegerWriter\";\n\n/**\n * Base-16 (hexadecimal) encoding [[Parser]]/[[Writer]] factory.\n */\nexport class Base16 {\n  /** @hidden */\n  readonly _alphabet: string;\n\n  constructor(alphabet: string) {\n    this._alphabet = alphabet;\n  }\n\n  /**\n   * Returns a 16 character string, where the character at index `i` is the\n   * encoding of the base-16 digit `i`.\n   */\n  alphabet(): string {\n    return this._alphabet;\n  }\n\n  /**\n   * Returns the Unicode code point of the base-16 digit that encodes the given\n   * 4-bit quantity.\n   */\n  encodeDigit(b: number): number {\n    return this._alphabet.charCodeAt(b);\n  }\n\n  /**\n   * Returns a `Writer` that, when fed an input `Uint8Array`, returns a\n   * continuation that writes the base-16 (hexadecimal) encoding of the input\n   * byte array.\n   */\n  uint8ArrayWriter(): Writer<Uint8Array, unknown>;\n  /**\n   * Returns a `Writer` continuation that writes the base-16 (hexadecimal)\n   * encoding of the `input` `Uint8Array`.\n   */\n  uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;\n  uint8ArrayWriter(input?: Uint8Array): Writer<unknown, unknown> {\n    if (input === void 0) {\n      return new Base16.Writer(void 0, void 0, this);\n    } else {\n      return new Base16.Writer(input, input, this);\n    }\n  }\n\n  /**\n   * Writes the base-16 (hexadecimal) encoding of the `input` `Uint8Array` to\n   * the `output`, returning a `Writer` continuation that knows how to write any\n   * remaining output that couldn't be immediately generated.\n   */\n  writeUint8Array(input: Uint8Array, output: Output): Writer<unknown, unknown> {\n    return Base16.Writer.write(output, void 0, input, this);\n  }\n\n  writeInteger(input: number, output: Output, width: number = 0): Writer<unknown, unknown> {\n    return Base16.IntegerWriter.write(output, void 0, input, width, this);\n  }\n\n  writeIntegerLiteral(input: number, output: Output, width: number = 0): Writer<unknown, unknown> {\n    return Base16.IntegerWriter.writeLiteral(output, void 0, input, width, this);\n  }\n\n  private static _lowercase?: Base16;\n  private static _uppercase?: Base16;\n\n  /**\n   * Returns the `Base16` encoding with lowercase alphanumeric digits.\n   */\n  public static lowercase(): Base16 {\n    if (!Base16._lowercase) {\n      Base16._lowercase = new Base16(\"0123456789abcdef\");\n    }\n    return Base16._lowercase;\n  }\n\n  /**\n   * Returns the `Base16` encoding with uppercase alphanumeric digits.\n   */\n  public static uppercase(): Base16 {\n    if (!Base16._uppercase) {\n      Base16._uppercase = new Base16(\"0123456789ABCDEF\");\n    }\n    return Base16._uppercase;\n  }\n\n  /**\n   * Returns `true` if the Unicode code point `c` is a valid base-16 digit.\n   */\n  static isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 70/*'F'*/\n        || c >= 97/*'a'*/ && c <= 102/*'f'*/;\n  }\n\n  /**\n   * Returns the 4-bit quantity represented by the base-16 digit `c`.\n   *\n   * @throws `Error` if `c` is not a valid base-16 digit.\n   */\n  static decodeDigit(c: number): number {\n    if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c - 48/*'0'*/;\n    } else if (c >= 65/*'A'*/ && c <= 70/*'F'*/) {\n      return 10 + (c - 65/*'A'*/);\n    } else if (c >= 97/*'a'*/ && c <= 102/*'f'*/) {\n      return 10 + (c - 97/*'a'*/);\n    } else {\n      const message = Unicode.stringOutput();\n      message.write(\"Invalid base-16 digit: \");\n      Format.debugChar(c, message);\n      throw new Error(message.bind());\n    }\n  }\n\n  /**\n   * Decodes the base-16 digits `c1` and `c2`, and writes the 8-bit  quantity\n   * they represent to the given `output`.\n   */\n  static writeQuantum(c1: number, c2: number, output: Output): void {\n    const x = Base16.decodeDigit(c1);\n    const y = Base16.decodeDigit(c2);\n    output = output.write(x << 4 | y);\n  }\n\n  /**\n   * Returns a `Parser` that decodes base-16 (hexadecimal) encoded input, and\n   * writes the decoded bytes to `output`.\n   */\n  static parser<O>(output: Output<O>): Parser<O> {\n    return new Base16.Parser<O>(output);\n  }\n\n  /**\n   * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded\n   * bytes to `output`, returning a `Parser` continuation that knows how to\n   * parse any additional input.\n   */\n  static parse<O>(input: Input, output: Output<O>): Parser<O> {\n    return Base16.Parser.parse(input, output);\n  }\n\n  /**\n   * Parses the base-16 (hexadecimal) encoded `input`, and writes the decoded\n   * bytes to a growable array, returning a `Parser` continuation that knows\n   * how to parse any additional input.  The returned `Parser` [[Parser.bind\n   * binds]] a `Uint8Array` array containing all parsed base-16 data.\n   */\n  static parseUint8Array(input: Input): Parser<Uint8Array> {\n    return Base16.Parser.parse(input, Binary.uint8ArrayOutput());\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Parser: typeof Base16Parser; // defined by Base16Parser\n  /** @hidden */\n  static Writer: typeof Base16Writer; // defined by Base16Writer\n  /** @hidden */\n  static IntegerWriter: typeof Base16IntegerWriter; // defined by Base16IntegerWriter\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {UtfErrorMode} from \"./UtfErrorMode\";\nimport {OutputException} from \"./OutputException\";\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\nimport {Unicode} from \"./Unicode\";\nimport {Base16} from \"./Base16\";\n\n/** @hidden */\nexport class Utf8DecodedOutput<T> extends Output<T> {\n  /** @hidden */\n  _output: Output<T>;\n  /** @hidden */\n  readonly _errorMode: UtfErrorMode;\n  /** @hidden */\n  _c1: number;\n  /** @hidden */\n  _c2: number;\n  /** @hidden */\n  _c3: number;\n  /** @hidden */\n  _have: number;\n\n  constructor(output: Output<T>, errorMode: UtfErrorMode,\n              c1: number = -1, c2: number = -1, c3: number = -1, have: number = 0) {\n    super();\n    this._output = output;\n    this._errorMode = errorMode;\n    this._c1 = c1;\n    this._c2 = c2;\n    this._c3 = c3;\n    this._have = have;\n  }\n\n  isCont(): boolean {\n    return this._output.isCont();\n  }\n\n  isFull(): boolean {\n    return this._output.isFull();\n  }\n\n  isDone(): boolean {\n    return this._output.isDone();\n  }\n\n  isError(): boolean {\n    return this._output.isError();\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return this._output.isPart();\n    } else {\n      this._output = this._output.isPart(isPart);\n      return this;\n    }\n  }\n\n  write(token: number | string): Output<T> {\n    if (typeof token === \"number\") {\n      let c1 = this._c1;\n      let c2 = this._c2;\n      let c3 = this._c3;\n      let c4 = -1;\n      let have = this._have;\n\n      if (token >= 0) {\n        switch (have) {\n          case 0:\n            c1 = token & 0xff;\n            have = 1;\n            break;\n          case 1:\n            c2 = token & 0xff;\n            have = 2;\n            break;\n          case 2:\n            c3 = token & 0xff;\n            have = 3;\n            break;\n          case 3:\n            c4 = token & 0xff;\n            have = 4;\n            break;\n          default:\n            throw new Error(\"unreachable\");\n        }\n      }\n\n      if (c1 === 0 && this._errorMode.isNonZero()) { // invalid NUL byte\n        return Output.error(new OutputException(\"unexpected NUL byte\"));\n      } else if (c1 >= 0 && c1 <= 0x7f) { // U+0000..U+007F\n        this._output = this._output.write(c1);\n        this._have = 0;\n      } else if (c1 >= 0xc2 && c1 <= 0xf4) {\n        if (c1 >= 0xc2 && c1 <= 0xdf && c2 >= 0x80 && c2 <= 0xbf) { // U+0080..U+07FF\n          this._output = this._output.write((c1 & 0x1f) << 6 | c2 & 0x3f);\n          this._c1 = -1;\n          this._have = 0;\n        } else if (c1 === 0xe0 && c2 >= 0xa0 && c2 <= 0xbf // U+0800..U+0FFF\n                || c1 >= 0xe1 && c1 <= 0xec && c2 >= 0x80 && c2 <= 0xbf // U+1000..U+CFFF\n                || c1 === 0xed && c2 >= 0x80 && c2 <= 0x9f // U+D000..U+D7FF\n                || c1 >= 0xee && c1 <= 0xef && c2 >= 0x80 && c2 <= 0xbf) { // U+E000..U+FFFF\n          if (c3 >= 0x80 && c3 <= 0xbf) {\n            this._output = this._output.write((c1 & 0x0f) << 12 | (c2 & 0x3f) << 6 | c3 & 0x3f);\n            this._c1 = -1;\n            this._c2 = -1;\n            this._have = 0;\n          } else if (c3 >= 0) { // invalid c3\n            if (this._errorMode.isFatal()) {\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            }\n            this._output = this._output.write(this._errorMode.replacementChar());\n            this._c1 = c3;\n            this._c2 = -1;\n            this._have = 1;\n          } else if (token < 0 || this._output.isDone()) { // incomplete c3\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          } else { // awaiting c3\n            this._c2 = c2;\n            this._have = 2;\n          }\n        } else if (c1 === 0xf0 && c2 >= 0x90 && c2 <= 0xbf // U+10000..U+3FFFF\n                || c1 >= 0xf1 && c1 <= 0xf3 && c2 >= 0x80 && c2 <= 0xbf // U+40000..U+FFFFF\n                || c1 === 0xf4 && c2 >= 0x80 && c2 <= 0x8f) { // U+100000..U+10FFFF\n          if (c3 >= 0x80 && c3 <= 0xbf) {\n            if (c4 >= 0x80 && c4 <= 0xbf) {\n              this._have = 4;\n              this._output = this._output.write((c1 & 0x07) << 18 | (c2 & 0x3f) << 12 | (c3 & 0x3f) << 6 | c4 & 0x3f);\n              this._c1 = -1;\n              this._c2 = -1;\n              this._c3 = -1;\n              this._have = 0;\n            } else if (c4 >= 0) { // invalid c4\n              if (this._errorMode.isFatal()) {\n                return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3, c4)));\n              }\n              this._output = this._output.write(this._errorMode.replacementChar());\n              this._c1 = c4;\n              this._c2 = -1;\n              this._c3 = -1;\n              this._have = 1;\n            } else if (token < 0 || this._output.isDone()) { // incomplete c4\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            } else { // awaiting c4\n              this._c3 = c3;\n              this._have = 3;\n            }\n          } else if (c3 >= 0) { // invalid c3\n            if (this._errorMode.isFatal()) {\n              return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2, c3)));\n            }\n            this._output = this._output.write(this._errorMode.replacementChar());\n            this._c1 = c3;\n            this._c2 = -1;\n            this._have = 1;\n          } else if (token < 0 || this._output.isDone()) { // incomplete c3\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          } else { // awaiting c3\n            this._c2 = c2;\n            this._have = 2;\n          }\n        } else if (c2 >= 0) { // invalid c2\n          if (this._errorMode.isFatal()) {\n            return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1, c2)));\n          }\n          this._output = this._output.write(this._errorMode.replacementChar());\n          this._c1 = c2;\n          this._have = 1;\n        } else if (token < 0 || this._output.isDone()) { // incomplete c2\n          return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));\n        } else { // awaiting c2\n          this._c1 = c1;\n          this._have = 1;\n        }\n      } else if (c1 >= 0) { // invalid c1\n        if (this._errorMode.isFatal()) {\n          return Output.error(new OutputException(Utf8DecodedOutput.invalid(c1)));\n        }\n        this._output = this._output.write(this._errorMode.replacementChar());\n        this._have = 0;\n      }\n      if (this._output.isError()) {\n        return this._output;\n      }\n      return this;\n    } else if (typeof token === \"string\") {\n      this._output.write(token);\n      return this;\n    } else {\n      throw new TypeError(\"\" + token);\n    }\n  }\n\n  static invalid(c1: number, c2?: number, c3?: number, c4?: number): string {\n    let output = Unicode.stringOutput();\n    output = output.write(\"invalid UTF-8 code unit sequence: \");\n    Base16.uppercase().writeIntegerLiteral(c1, output, 2);\n    if (c2 !== void 0) {\n      output = output.write(' ');\n      Base16.uppercase().writeIntegerLiteral(c2, output, 2);\n      if (c3 !== void 0) {\n        output = output.write(' ');\n        Base16.uppercase().writeIntegerLiteral(c3, output, 2);\n        if (c4 !== void 0) {\n          output = output.write(' ');\n          Base16.uppercase().writeIntegerLiteral(c4, output, 2);\n        }\n      }\n    }\n    return output.bind();\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<T>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._output.settings();\n    } else {\n      this._output.settings(settings);\n      return this;\n    }\n  }\n\n  bind(): T {\n    if (this._have === 0) {\n      return this._output.bind();\n    } else {\n      return this.write(-1).bind();\n    }\n  }\n\n  trap(): Error {\n    return this._output.trap();\n  }\n\n  clone(): Output<T> {\n    return new Utf8DecodedOutput<T>(this._output.clone(), this._errorMode,\n                                    this._c1, this._c2, this._c3, this._have);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {UtfErrorMode} from \"./UtfErrorMode\";\nimport {OutputException} from \"./OutputException\";\nimport {AnyOutputSettings, OutputSettings} from \"./OutputSettings\";\nimport {Output} from \"./Output\";\n\n/** @hidden */\nexport class Utf8EncodedOutput<T> extends Output<T> {\n  /** @hidden */\n  _output: Output<T>;\n  /** @hidden */\n  readonly _errorMode: UtfErrorMode;\n  /** @hidden */\n  _c2: number;\n  /** @hidden */\n  _c3: number;\n  /** @hidden */\n  _c4: number;\n  /** @hidden */\n  _index: number;\n\n  constructor(output: Output<T>, errorMode: UtfErrorMode, c2: number = 0,\n              c3: number = 0, c4: number = 0, index: number = 4) {\n    super();\n    this._output = output;\n    this._errorMode = errorMode;\n    this._c2 = c2;\n    this._c3 = c3;\n    this._c4 = c4;\n    this._index = index;\n  }\n\n  isCont(): boolean {\n    return this._output.isCont();\n  }\n\n  isFull(): boolean {\n    return this._output.isFull();\n  }\n\n  isDone(): boolean {\n    return this._output.isDone();\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<T>;\n  isPart(isPart?: boolean): boolean | Output<T> {\n    if (isPart === void 0) {\n      return this._output.isPart();\n    } else {\n      this._output = this._output.isPart(isPart);\n      return this;\n    }\n  }\n\n  write(token: number | string): Output<T> {\n    if (typeof token === \"number\") {\n      let c1 = 0;\n      let c2 = this._c2;\n      let c3 = this._c3;\n      let c4 = this._c4;\n      let index = this._index;\n      while (index < 4) {\n        if (this._output.isCont()) {\n          switch (index) {\n            case 1: this._output = this._output.write(c2); this._c2 = 0; break;\n            case 2: this._output = this._output.write(c3); this._c3 = 0; break;\n            case 3: this._output = this._output.write(c4); this._c4 = 0; break;\n            default: throw new Error(\"unreachable\");\n          }\n          index += 1;\n        } else {\n          return Output.error(new OutputException(\"unable to flush buffered code units\"));\n        }\n      }\n      if (token >= 0 && token <= 0x7f) { // U+0000..U+007F\n        c4 = token;\n        index = 3;\n      } else if (token >= 0x80 && token <= 0x7ff) { // U+0080..U+07FF\n        c3 = 0xc0 | (token >>> 6);\n        c4 = 0x80 | (token & 0x3f);\n        index = 2;\n      } else if (token >= 0x0800 && token <= 0xffff || // U+0800..U+D7FF\n                 token >= 0xe000 && token <= 0xffff) { // U+E000..U+FFFF\n        c2 = 0xe0 | (token  >>> 12);\n        c3 = 0x80 | ((token >>>  6) & 0x3f);\n        c4 = 0x80 | (token & 0x3f);\n        index = 1;\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        c1 = 0xf0 | (token  >>> 18);\n        c2 = 0x80 | ((token >>> 12) & 0x3f);\n        c3 = 0x80 | ((token >>>  6) & 0x3f);\n        c4 = 0x80 | (token & 0x3f);\n        index = 0;\n      } else { // surrogate or invalid code point\n        if (this._errorMode.isFatal()) {\n          return Output.error(new OutputException(\"invalid code point: \" + token));\n        } else {\n          return this.write(this._errorMode.replacementChar());\n        }\n      }\n      do {\n        switch (index) {\n          case 0: this._output = this._output.write(c1); break;\n          case 1: this._output = this._output.write(c2); this._c2 = 0; break;\n          case 2: this._output = this._output.write(c3); this._c3 = 0; break;\n          case 3: this._output = this._output.write(c4); this._c4 = 0; break;\n          default: throw new Error(\"unreachable\");\n        }\n        index += 1;\n      } while (index < 4 && this._output.isCont());\n      if (index < 4) {\n        if (index < 3) {\n          if (index < 2) {\n            this._c2 = c2;\n          }\n          this._c3 = c3;\n        }\n        this._c4 = c4;\n      }\n      this._index = index;\n      return this;\n    } else if (typeof token === \"string\") {\n      this._output.write(token);\n      return this;\n    } else {\n      throw new TypeError(\"\" + token);\n    }\n  }\n\n  flush(): Output<T> {\n    let index = this._index;\n    while (index < 4) {\n      if (this._output.isCont()) {\n        switch (index) {\n          case 1: this._output = this._output.write(this._c2); this._c2 = 0; break;\n          case 2: this._output = this._output.write(this._c3); this._c3 = 0; break;\n          case 3: this._output = this._output.write(this._c4); this._c4 = 0; break;\n          default: throw new Error(\"unreachable\");\n        }\n        index += 1;\n      } else {\n        return Output.error(new OutputException(\"unable to flush buffered code units\"));\n      }\n    }\n    this._index = index;\n    return this;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<T>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<T> {\n    if (settings === void 0) {\n      return this._output.settings();\n    } else {\n      this._output.settings(settings);\n      return this;\n    }\n  }\n\n  bind(): T {\n    return this._output.bind();\n  }\n\n  clone(): Output<T> {\n    return new Utf8EncodedOutput<T>(this._output.clone(), this._errorMode,\n                                    this._c2, this._c3, this._c4, this._index);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {UtfErrorMode} from \"./UtfErrorMode\";\nimport {Output} from \"./Output\";\nimport {Unicode} from \"./Unicode\";\nimport {Utf8DecodedOutput} from \"./Utf8DecodedOutput\";\nimport {Utf8EncodedOutput} from \"./Utf8EncodedOutput\";\n\n/**\n * UTF-8 [[Input]]/[[Output]] factory.\n */\nexport class Utf8 {\n  private constructor() {\n    // nop\n  }\n\n  /**\n   * Returns the number of bytes in the UTF-8 encoding of the Unicode code\n   * point `c`, handling invalid code unit sequences according to the\n   * `errorMode` policy.  Returns the size of the\n   * [[UtfErrorMode.replacementChar]] for surrogates and invalid code points,\n   * if [[UtfErrorMode.isReplacement]] is `true`; otherwise returns `0` for\n   * surrogates and invalid code points.  Uses the two byte modified UTF-8\n   * encoding of the NUL character (`U+0000`), if [[UtfErrorMode.isNonZero]]\n   * is `true`.\n   */\n  static sizeOf(c: number | undefined, errorMode?: UtfErrorMode): number;\n  /**\n   * Returns the number of bytes in the UTF-8 encoding of the Unicode code\n   * point `c`; returns the size of the Unicode replacement character (`U+FFFD`)\n   * for surrogates and invalid code points.\n   */\n  static sizeOf(c: number | undefined): number;\n  /**\n   * Returns the number of bytes in the UTF-8 encoding the given `string`,\n   * handling invalid code unit sequences according to the `errorMode` policy.\n   */\n  static sizeOf(string: string, errorMode?: UtfErrorMode): number;\n  /**\n   * Returns the number of bytes in the UTF-8 encoding the given `string`,\n   * assuming the Unicode replacement character (`U+FFFD`) replaces unpaired\n   * surrogates and invalid code points.\n   */\n  static sizeOf(string: string): number;\n  static sizeOf(u: string | number | undefined, errorMode?: UtfErrorMode): number {\n    if (typeof u === \"number\" || u === void 0) {\n      if (typeof u === \"number\") {\n        if (u === 0x0000 && errorMode !== void 0 && errorMode.isNonZero()) { // Modified UTF-8\n          return 2; // U+0000 encoded as 0xC0, 0x80\n        } else if (u >= 0x0000 && u <= 0x007F) { // U+0000..U+007F\n          return 1;\n        } else if (u >= 0x0080 && u <= 0x07FF) { // U+0080..U+07FF\n          return 2;\n        } else if (u >= 0x0800 && u <= 0xFFFF || // U+0800..U+D7FF\n                   u >= 0xE000 && u <= 0xFFFF) { // U+E000..U+FFFF\n          return 3;\n        } else if (u >= 0x10000 && u <= 0x10FFFF) { // U+10000..U+10FFFF\n          return 4;\n        }\n      }\n      // surrogate or invalid code point\n      if (errorMode === void 0) {\n        return 3;\n      } else if (errorMode.isReplacement()) {\n        return Utf8.sizeOf(errorMode.replacementChar());\n      } else {\n        return 0;\n      }\n    } else if (typeof u === \"string\") {\n      let size = 0;\n      for (let i = 0, n = u.length; i < n; i = u.offsetByCodePoints(i, 1)) {\n        size += Utf8.sizeOf(u.charCodeAt(i), errorMode);\n      }\n      return size;\n    } else {\n      throw new TypeError(\"\" + u);\n    }\n  }\n\n  /**\n   * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes\n   * writes decoded Unicode code points to the composed `output`, handling\n   * invalid code unit sequences according to the `errorMode` policy.\n   */\n  static decodedOutput<T>(output: Output<T>, errorMode: UtfErrorMode = UtfErrorMode.fatal()): Output<T> {\n    return new Utf8DecodedOutput<T>(output, errorMode);\n  }\n\n  /**\n   * Returns a new `Output` that accepts Unicode code points, and writes\n   * encoded UTF-8 code unit sequences to the composed `output`, handling\n   * invalid code unit sequences according to the `errorMode` policy.\n   */\n  static encodedOutput<T>(output: Output<T>, errorMode: UtfErrorMode = UtfErrorMode.fatal()): Output<T> {\n    return new Utf8EncodedOutput<T>(output, errorMode);\n  }\n\n  /**\n   * Returns a new `Output` that accepts UTF-8 code unit sequences, and writes\n   * decoded Unicode code points to a growable `string`, handling invalid code\n   * unit sequences according to the [[UtfErrorMode.fatal]] policy.  The\n   * returned `Output` accepts an unbounded number of UTF-8 code units,\n   * remaining permanently in the _cont_ state, and [[Output.bind binds]] a\n   * `string` containing all decoded code points.\n   */\n  static decodedString(): Output<string> {\n    return Utf8.decodedOutput(Unicode.stringOutput());\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Diagnostic} from \"./Diagnostic\";\nimport {Unicode} from \"./Unicode\";\nimport {Base10} from \"./Base10\";\n\n/** @hidden */\nexport class Base10NumberParser extends Parser<number> {\n  private readonly _sign: number | undefined;\n  private readonly _value: number | undefined;\n  private readonly _mode: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(sign?: number, value?: number, mode?: number, step?: number) {\n    super();\n    this._sign = sign;\n    this._value = value;\n    this._mode = mode;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<number> {\n    return Base10NumberParser.parse(input, this._sign, this._value, this._mode, this._step);\n  }\n\n  static parse(input: Input, sign: number = 1, value: number = 0,\n               mode: number = 2, step: number = 1): Parser<number> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 45/*'-'*/) {\n          input = input.step();\n          sign = -1;\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          value = sign * (c - 48/*'0'*/);\n          step = 3;\n        } else if (mode > 0 && c === 46/*'.'*/) {\n          let output = Unicode.stringOutput();\n          if (sign < 0) {\n            output = output.write(45/*'-'*/);\n          }\n          return Base10DecimalParser.parse(input, output, mode);\n        } else {\n          return Parser.error(Diagnostic.expected(\"number\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          const newValue = 10 * value + sign * (c - 48/*'0'*/);\n          if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {\n            value = newValue;\n            input = input.step();\n          } else {\n            return Parser.error(Diagnostic.message(\"integer overflow\", input));\n          }\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        step = 4;\n      } else if (input.isDone()) {\n        return Parser.done(value);\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (mode > 0 && c === 46/*'.'*/ || mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          let output = Unicode.stringOutput();\n          if (sign < 0 && value === 0) {\n            output = output.write(45/*'-'*/).write(48/*'0'*/);\n          } else {\n            output = output.write(\"\" + value);\n          }\n          return Base10DecimalParser.parse(input, output, mode);\n        } else {\n          return Parser.done(value);\n        }\n      } else if (input.isDone()) {\n        return Parser.done(value);\n      }\n    }\n    return new Base10NumberParser(sign, value, mode, step);\n  }\n}\nBase10.NumberParser = Base10NumberParser;\n\n/** @hidden */\nclass Base10DecimalParser extends Parser<number> {\n  private readonly _output: Output<string>;\n  private readonly _mode: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(output: Output<string>, mode?: number, step?: number) {\n    super();\n    this._output = output;\n    this._mode = mode;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<number> {\n    return Base10DecimalParser.parse(input, this._output, this._mode, this._step);\n  }\n\n  static parse(input: Input, output: Output<string>, mode: number = 2,\n               step: number = 1): Parser<number> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 46/*'.'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 2;\n        } else if (mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          input = input.step();\n          output = output.write(c);\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        if (mode > 1) {\n          step = 4;\n        } else {\n          return Parser.done(+output.bind());\n        }\n      } else if (input.isDone()) {\n        return Parser.done(+output.bind());\n      }\n    }\n    if (step === 4) {\n      c = input.head();\n      if (c === 69/*'E'*/ || c === 101/*'e'*/) {\n        input = input.step();\n        output = output.write(c);\n        step = 5;\n      } else {\n        return Parser.done(+output.bind());\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n          input = input.step();\n          output = output.write(c);\n        }\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 7;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 7) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(+output.bind());\n      }\n    }\n    return new Base10DecimalParser(output, mode, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\nimport {Base10} from \"./Base10\";\n\n/** @hidden */\nexport class Base10IntegerWriter extends Writer<any, any> {\n  /** @hidden */\n  readonly _value: any;\n  /** @hidden */\n  readonly _input: number;\n  /** @hidden */\n  readonly _index: number;\n  /** @hidden */\n  readonly _step: number;\n\n  constructor(value: any, input: number, index: number = 0, step: number = 1) {\n    super();\n    this._value = value;\n    this._input = input;\n    this._index = index;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer<any, any> {\n    return Base10IntegerWriter.write(output, this._value, this._input, this._index, this._step);\n  }\n\n  static write(output: Output, value: any, input: number, index: number = 0,\n               step: number = 1): Writer<any, any> {\n    if (step === 0) {\n      return Writer.done();\n    }\n    if (step === 1) {\n      if (input < 0) {\n        if (output.isCont()) {\n          output = output.write(45/*'-'*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (input > -10 && input < 10) {\n        if (output.isCont()) {\n          output = output.write(Base10.encodeDigit(Math.abs(input | 0)));\n          return Writer.done(value);\n        }\n      } else {\n        const digits = new Array<number>(19);\n        let x = input;\n        let i = 18;\n        while (x) {\n          digits[i] = Math.abs((x % 10) | 0);\n          x = (x / 10) | 0;\n          i -= 1;\n        }\n        i += 1 + index;\n        while (i < 19 && output.isCont()) {\n          output = output.write(Base10.encodeDigit(digits[i]));\n          index += 1;\n          i += 1;\n        }\n        if (i === 19) {\n          return Writer.done(value);\n        }\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base10IntegerWriter(value, input, index, step);\n  }\n}\nBase10.IntegerWriter = Base10IntegerWriter;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Diagnostic} from \"./Diagnostic\";\nimport {Base16} from \"./Base16\";\n\n/** @hidden */\nexport class Base16Parser<O> extends Parser<O> {\n  /** @hidden */\n  readonly _output: Output<O>;\n  /** @hidden */\n  readonly _p: number;\n  /** @hidden */\n  readonly _step: number;\n\n  constructor(output: Output<O>, p: number = 0, step: number = 1) {\n    super();\n    this._output = output;\n    this._p = p;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<O> {\n    return Base16Parser.parse(input, this._output.clone(), this._p, this._step);\n  }\n\n  static parse<O>(input: Input, output: Output<O>, p: number = 0, step: number = 1): Parser<O> {\n    let c = 0;\n    while (!input.isEmpty()) {\n      if (step === 1) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          p = c;\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(output.bind());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          Base16.writeQuantum(p, c, output);\n          p = 0;\n          step = 1;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"base16 digit\", input));\n        }\n      }\n    }\n    return new Base16Parser<O>(output, p, step);\n  }\n}\nBase16.Parser = Base16Parser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\nimport {Base16} from \"./Base16\";\n\n/** @hidden */\nexport class Base16Writer extends Writer<unknown, unknown> {\n  /** @hidden */\n  readonly _value: unknown;\n  /** @hidden */\n  readonly _input: Uint8Array | undefined;\n  /** @hidden */\n  readonly _base16: Base16;\n  /** @hidden */\n  readonly _index: number;\n  /** @hidden */\n  readonly _step: number;\n\n  constructor(value: unknown, input: Uint8Array | undefined, base16: Base16,\n              index: number = 0, step: number = 1) {\n    super();\n    this._value = value;\n    this._input = input;\n    this._base16 = base16;\n    this._index = index;\n    this._step = step;\n  }\n\n  feed(value: unknown): Writer<unknown, unknown> {\n    if (value instanceof Uint8Array) {\n      return new Base16Writer(undefined, value, this._base16);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  pull(output: Output): Writer<unknown, unknown> {\n    return Base16Writer.write(output, this._value, this._input!, this._base16,\n                              this._index, this._step);\n  }\n\n  static write(output: Output, value: unknown, input: Uint8Array, base16: Base16,\n               index: number = 0, step: number = 1): Writer<unknown, unknown> {\n    while (index < input.length) {\n      const x = input[index];\n      if (step === 1 && output.isCont()) {\n        output = output.write(base16.encodeDigit(x >>> 4));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base16.encodeDigit(x & 0x0f));\n        index += 1;\n        step = 1;\n      }\n    }\n    if (index === input.length) {\n      return Writer.done(value);\n    } else if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base16Writer(value, input, base16, index, step);\n  }\n}\nBase16.Writer = Base16Writer;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\nimport {Base16} from \"./Base16\";\n\nexport class Base16IntegerWriter extends Writer<unknown, unknown> {\n  private readonly _value: unknown;\n  private readonly _input: number;\n  private readonly _width: number;\n  private readonly _base16: Base16;\n  private readonly _index: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(value: unknown, input: number, width: number,\n              base16: Base16, index?: number, step?: number) {\n    super();\n    this._value = value;\n    this._input = input;\n    this._width = width;\n    this._base16 = base16;\n    this._index = index;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer<unknown, unknown> {\n    return Base16IntegerWriter.write(output, this._value, this._input, this._width,\n                                     this._base16, this._index, this._step);\n  }\n\n  static write(output: Output, value: unknown, input: number, width: number,\n               base16: Base16, index: number = 0, step: number = 3): Writer<unknown, unknown> {\n    if (step <= 0) {\n      return Writer.done();\n    }\n    if (step === 1 && output.isCont()) {\n      output = output.write(48/*'0'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(120/*'x'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (input >= 0 && input < 16 && width <= 1) {\n        if (output.isCont()) {\n          output = output.write(base16.encodeDigit(input));\n          return Writer.done(value);\n        }\n      } else {\n        let i = 15;\n        const digits = new Array<number>(16);\n        let x = input;\n        while (x !== 0 || i >= 16 - width) {\n          digits[i] = x & 0xf;\n          x >>>= 4;\n          i -= 1;\n        }\n        i += 1 + index;\n        while (i < 16 && output.isCont()) {\n          output = output.write(base16.encodeDigit(digits[i]));\n          index += 1;\n          i += 1;\n        }\n        if (i === 16) {\n          return Writer.done(value);\n        }\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base16IntegerWriter(value, input, width, base16, index, step);\n  }\n\n  static writeLiteral(output: Output, value: unknown, input: number, width: number,\n                      base16: Base16): Writer<unknown, unknown> {\n    return Base16IntegerWriter.write(output, value, input, width, base16, 0, 1);\n  }\n}\nBase16.IntegerWriter = Base16IntegerWriter;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Writer} from \"./Writer\";\nimport {Format} from \"./Format\";\nimport {Unicode} from \"./Unicode\";\nimport {Binary} from \"./Binary\";\nimport {Base64Parser} from \"./Base64Parser\";\nimport {Base64Writer} from \"./Base64Writer\";\n\n/**\n * Base-64 (7-bit ASCII) encoding [[Parser]]/[[Writer]] factory.\n */\nexport abstract class Base64 {\n  /** @hidden */\n  constructor() {\n    // stub\n  }\n\n  /**\n   * Returns a 64 character string, where the character at index `i` is the\n   * encoding of the base-64 digit `i`.\n   */\n  abstract alphabet(): string;\n\n  /**\n   * Returns `true` if this base-64 encoding requires padding.\n   */\n  abstract isPadded(): boolean;\n\n  /**\n   * Returns this `Base64` encoding with required padding, if `isPadded` is\n   * `true`.\n   */\n  abstract isPadded(isPadded: boolean): Base64;\n\n  /**\n   * Returns `true` if the Unicode code point `c` is a valid base-64 digit.\n   */\n  abstract isDigit(c: number): boolean;\n\n  /**\n   * Returns the 7-bit quantity represented by the base-64 digit `c`.\n   *\n   * @throws `Error` if `c` is not a valid base-64 digit.\n   */\n  public decodeDigit(c: number): number {\n    if (c >= 65/*'A'*/ && c <= 90/*'Z'*/) {\n      return c - 65/*'A'*/;\n    } else if (c >= 97/*'a'*/ && c <= 122/*'z'*/) {\n      return c + (26 - 97/*'a'*/);\n    } else if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n      return c + (52 - 48/*'0'*/);\n    } else if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n      return 62;\n    } else if (c === 47/*'/'*/ || c === 95/*'_'*/) {\n      return 63;\n    } else {\n      const message = Unicode.stringOutput();\n      message.write(\"Invalid base-64 digit: \");\n      Format.debugChar(c, message);\n      throw new Error(message.bind());\n    }\n  }\n\n  /**\n   * Returns the Unicode code point of the base-64 digit that encodes the given\n   * 7-bit quantity.\n   */\n  encodeDigit(b: number): number {\n    return this.alphabet().charCodeAt(b);\n  }\n\n  /**\n   * Decodes the base-64 digits `c1`, `c2`, `c3`, and `c4`, and writes the 8 to\n   * 24 bit quantity they represent to the given `output`.\n   */\n  writeQuantum(c1: number, c2: number, c3: number, c4: number, output: Output): void {\n    const x = this.decodeDigit(c1);\n    const y = this.decodeDigit(c2);\n    if (c3 !== 61/*'='*/) {\n      const z = this.decodeDigit(c3);\n      if (c4 !== 61/*'='*/) {\n        const w = this.decodeDigit(c4);\n        output = output.write((x << 2) | (y >>> 4));\n        output = output.write((y << 4) | (z >>> 2));\n        output = output.write((z << 6) | w);\n      } else {\n        output = output.write((x << 2) | (y >>> 4));\n        output = output.write((y << 4) | (z >>> 2));\n      }\n    } else {\n      if (c4 !== 61/*'='*/) {\n        throw new Error(\"Improperly padded base-64\");\n      }\n      output = output.write((x << 2) | (y >>> 4));\n    }\n  }\n\n  /**\n   * Returns a `Parser` that decodes base-64 (7-bit ASCII) encoded input, and\n   * writes the decoded bytes to `output`.\n   */\n  parser<O>(output: Output<O>): Parser<O> {\n    return new Base64.Parser<O>(output, this);\n  }\n\n  /**\n   * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded\n   * bytes to `output`, returning a `Parser` continuation that knows how to\n   * parse any additional input.\n   */\n  parse<O>(input: Input, output: Output<O>): Parser<O> {\n    return Base64.Parser.parse(input, output, this);\n  }\n\n  /**\n   * Parses the base-64 (7-bit ASCII) encoded `input`, and writes the decoded\n   * bytes to a growable array, returning a `Parser` continuation that knows\n   * how to parse any additional input.  The returned `Parser` [[Parser.bind\n   * binds]] a `Uint8Array` array containing all parsed base-64 data.\n   */\n  parseUint8Array(input: Input): Parser<Uint8Array> {\n    return Base64.Parser.parse(input, Binary.uint8ArrayOutput(), this);\n  }\n\n  /**\n   * Returns a `Writer` that, when fed an input `Uint8Array`, returns a\n   * continuation that writes the base-64 (7-bit ASCII) encoding of the input\n   * `Uint8Array`.\n   */\n  uint8ArrayWriter(): Writer<Uint8Array, unknown>;\n  /**\n   * Returns a {@code Writer} continuation that writes the base-64 (7-bit ASCII)\n   * encoding of the {@code input} byte array.\n   */\n  uint8ArrayWriter(input: Uint8Array): Writer<unknown, Uint8Array>;\n  uint8ArrayWriter(input?: Uint8Array): Writer<unknown, unknown> {\n    if (input === void 0) {\n      return new Base64.Writer(void 0, void 0, this);\n    } else {\n      return new Base64.Writer(input, input, this);\n    }\n  }\n\n  /**\n   * Writes the base-64 (7-bit ASCII) encoding of the `input` `Uint8Array` to\n   * the `output`, returning a `Writer` continuation that knows how to write any\n   * remaining output that couldn't be immediately generated.\n   */\n  writeUint8Array(input: Uint8Array, output: Output): Writer<unknown, unknown> {\n    return Base64.Writer.write(output, void 0, input, this);\n  }\n\n  private static _standard?: Base64;\n  private static _standardUnpadded?: Base64;\n  private static _url?: Base64;\n  private static _urlUnpadded?: Base64;\n\n  /**\n   * Returns the `Base64` encoding with the standard alphabet, and required\n   * padding, if `isPadding` is `true`.\n   */\n  static standard(isPadded: boolean = true): Base64 {\n    if (isPadded) {\n      if (!Base64._standard) {\n        Base64._standard = new Base64Standard(true);\n      }\n      return Base64._standard;\n    } else {\n      if (!Base64._standardUnpadded) {\n        Base64._standardUnpadded = new Base64Standard(true);\n      }\n      return Base64._standardUnpadded;\n    }\n  }\n\n  /**\n   * Returns the `Base64` encoding with the url and filename safe alphabet,\n   * and required padding, if `isPadded` is `true`.\n   */\n  static url(isPadded: boolean = true): Base64 {\n    if (isPadded) {\n      if (!Base64._url) {\n        Base64._url = new Base64Url(true);\n      }\n      return Base64._url;\n    } else {\n      if (!Base64._urlUnpadded) {\n        Base64._urlUnpadded = new Base64Url(false);\n      }\n      return Base64._urlUnpadded;\n    }\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Parser: typeof Base64Parser; // defined by Base64Parser\n  /** @hidden */\n  static Writer: typeof Base64Writer; // defined by Base64Writer\n}\n\n/** @hidden */\nclass Base64Standard extends Base64 {\n  /** @hidden */\n  readonly _isPadded: boolean;\n\n  constructor(isPadded: boolean) {\n    super();\n    this._isPadded = isPadded;\n  }\n\n  alphabet(): string {\n    return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n  }\n\n  isPadded(): boolean;\n  isPadded(isPadded: boolean): Base64;\n  isPadded(isPadded?: boolean): boolean | Base64 {\n    if (isPadded === void 0) {\n      return this._isPadded;\n    } else {\n      if (isPadded === this._isPadded) {\n        return this;\n      } else {\n        return Base64.standard(isPadded);\n      }\n    }\n  }\n\n  isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 43/*'+'*/ || c === 47/*'/'*/;\n  }\n}\n\n/** @hidden */\nclass Base64Url extends Base64 {\n  /** @hidden */\n  readonly _isPadded: boolean;\n\n  constructor(isPadded: boolean) {\n    super();\n    this._isPadded = isPadded;\n  }\n\n  alphabet(): string {\n    return \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_\";\n  }\n\n  isPadded(): boolean;\n  isPadded(isPadded: boolean): Base64;\n  isPadded(isPadded?: boolean): boolean | Base64 {\n    if (isPadded === void 0) {\n      return this._isPadded;\n    } else {\n      if (isPadded === this._isPadded) {\n        return this;\n      } else {\n        return Base64.url(isPadded);\n      }\n    }\n  }\n\n  isDigit(c: number): boolean {\n    return c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 45/*'-'*/ || c === 95/*'_'*/;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input} from \"./Input\";\nimport {Output} from \"./Output\";\nimport {Parser} from \"./Parser\";\nimport {Diagnostic} from \"./Diagnostic\";\nimport {Base64} from \"./Base64\";\n\n/** @hidden */\nexport class Base64Parser<O> extends Parser<O> {\n  /** @hidden */\n  readonly _output: Output<O>;\n  /** @hidden */\n  readonly _base64: Base64;\n  /** @hidden */\n  readonly _p: number;\n  /** @hidden */\n  readonly _q: number;\n  /** @hidden */\n  readonly _r: number;\n  /** @hidden */\n  readonly _step: number;\n\n  constructor(output: Output<O>, base64: Base64, p: number = 0, q: number = 0,\n              r: number = 0, step: number = 1) {\n    super();\n    this._output = output;\n    this._base64 = base64;\n    this._p = p;\n    this._q = q;\n    this._r = r;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<O> {\n    return Base64Parser.parse(input, this._output.clone(), this._base64,\n                              this._p, this._q, this._r, this._step);\n  }\n\n  static parse<O>(input: Input, output: Output<O>, base64: Base64, p: number = 0,\n                  q: number = 0, r: number = 0, step: number = 1): Parser<O> {\n    let c = 0;\n    while (!input.isEmpty()) {\n      if (step === 1) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c))) {\n          input = input.step();\n          p = c;\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(output.bind());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c))) {\n          input = input.step();\n          q = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"base64 digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61/*'='*/)) {\n          input = input.step();\n          r = c;\n          if (c !== 61/*'='*/) {\n            step = 4;\n          } else {\n            step = 5;\n          }\n        } else if (!input.isEmpty()) {\n          if (!base64.isPadded()) {\n            base64.writeQuantum(p, q, 61/*'='*/, 61/*'='*/, output);\n            return Parser.done(output.bind());\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        }\n      }\n      if (step === 4) {\n        if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61/*'='*/)) {\n          input = input.step();\n          base64.writeQuantum(p, q, r, c, output);\n          r = 0;\n          q = 0;\n          p = 0;\n          if (c !== 61/*'='*/) {\n            step = 1;\n          } else {\n            return Parser.done(output.bind());\n          }\n        } else if (!input.isEmpty()) {\n          if (!base64.isPadded()) {\n            base64.writeQuantum(p, q, r, 61/*'='*/, output);\n            return Parser.done(output.bind());\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        }\n      } else if (step === 5) {\n        if (input.isCont() && (c = input.head(), c === 61/*'='*/)) {\n          input = input.step();\n          base64.writeQuantum(p, q, r, c, output);\n          r = 0;\n          q = 0;\n          p = 0;\n          return Parser.done(output.bind());\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(61/*'='*/, input));\n        }\n      }\n    }\n    return new Base64Parser<O>(output, base64, p, q, r, step);\n  }\n}\nBase64.Parser = Base64Parser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"./Output\";\nimport {WriterException} from \"./WriterException\";\nimport {Writer} from \"./Writer\";\nimport {Base64} from \"./Base64\";\n\n/** @hidden */\nexport class Base64Writer extends Writer<unknown, unknown> {\n  /** @hidden */\n  readonly _value: unknown;\n  /** @hidden */\n  readonly _input: Uint8Array | undefined;\n  /** @hidden */\n  readonly _base64: Base64;\n  /** @hidden */\n  readonly _index: number;\n  /** @hidden */\n  readonly _step: number;\n\n  constructor(value: unknown, input: Uint8Array | undefined, base64: Base64,\n              index: number = 0, step: number = 1) {\n    super();\n    this._value = value;\n    this._input = input;\n    this._base64 = base64;\n    this._index = index;\n    this._step = step;\n  }\n\n  feed(value: unknown): Writer<unknown, unknown> {\n    if (value instanceof Uint8Array) {\n      return new Base64Writer(undefined, value, this._base64);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  pull(output: Output): Writer<unknown, unknown> {\n    return Base64Writer.write(output, this._value, this._input!, this._base64,\n                              this._index, this._step);\n  }\n\n  static write(output: Output, value: unknown, input: Uint8Array, base64: Base64,\n               index: number = 0, step: number = 1): Writer<unknown, unknown> {\n    while (index + 2 < input.length && output.isCont()) {\n      const x = input[index];\n      const y = input[index + 1];\n      const z = input[index + 2];\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((y << 2) | (z >>> 6)) & 0x3f));\n        step = 4;\n      }\n      if (step === 4 && output.isCont()) {\n        output = output.write(base64.encodeDigit(z & 0x3f));\n        index += 3;\n        step = 1;\n      }\n    }\n    if (index + 1 < input.length && output.isCont()) {\n      const x = input[index];\n      const y = input[index + 1];\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(base64.encodeDigit((y << 2) & 0x3f));\n        step = 4;\n      }\n      if (step === 4) {\n        if (!base64.isPadded()) {\n          index += 2;\n        } else if (output.isCont()) {\n          output = output.write(61/*'='*/);\n          index += 2;\n        }\n      }\n    } else if (index < input.length && output.isCont()) {\n      const x = input[index];\n      if (step === 1 && output.isCont()) {\n        output = output.write(base64.encodeDigit(x >>> 2));\n        step = 2;\n      }\n      if (step === 2 && output.isCont()) {\n        output = output.write(base64.encodeDigit((x << 4) & 0x3f));\n        step = 3;\n      }\n      if (step === 3) {\n        if (!base64.isPadded()) {\n          index += 1;\n        } else if (output.isCont()) {\n          output = output.write(61/*'='*/);\n          step = 4;\n        }\n      }\n      if (step === 4 && output.isCont()) {\n        output = output.write(61/*'='*/);\n        index += 1;\n      }\n    }\n    if (index === input.length) {\n      return Writer.done(value);\n    } else if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new Base64Writer(value, input, base64, index, step);\n  }\n}\nBase64.Writer = Base64Writer;\n"]}