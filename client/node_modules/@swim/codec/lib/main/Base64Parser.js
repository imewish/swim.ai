import { __extends } from "tslib";
import { Parser } from "./Parser";
import { Diagnostic } from "./Diagnostic";
import { Base64 } from "./Base64";
var Base64Parser = (function (_super) {
    __extends(Base64Parser, _super);
    function Base64Parser(output, base64, p, q, r, step) {
        if (p === void 0) { p = 0; }
        if (q === void 0) { q = 0; }
        if (r === void 0) { r = 0; }
        if (step === void 0) { step = 1; }
        var _this = _super.call(this) || this;
        _this._output = output;
        _this._base64 = base64;
        _this._p = p;
        _this._q = q;
        _this._r = r;
        _this._step = step;
        return _this;
    }
    Base64Parser.prototype.feed = function (input) {
        return Base64Parser.parse(input, this._output.clone(), this._base64, this._p, this._q, this._r, this._step);
    };
    Base64Parser.parse = function (input, output, base64, p, q, r, step) {
        if (p === void 0) { p = 0; }
        if (q === void 0) { q = 0; }
        if (r === void 0) { r = 0; }
        if (step === void 0) { step = 1; }
        var c = 0;
        while (!input.isEmpty()) {
            if (step === 1) {
                if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
                    input = input.step();
                    p = c;
                    step = 2;
                }
                else if (!input.isEmpty()) {
                    return Parser.done(output.bind());
                }
            }
            if (step === 2) {
                if (input.isCont() && (c = input.head(), base64.isDigit(c))) {
                    input = input.step();
                    q = c;
                    step = 3;
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.expected("base64 digit", input));
                }
            }
            if (step === 3) {
                if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
                    input = input.step();
                    r = c;
                    if (c !== 61) {
                        step = 4;
                    }
                    else {
                        step = 5;
                    }
                }
                else if (!input.isEmpty()) {
                    if (!base64.isPadded()) {
                        base64.writeQuantum(p, q, 61, 61, output);
                        return Parser.done(output.bind());
                    }
                    else {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
            }
            if (step === 4) {
                if (input.isCont() && (c = input.head(), base64.isDigit(c) || c === 61)) {
                    input = input.step();
                    base64.writeQuantum(p, q, r, c, output);
                    r = 0;
                    q = 0;
                    p = 0;
                    if (c !== 61) {
                        step = 1;
                    }
                    else {
                        return Parser.done(output.bind());
                    }
                }
                else if (!input.isEmpty()) {
                    if (!base64.isPadded()) {
                        base64.writeQuantum(p, q, r, 61, output);
                        return Parser.done(output.bind());
                    }
                    else {
                        return Parser.error(Diagnostic.unexpected(input));
                    }
                }
            }
            else if (step === 5) {
                if (input.isCont() && (c = input.head(), c === 61)) {
                    input = input.step();
                    base64.writeQuantum(p, q, r, c, output);
                    r = 0;
                    q = 0;
                    p = 0;
                    return Parser.done(output.bind());
                }
                else if (!input.isEmpty()) {
                    return Parser.error(Diagnostic.expected(61, input));
                }
            }
        }
        return new Base64Parser(output, base64, p, q, r, step);
    };
    return Base64Parser;
}(Parser));
export { Base64Parser };
Base64.Parser = Base64Parser;
//# sourceMappingURL=Base64Parser.js.map