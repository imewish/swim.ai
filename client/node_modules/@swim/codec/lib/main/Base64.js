import { __extends } from "tslib";
import { Format } from "./Format";
import { Unicode } from "./Unicode";
import { Binary } from "./Binary";
var Base64 = (function () {
    function Base64() {
    }
    Base64.prototype.decodeDigit = function (c) {
        if (c >= 65 && c <= 90) {
            return c - 65;
        }
        else if (c >= 97 && c <= 122) {
            return c + (26 - 97);
        }
        else if (c >= 48 && c <= 57) {
            return c + (52 - 48);
        }
        else if (c === 43 || c === 45) {
            return 62;
        }
        else if (c === 47 || c === 95) {
            return 63;
        }
        else {
            var message = Unicode.stringOutput();
            message.write("Invalid base-64 digit: ");
            Format.debugChar(c, message);
            throw new Error(message.bind());
        }
    };
    Base64.prototype.encodeDigit = function (b) {
        return this.alphabet().charCodeAt(b);
    };
    Base64.prototype.writeQuantum = function (c1, c2, c3, c4, output) {
        var x = this.decodeDigit(c1);
        var y = this.decodeDigit(c2);
        if (c3 !== 61) {
            var z = this.decodeDigit(c3);
            if (c4 !== 61) {
                var w = this.decodeDigit(c4);
                output = output.write((x << 2) | (y >>> 4));
                output = output.write((y << 4) | (z >>> 2));
                output = output.write((z << 6) | w);
            }
            else {
                output = output.write((x << 2) | (y >>> 4));
                output = output.write((y << 4) | (z >>> 2));
            }
        }
        else {
            if (c4 !== 61) {
                throw new Error("Improperly padded base-64");
            }
            output = output.write((x << 2) | (y >>> 4));
        }
    };
    Base64.prototype.parser = function (output) {
        return new Base64.Parser(output, this);
    };
    Base64.prototype.parse = function (input, output) {
        return Base64.Parser.parse(input, output, this);
    };
    Base64.prototype.parseUint8Array = function (input) {
        return Base64.Parser.parse(input, Binary.uint8ArrayOutput(), this);
    };
    Base64.prototype.uint8ArrayWriter = function (input) {
        if (input === void 0) {
            return new Base64.Writer(void 0, void 0, this);
        }
        else {
            return new Base64.Writer(input, input, this);
        }
    };
    Base64.prototype.writeUint8Array = function (input, output) {
        return Base64.Writer.write(output, void 0, input, this);
    };
    Base64.standard = function (isPadded) {
        if (isPadded === void 0) { isPadded = true; }
        if (isPadded) {
            if (!Base64._standard) {
                Base64._standard = new Base64Standard(true);
            }
            return Base64._standard;
        }
        else {
            if (!Base64._standardUnpadded) {
                Base64._standardUnpadded = new Base64Standard(true);
            }
            return Base64._standardUnpadded;
        }
    };
    Base64.url = function (isPadded) {
        if (isPadded === void 0) { isPadded = true; }
        if (isPadded) {
            if (!Base64._url) {
                Base64._url = new Base64Url(true);
            }
            return Base64._url;
        }
        else {
            if (!Base64._urlUnpadded) {
                Base64._urlUnpadded = new Base64Url(false);
            }
            return Base64._urlUnpadded;
        }
    };
    return Base64;
}());
export { Base64 };
var Base64Standard = (function (_super) {
    __extends(Base64Standard, _super);
    function Base64Standard(isPadded) {
        var _this = _super.call(this) || this;
        _this._isPadded = isPadded;
        return _this;
    }
    Base64Standard.prototype.alphabet = function () {
        return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    };
    Base64Standard.prototype.isPadded = function (isPadded) {
        if (isPadded === void 0) {
            return this._isPadded;
        }
        else {
            if (isPadded === this._isPadded) {
                return this;
            }
            else {
                return Base64.standard(isPadded);
            }
        }
    };
    Base64Standard.prototype.isDigit = function (c) {
        return c >= 48 && c <= 57
            || c >= 65 && c <= 90
            || c >= 97 && c <= 122
            || c === 43 || c === 47;
    };
    return Base64Standard;
}(Base64));
var Base64Url = (function (_super) {
    __extends(Base64Url, _super);
    function Base64Url(isPadded) {
        var _this = _super.call(this) || this;
        _this._isPadded = isPadded;
        return _this;
    }
    Base64Url.prototype.alphabet = function () {
        return "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_";
    };
    Base64Url.prototype.isPadded = function (isPadded) {
        if (isPadded === void 0) {
            return this._isPadded;
        }
        else {
            if (isPadded === this._isPadded) {
                return this;
            }
            else {
                return Base64.url(isPadded);
            }
        }
    };
    Base64Url.prototype.isDigit = function (c) {
        return c >= 48 && c <= 57
            || c >= 65 && c <= 90
            || c >= 97 && c <= 122
            || c === 45 || c === 95;
    };
    return Base64Url;
}(Base64));
//# sourceMappingURL=Base64.js.map