import { __extends } from "tslib";
import { OutputException } from "./OutputException";
import { Output } from "./Output";
var Utf8EncodedOutput = (function (_super) {
    __extends(Utf8EncodedOutput, _super);
    function Utf8EncodedOutput(output, errorMode, c2, c3, c4, index) {
        if (c2 === void 0) { c2 = 0; }
        if (c3 === void 0) { c3 = 0; }
        if (c4 === void 0) { c4 = 0; }
        if (index === void 0) { index = 4; }
        var _this = _super.call(this) || this;
        _this._output = output;
        _this._errorMode = errorMode;
        _this._c2 = c2;
        _this._c3 = c3;
        _this._c4 = c4;
        _this._index = index;
        return _this;
    }
    Utf8EncodedOutput.prototype.isCont = function () {
        return this._output.isCont();
    };
    Utf8EncodedOutput.prototype.isFull = function () {
        return this._output.isFull();
    };
    Utf8EncodedOutput.prototype.isDone = function () {
        return this._output.isDone();
    };
    Utf8EncodedOutput.prototype.isError = function () {
        return false;
    };
    Utf8EncodedOutput.prototype.isPart = function (isPart) {
        if (isPart === void 0) {
            return this._output.isPart();
        }
        else {
            this._output = this._output.isPart(isPart);
            return this;
        }
    };
    Utf8EncodedOutput.prototype.write = function (token) {
        if (typeof token === "number") {
            var c1 = 0;
            var c2 = this._c2;
            var c3 = this._c3;
            var c4 = this._c4;
            var index = this._index;
            while (index < 4) {
                if (this._output.isCont()) {
                    switch (index) {
                        case 1:
                            this._output = this._output.write(c2);
                            this._c2 = 0;
                            break;
                        case 2:
                            this._output = this._output.write(c3);
                            this._c3 = 0;
                            break;
                        case 3:
                            this._output = this._output.write(c4);
                            this._c4 = 0;
                            break;
                        default: throw new Error("unreachable");
                    }
                    index += 1;
                }
                else {
                    return Output.error(new OutputException("unable to flush buffered code units"));
                }
            }
            if (token >= 0 && token <= 0x7f) {
                c4 = token;
                index = 3;
            }
            else if (token >= 0x80 && token <= 0x7ff) {
                c3 = 0xc0 | (token >>> 6);
                c4 = 0x80 | (token & 0x3f);
                index = 2;
            }
            else if (token >= 0x0800 && token <= 0xffff ||
                token >= 0xe000 && token <= 0xffff) {
                c2 = 0xe0 | (token >>> 12);
                c3 = 0x80 | ((token >>> 6) & 0x3f);
                c4 = 0x80 | (token & 0x3f);
                index = 1;
            }
            else if (token >= 0x10000 && token <= 0x10ffff) {
                c1 = 0xf0 | (token >>> 18);
                c2 = 0x80 | ((token >>> 12) & 0x3f);
                c3 = 0x80 | ((token >>> 6) & 0x3f);
                c4 = 0x80 | (token & 0x3f);
                index = 0;
            }
            else {
                if (this._errorMode.isFatal()) {
                    return Output.error(new OutputException("invalid code point: " + token));
                }
                else {
                    return this.write(this._errorMode.replacementChar());
                }
            }
            do {
                switch (index) {
                    case 0:
                        this._output = this._output.write(c1);
                        break;
                    case 1:
                        this._output = this._output.write(c2);
                        this._c2 = 0;
                        break;
                    case 2:
                        this._output = this._output.write(c3);
                        this._c3 = 0;
                        break;
                    case 3:
                        this._output = this._output.write(c4);
                        this._c4 = 0;
                        break;
                    default: throw new Error("unreachable");
                }
                index += 1;
            } while (index < 4 && this._output.isCont());
            if (index < 4) {
                if (index < 3) {
                    if (index < 2) {
                        this._c2 = c2;
                    }
                    this._c3 = c3;
                }
                this._c4 = c4;
            }
            this._index = index;
            return this;
        }
        else if (typeof token === "string") {
            this._output.write(token);
            return this;
        }
        else {
            throw new TypeError("" + token);
        }
    };
    Utf8EncodedOutput.prototype.flush = function () {
        var index = this._index;
        while (index < 4) {
            if (this._output.isCont()) {
                switch (index) {
                    case 1:
                        this._output = this._output.write(this._c2);
                        this._c2 = 0;
                        break;
                    case 2:
                        this._output = this._output.write(this._c3);
                        this._c3 = 0;
                        break;
                    case 3:
                        this._output = this._output.write(this._c4);
                        this._c4 = 0;
                        break;
                    default: throw new Error("unreachable");
                }
                index += 1;
            }
            else {
                return Output.error(new OutputException("unable to flush buffered code units"));
            }
        }
        this._index = index;
        return this;
    };
    Utf8EncodedOutput.prototype.settings = function (settings) {
        if (settings === void 0) {
            return this._output.settings();
        }
        else {
            this._output.settings(settings);
            return this;
        }
    };
    Utf8EncodedOutput.prototype.bind = function () {
        return this._output.bind();
    };
    Utf8EncodedOutput.prototype.clone = function () {
        return new Utf8EncodedOutput(this._output.clone(), this._errorMode, this._c2, this._c3, this._c4, this._index);
    };
    return Utf8EncodedOutput;
}(Output));
export { Utf8EncodedOutput };
//# sourceMappingURL=Utf8EncodedOutput.js.map