import { __extends } from "tslib";
import { WriterException } from "./WriterException";
import { Writer } from "./Writer";
import { Base64 } from "./Base64";
var Base64Writer = (function (_super) {
    __extends(Base64Writer, _super);
    function Base64Writer(value, input, base64, index, step) {
        if (index === void 0) { index = 0; }
        if (step === void 0) { step = 1; }
        var _this = _super.call(this) || this;
        _this._value = value;
        _this._input = input;
        _this._base64 = base64;
        _this._index = index;
        _this._step = step;
        return _this;
    }
    Base64Writer.prototype.feed = function (value) {
        if (value instanceof Uint8Array) {
            return new Base64Writer(undefined, value, this._base64);
        }
        else {
            throw new TypeError("" + value);
        }
    };
    Base64Writer.prototype.pull = function (output) {
        return Base64Writer.write(output, this._value, this._input, this._base64, this._index, this._step);
    };
    Base64Writer.write = function (output, value, input, base64, index, step) {
        if (index === void 0) { index = 0; }
        if (step === void 0) { step = 1; }
        while (index + 2 < input.length && output.isCont()) {
            var x = input[index];
            var y = input[index + 1];
            var z = input[index + 2];
            if (step === 1 && output.isCont()) {
                output = output.write(base64.encodeDigit(x >>> 2));
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(base64.encodeDigit(((y << 2) | (z >>> 6)) & 0x3f));
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(base64.encodeDigit(z & 0x3f));
                index += 3;
                step = 1;
            }
        }
        if (index + 1 < input.length && output.isCont()) {
            var x = input[index];
            var y = input[index + 1];
            if (step === 1 && output.isCont()) {
                output = output.write(base64.encodeDigit(x >>> 2));
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(base64.encodeDigit(((x << 4) | (y >>> 4)) & 0x3f));
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(base64.encodeDigit((y << 2) & 0x3f));
                step = 4;
            }
            if (step === 4) {
                if (!base64.isPadded()) {
                    index += 2;
                }
                else if (output.isCont()) {
                    output = output.write(61);
                    index += 2;
                }
            }
        }
        else if (index < input.length && output.isCont()) {
            var x = input[index];
            if (step === 1 && output.isCont()) {
                output = output.write(base64.encodeDigit(x >>> 2));
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(base64.encodeDigit((x << 4) & 0x3f));
                step = 3;
            }
            if (step === 3) {
                if (!base64.isPadded()) {
                    index += 1;
                }
                else if (output.isCont()) {
                    output = output.write(61);
                    step = 4;
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(61);
                index += 1;
            }
        }
        if (index === input.length) {
            return Writer.done(value);
        }
        else if (output.isDone()) {
            return Writer.error(new WriterException("truncated"));
        }
        else if (output.isError()) {
            return Writer.error(output.trap());
        }
        return new Base64Writer(value, input, base64, index, step);
    };
    return Base64Writer;
}(Writer));
export { Base64Writer };
Base64.Writer = Base64Writer;
//# sourceMappingURL=Base64Writer.js.map