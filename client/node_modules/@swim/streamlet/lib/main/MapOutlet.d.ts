import { Iterator, Map } from "@swim/util";
import { Outlet } from "./Outlet";
import { KeyEffect } from "./KeyEffect";
import { FilterFieldsFunction } from "./function";
import { MapValueFunction, MapFieldValuesFunction } from "./function";
import { WatchValueFunction, WatchFieldsFunction } from "./function";
import { MemoizeMapCombinator } from "./combinator/MemoizeMapCombinator";
import { FilterFieldsCombinator } from "./combinator/FilterFieldsCombinator";
import { MapFieldValuesCombinator } from "./combinator/MapFieldValuesCombinator";
import { ReduceFieldsCombinator } from "./combinator/ReduceFieldsCombinator";
import { WatchFieldsCombinator } from "./combinator/WatchFieldsCombinator";
export interface MapOutlet<K, V, O> extends Outlet<O> {
    has(key: K): boolean;
    get(): O | undefined;
    get(key: K): V | undefined;
    keyIterator(): Iterator<K>;
    outlet(key: K): Outlet<V>;
    invalidateInputKey(key: K, effect: KeyEffect): void;
    reconcileInputKey(key: K, version: number): void;
    memoize(): MapOutlet<K, V, O>;
    filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<O>): this;
    watch(func: WatchFieldsFunction<K, V>): this;
}
export declare const MapOutlet: {
    is<K, V, I>(object: unknown): object is MapOutlet<K, V, I>;
    MemoizeMapCombinator: typeof MemoizeMapCombinator;
    FilterFieldsCombinator: typeof FilterFieldsCombinator;
    MapFieldValuesCombinator: typeof MapFieldValuesCombinator;
    ReduceFieldsCombinator: typeof ReduceFieldsCombinator;
    WatchFieldsCombinator: typeof WatchFieldsCombinator;
};
//# sourceMappingURL=MapOutlet.d.ts.map