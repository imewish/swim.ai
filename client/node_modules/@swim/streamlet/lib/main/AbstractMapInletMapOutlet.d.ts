import { Iterator, Map } from "@swim/util";
import { BTree } from "@swim/collections";
import { Inlet } from "./Inlet";
import { Outlet } from "./Outlet";
import { KeyEffect } from "./KeyEffect";
import { MapOutlet } from "./MapOutlet";
import { KeyOutlet } from "./KeyOutlet";
import { FilterFieldsFunction } from "./function";
import { MapInletMapOutlet } from "./MapInletMapOutlet";
import { MapValueFunction, MapFieldValuesFunction } from "./function";
import { WatchValueFunction, WatchFieldsFunction } from "./function";
export declare abstract class AbstractMapInletMapOutlet<KI, KO, VI, VO, I, O> implements MapInletMapOutlet<KI, KO, VI, VO, I, O> {
    protected _input: MapOutlet<KI, VI, I> | null;
    protected _outputEffects: BTree<KI, KeyEffect>;
    protected _inputEffects: BTree<KO, KeyEffect>;
    protected _outlets: BTree<KO, KeyOutlet<KO, VO>>;
    protected _outputs: ReadonlyArray<Inlet<O>> | null;
    protected _version: number;
    constructor();
    abstract has(key: KO): boolean;
    abstract get(): O;
    abstract get(key: KO): VO | undefined;
    abstract keyIterator(): Iterator<KO>;
    input(): MapOutlet<KI, VI, I> | null;
    bindInput(input: MapOutlet<KI, VI, I>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    outlet(key: KO): Outlet<VO>;
    outputIterator(): Iterator<Inlet<O>>;
    bindOutput(output: Inlet<O>): void;
    unbindOutput(output: Inlet<O>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    invalidateOutputKey(key: KI, effect: KeyEffect): void;
    invalidateInputKey(key: KO, effect: KeyEffect): void;
    invalidateOutput(): void;
    invalidateInput(): void;
    invalidate(): void;
    reconcileOutputKey(key: KI, version: number): void;
    reconcileInputKey(key: KO, version: number): void;
    reconcileOutput(version: number): void;
    reconcileInput(version: number): void;
    reconcile(version: number): void;
    protected willInvalidateOutputKey(key: KI, effect: KeyEffect): void;
    protected onInvalidateOutputKey(key: KI, effect: KeyEffect): void;
    protected didInvalidateOutputKey(key: KI, effect: KeyEffect): void;
    protected willInvalidateInputKey(key: KO, effect: KeyEffect): void;
    protected onInvalidateInputKey(key: KO, effect: KeyEffect): void;
    protected didInvalidateInputKey(key: KO, effect: KeyEffect): void;
    protected willInvalidate(): void;
    protected onInvalidate(): void;
    protected didInvalidate(): void;
    protected willReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected onReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected didReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void;
    protected willReconcileInputKey(key: KO, effect: KeyEffect, version: number): KeyEffect;
    protected onReconcileInputKey(key: KO, effect: KeyEffect, version: number): void;
    protected didReconcileInputKey(key: KO, effect: KeyEffect, version: number): void;
    protected willReconcile(version: number): void;
    protected onReconcile(version: number): void;
    protected didReconcile(version: number): void;
    memoize(): MapOutlet<KO, VO, O>;
    filter(func: FilterFieldsFunction<KO, VO>): MapOutlet<KO, VO, Map<KO, VO>>;
    map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<KO, VO, V2>): MapOutlet<KO, V2, Map<KO, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: VO) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<O>): this;
    watch(func: WatchFieldsFunction<KO, VO>): this;
}
//# sourceMappingURL=AbstractMapInletMapOutlet.d.ts.map