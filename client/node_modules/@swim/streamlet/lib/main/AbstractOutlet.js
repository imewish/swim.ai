import { Cursor } from "@swim/util";
import { Outlet } from "./Outlet";
var AbstractOutlet = (function () {
    function AbstractOutlet() {
        this._outputs = null;
        this._version = -1;
    }
    AbstractOutlet.prototype.outputIterator = function () {
        return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();
    };
    AbstractOutlet.prototype.bindOutput = function (output) {
        var oldOutputs = this._outputs;
        var n = oldOutputs !== null ? oldOutputs.length : 0;
        var newOutputs = new Array(n + 1);
        for (var i = 0; i < n; i += 1) {
            newOutputs[i] = oldOutputs[i];
        }
        newOutputs[n] = output;
        this._outputs = newOutputs;
    };
    AbstractOutlet.prototype.unbindOutput = function (output) {
        var oldOutputs = this._outputs;
        for (var i = 0, n = oldOutputs !== null ? oldOutputs.length : 0; i < n; i += 1) {
            if (oldOutputs[i] === output) {
                if (n > 1) {
                    var newOutputs = new Array(n - 1);
                    for (var j = 0; j < i; j += 1) {
                        newOutputs[j] = oldOutputs[j];
                    }
                    for (var j = i; j < n - 1; j += 1) {
                        newOutputs[j] = oldOutputs[j + 1];
                    }
                    this._outputs = newOutputs;
                }
                else {
                    this._outputs = null;
                }
                break;
            }
        }
    };
    AbstractOutlet.prototype.unbindOutputs = function () {
        var outputs = this._outputs;
        if (outputs !== null) {
            this._outputs = null;
            for (var i = 0, n = outputs.length; i < n; i += 1) {
                var output = outputs[i];
                output.unbindInput();
            }
        }
    };
    AbstractOutlet.prototype.disconnectOutputs = function () {
        var outputs = this._outputs;
        if (outputs !== null) {
            this._outputs = null;
            for (var i = 0, n = outputs.length; i < n; i += 1) {
                var output = outputs[i];
                output.unbindInput();
                output.disconnectOutputs();
            }
        }
    };
    AbstractOutlet.prototype.disconnectInputs = function () {
    };
    AbstractOutlet.prototype.invalidateInput = function () {
        if (this._version >= 0) {
            this.willInvalidateInput();
            this._version = -1;
            this.onInvalidateInput();
            for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                this._outputs[i].invalidateOutput();
            }
            this.didInvalidateInput();
        }
    };
    AbstractOutlet.prototype.reconcileInput = function (version) {
        if (this._version < 0) {
            this.willReconcileInput(version);
            this._version = version;
            this.onReconcileInput(version);
            for (var i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {
                this._outputs[i].reconcileOutput(version);
            }
            this.didReconcileInput(version);
        }
    };
    AbstractOutlet.prototype.willInvalidateInput = function () {
    };
    AbstractOutlet.prototype.onInvalidateInput = function () {
    };
    AbstractOutlet.prototype.didInvalidateInput = function () {
    };
    AbstractOutlet.prototype.willReconcileInput = function (version) {
    };
    AbstractOutlet.prototype.onReconcileInput = function (version) {
    };
    AbstractOutlet.prototype.didReconcileInput = function (version) {
    };
    AbstractOutlet.prototype.memoize = function () {
        var combinator = new Outlet.MemoizeValueCombinator();
        combinator.bindInput(this);
        return combinator;
    };
    AbstractOutlet.prototype.map = function (func) {
        var combinator = new Outlet.MapValueCombinator(func);
        combinator.bindInput(this);
        return combinator;
    };
    AbstractOutlet.prototype.watch = function (func) {
        var combinator = new Outlet.WatchValueCombinator(func);
        combinator.bindInput(this);
        return this;
    };
    return AbstractOutlet;
}());
export { AbstractOutlet };
//# sourceMappingURL=AbstractOutlet.js.map