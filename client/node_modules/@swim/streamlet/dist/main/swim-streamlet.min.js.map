{"version":3,"sources":["../../main/KeyEffect.ts","../../main/Inlet.ts","../../main/Outlet.ts","../../main/MapInlet.ts","../../main/MapOutlet.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/StreamletException.ts","../../main/AbstractInlet.ts","../../main/AbstractOutlet.ts","../../main/AbstractInoutlet.ts","../../main/KeyOutlet.ts","../../main/AbstractMapInlet.ts","../../main/AbstractMapOutlet.ts","../../main/AbstractMapInoutlet.ts","../../main/AbstractMapInletOutlet.ts","../../main/AbstractMapInletMapOutlet.ts","../../main/OutletInlet.ts","../../main/OutletMapInlet.ts","../../main/ValueInput.ts","../../main/ValueOutput.ts","../../main/MapInput.ts","../../main/MapOutput.ts","../../main/combinator/MemoizeValueCombinator.ts","../../main/combinator/MemoizeMapCombinator.ts","../../main/combinator/FilterFieldsOperator.ts","../../main/combinator/FilterFieldsCombinator.ts","../../main/combinator/MapValueOperator.ts","../../main/combinator/MapValueCombinator.ts","../../main/combinator/MapFieldValuesOperator.ts","../../main/combinator/MapFieldValuesCombinator.ts","../../main/combinator/ReduceFieldsOperator.ts","../../main/combinator/ReduceFieldsCombinator.ts","../../main/combinator/WatchValueOperator.ts","../../main/combinator/WatchValueCombinator.ts","../../main/combinator/WatchFieldsOperator.ts","../../main/combinator/WatchFieldsCombinator.ts","../../main/StreamletInlet.ts","../../main/StreamletOutlet.ts","../../main/StreamletInoutlet.ts","../../main/AbstractStreamlet.ts","../../main/In.ts","../../main/Inout.ts","../../main/Out.ts","../../main/Streamlet.ts","../../main/StreamletScope.ts"],"names":["KeyEffect","Inlet","is","object","inlet","input","bindInput","unbindInput","Outlet","outlet","outputIterator","bindOutput","unbindOutput","MemoizeValueCombinator","MapValueCombinator","WatchValueCombinator","MapInlet","invalidateOutputKey","reconcileOutputKey","MapOutlet","keyIterator","MemoizeMapCombinator","FilterFieldsCombinator","MapFieldValuesCombinator","ReduceFieldsCombinator","WatchFieldsCombinator","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","StreamletException","message","_this","_super","call","Error","AbstractInlet","_input","_version","disconnectInputs","disconnectOutputs","invalidateOutput","willInvalidateOutput","onInvalidateOutput","didInvalidateOutput","reconcileOutput","version","willReconcileOutput","reconcileInput","onReconcileOutput","didReconcileOutput","AbstractOutlet","_outputs","Cursor","array","empty","output","oldOutputs","n","length","newOutputs","i","j","unbindOutputs","outputs","invalidateInput","willInvalidateInput","onInvalidateInput","didInvalidateInput","willReconcileInput","onReconcileInput","didReconcileInput","memoize","combinator","map","func","watch","AbstractInoutlet","invalidate","willInvalidate","onInvalidate","didInvalidate","reconcile","willReconcile","onReconcile","didReconcile","KeyOutlet","key","_key","get","AbstractMapInlet","_effects","BTree","TypeError","effect","oldEffects","willInvalidateOutputKey","updated","onInvalidateOutputKey","didInvalidateOutputKey","willReconcileOutputKey","removed","reconcileInputKey","onReconcileOutputKey","didReconcileOutputKey","forEach","AbstractMapOutlet","_outlets","outlets","isEmpty","keyOutlet","invalidateInputKey","willInvalidateInputKey","onInvalidateInputKey","didInvalidateInputKey","willReconcileInputKey","onReconcileInputKey","didReconcileInputKey","filter","reduce","identity","accumulator","combiner","AbstractMapInoutlet","invalidateKey","willInvalidateKey","onInvalidateKey","didInvalidateKey","reconcileKey","willReconcileKey","onReconcileKey","didReconcileKey","AbstractMapInletOutlet","AbstractMapInletMapOutlet","_outputEffects","_inputEffects","oldOutputEffects","oldInputEffects","oldEffect","newEffect","OutletInlet","_outlet","OutletMapInlet","ValueInput","state","_state","set","newState","oldState","ValueOutput","MapInput","has","newValue","oldValue","delete","keys","MapOutput","value","_cache","FilterFieldsOperator","evaluate","next","done","key_1","_func","MapValueOperator","MapFieldValuesOperator","ReduceFieldsOperator","reduced","accumulate","bind","combine","_identity","_accumulator","_combiner","result","WatchValueOperator","WatchFieldsOperator","StreamletInlet","streamlet","_streamlet","willInvalidateInlet","didInvalidateInlet","willReconcileInlet","didReconcileInlet","StreamletOutlet","getOutput","willInvalidateOutlet","didInvalidateOutlet","willReconcileOutlet","didReconcileOutlet","StreamletInoutlet","willUpdate","didUpdate","name","type","InoutletDescriptor","AbstractStreamlet","scope","streamletClass","streamletScope","setStreamletScope","streamletContext","context","setStreamletContext","reflectInletKey","reflectOutletKey","inoutlet","onInvalidateOutlets","onReconcileInlets","onReconcileOutlets","getInput","orElse","name_1","_inlets","inletDescriptor","InletDescriptor","reflectInletField","reflectInoutletField","name_2","outletDescriptor","OutletDescriptor","reflectOutletField","invalidateOutlets","name_3","reconcileInlets","name_4","reconcileOutlets","name_5","reflectEachInlet","callback","thisArg","index","name_6","reflectEachOutlet","name_7","reflectInletCount","count","_","reflectOutletCount","reflectInletIndex","name_8","reflectOutletIndex","name_9","reflectValueInletField","reflectMapInletField","reflectValueOutletField","reflectMapOutletField","inoutletDescriptor","reflectValueInoutletField","reflectMapInoutletField","init","_inoutlets","decorateInlet","options","target","decorateOutlet","decorateInoutlet","arguments"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/streamlet/dist/main/swim-streamlet.min.js","sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport const enum KeyEffect {\n  Update,\n  Remove,\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\n\nexport type InletType = \"value\" | \"map\";\n\nexport interface InletOptions {\n  name?: string;\n  type?: InletType;\n}\n\n/**\n * Input connector into a [[Streamlet]].  An `Inlet` represents a source from\n * which a `Streamlet` acquires state.\n *\n * In order for an `Inlet` to provide state to its `Streamlet`, it must bind to\n * an [[input]] source.  The input source of an `Inlet` is an [[Outlet]] of\n * some other `Streamlet`.  The [[bindInput]] method \"plugs\" the `Inlet` into\n * an `Outlet`.  The [[unbindInput]] method \"unplugs\" the `Inlet` from its\n * connected `Outlet`.\n *\n * The state of an `Inlet` has an integral _version_.  When its version is\n * negative, the state of the `Inlet` is considered _invalid_.  When any state\n * on which an `Inlet` transitively depends changes, the `Inlet` will be\n * [[invalidatOutput invalidated]].  Invalidation does not immediately cause an\n * `Inlet` to recompute its state.  Instead, a separate [[reconcileOutput\n * reconcile]] step causes all of the invalid paths in the dataflow graph\n * passing through the `Inlet` to reconcile their state.\n */\nexport interface Inlet<I = unknown> {\n  /**\n   * Returns the `Outlet` from which this `Inlet` acquires its state; returns\n   * `null` if this `Inlet` is disconnected.\n   */\n  input(): Outlet<I> | null;\n\n  /**\n   * Connects this `Inlet` to an `Outlet` from which it will  acquire its\n   * state.  If this `Inlet` is already connected, it will first disconnect\n   * from its existing input.  Then, after updating its [[input]] property,\n   * the `Inlet` will invoke [[Outlet.bindOutput]] on its new `input`.\n   */\n  bindInput(input: Outlet<I> | null): void;\n\n  /**\n   * Disconnects this `Inlet` from its input `Outlet`, if connected.  After\n   * setting its [[input]] property to `null`, the `Inlet` will invoke\n   * [[Outlet.unbindOutput]] on its old input, if defined.\n   */\n  unbindInput(): void;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Inlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * terminating at this `Inlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Disconnects all `Outlet`s dominated by this `Inlet` in the dataflow graph.\n   * Used to recursively clean up chains of combinators passing through this\n   * `Inlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Marks this `Inlet`—and the `Streamlet` to which this `Inlet` is attached—as\n   * having stale state.  Invalidating an `Inlet` will recursively invalidate\n   * all streamlets that transitively depend on the state of this `Inlet`.\n   * Invalidating an `Inlet` does not cause its state to be recomputed.  A\n   * subsequent [[reconcileOutput]] call will reconcile the state of the `Inlet`.\n   */\n  invalidateOutput(): void;\n\n  /**\n   * Reconciles the state of this `Inlet`, if the version of this `Inlet`'s\n   * state differs from the target `version`.  To reconcile its state, the\n   * `Inlet` first invokes [[Outlet.reconcileInput]] on its [[input]], to\n   * ensure that its input is up-to-date.  It then invokes\n   * [[Streamlet.reconcile]] on the `Streamlet` to which it's attached,\n   * causing the `Streamlet` to reconcile its own state.\n   */\n  reconcileOutput(version: number): void;\n}\n\n/** @hidden */\nexport const Inlet = {\n  is<I>(object: unknown): object is Inlet<I> {\n    if (typeof object === \"object\" && object) {\n      const inlet = object as Inlet<I>;\n      return typeof inlet.input === \"function\"\n          && typeof inlet.bindInput === \"function\"\n          && typeof inlet.unbindInput === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\nimport {MemoizeValueCombinator} from \"./combinator/MemoizeValueCombinator\";\nimport {MapValueCombinator} from \"./combinator/MapValueCombinator\";\nimport {WatchValueCombinator} from \"./combinator/WatchValueCombinator\";\n\nexport type OutletType = \"value\" | \"map\";\n\nexport interface OutletOptions {\n  name?: string;\n  type?: OutletType;\n}\n\n/**\n * Output connector from a [[Streamlet]].  An `Outlet` represents a sink to\n * which a `Streamlet` provides state.\n *\n * An `Outlet` has a one-to-many relationship with a set of output sinks.\n * An output sink of an `Outlet` is an `Inlet` of some other `Streamlet`.\n * The [[bindOutput]] method \"plugs\" an `Inlet` into the `Outlet`.\n * The [[unbindOutput]] method \"unplugs\" an `Inlet` from the `Outlet`.\n */\nexport interface Outlet<O = unknown> {\n  /**\n   * Returns the current state of this `Outlet`.\n   */\n  get(): O | undefined;\n\n  /**\n   * Returns an `Iterator` over the set of `Inlet`s that depend on the state of\n   * this `Outlet`.\n   */\n  outputIterator(): Iterator<Inlet<O>>;\n\n  /**\n   * Adds an `output` to the set of `Inlet`s that depend on the state of this\n   * `Outlet`.  The `output` will be invalidated when the state of this\n   * `Outlet` is invalidated, and updated when this `Outlet` is updated.\n   */\n  bindOutput(output: Inlet<O>): void;\n\n  /**\n   * Removes an `output` from the set of `Inlet`s that depend on the state of\n   * this `Outlet`.\n   */\n  unbindOutput(output: Inlet<O>): void;\n\n  /**\n   * Disconnects all outputs from this `Outlet` by invoking\n   * [[Inlet.unbindInput]] on each `Inelt` that depends on the state of this\n   * `Outlet`.\n   */\n  unbindOutputs(): void;\n\n  /**\n   * Disconnects all `Outlet`s dominated by this `Outlet` in the dataflow\n   * graph.  Used to recursively clean up chains of combinators originating\n   * from this `Inlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Outlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * passing through this `Outlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Marks this `Outlet`—and all [[outputIterator outputs]] that depend on the\n   * state of this `Outlet`—as having stale state.\n   */\n  invalidateInput(): void;\n\n  /**\n   * Reconciles the state of this `Outlet`, if the version of this `Outlet`'s\n   * state differs from the target `version`.  To reconcile its state, the\n   * `Outlet` first invokes [[Streamlet.reconcile]] on the `Streamlet` to which\n   * it's attached. It then invokes [[Inlet.reconcileOutput]] on each of its\n   * dependent [[outputIterator outputs]].\n   */\n  reconcileInput(version: number): void;\n\n  memoize(): Outlet<O>;\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n\n  watch(func: WatchValueFunction<O>): this;\n}\n\n/** @hidden */\nexport const Outlet = {\n  is<O>(object: unknown): object is Outlet<O> {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as Outlet<O>;\n      return typeof outlet.outputIterator === \"function\"\n          && typeof outlet.bindOutput === \"function\"\n          && typeof outlet.unbindOutput === \"function\";\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  MemoizeValueCombinator: void 0 as unknown as typeof MemoizeValueCombinator, // defined by MemoizeValueCombinator\n  /** @hidden */\n  MapValueCombinator: void 0 as unknown as typeof MapValueCombinator, // defined by MapValueCombinator\n  /** @hidden */\n  WatchValueCombinator: void 0 as unknown as typeof WatchValueCombinator, // defined by WatchValueCombinator\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {KeyEffect} from \"./KeyEffect\";\n\n/**\n * Input connector into a `Streamlet` for a key-value map state.\n */\nexport interface MapInlet<K, V, I> extends Inlet<I> {\n  /**\n   * Marks this `MapInlet` as needing an `effect` applied to a given `key`.\n   * Invalidating an individual key invalidates the entire state of the `Inlet`.\n   * But only the invalidated keys need to be updated in order to reconcile the\n   * overall state of the `Inlet`.\n   */\n  invalidateOutputKey(key: K, effect: KeyEffect): void;\n\n  /**\n   * Reconciles the state of an individual `key` in this `MapInlet`, if the\n   * version of this `MapInlet`'s state differs from the target `version`.\n   * To reconcile the state of a key, the `MapInlet` first invokes\n   * [[MapOutlet.reconcileInputKey]] on its [[input]], if its input is a\n   * `MapOutlet`, or it invokes [[Outlet.reconcileInput]], if its input is not\n   * a `MapOutlet`.  Then, if all invalid keys have been reconciled, the\n   * `MapInlet` invokes [[Streamletreconcile]] on its attached streamlet.\n   */\n  reconcileOutputKey(key: K, version: number): void;\n}\n\n/** @hidden */\nexport const MapInlet = {\n  is<K, V, I>(object: unknown): object is MapInlet<K, V, I> {\n    if (typeof object === \"object\" && object) {\n      const inlet = object as MapInlet<K, V, I>;\n      return Inlet.is(inlet)\n          && typeof inlet.invalidateOutputKey === \"function\"\n          && typeof inlet.reconcileOutputKey === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Map} from \"@swim/util\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\nimport {MemoizeMapCombinator} from \"./combinator/MemoizeMapCombinator\";\nimport {FilterFieldsCombinator} from \"./combinator/FilterFieldsCombinator\";\nimport {MapFieldValuesCombinator} from \"./combinator/MapFieldValuesCombinator\";\nimport {ReduceFieldsCombinator} from \"./combinator/ReduceFieldsCombinator\";\nimport {WatchFieldsCombinator} from \"./combinator/WatchFieldsCombinator\";\n\n/**\n * Output connector from a [[Streamlet]] for a key-value map state.\n */\nexport interface MapOutlet<K, V, O> extends Outlet<O> {\n  /**\n   * Returns `true` if the current state of this `MapOutlet` contains the given\n   * `key`; otherwise returns `false`.\n   */\n  has(key: K): boolean;\n\n  /**\n   * Returns the current state of this `Outlet`.\n   */\n  get(): O | undefined;\n\n  /**\n   * Returns the value assocaited with the given `key` in the current state of\n   * this `MapOutlet`, if defined; otherwise returns `undefined`.\n   */\n  get(key: K): V | undefined;\n\n  /**\n   * Returns an `Iterator` over the keys in the current state of this `MapOutlet`.\n   */\n  keyIterator(): Iterator<K>;\n\n  /**\n   * Returns an `Outlet` that updates when the specified `key` updates.\n   */\n  outlet(key: K): Outlet<V>;\n\n  /**\n   * Marks this `MapOutlet` as needing an `effect` applied to a given `key`.\n   * Invalidating an individual key invalidates the entire state of the\n   * `Outlet`.  But only the invalidated keys need to be updated in order to\n   * reconcile the overall state of the `Outlet`.\n   */\n  invalidateInputKey(key: K, effect: KeyEffect): void;\n\n  /**\n   * Reconciles the state of an individual `key` in this `MapOutlet`, if the\n   * version of this `MapOutlet`'s state differs from the target `version`.\n   * To reconcile the state of a key, the `MapOutlet` first invokes\n   * [[Streamlet.reconcile]] on its attached streamlets.  Then, for each\n   * dependent output, it invokes [[MapInlet.reconcileOutputKey]], if the\n   * dependent output is a [[MapInlet]], or it invokes [[Inlet.reconcile]],\n   * if the dependent output is not a `MapInlet`.\n   */\n  reconcileInputKey(key: K, version: number): void;\n\n  memoize(): MapOutlet<K, V, O>;\n\n  filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>>;\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;\n\n  reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, V>): this;\n}\n\n/** @hidden */\nexport const MapOutlet = {\n  is<K, V, I>(object: unknown): object is MapOutlet<K, V, I> {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as MapOutlet<K, V, I>;\n      return Outlet.is(outlet)\n          && typeof outlet.keyIterator === \"function\"\n          && typeof outlet.outlet === \"function\";\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  MemoizeMapCombinator: void 0 as unknown as typeof MemoizeMapCombinator, // defined by MemoizeMapCombinator\n  /** @hidden */\n  FilterFieldsCombinator: void 0 as unknown as typeof FilterFieldsCombinator, // defined by FilterFieldsCombinator\n  /** @hidden */\n  MapFieldValuesCombinator: void 0 as unknown as typeof MapFieldValuesCombinator, // defined by MapFieldValuesCombinator\n  /** @hidden */\n  ReduceFieldsCombinator: void 0 as unknown as typeof ReduceFieldsCombinator, // defined by ReduceFieldsCombinator\n  /** @hidden */\n  WatchFieldsCombinator: void 0 as unknown as typeof WatchFieldsCombinator, // defined by WatchFieldsCombinator\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport class StreamletException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = StreamletException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\n\nexport abstract class AbstractInlet<I> implements Inlet<I> {\n  /** @hidden */\n  protected _input: Outlet<I> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._version = -1;\n  }\n\n  input(): Outlet<I> | null {\n    return this._input;\n  }\n\n  bindInput(input: Outlet<I> | null): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    const input = this._input;\n    if (input !== null) {\n      input.unbindOutput(this);\n      this._input = null;\n      input.disconnectInputs();\n    }\n  }\n\n  disconnectOutputs(): void {\n    // nop\n  }\n\n  invalidateOutput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateOutput();\n      this._version = -1;\n      this.onInvalidateOutput();\n      this.didInvalidateOutput();\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileOutput(version);\n      this._version = version;\n      if (this._input !== null) {\n        this._input.reconcileInput(version);\n      }\n      this.onReconcileOutput(version);\n      this.didReconcileOutput(version);\n    }\n  }\n\n  protected willInvalidateOutput(): void {\n    // stub\n  }\n\n  protected onInvalidateOutput(): void {\n    // stub\n  }\n\n  protected didInvalidateOutput(): void {\n    // stub\n  }\n\n  protected willReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutput(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractOutlet<O> implements Outlet<O> {\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  outputIterator(): Cursor<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    for (let i = 0, n = oldOutputs !== null ? oldOutputs.length : 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {Inoutlet} from \"./Inoutlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractInoutlet<I, O> implements Inoutlet<I, O> {\n  /** @hidden */\n  protected _input: Outlet<I> | null;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  input(): Outlet<I> | null {\n    return this._input;\n  }\n\n  bindInput(input: Outlet<I> | null): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      if (this._input !== null) {\n        this._input.reconcileInput(version);\n      }\n      this.onReconcile(version);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"./MapOutlet\";\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\nexport class KeyOutlet<K, V> extends AbstractOutlet<V> {\n  /** @hidden */\n  protected readonly _input: MapOutlet<K, V, unknown>;\n  /** @hidden */\n  protected readonly _key: K;\n\n  constructor(input: MapOutlet<K, V, unknown>, key: K) {\n    super();\n    this._input = input;\n    this._key = key;\n  }\n\n  input(): MapOutlet<K, V, unknown> {\n    return this._input;\n  }\n\n  key(): K {\n    return this._key;\n  }\n\n  get(): V | undefined {\n    return this._input.get(this._key);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\n\nexport abstract class AbstractMapInlet<K, V, O> implements MapInlet<K, V, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, V, O> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._version = -1;\n  }\n\n  input(): MapOutlet<K, V, O> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, V, O> | null): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input != null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    const input = this._input;\n    if (input !== null) {\n      input.unbindOutput(this);\n      this._input = null;\n      input.disconnectInputs();\n    }\n  }\n\n  disconnectOutputs(): void {\n    // nop\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateOutput();\n      this._version = -1;\n      this.onInvalidateOutput();\n      this.didInvalidateOutput();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileOutput(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileOutput(version);\n      this.didReconcileOutput(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateOutput(): void {\n    // stub\n  }\n\n  protected onInvalidateOutput(): void {\n    // stub\n  }\n\n  protected didInvalidateOutput(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutput(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapOutlet<K, V, O> implements MapOutlet<K, V, O> {\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<K, KeyOutlet<K, V>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: K): boolean;\n\n  abstract get(): O | undefined;\n\n  abstract get(key: K): V | undefined;\n\n  abstract keyIterator(): Iterator<K>;\n\n  outlet(key: K): Outlet<V> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<K, V>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, V>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, V>) {\n        keyOutlet.disconnectOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: K, outlet: KeyOutlet<K, V>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileInputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        this.onReconcileInputKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<K, V, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<K, V, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<K, V, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<K, V, V2>): Outlet<V2> | MapOutlet<K, V2, Map<K, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<K, V, V2, O>(func as MapFieldValuesFunction<K, V, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<K, V, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, V>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<K, V>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<K, V, O>(func as WatchFieldsFunction<K, V>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {MapInoutlet} from \"./MapInoutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapInoutlet<K, VI, VO, I, O> implements MapInoutlet<K, VI, VO, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, VI, I> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<K, KeyOutlet<K, VO>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: K): boolean;\n\n  abstract get(): O | undefined;\n\n  abstract get(key: K): VO | undefined;\n\n  abstract keyIterator(): Iterator<K>;\n\n  input(): MapOutlet<K, VI, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, VI, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null && this._outlets.isEmpty()) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outlet(key: K): Outlet<VO> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<K, VO>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, VO>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outlets = this._outlets;\n      if (outlets.isEmpty()) {\n        this._outlets = new BTree();\n        outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, VO>) {\n          keyOutlet.disconnectOutputs();\n        }, this);\n      }\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    this.invalidateKey(key, effect);\n  }\n\n  invalidateInputKey(key: K, effect: KeyEffect): void {\n    this.invalidateKey(key, effect);\n  }\n\n  invalidateKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: K, outlet: KeyOutlet<K, VO>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    this.reconcileKey(key, version);\n  }\n\n  reconcileInputKey(key: K, version: number): void {\n    this.reconcileKey(key, version);\n  }\n\n  reconcileKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<K, VO, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<K, VO, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<K, VO>): MapOutlet<K, VO, Map<K, VO>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<K, VO, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, VO, V2>): MapOutlet<K, V2, Map<K, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<K, VO, V2>): Outlet<V2> | MapOutlet<K, V2, Map<K, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<K, VO, V2, O>(func as MapFieldValuesFunction<K, VO, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: VO) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<K, VO, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, VO>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<K, VO>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<K, VO, O>(func as WatchFieldsFunction<K, VO>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {MapInletOutlet} from \"./MapInletOutlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractMapInletOutlet<K, V, I, O> implements MapInletOutlet<K, V, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, V, I> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  input(): MapOutlet<K, V, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, V, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        output.invalidateOutput();\n      }\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapInletMapOutlet} from \"./MapInletMapOutlet\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapInletMapOutlet<KI, KO, VI, VO, I, O> implements MapInletMapOutlet<KI, KO, VI, VO, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<KI, VI, I> | null;\n  /** @hidden */\n  protected _outputEffects: BTree<KI, KeyEffect>;\n  /** @hidden */\n  protected _inputEffects: BTree<KO, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<KO, KeyOutlet<KO, VO>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._outputEffects = new BTree();\n    this._inputEffects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: KO): boolean;\n\n  abstract get(): O;\n\n  abstract get(key: KO): VO | undefined;\n\n  abstract keyIterator(): Iterator<KO>;\n\n  input(): MapOutlet<KI, VI, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<KI, VI, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null && this._outlets.isEmpty()) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outlet(key: KO): Outlet<VO> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<KO, VO>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: KO, keyOutlet: KeyOutlet<KO, VO>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outlets = this._outlets;\n      if (outlets.isEmpty()) {\n        this._outlets = new BTree();\n        outlets.forEach(function (key: KO, keyOutlet: KeyOutlet<KO, VO>) {\n          keyOutlet.disconnectOutputs();\n        }, this);\n      }\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n  invalidateOutputKey(key: KI, effect: KeyEffect): void {\n    const oldOutputEffects = this._outputEffects;\n    if (oldOutputEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._outputEffects = oldOutputEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateInputKey(key: KO, effect: KeyEffect): void {\n    const oldInputEffects = this._inputEffects;\n    if (oldInputEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._inputEffects = oldInputEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: KO, outlet: KeyOutlet<KO, VO>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: KI, version: number): void {\n    if (this._version < 0) {\n      const oldOutputEffects = this._outputEffects;\n      const effect = oldOutputEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._outputEffects = oldOutputEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInputKey(key: KO, version: number): void {\n    if (this._version < 0) {\n      const oldInputEffects = this._inputEffects;\n      const oldEffect = oldInputEffects.get(key);\n      if (oldEffect !== void 0) {\n        const newEffect = this.willReconcileInputKey(key, oldEffect, version);\n        if (oldEffect !== newEffect) {\n          this.invalidateInputKey(key, newEffect);\n        }\n        this._inputEffects = oldInputEffects.removed(key);\n        this.onReconcileInputKey(key, newEffect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, newEffect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._outputEffects.forEach(function (key: KI): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._inputEffects.forEach(function (key: KO): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: KO, effect: KeyEffect, version: number): KeyEffect {\n    return effect;\n  }\n\n  protected onReconcileInputKey(key: KO, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: KO, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<KO, VO, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<KO, VO, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<KO, VO>): MapOutlet<KO, VO, Map<KO, VO>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<KO, VO, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<KO, VO, V2>): MapOutlet<KO, V2, Map<KO, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<KO, VO, V2>): Outlet<V2> | MapOutlet<KO, V2, Map<KO, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<KO, VO, V2, O>(func as MapFieldValuesFunction<KO, VO, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: VO) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<KO, VO, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<KO, VO>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<KO, VO>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<KO, VO, O>(func as WatchFieldsFunction<KO, VO>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\nimport {AbstractInlet} from \"./AbstractInlet\";\n\n/**\n * An `Inlet` that invalidates a parameterized `Outlet` whenever the `Inlet`\n * is invalidated, and that updates the parameterized `Outlet` whenever the\n * `Inlet` updates.\n */\nexport class OutletInlet<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected readonly _outlet: Outlet<unknown>;\n\n  constructor(outlet: Outlet<unknown>) {\n    super();\n    this._outlet = outlet;\n  }\n\n  outlet(): Outlet<unknown> {\n    return this._outlet;\n  }\n\n  protected onInvalidateOutput(): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onReconcileOutput(version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapInlet} from \"./AbstractMapInlet\";\n\n/**\n * A `MapInlet` that invalidates a parameterized `Outlet` whenever the\n * `MapInlet` is invalidated, and that updates the parameterized `Outlet`\n * whenever the `MapInlet` updates.\n */\nexport class OutletMapInlet<K, V, O> extends AbstractMapInlet<K, V, O> {\n  /** @hidden */\n  protected readonly _outlet: Outlet<unknown>;\n\n  constructor(outlet: Outlet<unknown>) {\n    super();\n    this._outlet = outlet;\n  }\n\n  outlet(): Outlet<unknown> {\n    return this._outlet;\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onInvalidateOutput(): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n\n  protected onReconcileOutput(version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\nexport class ValueInput<O> extends AbstractOutlet<O> {\n  /** @hidden */\n  protected _state: O | undefined;\n\n  constructor(state?: O) {\n    super();\n    this._state = state;\n  }\n\n  get(): O | undefined {\n    return this._state;\n  }\n\n  set(newState: O | undefined): O | undefined {\n    const oldState = this._state;\n    this._state = newState;\n    this.invalidateInput();\n    return oldState;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInlet} from \"./AbstractInlet\";\n\nexport class ValueOutput<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected _state: I | undefined;\n\n  constructor(state?: I) {\n    super();\n    this._state = state;\n  }\n\n  get(): I | undefined {\n    return this._state;\n  }\n\n  protected onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      this._state = this._input.get();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapOutlet} from \"./AbstractMapOutlet\";\n\nexport class MapInput<K, V> extends AbstractMapOutlet<K, V, Map<K, V>> {\n  /** @hidden */\n  protected _state: BTree<K, V>;\n\n  constructor(state: BTree<K, V> = new BTree()) {\n    super();\n    this._state = state;\n    state.forEach(function (key: K): void {\n      this._effects = this._effects.updated(key, KeyEffect.Update);\n    }, this);\n  }\n\n  has(key: K): boolean {\n    return this._state.has(key);\n  }\n\n  get(): Map<K, V> | undefined;\n  get(key: K): V | undefined;\n  get(key?: K): Map<K, V> | V | undefined {\n    if (key === void 0) {\n      return this._state;\n    } else {\n      return this._state.get(key);\n    }\n  }\n\n  set(key: K, newValue: V): V | undefined {\n    const oldValue = this._state.get(key);\n    this._state = this._state.updated(key, newValue);\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return oldValue;\n  }\n\n  delete(key: K): this {\n    const oldState = this._state;\n    const newState = oldState.removed(key);\n    if (oldState !== newState) {\n      this._state = newState;\n      this.invalidateInputKey(key, KeyEffect.Remove);\n    }\n    return this;\n  }\n\n  keyIterator(): Cursor<K> {\n    return this._state.keys();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapInlet} from \"./AbstractMapInlet\";\n\nexport class MapOutput<K, V> extends AbstractMapInlet<K, V, Map<K, V>> {\n  /** @hidden */\n  protected _state: BTree<K, V>;\n\n  constructor() {\n    super();\n    this._state = new BTree();\n  }\n\n  get(): Map<K, V> {\n    return this._state;\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._state = this._state.updated(key, value);\n        } else {\n          this._state = this._state.removed(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._state = this._state.removed(key);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {AbstractInoutlet} from \"../AbstractInoutlet\";\n\nexport class MemoizeValueCombinator<IO> extends AbstractInoutlet<IO, IO> {\n  /** @hidden */\n  protected _state: IO | undefined;\n\n  get(): IO | undefined {\n    return this._state;\n  }\n\n  protected onReconcile(version: number): void {\n    if (this._input !== null) {\n      this._state = this._input.get();\n    }\n  }\n\n  memoize(): Outlet<IO> {\n    return this;\n  }\n}\nOutlet.MemoizeValueCombinator = MemoizeValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {MapOutlet} from \"../MapOutlet\";\nimport {AbstractMapInoutlet} from \"../AbstractMapInoutlet\";\n\nexport class MemoizeMapCombinator<K, V, IO> extends AbstractMapInoutlet<K, V, V, IO, IO> {\n  /** @hidden */\n  protected _state: IO | undefined;\n  /** @hidden */\n  protected _cache: BTree<K, V>;\n\n  constructor() {\n    super();\n    this._cache = new BTree();\n  }\n\n  has(key: K): boolean {\n    return this._cache.has(key);\n  }\n\n  get(): IO | undefined;\n  get(key: K): V | undefined;\n  get(key?: K): IO | V | undefined {\n    if (key === void 0) {\n      if (this._state === void 0 && this._input != null) {\n        this._state = this._input.get();\n      }\n      return this._state;\n    } else {\n      return this._cache.get(key);\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    return this._cache.keys();\n  }\n\n  protected onReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._cache = this._cache.updated(key, value);\n        } else {\n          this._cache = this._cache.removed(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._cache = this._cache.removed(key);\n    }\n  }\n\n  protected onReconcile(version: number): void {\n    this._state = void 0;\n  }\n\n  memoize(): MapOutlet<K, V, IO> {\n    return this;\n  }\n}\nMapOutlet.MemoizeMapCombinator = MemoizeMapCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInletMapOutlet} from \"../AbstractMapInletMapOutlet\";\n\nexport abstract class FilterFieldsOperator<K, V, I> extends AbstractMapInletMapOutlet<K, K, V, V, I, Map<K, V>> {\n  has(key: K): boolean {\n    if (this._input !== null) {\n      const value = this._input.get(key);\n      return value !== void 0 && this.evaluate(key, value);\n    }\n    return false;\n  }\n\n  get(): Map<K, V>;\n  get(key: K): V | undefined;\n  get(key?: K): Map<K, V> | V | undefined {\n    if (key === void 0) {\n      const output = new BTree<K, V>();\n      const keys = this.keyIterator();\n      do {\n        const next = keys.next();\n        if (!next.done) {\n          const key = next.value!;\n          const value = this._input!.get(key);\n          if (value !== void 0 && this.evaluate(key, value)) {\n            output.set(key, value);\n          }\n          continue;\n        }\n        break;\n      } while (true);\n      return output;\n    } else {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0 && this.evaluate(key, value)) {\n          return value;\n        }\n      }\n      return void 0;\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    if (this._input !== null) {\n      return this._input.keyIterator(); // TODO: filter keys\n    } else {\n      return Cursor.empty();\n    }\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    this.invalidateInputKey(key, effect);\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    this.reconcileInputKey(key, version);\n  }\n\n  protected willReconcileInputKey(key: K, effect: KeyEffect, version: number): KeyEffect {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value === void 0 || !this.evaluate(key, value)) {\n          return KeyEffect.Remove;\n        }\n      }\n    }\n    return effect;\n  }\n\n  abstract evaluate(key: K, value: V): boolean;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {FilterFieldsFunction} from \"../function\";\nimport {FilterFieldsOperator} from \"./FilterFieldsOperator\";\n\nexport class FilterFieldsCombinator<K, V, I> extends FilterFieldsOperator<K, V, I> {\n  /** @hidden */\n  protected readonly _func: FilterFieldsFunction<K, V>;\n\n  constructor(func: FilterFieldsFunction<K, V>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: V): boolean {\n    return this._func(key, value);\n  }\n}\nMapOutlet.FilterFieldsCombinator = FilterFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInoutlet} from \"../AbstractInoutlet\";\n\nexport abstract class MapValueOperator<I, O> extends AbstractInoutlet<I, O> {\n  get(): O | undefined {\n    if (this._input !== null) {\n      return this.evaluate(this._input.get());\n    } else {\n      return void 0;\n    }\n  }\n\n  abstract evaluate(value: I | undefined): O | undefined;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {MapValueFunction} from \"../function\";\nimport {MapValueOperator} from \"./MapValueOperator\";\n\nexport class MapValueCombinator<I, O> extends MapValueOperator<I, O> {\n  /** @hidden */\n  protected readonly _func: MapValueFunction<I, O>;\n\n  constructor(func: MapValueFunction<I, O>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(value: I | undefined): O | undefined {\n    if (value !== void 0) {\n      return this._func(value);\n    } else {\n      return void 0;\n    }\n  }\n}\nOutlet.MapValueCombinator = MapValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AbstractMapInoutlet} from \"../AbstractMapInoutlet\";\n\nexport abstract class MapFieldValuesOperator<K, VI, VO, I> extends AbstractMapInoutlet<K, VI, VO, I, Map<K, VO>> {\n  has(key: K): boolean {\n    if (this._input !== null) {\n      return this._input.has(key);\n    } else {\n      return false;\n    }\n  }\n\n  get(): Map<K, VO>;\n  get(key: K): VO | undefined;\n  get(key?: K): Map<K, VO> | VO | undefined {\n    if (key === void 0) {\n      const output = new BTree<K, VO>();\n      const keys = this.keyIterator();\n      do {\n        const next = keys.next();\n        if (!next.done) {\n          const key = next.value!;\n          const value = this.evaluate(key, this._input!.get(key));\n          if (value !== void 0) {\n            output.set(key, value);\n          }\n          continue;\n        }\n        break;\n      } while (true);\n      return output;\n    } else {\n      if (this._input !== null) {\n        return this.evaluate(key, this._input.get(key));\n      } else {\n        return void 0;\n      }\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    if (this._input !== null) {\n      return this._input.keyIterator(); // TODO: filter keys\n    } else {\n      return Cursor.empty();\n    }\n  }\n\n  abstract evaluate(key: K, value: VI | undefined): VO | undefined;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {MapFieldValuesFunction} from \"../function\";\nimport {MapFieldValuesOperator} from \"./MapFieldValuesOperator\";\n\nexport class MapFieldValuesCombinator<K, VI, VO, I> extends MapFieldValuesOperator<K, VI, VO, I> {\n  /** @hidden */\n  protected readonly _func: MapFieldValuesFunction<K, VI, VO>;\n\n  constructor(func: MapFieldValuesFunction<K, VI, VO> ) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: VI | undefined): VO | undefined {\n    if (value !== void 0) {\n      return this._func(key, value);\n    } else {\n      return void 0;\n    }\n  }\n}\nMapOutlet.MapFieldValuesCombinator = MapFieldValuesCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInletOutlet} from \"../AbstractMapInletOutlet\";\n\nexport abstract class ReduceFieldsOperator<K, V, I, O> extends AbstractMapInletOutlet<K, V, I, O> {\n  /** @hidden */\n  protected _state: BTree<K, V, O>;\n\n  constructor() {\n    super();\n    this._state = new BTree();\n  }\n\n  get(): O | undefined {\n    return this._state.reduced(this.identity(), this.accumulate.bind(this), this.combine.bind(this));\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._state.set(key, value);\n        } else {\n          this._state.delete(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._state.delete(key);\n    }\n  }\n\n  abstract identity(): O;\n\n  abstract accumulate(result: O, value: V): O;\n\n  abstract combine(result: O, value: O): O;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {ReduceFieldsOperator} from \"./ReduceFieldsOperator\";\n\nexport class ReduceFieldsCombinator<K, V, I, O> extends ReduceFieldsOperator<K, V, I, O> {\n  /** @hidden */\n  protected readonly _identity: O;\n  /** @hidden */\n  protected readonly _accumulator: (result: O, element: V) => O;\n  /** @hidden */\n  protected readonly _combiner: (result: O, result2: O) => O;\n\n  constructor(identity: O, accumulator: (result: O, element: V) => O,\n              combiner: (result: O, result2: O) => O) {\n    super();\n    this._identity = identity;\n    this._accumulator = accumulator;\n    this._combiner = combiner;\n  }\n\n  get(): O {\n    return this._state.reduced(this._identity, this._accumulator, this._combiner);\n  }\n\n  identity(): O {\n    return this._identity;\n  }\n\n  accumulate(result: O, value: V): O {\n    return this._accumulator(result, value);\n  }\n\n  combine(result: O, value: O): O {\n    return this._combiner(result, value);\n  }\n}\nMapOutlet.ReduceFieldsCombinator = ReduceFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInlet} from \"../AbstractInlet\";\n\nexport abstract class WatchValueOperator<I> extends AbstractInlet<I> {\n  onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      this.evaluate(this._input.get());\n    }\n  }\n\n  abstract evaluate(value: I | undefined): void;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {WatchValueFunction} from \"../function\";\nimport {WatchValueOperator} from \"./WatchValueOperator\";\n\nexport class WatchValueCombinator<I> extends WatchValueOperator<I> {\n  /** @hidden */\n  protected readonly _func: WatchValueFunction<I>;\n\n  constructor(func: WatchValueFunction<I>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(value: I | undefined): void {\n    if (value !== void 0) {\n      return this._func(value);\n    }\n  }\n}\nOutlet.WatchValueCombinator = WatchValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInlet} from \"../AbstractMapInlet\";\n\nexport abstract class WatchFieldsOperator<K, V, O> extends AbstractMapInlet<K, V, O> {\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        this.evaluate(key, this._input.get(key));\n      } else {\n        this.evaluate(key, void 0);\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this.evaluate(key, void 0);\n    }\n  }\n\n  abstract evaluate(key: K, value: V | undefined): void;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {WatchFieldsFunction} from \"../function\";\nimport {WatchFieldsOperator} from \"./WatchFieldsOperator\";\n\nexport class WatchFieldsCombinator<K, V, O> extends WatchFieldsOperator<K, V, O> {\n  /** @hidden */\n  protected readonly _func: WatchFieldsFunction<K, V>;\n\n  constructor(func: WatchFieldsFunction<K, V>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: V | undefined): void {\n    if (value !== void 0) {\n      return this._func(key, value);\n    }\n  }\n}\nMapOutlet.WatchFieldsCombinator = WatchFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractInlet} from \"./AbstractInlet\";\n\n/**\n * An `Inlet` that invalidates a parameterized `Streamlet` whenever the `Inlet`\n * is invalidated, and that updates the parameterized `Streamlet` whenever the\n * `Inlet` updates.\n */\nexport class StreamletInlet<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<I, unknown>;\n\n  constructor(streamlet: Streamlet<I, unknown>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<I, unknown> {\n    return this._streamlet;\n  }\n\n  protected willInvalidateOutput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.willInvalidateInlet) {\n      streamlet.willInvalidateInlet(this);\n    }\n  }\n\n  protected didInvalidateOutput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.didInvalidateInlet) {\n      streamlet.didInvalidateInlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willReconcileOutput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.willReconcileInlet) {\n      streamlet.willReconcileInlet(this, version);\n    }\n  }\n\n  protected didReconcileOutput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.didReconcileInlet) {\n      streamlet.didReconcileInlet(this, version);\n    } else {\n      streamlet.reconcile(version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\n/**\n * An `Outlet` that invalidates a parameterized `Streamlet` whenever the\n * `Outlet` is invalidated, and which gets its state from the parameterized\n * `Streamlet`.\n */\nexport class StreamletOutlet<O> extends AbstractOutlet<O> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<unknown, O>;\n\n  constructor(streamlet: Streamlet<unknown, O>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<unknown, O> {\n    return this._streamlet;\n  }\n\n  get(): O | undefined {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.getOutput) {\n      return streamlet.getOutput(this);\n    }\n    return void 0;\n  }\n\n  protected willInvalidateInput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.willInvalidateOutlet) {\n      streamlet.willInvalidateOutlet(this);\n    }\n  }\n\n  protected didInvalidateInput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.didInvalidateOutlet) {\n      streamlet.didInvalidateOutlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willReconcileInput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.willReconcileOutlet) {\n      streamlet.willReconcileOutlet(this, version);\n    }\n  }\n\n  protected didReconcileInput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.didReconcileOutlet) {\n      streamlet.didReconcileOutlet(this, version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractInoutlet} from \"./AbstractInoutlet\";\n\n/**\n * An `Inoutlet` that invalidates a parameterized `Streamlet` whenever the\n * `Inoutlet` is invalidated, that updates the parameterized `Streamlet`\n * whenever the `Inoutlet` updates, and which gets its state from the\n * parameterized `Streamlet`.\n */\nexport class StreamletInoutlet<I, O> extends AbstractInoutlet<I, O> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<I, O>;\n\n  constructor(streamlet: Streamlet<I, O>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<I, O> {\n    return this._streamlet;\n  }\n\n  get(): O | undefined {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.getOutput) {\n      const output = streamlet.getOutput(this);\n      if (output !== void 0) {\n        return output;\n      }\n    }\n    if (this._input !== null) {\n      return this._input.get() as O | undefined;\n    }\n    return void 0;\n  }\n\n  protected willInvalidate(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.willInvalidateOutlet) {\n      streamlet.willInvalidateOutlet(this);\n    }\n  }\n\n  protected didInvalidate(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.didInvalidateOutlet) {\n      streamlet.didInvalidateOutlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willUpdate(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.willReconcileOutlet) {\n      streamlet.willReconcileOutlet(this, version);\n    }\n  }\n\n  protected didUpdate(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.didReconcileOutlet) {\n      streamlet.didReconcileOutlet(this, version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InletType, InletOptions, Inlet} from \"./Inlet\";\nimport {OutletType, OutletOptions, Outlet} from \"./Outlet\";\nimport {InoutletType, InoutletOptions, Inoutlet} from \"./Inoutlet\";\nimport {StreamletContext} from \"./StreamletContext\";\nimport {StreamletScope} from \"./StreamletScope\";\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {StreamletInlet} from \"./StreamletInlet\";\nimport {StreamletOutlet} from \"./StreamletOutlet\";\nimport {StreamletInoutlet} from \"./StreamletInoutlet\";\n\n/** @hidden */\nexport class InletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: InletType;\n\n  constructor(key: string, name: string, type: InletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport class OutletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: OutletType;\n\n  constructor(key: string, name: string, type: OutletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport class InoutletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: InoutletType;\n\n  constructor(key: string, name: string, type: InoutletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport interface StreamletClass {\n  _inlets?: {[name: string]: InletDescriptor | InoutletDescriptor | undefined};\n  _outlets?: {[name: string]: OutletDescriptor | InoutletDescriptor | undefined};\n  _inoutlets?: {[name: string]: InoutletDescriptor | undefined};\n}\n\nexport abstract class AbstractStreamlet<I = unknown, O = I> implements GenericStreamlet<I, O> {\n  protected scope: StreamletScope<O> | null;\n  protected context: StreamletContext | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor(scope: StreamletScope<O> | null = null) {\n    this.scope = scope;\n    this._version = -1;\n  }\n\n  protected streamletClass(): StreamletClass {\n    return (this as any).__proto__ as StreamletClass;\n  }\n\n  streamletScope(): StreamletScope<O> | null {\n    return this.scope;\n  }\n\n  setStreamletScope(scope: StreamletScope<O> | null): void {\n    this.scope = scope;\n  }\n\n  streamletContext(): StreamletContext | null {\n    if (this.context) {\n      return this.context;\n    }\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  setStreamletContext(context: StreamletContext | null): void {\n    this.context = context;\n  }\n\n  inlet(key: string): Inlet<I> | null;\n  inlet<I2 extends I>(): Inlet<I2>;\n  inlet(key?: string): Inlet<I> | null {\n    if (key === void 0) {\n      return new StreamletInlet<I>(this);\n    } else {\n      return AbstractStreamlet.reflectInletKey<I, O>(key, this, this.streamletClass());\n    }\n  }\n\n  bindInput(key: string, input: Outlet<I>): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.bindInput(input);\n  }\n\n  unbindInput(key: string): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.unbindInput();\n  }\n\n  outlet(key: string | Outlet<O>): Outlet<O> | null;\n  outlet<O2>(): Outlet<O2>;\n  outlet(key?: string | Outlet<O>): Outlet<O> | null {\n    if (key === void 0) {\n      return new StreamletOutlet<O>(this);\n    } else if (typeof key === \"string\") {\n      return AbstractStreamlet.reflectOutletKey<I, O>(key, this, this.streamletClass());\n    } else {\n      return key;\n    }\n  }\n\n  inoutlet<I2 extends I, O2>(): Inoutlet<I2, O2> {\n    return new StreamletInoutlet<I2, O2>(this as Streamlet<I2, O2>);\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      this.onInvalidateOutlets();\n      this.didInvalidate();\n    }\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      this.onReconcileInlets(version);\n      this.onReconcile(version);\n      this.onReconcileOutlets(version);\n      this.didReconcile(version);\n    }\n  }\n\n  getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse?: E): I2 | E | undefined {\n    if (typeof inlet === \"string\") {\n      inlet = this.inlet(inlet) as Inlet<I2>;\n    }\n    let object: I2 | E | undefined;\n    if (inlet !== null) {\n      const input = inlet.input();\n      if (input !== null) {\n        object = input.get();\n      }\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  getOutput(outlet: Outlet<O> | string): O | undefined {\n    return void 0;\n  }\n\n  disconnectInputs(): void {\n    AbstractStreamlet.disconnectInputs(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static disconnectInputs<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          if (inletDescriptor instanceof InletDescriptor) {\n            const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n            inlet.disconnectInputs();\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n            inoutlet.disconnectInputs();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  disconnectOutputs(): void {\n    AbstractStreamlet.disconnectOutputs(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static disconnectOutputs<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.disconnectOutputs();\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.disconnectOutputs();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  willInvalidateInlet(inlet: Inlet<I>): void {\n    // stub\n  }\n\n  didInvalidateInlet(inlet: Inlet<I>): void {\n    this.invalidate();\n  }\n\n  willReconcileInlet(inlet: Inlet<I>, version: number): void {\n    // stub\n  }\n\n  didReconcileInlet(inlet: Inlet<I>, version: number): void {\n    this.reconcile(version);\n  }\n\n  willInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  didInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  willReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  didReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidateOutlets(): void {\n    AbstractStreamlet.invalidateOutlets(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static invalidateOutlets<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.invalidateInput();\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.invalidateInput();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInlets(version: number): void {\n    AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static reconcileInlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          if (inletDescriptor instanceof InletDescriptor) {\n            const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n            inlet.reconcileOutput(version);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n            inoutlet.reconcileOutput(version);\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutlets(version: number): void {\n    AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static reconcileOutlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.reconcileInput(version);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.reconcileInput(version);\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  /** @hidden */\n  static reflectEachInlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null,\n                                      callback: (this: S, inlet: Inlet<I>, name: string, index: number) => T | void,\n                                      thisArg?: S): T | undefined {\n    let index = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          let inlet: Inlet<I> | null;\n          if (inletDescriptor instanceof InletDescriptor) {\n            inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            inlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n          } else {\n            inlet = null;\n          }\n          const result = callback.call(thisArg, inlet, inletDescriptor.name, index);\n          if (result !== void 0) {\n            return result;\n          }\n          index += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return void 0;\n  }\n\n  /** @hidden */\n  static reflectEachOutlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null,\n                                       callback: (this: S, outlet: Outlet<O>, name: string, index: number) => T | void,\n                                       thisArg?: S): T | undefined {\n    let index = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          let outlet: Outlet<O> | null;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            outlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n          } else {\n            outlet = null;\n          }\n          const result = callback.call(thisArg, outlet, outletDescriptor.name, index);\n          if (result !== void 0) {\n            return result;\n          }\n          index += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return void 0;\n  }\n\n  /** @hidden */\n  static reflectInletCount(streamletClass: StreamletClass | null): number {\n    let count = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const _ in streamletClass._inlets) {\n          count += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return count;\n  }\n\n  /** @hidden */\n  static reflectOutletCount(streamletClass: StreamletClass | null): number {\n    let count = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const _ in streamletClass._outlets) {\n          count += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return count;\n  }\n\n  /** @hidden */\n  static reflectInletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): [string, Inlet<I>] | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          if (index === 0) {\n            const inletDescriptor = streamletClass._inlets[name]!;\n            if (inletDescriptor instanceof InletDescriptor) {\n              return [inletDescriptor.name, AbstractStreamlet.reflectInletField(streamlet, inletDescriptor)];\n            } else if (inletDescriptor instanceof InoutletDescriptor) {\n              return [inletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor)];\n            } else {\n              return null;\n            }\n          }\n          index -= 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectOutletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): [string, Outlet<O>] | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          if (index === 0) {\n            const outletDescriptor = streamletClass._outlets[name]!;\n            if (outletDescriptor instanceof OutletDescriptor) {\n              return [outletDescriptor.name, AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor)];\n            } else if (outletDescriptor instanceof InoutletDescriptor) {\n              return [outletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor)];\n            } else {\n              return null;\n            }\n          }\n          index -= 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectInletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): Inlet<I> | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        const inletDescriptor = streamletClass._inlets![key];\n        if (inletDescriptor !== void 0) {\n          if (inletDescriptor instanceof InletDescriptor) {\n            return AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            return AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n          } else {\n            return null;\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectOutletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): Outlet<O> | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        const outletDescriptor = streamletClass._outlets![key];\n        if (outletDescriptor !== void 0) {\n          if (outletDescriptor instanceof OutletDescriptor) {\n            return AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            return AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n          } else {\n            return null;\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectInletField<I, O>(streamlet: Streamlet<I, O>, inletDescriptor: InletDescriptor): Inlet<I> {\n    if (inletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueInletField(streamlet, inletDescriptor.key);\n    } else if (inletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapInletField(streamlet, inletDescriptor.key);\n    } else {\n      throw new TypeError(inletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I> {\n    let inlet = (streamlet as any)[key] as Inlet<I> | undefined;\n    if (!inlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        inlet = streamlet.inlet();\n      } else {\n        inlet = new StreamletInlet<I>(streamlet);\n      }\n      (streamlet as any)[key] = inlet;\n    }\n    return inlet;\n  }\n\n  /** @hidden */\n  static reflectMapInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static reflectOutletField<I, O>(streamlet: Streamlet<I, O>, outletDescriptor: OutletDescriptor): Outlet<O> {\n    if (outletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueOutletField(streamlet, outletDescriptor.key);\n    } else if (outletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapOutletField(streamlet, outletDescriptor.key);\n    } else {\n      throw new TypeError(outletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O> {\n    let outlet = (streamlet as any)[key] as Outlet<O> | undefined;\n    if (!outlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        outlet = streamlet.outlet();\n      } else {\n        outlet = new StreamletOutlet<O>(streamlet);\n      }\n      (streamlet as any)[key] = outlet;\n    }\n    return outlet;\n  }\n\n  /** @hidden */\n  static reflectMapOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static reflectInoutletField<I, O>(streamlet: Streamlet<I, O>, inoutletDescriptor: InoutletDescriptor): Inoutlet<I, O> {\n    if (inoutletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueInoutletField(streamlet, inoutletDescriptor.key);\n    } else if (inoutletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapInoutletField(streamlet, inoutletDescriptor.key);\n    } else {\n      throw new TypeError(inoutletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O> {\n    let inoutlet = (streamlet as any)[key] as Inoutlet<I, O> | undefined;\n    if (!inoutlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        inoutlet = streamlet.inoutlet();\n      } else {\n        inoutlet = new StreamletInoutlet<I, O>(streamlet);\n      }\n      (streamlet as any)[key] = inoutlet;\n    }\n    return inoutlet;\n  }\n\n  /** @hidden */\n  static reflectMapInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static init(streamletClass: StreamletClass): void {\n    if (!streamletClass.hasOwnProperty(\"_inlets\")) {\n      streamletClass._inlets = {};\n    }\n    if (!streamletClass.hasOwnProperty(\"_outlets\")) {\n      streamletClass._outlets = {};\n    }\n    if (!streamletClass.hasOwnProperty(\"_inoutlets\")) {\n      streamletClass._inoutlets = {};\n    }\n  }\n\n  /** @hidden */\n  static decorateInlet(options: InletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const inletDescriptor = new InletDescriptor(key, name, type);\n    target._inlets![name] = inletDescriptor;\n  }\n\n  /** @hidden */\n  static decorateOutlet(options: OutletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const outletDescriptor = new OutletDescriptor(key, name, type);\n    target._outlets![name] = outletDescriptor;\n  }\n\n  /** @hidden */\n  static decorateInoutlet(options: InoutletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const inoutletDescriptor = new InoutletDescriptor(key, name, type);\n    target._inlets![name] = inoutletDescriptor;\n    target._outlets![name] = inoutletDescriptor;\n    target._inoutlets![name] = inoutletDescriptor;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InletOptions} from \"./Inlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function In(name: string): PropertyDecorator;\nexport function In(options: InletOptions): PropertyDecorator;\nexport function In(target: unknown, key: string): void;\nexport function In(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as InletOptions;\n    }\n    return AbstractStreamlet.decorateInlet.bind(void 0, target as InletOptions);\n  } else {\n    AbstractStreamlet.decorateInlet({}, target as StreamletClass, key!);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InoutletOptions} from \"./Inoutlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function Inout(name: string): PropertyDecorator;\nexport function Inout(options: InoutletOptions): PropertyDecorator;\nexport function Inout(target: unknown, key: string): void;\nexport function Inout(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as InoutletOptions;\n    }\n    return AbstractStreamlet.decorateInoutlet.bind(void 0, target as InoutletOptions);\n  } else {\n    AbstractStreamlet.decorateInoutlet({}, target as StreamletClass, key!);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutletOptions} from \"./Outlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function Out(name: string): PropertyDecorator;\nexport function Out(options: OutletOptions): PropertyDecorator;\nexport function Out(target: unknown, key: string): void;\nexport function Out(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as OutletOptions;\n    }\n    return AbstractStreamlet.decorateOutlet.bind(void 0, target as OutletOptions);\n  } else {\n    AbstractStreamlet.decorateOutlet({}, target as StreamletClass, key!);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {StreamletContext} from \"./StreamletContext\";\nimport {StreamletScope} from \"./StreamletScope\";\n\n/**\n * Stateful node in a dataflow graph that uses the state of its [[Inlet\n * inlets]] to compute the state of its [[Outlet Outlets]].\n */\nexport interface Streamlet<I = unknown, O = I> extends StreamletScope<O> {\n  /**\n   * Returns the lexically scoped parent of this `Streamlet`.  Returns `null`\n   * if this `Streamlet` has no lexical parent.\n   */\n  streamletScope(): StreamletScope<O> | null;\n\n  /**\n   * Sets the lexically scoped parent of this `Streamlet`.\n   */\n  setStreamletScope(scope: StreamletScope<O> | null): void;\n\n  /**\n   * Returns the environment in which this `Streamlet` operates.\n   */\n  streamletContext(): StreamletContext | null;\n\n  /**\n   * Sets the environment in which this `Streamlet` operates.\n   */\n  setStreamletContext(context: StreamletContext | null): void;\n\n  /**\n   * Returns the `Inlet` to this `Streamlet` identified by the given `key`;\n   * returns `null` if this `Streamlet` has no such `Inlet`.\n   */\n  inlet(key: string): Inlet<I> | null;\n\n  /**\n   * Connects the `Inlet` of this `Streamlet`, identified by the given `key` to\n   * the `input` from which the `Inlet` should acquire its state.  Delegates to\n   * [[Inlet.bindInput]] on the identified `Inlet`.\n   *\n   * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.\n   */\n  bindInput(key: string, input: Outlet<I>): void;\n\n  /**\n   * Disconnects the `Inlet` of this `Streamlet`, identified by the given\n   * `key`, from its [[Inlet.input input]] `Outlet`, if connected.  Delegates\n   * to [[Inlet.unbindInput]] on the identified `Inlet`.\n   *\n   * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.\n   */\n  unbindInput(key: string): void;\n\n  /**\n   * Returns the `Outlet` of this `Streamlet` identified by the given `key`;\n   * returns `null` if this `Streamlet` has no such `Outlet`.\n   */\n  outlet(key: string): Outlet<O> | null;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Streamlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * terminating at this `Streamlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Disconnects all `Inlets`s dominated by this `Streamlet` in the dataflow\n   * graph.  Used to recursively clean up chains of combinators originating\n   * from this `Streamlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Marks this `Streamlet`—and all of its outlets—as having stale state.\n   * Invalidating a `Streamlet` will recursively invalidate all streamlets\n   * that transitively depend on the state of this `Streamlet`.  Invalidating\n   * a `Streamlet` does not cause its state to be recomputed.  A subsequent\n   * [[reconcile]] call will reconcile the state of the `Streamlet`.\n   */\n  invalidate(): void;\n\n  /**\n   * Reconciles the state of this `Streamlet`, if the version of this\n   * `Streamlet`'s state differs from the target `version`.  To reconcile its\n   * state, the `Streamlet` first invokes [[Inlet.reconcileOutput]] on each of\n   * its inlets, to ensure that its input states are up-to-date.  It then\n   * recomputes its own state, in an implementation defined manner.  Finally,\n   * it invokes [[Outlet.reconcileInput]] on its outlets, causing all\n   * transitively dependent streamlets to reconcile their own state.\n   */\n  reconcile(version: number): void;\n}\n\n/** @hidden */\nexport const Streamlet = {\n  is<I, O>(object: unknown): object is Streamlet<I, O> {\n    if (typeof object === \"object\" && object) {\n      const streamlet = object as Streamlet<I, O>;\n      return typeof streamlet.streamletScope === \"function\"\n          && typeof streamlet.setStreamletScope === \"function\"\n          && typeof streamlet.streamletContext === \"function\"\n          && typeof streamlet.setStreamletContext === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\n\nimport {StreamletContext} from \"./StreamletContext\";\n\nexport interface StreamletScope<O> {\n  /**\n   * Returns the lexically scoped parent of this `StreamletScope`.\n   * Returns `null` if this `StreamletScope` has no lexical parent.\n   */\n  streamletScope(): StreamletScope<O> | null;\n\n  /**\n   * Returns the environment in which this `StreamletScope` operates.\n   */\n  streamletContext(): StreamletContext | null;\n\n  /**\n   * Returns an `Outlet` that updates when the specified `key` updates.\n   */\n  outlet(key: string): Outlet<O> | null;\n}\n\n/** @hidden */\nexport const StreamletScope = {\n  is<O>(object: unknown): object is StreamletScope<O> {\n    if (typeof object === \"object\" && object) {\n      const scope = object as StreamletScope<O>;\n      return typeof scope.streamletScope === \"function\"\n          && typeof scope.streamletContext === \"function\"\n          && typeof scope.outlet === \"function\";\n    }\n    return false;\n  },\n};\n"]}