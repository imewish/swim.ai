{"version":3,"file":"swim-streamlet.js","sources":["../../main/Inlet.ts","../../main/Outlet.ts","../../main/KeyEffect.ts","../../main/MapInlet.ts","../../main/MapOutlet.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/StreamletException.ts","../../main/StreamletScope.ts","../../main/Streamlet.ts","../../main/AbstractInlet.ts","../../main/AbstractOutlet.ts","../../main/AbstractInoutlet.ts","../../main/KeyOutlet.ts","../../main/AbstractMapInlet.ts","../../main/AbstractMapOutlet.ts","../../main/AbstractMapInoutlet.ts","../../main/AbstractMapInletOutlet.ts","../../main/AbstractMapInletMapOutlet.ts","../../main/OutletInlet.ts","../../main/OutletMapInlet.ts","../../main/ValueInput.ts","../../main/ValueOutput.ts","../../main/MapInput.ts","../../main/MapOutput.ts","../../main/combinator/MemoizeValueCombinator.ts","../../main/combinator/MemoizeMapCombinator.ts","../../main/combinator/FilterFieldsOperator.ts","../../main/combinator/FilterFieldsCombinator.ts","../../main/combinator/MapValueOperator.ts","../../main/combinator/MapValueCombinator.ts","../../main/combinator/MapFieldValuesOperator.ts","../../main/combinator/MapFieldValuesCombinator.ts","../../main/combinator/ReduceFieldsOperator.ts","../../main/combinator/ReduceFieldsCombinator.ts","../../main/combinator/WatchValueOperator.ts","../../main/combinator/WatchValueCombinator.ts","../../main/combinator/WatchFieldsOperator.ts","../../main/combinator/WatchFieldsCombinator.ts","../../main/StreamletInlet.ts","../../main/StreamletOutlet.ts","../../main/StreamletInoutlet.ts","../../main/AbstractStreamlet.ts","../../main/In.ts","../../main/Out.ts","../../main/Inout.ts"],"sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\n\nexport type InletType = \"value\" | \"map\";\n\nexport interface InletOptions {\n  name?: string;\n  type?: InletType;\n}\n\n/**\n * Input connector into a [[Streamlet]].  An `Inlet` represents a source from\n * which a `Streamlet` acquires state.\n *\n * In order for an `Inlet` to provide state to its `Streamlet`, it must bind to\n * an [[input]] source.  The input source of an `Inlet` is an [[Outlet]] of\n * some other `Streamlet`.  The [[bindInput]] method \"plugs\" the `Inlet` into\n * an `Outlet`.  The [[unbindInput]] method \"unplugs\" the `Inlet` from its\n * connected `Outlet`.\n *\n * The state of an `Inlet` has an integral _version_.  When its version is\n * negative, the state of the `Inlet` is considered _invalid_.  When any state\n * on which an `Inlet` transitively depends changes, the `Inlet` will be\n * [[invalidatOutput invalidated]].  Invalidation does not immediately cause an\n * `Inlet` to recompute its state.  Instead, a separate [[reconcileOutput\n * reconcile]] step causes all of the invalid paths in the dataflow graph\n * passing through the `Inlet` to reconcile their state.\n */\nexport interface Inlet<I = unknown> {\n  /**\n   * Returns the `Outlet` from which this `Inlet` acquires its state; returns\n   * `null` if this `Inlet` is disconnected.\n   */\n  input(): Outlet<I> | null;\n\n  /**\n   * Connects this `Inlet` to an `Outlet` from which it will  acquire its\n   * state.  If this `Inlet` is already connected, it will first disconnect\n   * from its existing input.  Then, after updating its [[input]] property,\n   * the `Inlet` will invoke [[Outlet.bindOutput]] on its new `input`.\n   */\n  bindInput(input: Outlet<I> | null): void;\n\n  /**\n   * Disconnects this `Inlet` from its input `Outlet`, if connected.  After\n   * setting its [[input]] property to `null`, the `Inlet` will invoke\n   * [[Outlet.unbindOutput]] on its old input, if defined.\n   */\n  unbindInput(): void;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Inlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * terminating at this `Inlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Disconnects all `Outlet`s dominated by this `Inlet` in the dataflow graph.\n   * Used to recursively clean up chains of combinators passing through this\n   * `Inlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Marks this `Inlet`—and the `Streamlet` to which this `Inlet` is attached—as\n   * having stale state.  Invalidating an `Inlet` will recursively invalidate\n   * all streamlets that transitively depend on the state of this `Inlet`.\n   * Invalidating an `Inlet` does not cause its state to be recomputed.  A\n   * subsequent [[reconcileOutput]] call will reconcile the state of the `Inlet`.\n   */\n  invalidateOutput(): void;\n\n  /**\n   * Reconciles the state of this `Inlet`, if the version of this `Inlet`'s\n   * state differs from the target `version`.  To reconcile its state, the\n   * `Inlet` first invokes [[Outlet.reconcileInput]] on its [[input]], to\n   * ensure that its input is up-to-date.  It then invokes\n   * [[Streamlet.reconcile]] on the `Streamlet` to which it's attached,\n   * causing the `Streamlet` to reconcile its own state.\n   */\n  reconcileOutput(version: number): void;\n}\n\n/** @hidden */\nexport const Inlet = {\n  is<I>(object: unknown): object is Inlet<I> {\n    if (typeof object === \"object\" && object) {\n      const inlet = object as Inlet<I>;\n      return typeof inlet.input === \"function\"\n          && typeof inlet.bindInput === \"function\"\n          && typeof inlet.unbindInput === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\nimport {MemoizeValueCombinator} from \"./combinator/MemoizeValueCombinator\";\nimport {MapValueCombinator} from \"./combinator/MapValueCombinator\";\nimport {WatchValueCombinator} from \"./combinator/WatchValueCombinator\";\n\nexport type OutletType = \"value\" | \"map\";\n\nexport interface OutletOptions {\n  name?: string;\n  type?: OutletType;\n}\n\n/**\n * Output connector from a [[Streamlet]].  An `Outlet` represents a sink to\n * which a `Streamlet` provides state.\n *\n * An `Outlet` has a one-to-many relationship with a set of output sinks.\n * An output sink of an `Outlet` is an `Inlet` of some other `Streamlet`.\n * The [[bindOutput]] method \"plugs\" an `Inlet` into the `Outlet`.\n * The [[unbindOutput]] method \"unplugs\" an `Inlet` from the `Outlet`.\n */\nexport interface Outlet<O = unknown> {\n  /**\n   * Returns the current state of this `Outlet`.\n   */\n  get(): O | undefined;\n\n  /**\n   * Returns an `Iterator` over the set of `Inlet`s that depend on the state of\n   * this `Outlet`.\n   */\n  outputIterator(): Iterator<Inlet<O>>;\n\n  /**\n   * Adds an `output` to the set of `Inlet`s that depend on the state of this\n   * `Outlet`.  The `output` will be invalidated when the state of this\n   * `Outlet` is invalidated, and updated when this `Outlet` is updated.\n   */\n  bindOutput(output: Inlet<O>): void;\n\n  /**\n   * Removes an `output` from the set of `Inlet`s that depend on the state of\n   * this `Outlet`.\n   */\n  unbindOutput(output: Inlet<O>): void;\n\n  /**\n   * Disconnects all outputs from this `Outlet` by invoking\n   * [[Inlet.unbindInput]] on each `Inelt` that depends on the state of this\n   * `Outlet`.\n   */\n  unbindOutputs(): void;\n\n  /**\n   * Disconnects all `Outlet`s dominated by this `Outlet` in the dataflow\n   * graph.  Used to recursively clean up chains of combinators originating\n   * from this `Inlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Outlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * passing through this `Outlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Marks this `Outlet`—and all [[outputIterator outputs]] that depend on the\n   * state of this `Outlet`—as having stale state.\n   */\n  invalidateInput(): void;\n\n  /**\n   * Reconciles the state of this `Outlet`, if the version of this `Outlet`'s\n   * state differs from the target `version`.  To reconcile its state, the\n   * `Outlet` first invokes [[Streamlet.reconcile]] on the `Streamlet` to which\n   * it's attached. It then invokes [[Inlet.reconcileOutput]] on each of its\n   * dependent [[outputIterator outputs]].\n   */\n  reconcileInput(version: number): void;\n\n  memoize(): Outlet<O>;\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n\n  watch(func: WatchValueFunction<O>): this;\n}\n\n/** @hidden */\nexport const Outlet = {\n  is<O>(object: unknown): object is Outlet<O> {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as Outlet<O>;\n      return typeof outlet.outputIterator === \"function\"\n          && typeof outlet.bindOutput === \"function\"\n          && typeof outlet.unbindOutput === \"function\";\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  MemoizeValueCombinator: void 0 as unknown as typeof MemoizeValueCombinator, // defined by MemoizeValueCombinator\n  /** @hidden */\n  MapValueCombinator: void 0 as unknown as typeof MapValueCombinator, // defined by MapValueCombinator\n  /** @hidden */\n  WatchValueCombinator: void 0 as unknown as typeof WatchValueCombinator, // defined by WatchValueCombinator\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport const enum KeyEffect {\n  Update,\n  Remove,\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {KeyEffect} from \"./KeyEffect\";\n\n/**\n * Input connector into a `Streamlet` for a key-value map state.\n */\nexport interface MapInlet<K, V, I> extends Inlet<I> {\n  /**\n   * Marks this `MapInlet` as needing an `effect` applied to a given `key`.\n   * Invalidating an individual key invalidates the entire state of the `Inlet`.\n   * But only the invalidated keys need to be updated in order to reconcile the\n   * overall state of the `Inlet`.\n   */\n  invalidateOutputKey(key: K, effect: KeyEffect): void;\n\n  /**\n   * Reconciles the state of an individual `key` in this `MapInlet`, if the\n   * version of this `MapInlet`'s state differs from the target `version`.\n   * To reconcile the state of a key, the `MapInlet` first invokes\n   * [[MapOutlet.reconcileInputKey]] on its [[input]], if its input is a\n   * `MapOutlet`, or it invokes [[Outlet.reconcileInput]], if its input is not\n   * a `MapOutlet`.  Then, if all invalid keys have been reconciled, the\n   * `MapInlet` invokes [[Streamletreconcile]] on its attached streamlet.\n   */\n  reconcileOutputKey(key: K, version: number): void;\n}\n\n/** @hidden */\nexport const MapInlet = {\n  is<K, V, I>(object: unknown): object is MapInlet<K, V, I> {\n    if (typeof object === \"object\" && object) {\n      const inlet = object as MapInlet<K, V, I>;\n      return Inlet.is(inlet)\n          && typeof inlet.invalidateOutputKey === \"function\"\n          && typeof inlet.reconcileOutputKey === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Map} from \"@swim/util\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\nimport {MemoizeMapCombinator} from \"./combinator/MemoizeMapCombinator\";\nimport {FilterFieldsCombinator} from \"./combinator/FilterFieldsCombinator\";\nimport {MapFieldValuesCombinator} from \"./combinator/MapFieldValuesCombinator\";\nimport {ReduceFieldsCombinator} from \"./combinator/ReduceFieldsCombinator\";\nimport {WatchFieldsCombinator} from \"./combinator/WatchFieldsCombinator\";\n\n/**\n * Output connector from a [[Streamlet]] for a key-value map state.\n */\nexport interface MapOutlet<K, V, O> extends Outlet<O> {\n  /**\n   * Returns `true` if the current state of this `MapOutlet` contains the given\n   * `key`; otherwise returns `false`.\n   */\n  has(key: K): boolean;\n\n  /**\n   * Returns the current state of this `Outlet`.\n   */\n  get(): O | undefined;\n\n  /**\n   * Returns the value assocaited with the given `key` in the current state of\n   * this `MapOutlet`, if defined; otherwise returns `undefined`.\n   */\n  get(key: K): V | undefined;\n\n  /**\n   * Returns an `Iterator` over the keys in the current state of this `MapOutlet`.\n   */\n  keyIterator(): Iterator<K>;\n\n  /**\n   * Returns an `Outlet` that updates when the specified `key` updates.\n   */\n  outlet(key: K): Outlet<V>;\n\n  /**\n   * Marks this `MapOutlet` as needing an `effect` applied to a given `key`.\n   * Invalidating an individual key invalidates the entire state of the\n   * `Outlet`.  But only the invalidated keys need to be updated in order to\n   * reconcile the overall state of the `Outlet`.\n   */\n  invalidateInputKey(key: K, effect: KeyEffect): void;\n\n  /**\n   * Reconciles the state of an individual `key` in this `MapOutlet`, if the\n   * version of this `MapOutlet`'s state differs from the target `version`.\n   * To reconcile the state of a key, the `MapOutlet` first invokes\n   * [[Streamlet.reconcile]] on its attached streamlets.  Then, for each\n   * dependent output, it invokes [[MapInlet.reconcileOutputKey]], if the\n   * dependent output is a [[MapInlet]], or it invokes [[Inlet.reconcile]],\n   * if the dependent output is not a `MapInlet`.\n   */\n  reconcileInputKey(key: K, version: number): void;\n\n  memoize(): MapOutlet<K, V, O>;\n\n  filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>>;\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;\n\n  reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, V>): this;\n}\n\n/** @hidden */\nexport const MapOutlet = {\n  is<K, V, I>(object: unknown): object is MapOutlet<K, V, I> {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as MapOutlet<K, V, I>;\n      return Outlet.is(outlet)\n          && typeof outlet.keyIterator === \"function\"\n          && typeof outlet.outlet === \"function\";\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  MemoizeMapCombinator: void 0 as unknown as typeof MemoizeMapCombinator, // defined by MemoizeMapCombinator\n  /** @hidden */\n  FilterFieldsCombinator: void 0 as unknown as typeof FilterFieldsCombinator, // defined by FilterFieldsCombinator\n  /** @hidden */\n  MapFieldValuesCombinator: void 0 as unknown as typeof MapFieldValuesCombinator, // defined by MapFieldValuesCombinator\n  /** @hidden */\n  ReduceFieldsCombinator: void 0 as unknown as typeof ReduceFieldsCombinator, // defined by ReduceFieldsCombinator\n  /** @hidden */\n  WatchFieldsCombinator: void 0 as unknown as typeof WatchFieldsCombinator, // defined by WatchFieldsCombinator\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport class StreamletException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = StreamletException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\n\nimport {StreamletContext} from \"./StreamletContext\";\n\nexport interface StreamletScope<O> {\n  /**\n   * Returns the lexically scoped parent of this `StreamletScope`.\n   * Returns `null` if this `StreamletScope` has no lexical parent.\n   */\n  streamletScope(): StreamletScope<O> | null;\n\n  /**\n   * Returns the environment in which this `StreamletScope` operates.\n   */\n  streamletContext(): StreamletContext | null;\n\n  /**\n   * Returns an `Outlet` that updates when the specified `key` updates.\n   */\n  outlet(key: string): Outlet<O> | null;\n}\n\n/** @hidden */\nexport const StreamletScope = {\n  is<O>(object: unknown): object is StreamletScope<O> {\n    if (typeof object === \"object\" && object) {\n      const scope = object as StreamletScope<O>;\n      return typeof scope.streamletScope === \"function\"\n          && typeof scope.streamletContext === \"function\"\n          && typeof scope.outlet === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {StreamletContext} from \"./StreamletContext\";\nimport {StreamletScope} from \"./StreamletScope\";\n\n/**\n * Stateful node in a dataflow graph that uses the state of its [[Inlet\n * inlets]] to compute the state of its [[Outlet Outlets]].\n */\nexport interface Streamlet<I = unknown, O = I> extends StreamletScope<O> {\n  /**\n   * Returns the lexically scoped parent of this `Streamlet`.  Returns `null`\n   * if this `Streamlet` has no lexical parent.\n   */\n  streamletScope(): StreamletScope<O> | null;\n\n  /**\n   * Sets the lexically scoped parent of this `Streamlet`.\n   */\n  setStreamletScope(scope: StreamletScope<O> | null): void;\n\n  /**\n   * Returns the environment in which this `Streamlet` operates.\n   */\n  streamletContext(): StreamletContext | null;\n\n  /**\n   * Sets the environment in which this `Streamlet` operates.\n   */\n  setStreamletContext(context: StreamletContext | null): void;\n\n  /**\n   * Returns the `Inlet` to this `Streamlet` identified by the given `key`;\n   * returns `null` if this `Streamlet` has no such `Inlet`.\n   */\n  inlet(key: string): Inlet<I> | null;\n\n  /**\n   * Connects the `Inlet` of this `Streamlet`, identified by the given `key` to\n   * the `input` from which the `Inlet` should acquire its state.  Delegates to\n   * [[Inlet.bindInput]] on the identified `Inlet`.\n   *\n   * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.\n   */\n  bindInput(key: string, input: Outlet<I>): void;\n\n  /**\n   * Disconnects the `Inlet` of this `Streamlet`, identified by the given\n   * `key`, from its [[Inlet.input input]] `Outlet`, if connected.  Delegates\n   * to [[Inlet.unbindInput]] on the identified `Inlet`.\n   *\n   * @throws `Error` if this `Streamlet` has no `Inlet` with the given `key`.\n   */\n  unbindInput(key: string): void;\n\n  /**\n   * Returns the `Outlet` of this `Streamlet` identified by the given `key`;\n   * returns `null` if this `Streamlet` has no such `Outlet`.\n   */\n  outlet(key: string): Outlet<O> | null;\n\n  /**\n   * Disconnects all `Inlet`s dominated by this `Streamlet` in the dataflow\n   * dependency graph.  Used to recursively clean up chains of combinators\n   * terminating at this `Streamlet`.\n   */\n  disconnectInputs(): void;\n\n  /**\n   * Disconnects all `Inlets`s dominated by this `Streamlet` in the dataflow\n   * graph.  Used to recursively clean up chains of combinators originating\n   * from this `Streamlet`.\n   */\n  disconnectOutputs(): void;\n\n  /**\n   * Marks this `Streamlet`—and all of its outlets—as having stale state.\n   * Invalidating a `Streamlet` will recursively invalidate all streamlets\n   * that transitively depend on the state of this `Streamlet`.  Invalidating\n   * a `Streamlet` does not cause its state to be recomputed.  A subsequent\n   * [[reconcile]] call will reconcile the state of the `Streamlet`.\n   */\n  invalidate(): void;\n\n  /**\n   * Reconciles the state of this `Streamlet`, if the version of this\n   * `Streamlet`'s state differs from the target `version`.  To reconcile its\n   * state, the `Streamlet` first invokes [[Inlet.reconcileOutput]] on each of\n   * its inlets, to ensure that its input states are up-to-date.  It then\n   * recomputes its own state, in an implementation defined manner.  Finally,\n   * it invokes [[Outlet.reconcileInput]] on its outlets, causing all\n   * transitively dependent streamlets to reconcile their own state.\n   */\n  reconcile(version: number): void;\n}\n\n/** @hidden */\nexport const Streamlet = {\n  is<I, O>(object: unknown): object is Streamlet<I, O> {\n    if (typeof object === \"object\" && object) {\n      const streamlet = object as Streamlet<I, O>;\n      return typeof streamlet.streamletScope === \"function\"\n          && typeof streamlet.setStreamletScope === \"function\"\n          && typeof streamlet.streamletContext === \"function\"\n          && typeof streamlet.setStreamletContext === \"function\";\n    }\n    return false;\n  },\n};\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\n\nexport abstract class AbstractInlet<I> implements Inlet<I> {\n  /** @hidden */\n  protected _input: Outlet<I> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._version = -1;\n  }\n\n  input(): Outlet<I> | null {\n    return this._input;\n  }\n\n  bindInput(input: Outlet<I> | null): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    const input = this._input;\n    if (input !== null) {\n      input.unbindOutput(this);\n      this._input = null;\n      input.disconnectInputs();\n    }\n  }\n\n  disconnectOutputs(): void {\n    // nop\n  }\n\n  invalidateOutput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateOutput();\n      this._version = -1;\n      this.onInvalidateOutput();\n      this.didInvalidateOutput();\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileOutput(version);\n      this._version = version;\n      if (this._input !== null) {\n        this._input.reconcileInput(version);\n      }\n      this.onReconcileOutput(version);\n      this.didReconcileOutput(version);\n    }\n  }\n\n  protected willInvalidateOutput(): void {\n    // stub\n  }\n\n  protected onInvalidateOutput(): void {\n    // stub\n  }\n\n  protected didInvalidateOutput(): void {\n    // stub\n  }\n\n  protected willReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutput(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractOutlet<O> implements Outlet<O> {\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  outputIterator(): Cursor<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    for (let i = 0, n = oldOutputs !== null ? oldOutputs.length : 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor} from \"@swim/util\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {Inoutlet} from \"./Inoutlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractInoutlet<I, O> implements Inoutlet<I, O> {\n  /** @hidden */\n  protected _input: Outlet<I> | null;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  input(): Outlet<I> | null {\n    return this._input;\n  }\n\n  bindInput(input: Outlet<I> | null): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      if (this._input !== null) {\n        this._input.reconcileInput(version);\n      }\n      this.onReconcile(version);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"./MapOutlet\";\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\nexport class KeyOutlet<K, V> extends AbstractOutlet<V> {\n  /** @hidden */\n  protected readonly _input: MapOutlet<K, V, unknown>;\n  /** @hidden */\n  protected readonly _key: K;\n\n  constructor(input: MapOutlet<K, V, unknown>, key: K) {\n    super();\n    this._input = input;\n    this._key = key;\n  }\n\n  input(): MapOutlet<K, V, unknown> {\n    return this._input;\n  }\n\n  key(): K {\n    return this._key;\n  }\n\n  get(): V | undefined {\n    return this._input.get(this._key);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\n\nexport abstract class AbstractMapInlet<K, V, O> implements MapInlet<K, V, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, V, O> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._version = -1;\n  }\n\n  input(): MapOutlet<K, V, O> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, V, O> | null): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input != null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    const input = this._input;\n    if (input !== null) {\n      input.unbindOutput(this);\n      this._input = null;\n      input.disconnectInputs();\n    }\n  }\n\n  disconnectOutputs(): void {\n    // nop\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateOutput();\n      this._version = -1;\n      this.onInvalidateOutput();\n      this.didInvalidateOutput();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileOutput(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileOutput(version);\n      this.didReconcileOutput(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateOutput(): void {\n    // stub\n  }\n\n  protected onInvalidateOutput(): void {\n    // stub\n  }\n\n  protected didInvalidateOutput(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutput(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapOutlet<K, V, O> implements MapOutlet<K, V, O> {\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<K, KeyOutlet<K, V>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: K): boolean;\n\n  abstract get(): O | undefined;\n\n  abstract get(key: K): V | undefined;\n\n  abstract keyIterator(): Iterator<K>;\n\n  outlet(key: K): Outlet<V> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<K, V>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, V>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, V>) {\n        keyOutlet.disconnectOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: K, outlet: KeyOutlet<K, V>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileInputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        this.onReconcileInputKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<K, V, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<K, V, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<K, V, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<K, V, V2>): Outlet<V2> | MapOutlet<K, V2, Map<K, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<K, V, V2, O>(func as MapFieldValuesFunction<K, V, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<K, V, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, V>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<K, V>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<K, V, O>(func as WatchFieldsFunction<K, V>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {MapInoutlet} from \"./MapInoutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapInoutlet<K, VI, VO, I, O> implements MapInoutlet<K, VI, VO, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, VI, I> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<K, KeyOutlet<K, VO>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: K): boolean;\n\n  abstract get(): O | undefined;\n\n  abstract get(key: K): VO | undefined;\n\n  abstract keyIterator(): Iterator<K>;\n\n  input(): MapOutlet<K, VI, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, VI, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null && this._outlets.isEmpty()) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outlet(key: K): Outlet<VO> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<K, VO>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, VO>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outlets = this._outlets;\n      if (outlets.isEmpty()) {\n        this._outlets = new BTree();\n        outlets.forEach(function (key: K, keyOutlet: KeyOutlet<K, VO>) {\n          keyOutlet.disconnectOutputs();\n        }, this);\n      }\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    this.invalidateKey(key, effect);\n  }\n\n  invalidateInputKey(key: K, effect: KeyEffect): void {\n    this.invalidateKey(key, effect);\n  }\n\n  invalidateKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: K, outlet: KeyOutlet<K, VO>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    this.reconcileKey(key, version);\n  }\n\n  reconcileInputKey(key: K, version: number): void {\n    this.reconcileKey(key, version);\n  }\n\n  reconcileKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<K, VO, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<K, VO, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<K, VO>): MapOutlet<K, VO, Map<K, VO>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<K, VO, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<K, VO, V2>): MapOutlet<K, V2, Map<K, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<K, VO, V2>): Outlet<V2> | MapOutlet<K, V2, Map<K, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<K, VO, V2, O>(func as MapFieldValuesFunction<K, VO, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: VO) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<K, VO, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<K, VO>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<K, VO>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<K, VO, O>(func as WatchFieldsFunction<K, VO>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {MapInletOutlet} from \"./MapInletOutlet\";\nimport {MapValueFunction, WatchValueFunction} from \"./function\";\n\nexport abstract class AbstractMapInletOutlet<K, V, I, O> implements MapInletOutlet<K, V, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<K, V, I> | null;\n  /** @hidden */\n  protected _effects: BTree<K, KeyEffect>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._effects = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract get(): O | undefined;\n\n  input(): MapOutlet<K, V, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<K, V, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n\n  invalidateOutputKey(key: K, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        output.invalidateOutput();\n      }\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: K, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._effects.forEach(function (key: K): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): Outlet<O> {\n    const combinator = new Outlet.MemoizeValueCombinator<O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2> {\n    const combinator = new Outlet.MapValueCombinator<O, O2>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this {\n    const combinator = new Outlet.WatchValueCombinator<O>(func);\n    combinator.bindInput(this);\n    return this;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {Inlet} from \"./Inlet\";\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {MapInlet} from \"./MapInlet\";\nimport {MapOutlet} from \"./MapOutlet\";\nimport {KeyOutlet} from \"./KeyOutlet\";\nimport {FilterFieldsFunction} from \"./function\";\nimport {MapInletMapOutlet} from \"./MapInletMapOutlet\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"./function\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"./function\";\n\nexport abstract class AbstractMapInletMapOutlet<KI, KO, VI, VO, I, O> implements MapInletMapOutlet<KI, KO, VI, VO, I, O> {\n  /** @hidden */\n  protected _input: MapOutlet<KI, VI, I> | null;\n  /** @hidden */\n  protected _outputEffects: BTree<KI, KeyEffect>;\n  /** @hidden */\n  protected _inputEffects: BTree<KO, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<KO, KeyOutlet<KO, VO>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<O>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    this._input = null;\n    this._outputEffects = new BTree();\n    this._inputEffects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  abstract has(key: KO): boolean;\n\n  abstract get(): O;\n\n  abstract get(key: KO): VO | undefined;\n\n  abstract keyIterator(): Iterator<KO>;\n\n  input(): MapOutlet<KI, VI, I> | null {\n    return this._input;\n  }\n\n  bindInput(input: MapOutlet<KI, VI, I>): void {\n    if (!MapOutlet.is(input)) {\n      throw new TypeError(\"\" + input);\n    }\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = input;\n    if (this._input !== null) {\n      this._input.bindOutput(this);\n    }\n  }\n\n  unbindInput(): void {\n    if (this._input !== null) {\n      this._input.unbindOutput(this);\n    }\n    this._input = null;\n  }\n\n  disconnectInputs(): void {\n    if (this._outputs === null && this._outlets.isEmpty()) {\n      const input = this._input;\n      if (input !== null) {\n        input.unbindOutput(this);\n        this._input = null;\n        input.disconnectInputs();\n      }\n    }\n  }\n\n  outlet(key: KO): Outlet<VO> {\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<KO, VO>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Iterator<Inlet<O>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<O>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<O>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<O>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: KO, keyOutlet: KeyOutlet<KO, VO>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    if (this._input === null) {\n      const outlets = this._outlets;\n      if (outlets.isEmpty()) {\n        this._outlets = new BTree();\n        outlets.forEach(function (key: KO, keyOutlet: KeyOutlet<KO, VO>) {\n          keyOutlet.disconnectOutputs();\n        }, this);\n      }\n      const outputs = this._outputs;\n      if (outputs !== null) {\n        this._outputs = null;\n        for (let i = 0, n = outputs.length; i < n; i += 1) {\n          const output = outputs[i];\n          output.unbindInput();\n          output.disconnectOutputs();\n        }\n      }\n    }\n  }\n  invalidateOutputKey(key: KI, effect: KeyEffect): void {\n    const oldOutputEffects = this._outputEffects;\n    if (oldOutputEffects.get(key) !== effect) {\n      this.willInvalidateOutputKey(key, effect);\n      this._outputEffects = oldOutputEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateOutputKey(key, effect);\n      this.didInvalidateOutputKey(key, effect);\n    }\n  }\n\n  invalidateInputKey(key: KO, effect: KeyEffect): void {\n    const oldInputEffects = this._inputEffects;\n    if (oldInputEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._inputEffects = oldInputEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateOutput(): void {\n    this.invalidate();\n  }\n\n  invalidateInput(): void {\n    this.invalidate();\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: KO, outlet: KeyOutlet<KO, VO>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidate();\n    }\n  }\n\n  reconcileOutputKey(key: KI, version: number): void {\n    if (this._version < 0) {\n      const oldOutputEffects = this._outputEffects;\n      const effect = oldOutputEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileOutputKey(key, effect, version);\n        this._outputEffects = oldOutputEffects.removed(key);\n        if (this._input !== null) {\n          this._input.reconcileInputKey(key, version);\n        }\n        this.onReconcileOutputKey(key, effect, version);\n        this.didReconcileOutputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInputKey(key: KO, version: number): void {\n    if (this._version < 0) {\n      const oldInputEffects = this._inputEffects;\n      const oldEffect = oldInputEffects.get(key);\n      if (oldEffect !== void 0) {\n        const newEffect = this.willReconcileInputKey(key, oldEffect, version);\n        if (oldEffect !== newEffect) {\n          this.invalidateInputKey(key, newEffect);\n        }\n        this._inputEffects = oldInputEffects.removed(key);\n        this.onReconcileInputKey(key, newEffect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, newEffect, version);\n      }\n    }\n  }\n\n  reconcileOutput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcileInput(version: number): void {\n    this.reconcile(version);\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._outputEffects.forEach(function (key: KI): void {\n        this.reconcileOutputKey(key, version);\n      }, this);\n      this._inputEffects.forEach(function (key: KO): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcile(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.didReconcile(version);\n    }\n  }\n\n  protected willInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateOutputKey(key: KI, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: KO, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileOutputKey(key: KI, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: KO, effect: KeyEffect, version: number): KeyEffect {\n    return effect;\n  }\n\n  protected onReconcileInputKey(key: KO, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: KO, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<KO, VO, O> {\n    const combinator = new MapOutlet.MemoizeMapCombinator<KO, VO, O>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(func: FilterFieldsFunction<KO, VO>): MapOutlet<KO, VO, Map<KO, VO>> {\n    const combinator = new MapOutlet.FilterFieldsCombinator<KO, VO, O>(func);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  map<O2>(func: MapValueFunction<O, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<KO, VO, V2>): MapOutlet<KO, V2, Map<KO, V2>>;\n  map<V2>(func: MapValueFunction<O, V2> | MapFieldValuesFunction<KO, VO, V2>): Outlet<V2> | MapOutlet<KO, V2, Map<KO, V2>> {\n    if (func.length === 1) {\n      const combinator = new Outlet.MapValueCombinator<O, V2>(func as MapValueFunction<O, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapOutlet.MapFieldValuesCombinator<KO, VO, V2, O>(func as MapFieldValuesFunction<KO, VO, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: VO) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new MapOutlet.ReduceFieldsCombinator<KO, VO, O, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<O>): this;\n  watch(func: WatchFieldsFunction<KO, VO>): this;\n  watch(func: WatchValueFunction<O> | WatchFieldsFunction<KO, VO>): this {\n    if (func.length === 1) {\n      const combinator = new Outlet.WatchValueCombinator<O>(func as WatchValueFunction<O>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new MapOutlet.WatchFieldsCombinator<KO, VO, O>(func as WatchFieldsFunction<KO, VO>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\nimport {AbstractInlet} from \"./AbstractInlet\";\n\n/**\n * An `Inlet` that invalidates a parameterized `Outlet` whenever the `Inlet`\n * is invalidated, and that updates the parameterized `Outlet` whenever the\n * `Inlet` updates.\n */\nexport class OutletInlet<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected readonly _outlet: Outlet<unknown>;\n\n  constructor(outlet: Outlet<unknown>) {\n    super();\n    this._outlet = outlet;\n  }\n\n  outlet(): Outlet<unknown> {\n    return this._outlet;\n  }\n\n  protected onInvalidateOutput(): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onReconcileOutput(version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"./Outlet\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapInlet} from \"./AbstractMapInlet\";\n\n/**\n * A `MapInlet` that invalidates a parameterized `Outlet` whenever the\n * `MapInlet` is invalidated, and that updates the parameterized `Outlet`\n * whenever the `MapInlet` updates.\n */\nexport class OutletMapInlet<K, V, O> extends AbstractMapInlet<K, V, O> {\n  /** @hidden */\n  protected readonly _outlet: Outlet<unknown>;\n\n  constructor(outlet: Outlet<unknown>) {\n    super();\n    this._outlet = outlet;\n  }\n\n  outlet(): Outlet<unknown> {\n    return this._outlet;\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onInvalidateOutput(): void {\n    this._outlet.invalidateInput();\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n\n  protected onReconcileOutput(version: number): void {\n    this._outlet.reconcileInput(version);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\nexport class ValueInput<O> extends AbstractOutlet<O> {\n  /** @hidden */\n  protected _state: O | undefined;\n\n  constructor(state?: O) {\n    super();\n    this._state = state;\n  }\n\n  get(): O | undefined {\n    return this._state;\n  }\n\n  set(newState: O | undefined): O | undefined {\n    const oldState = this._state;\n    this._state = newState;\n    this.invalidateInput();\n    return oldState;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInlet} from \"./AbstractInlet\";\n\nexport class ValueOutput<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected _state: I | undefined;\n\n  constructor(state?: I) {\n    super();\n    this._state = state;\n  }\n\n  get(): I | undefined {\n    return this._state;\n  }\n\n  protected onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      this._state = this._input.get();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapOutlet} from \"./AbstractMapOutlet\";\n\nexport class MapInput<K, V> extends AbstractMapOutlet<K, V, Map<K, V>> {\n  /** @hidden */\n  protected _state: BTree<K, V>;\n\n  constructor(state: BTree<K, V> = new BTree()) {\n    super();\n    this._state = state;\n    state.forEach(function (key: K): void {\n      this._effects = this._effects.updated(key, KeyEffect.Update);\n    }, this);\n  }\n\n  has(key: K): boolean {\n    return this._state.has(key);\n  }\n\n  get(): Map<K, V> | undefined;\n  get(key: K): V | undefined;\n  get(key?: K): Map<K, V> | V | undefined {\n    if (key === void 0) {\n      return this._state;\n    } else {\n      return this._state.get(key);\n    }\n  }\n\n  set(key: K, newValue: V): V | undefined {\n    const oldValue = this._state.get(key);\n    this._state = this._state.updated(key, newValue);\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return oldValue;\n  }\n\n  delete(key: K): this {\n    const oldState = this._state;\n    const newState = oldState.removed(key);\n    if (oldState !== newState) {\n      this._state = newState;\n      this.invalidateInputKey(key, KeyEffect.Remove);\n    }\n    return this;\n  }\n\n  keyIterator(): Cursor<K> {\n    return this._state.keys();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"./KeyEffect\";\nimport {AbstractMapInlet} from \"./AbstractMapInlet\";\n\nexport class MapOutput<K, V> extends AbstractMapInlet<K, V, Map<K, V>> {\n  /** @hidden */\n  protected _state: BTree<K, V>;\n\n  constructor() {\n    super();\n    this._state = new BTree();\n  }\n\n  get(): Map<K, V> {\n    return this._state;\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._state = this._state.updated(key, value);\n        } else {\n          this._state = this._state.removed(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._state = this._state.removed(key);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {AbstractInoutlet} from \"../AbstractInoutlet\";\n\nexport class MemoizeValueCombinator<IO> extends AbstractInoutlet<IO, IO> {\n  /** @hidden */\n  protected _state: IO | undefined;\n\n  get(): IO | undefined {\n    return this._state;\n  }\n\n  protected onReconcile(version: number): void {\n    if (this._input !== null) {\n      this._state = this._input.get();\n    }\n  }\n\n  memoize(): Outlet<IO> {\n    return this;\n  }\n}\nOutlet.MemoizeValueCombinator = MemoizeValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {MapOutlet} from \"../MapOutlet\";\nimport {AbstractMapInoutlet} from \"../AbstractMapInoutlet\";\n\nexport class MemoizeMapCombinator<K, V, IO> extends AbstractMapInoutlet<K, V, V, IO, IO> {\n  /** @hidden */\n  protected _state: IO | undefined;\n  /** @hidden */\n  protected _cache: BTree<K, V>;\n\n  constructor() {\n    super();\n    this._cache = new BTree();\n  }\n\n  has(key: K): boolean {\n    return this._cache.has(key);\n  }\n\n  get(): IO | undefined;\n  get(key: K): V | undefined;\n  get(key?: K): IO | V | undefined {\n    if (key === void 0) {\n      if (this._state === void 0 && this._input != null) {\n        this._state = this._input.get();\n      }\n      return this._state;\n    } else {\n      return this._cache.get(key);\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    return this._cache.keys();\n  }\n\n  protected onReconcileKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._cache = this._cache.updated(key, value);\n        } else {\n          this._cache = this._cache.removed(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._cache = this._cache.removed(key);\n    }\n  }\n\n  protected onReconcile(version: number): void {\n    this._state = void 0;\n  }\n\n  memoize(): MapOutlet<K, V, IO> {\n    return this;\n  }\n}\nMapOutlet.MemoizeMapCombinator = MemoizeMapCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInletMapOutlet} from \"../AbstractMapInletMapOutlet\";\n\nexport abstract class FilterFieldsOperator<K, V, I> extends AbstractMapInletMapOutlet<K, K, V, V, I, Map<K, V>> {\n  has(key: K): boolean {\n    if (this._input !== null) {\n      const value = this._input.get(key);\n      return value !== void 0 && this.evaluate(key, value);\n    }\n    return false;\n  }\n\n  get(): Map<K, V>;\n  get(key: K): V | undefined;\n  get(key?: K): Map<K, V> | V | undefined {\n    if (key === void 0) {\n      const output = new BTree<K, V>();\n      const keys = this.keyIterator();\n      do {\n        const next = keys.next();\n        if (!next.done) {\n          const key = next.value!;\n          const value = this._input!.get(key);\n          if (value !== void 0 && this.evaluate(key, value)) {\n            output.set(key, value);\n          }\n          continue;\n        }\n        break;\n      } while (true);\n      return output;\n    } else {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0 && this.evaluate(key, value)) {\n          return value;\n        }\n      }\n      return void 0;\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    if (this._input !== null) {\n      return this._input.keyIterator(); // TODO: filter keys\n    } else {\n      return Cursor.empty();\n    }\n  }\n\n  protected onInvalidateOutputKey(key: K, effect: KeyEffect): void {\n    this.invalidateInputKey(key, effect);\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    this.reconcileInputKey(key, version);\n  }\n\n  protected willReconcileInputKey(key: K, effect: KeyEffect, version: number): KeyEffect {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value === void 0 || !this.evaluate(key, value)) {\n          return KeyEffect.Remove;\n        }\n      }\n    }\n    return effect;\n  }\n\n  abstract evaluate(key: K, value: V): boolean;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {FilterFieldsFunction} from \"../function\";\nimport {FilterFieldsOperator} from \"./FilterFieldsOperator\";\n\nexport class FilterFieldsCombinator<K, V, I> extends FilterFieldsOperator<K, V, I> {\n  /** @hidden */\n  protected readonly _func: FilterFieldsFunction<K, V>;\n\n  constructor(func: FilterFieldsFunction<K, V>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: V): boolean {\n    return this._func(key, value);\n  }\n}\nMapOutlet.FilterFieldsCombinator = FilterFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInoutlet} from \"../AbstractInoutlet\";\n\nexport abstract class MapValueOperator<I, O> extends AbstractInoutlet<I, O> {\n  get(): O | undefined {\n    if (this._input !== null) {\n      return this.evaluate(this._input.get());\n    } else {\n      return void 0;\n    }\n  }\n\n  abstract evaluate(value: I | undefined): O | undefined;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {MapValueFunction} from \"../function\";\nimport {MapValueOperator} from \"./MapValueOperator\";\n\nexport class MapValueCombinator<I, O> extends MapValueOperator<I, O> {\n  /** @hidden */\n  protected readonly _func: MapValueFunction<I, O>;\n\n  constructor(func: MapValueFunction<I, O>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(value: I | undefined): O | undefined {\n    if (value !== void 0) {\n      return this._func(value);\n    } else {\n      return void 0;\n    }\n  }\n}\nOutlet.MapValueCombinator = MapValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Iterator, Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AbstractMapInoutlet} from \"../AbstractMapInoutlet\";\n\nexport abstract class MapFieldValuesOperator<K, VI, VO, I> extends AbstractMapInoutlet<K, VI, VO, I, Map<K, VO>> {\n  has(key: K): boolean {\n    if (this._input !== null) {\n      return this._input.has(key);\n    } else {\n      return false;\n    }\n  }\n\n  get(): Map<K, VO>;\n  get(key: K): VO | undefined;\n  get(key?: K): Map<K, VO> | VO | undefined {\n    if (key === void 0) {\n      const output = new BTree<K, VO>();\n      const keys = this.keyIterator();\n      do {\n        const next = keys.next();\n        if (!next.done) {\n          const key = next.value!;\n          const value = this.evaluate(key, this._input!.get(key));\n          if (value !== void 0) {\n            output.set(key, value);\n          }\n          continue;\n        }\n        break;\n      } while (true);\n      return output;\n    } else {\n      if (this._input !== null) {\n        return this.evaluate(key, this._input.get(key));\n      } else {\n        return void 0;\n      }\n    }\n  }\n\n  keyIterator(): Iterator<K> {\n    if (this._input !== null) {\n      return this._input.keyIterator(); // TODO: filter keys\n    } else {\n      return Cursor.empty();\n    }\n  }\n\n  abstract evaluate(key: K, value: VI | undefined): VO | undefined;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {MapFieldValuesFunction} from \"../function\";\nimport {MapFieldValuesOperator} from \"./MapFieldValuesOperator\";\n\nexport class MapFieldValuesCombinator<K, VI, VO, I> extends MapFieldValuesOperator<K, VI, VO, I> {\n  /** @hidden */\n  protected readonly _func: MapFieldValuesFunction<K, VI, VO>;\n\n  constructor(func: MapFieldValuesFunction<K, VI, VO> ) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: VI | undefined): VO | undefined {\n    if (value !== void 0) {\n      return this._func(key, value);\n    } else {\n      return void 0;\n    }\n  }\n}\nMapOutlet.MapFieldValuesCombinator = MapFieldValuesCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {BTree} from \"@swim/collections\";\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInletOutlet} from \"../AbstractMapInletOutlet\";\n\nexport abstract class ReduceFieldsOperator<K, V, I, O> extends AbstractMapInletOutlet<K, V, I, O> {\n  /** @hidden */\n  protected _state: BTree<K, V, O>;\n\n  constructor() {\n    super();\n    this._state = new BTree();\n  }\n\n  get(): O | undefined {\n    return this._state.reduced(this.identity(), this.accumulate.bind(this), this.combine.bind(this));\n  }\n\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        const value = this._input.get(key);\n        if (value !== void 0) {\n          this._state.set(key, value);\n        } else {\n          this._state.delete(key);\n        }\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this._state.delete(key);\n    }\n  }\n\n  abstract identity(): O;\n\n  abstract accumulate(result: O, value: V): O;\n\n  abstract combine(result: O, value: O): O;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {ReduceFieldsOperator} from \"./ReduceFieldsOperator\";\n\nexport class ReduceFieldsCombinator<K, V, I, O> extends ReduceFieldsOperator<K, V, I, O> {\n  /** @hidden */\n  protected readonly _identity: O;\n  /** @hidden */\n  protected readonly _accumulator: (result: O, element: V) => O;\n  /** @hidden */\n  protected readonly _combiner: (result: O, result2: O) => O;\n\n  constructor(identity: O, accumulator: (result: O, element: V) => O,\n              combiner: (result: O, result2: O) => O) {\n    super();\n    this._identity = identity;\n    this._accumulator = accumulator;\n    this._combiner = combiner;\n  }\n\n  get(): O {\n    return this._state.reduced(this._identity, this._accumulator, this._combiner);\n  }\n\n  identity(): O {\n    return this._identity;\n  }\n\n  accumulate(result: O, value: V): O {\n    return this._accumulator(result, value);\n  }\n\n  combine(result: O, value: O): O {\n    return this._combiner(result, value);\n  }\n}\nMapOutlet.ReduceFieldsCombinator = ReduceFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AbstractInlet} from \"../AbstractInlet\";\n\nexport abstract class WatchValueOperator<I> extends AbstractInlet<I> {\n  onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      this.evaluate(this._input.get());\n    }\n  }\n\n  abstract evaluate(value: I | undefined): void;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Outlet} from \"../Outlet\";\nimport {WatchValueFunction} from \"../function\";\nimport {WatchValueOperator} from \"./WatchValueOperator\";\n\nexport class WatchValueCombinator<I> extends WatchValueOperator<I> {\n  /** @hidden */\n  protected readonly _func: WatchValueFunction<I>;\n\n  constructor(func: WatchValueFunction<I>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(value: I | undefined): void {\n    if (value !== void 0) {\n      return this._func(value);\n    }\n  }\n}\nOutlet.WatchValueCombinator = WatchValueCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {KeyEffect} from \"../KeyEffect\";\nimport {AbstractMapInlet} from \"../AbstractMapInlet\";\n\nexport abstract class WatchFieldsOperator<K, V, O> extends AbstractMapInlet<K, V, O> {\n  protected onReconcileOutputKey(key: K, effect: KeyEffect, version: number): void {\n    if (effect === KeyEffect.Update) {\n      if (this._input !== null) {\n        this.evaluate(key, this._input.get(key));\n      } else {\n        this.evaluate(key, void 0);\n      }\n    } else if (effect === KeyEffect.Remove) {\n      this.evaluate(key, void 0);\n    }\n  }\n\n  abstract evaluate(key: K, value: V | undefined): void;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {MapOutlet} from \"../MapOutlet\";\nimport {WatchFieldsFunction} from \"../function\";\nimport {WatchFieldsOperator} from \"./WatchFieldsOperator\";\n\nexport class WatchFieldsCombinator<K, V, O> extends WatchFieldsOperator<K, V, O> {\n  /** @hidden */\n  protected readonly _func: WatchFieldsFunction<K, V>;\n\n  constructor(func: WatchFieldsFunction<K, V>) {\n    super();\n    this._func = func;\n  }\n\n  evaluate(key: K, value: V | undefined): void {\n    if (value !== void 0) {\n      return this._func(key, value);\n    }\n  }\n}\nMapOutlet.WatchFieldsCombinator = WatchFieldsCombinator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractInlet} from \"./AbstractInlet\";\n\n/**\n * An `Inlet` that invalidates a parameterized `Streamlet` whenever the `Inlet`\n * is invalidated, and that updates the parameterized `Streamlet` whenever the\n * `Inlet` updates.\n */\nexport class StreamletInlet<I> extends AbstractInlet<I> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<I, unknown>;\n\n  constructor(streamlet: Streamlet<I, unknown>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<I, unknown> {\n    return this._streamlet;\n  }\n\n  protected willInvalidateOutput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.willInvalidateInlet) {\n      streamlet.willInvalidateInlet(this);\n    }\n  }\n\n  protected didInvalidateOutput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.didInvalidateInlet) {\n      streamlet.didInvalidateInlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willReconcileOutput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.willReconcileInlet) {\n      streamlet.willReconcileInlet(this, version);\n    }\n  }\n\n  protected didReconcileOutput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, unknown>;\n    if (streamlet.didReconcileInlet) {\n      streamlet.didReconcileInlet(this, version);\n    } else {\n      streamlet.reconcile(version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractOutlet} from \"./AbstractOutlet\";\n\n/**\n * An `Outlet` that invalidates a parameterized `Streamlet` whenever the\n * `Outlet` is invalidated, and which gets its state from the parameterized\n * `Streamlet`.\n */\nexport class StreamletOutlet<O> extends AbstractOutlet<O> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<unknown, O>;\n\n  constructor(streamlet: Streamlet<unknown, O>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<unknown, O> {\n    return this._streamlet;\n  }\n\n  get(): O | undefined {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.getOutput) {\n      return streamlet.getOutput(this);\n    }\n    return void 0;\n  }\n\n  protected willInvalidateInput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.willInvalidateOutlet) {\n      streamlet.willInvalidateOutlet(this);\n    }\n  }\n\n  protected didInvalidateInput(): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.didInvalidateOutlet) {\n      streamlet.didInvalidateOutlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willReconcileInput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.willReconcileOutlet) {\n      streamlet.willReconcileOutlet(this, version);\n    }\n  }\n\n  protected didReconcileInput(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<unknown, O>;\n    if (streamlet.didReconcileOutlet) {\n      streamlet.didReconcileOutlet(this, version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {AbstractInoutlet} from \"./AbstractInoutlet\";\n\n/**\n * An `Inoutlet` that invalidates a parameterized `Streamlet` whenever the\n * `Inoutlet` is invalidated, that updates the parameterized `Streamlet`\n * whenever the `Inoutlet` updates, and which gets its state from the\n * parameterized `Streamlet`.\n */\nexport class StreamletInoutlet<I, O> extends AbstractInoutlet<I, O> {\n  /** @hidden */\n  protected readonly _streamlet: Streamlet<I, O>;\n\n  constructor(streamlet: Streamlet<I, O>) {\n    super();\n    this._streamlet = streamlet;\n  }\n\n  streamlet(): Streamlet<I, O> {\n    return this._streamlet;\n  }\n\n  get(): O | undefined {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.getOutput) {\n      const output = streamlet.getOutput(this);\n      if (output !== void 0) {\n        return output;\n      }\n    }\n    if (this._input !== null) {\n      return this._input.get() as O | undefined;\n    }\n    return void 0;\n  }\n\n  protected willInvalidate(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.willInvalidateOutlet) {\n      streamlet.willInvalidateOutlet(this);\n    }\n  }\n\n  protected didInvalidate(): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.didInvalidateOutlet) {\n      streamlet.didInvalidateOutlet(this);\n    } else {\n      streamlet.invalidate();\n    }\n  }\n\n  protected willUpdate(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.willReconcileOutlet) {\n      streamlet.willReconcileOutlet(this, version);\n    }\n  }\n\n  protected didUpdate(version: number): void {\n    const streamlet = this._streamlet as GenericStreamlet<I, O>;\n    if (streamlet.didReconcileOutlet) {\n      streamlet.didReconcileOutlet(this, version);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InletType, InletOptions, Inlet} from \"./Inlet\";\nimport {OutletType, OutletOptions, Outlet} from \"./Outlet\";\nimport {InoutletType, InoutletOptions, Inoutlet} from \"./Inoutlet\";\nimport {StreamletContext} from \"./StreamletContext\";\nimport {StreamletScope} from \"./StreamletScope\";\nimport {Streamlet} from \"./Streamlet\";\nimport {GenericStreamlet} from \"./GenericStreamlet\";\nimport {StreamletInlet} from \"./StreamletInlet\";\nimport {StreamletOutlet} from \"./StreamletOutlet\";\nimport {StreamletInoutlet} from \"./StreamletInoutlet\";\n\n/** @hidden */\nexport class InletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: InletType;\n\n  constructor(key: string, name: string, type: InletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport class OutletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: OutletType;\n\n  constructor(key: string, name: string, type: OutletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport class InoutletDescriptor {\n  readonly key: string;\n  readonly name: string;\n  readonly type: InoutletType;\n\n  constructor(key: string, name: string, type: InoutletType) {\n    this.key = key;\n    this.name = name;\n    this.type = type;\n  }\n}\n\n/** @hidden */\nexport interface StreamletClass {\n  _inlets?: {[name: string]: InletDescriptor | InoutletDescriptor | undefined};\n  _outlets?: {[name: string]: OutletDescriptor | InoutletDescriptor | undefined};\n  _inoutlets?: {[name: string]: InoutletDescriptor | undefined};\n}\n\nexport abstract class AbstractStreamlet<I = unknown, O = I> implements GenericStreamlet<I, O> {\n  protected scope: StreamletScope<O> | null;\n  protected context: StreamletContext | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor(scope: StreamletScope<O> | null = null) {\n    this.scope = scope;\n    this._version = -1;\n  }\n\n  protected streamletClass(): StreamletClass {\n    return (this as any).__proto__ as StreamletClass;\n  }\n\n  streamletScope(): StreamletScope<O> | null {\n    return this.scope;\n  }\n\n  setStreamletScope(scope: StreamletScope<O> | null): void {\n    this.scope = scope;\n  }\n\n  streamletContext(): StreamletContext | null {\n    if (this.context) {\n      return this.context;\n    }\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  setStreamletContext(context: StreamletContext | null): void {\n    this.context = context;\n  }\n\n  inlet(key: string): Inlet<I> | null;\n  inlet<I2 extends I>(): Inlet<I2>;\n  inlet(key?: string): Inlet<I> | null {\n    if (key === void 0) {\n      return new StreamletInlet<I>(this);\n    } else {\n      return AbstractStreamlet.reflectInletKey<I, O>(key, this, this.streamletClass());\n    }\n  }\n\n  bindInput(key: string, input: Outlet<I>): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.bindInput(input);\n  }\n\n  unbindInput(key: string): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.unbindInput();\n  }\n\n  outlet(key: string | Outlet<O>): Outlet<O> | null;\n  outlet<O2>(): Outlet<O2>;\n  outlet(key?: string | Outlet<O>): Outlet<O> | null {\n    if (key === void 0) {\n      return new StreamletOutlet<O>(this);\n    } else if (typeof key === \"string\") {\n      return AbstractStreamlet.reflectOutletKey<I, O>(key, this, this.streamletClass());\n    } else {\n      return key;\n    }\n  }\n\n  inoutlet<I2 extends I, O2>(): Inoutlet<I2, O2> {\n    return new StreamletInoutlet<I2, O2>(this as Streamlet<I2, O2>);\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      this.onInvalidateOutlets();\n      this.didInvalidate();\n    }\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      this.onReconcileInlets(version);\n      this.onReconcile(version);\n      this.onReconcileOutlets(version);\n      this.didReconcile(version);\n    }\n  }\n\n  getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse?: E): I2 | E | undefined {\n    if (typeof inlet === \"string\") {\n      inlet = this.inlet(inlet) as Inlet<I2>;\n    }\n    let object: I2 | E | undefined;\n    if (inlet !== null) {\n      const input = inlet.input();\n      if (input !== null) {\n        object = input.get();\n      }\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  getOutput(outlet: Outlet<O> | string): O | undefined {\n    return void 0;\n  }\n\n  disconnectInputs(): void {\n    AbstractStreamlet.disconnectInputs(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static disconnectInputs<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          if (inletDescriptor instanceof InletDescriptor) {\n            const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n            inlet.disconnectInputs();\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n            inoutlet.disconnectInputs();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  disconnectOutputs(): void {\n    AbstractStreamlet.disconnectOutputs(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static disconnectOutputs<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.disconnectOutputs();\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.disconnectOutputs();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  willInvalidateInlet(inlet: Inlet<I>): void {\n    // stub\n  }\n\n  didInvalidateInlet(inlet: Inlet<I>): void {\n    this.invalidate();\n  }\n\n  willReconcileInlet(inlet: Inlet<I>, version: number): void {\n    // stub\n  }\n\n  didReconcileInlet(inlet: Inlet<I>, version: number): void {\n    this.reconcile(version);\n  }\n\n  willInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  didInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  willReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  didReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidateOutlets(): void {\n    AbstractStreamlet.invalidateOutlets(this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static invalidateOutlets<I, O>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.invalidateInput();\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.invalidateInput();\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInlets(version: number): void {\n    AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static reconcileInlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          if (inletDescriptor instanceof InletDescriptor) {\n            const inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n            inlet.reconcileOutput(version);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n            inoutlet.reconcileOutput(version);\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutlets(version: number): void {\n    AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());\n  }\n\n  /** @hidden */\n  static reconcileOutlets<I, O>(version: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): void {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            const outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n            outlet.reconcileInput(version);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            const inoutlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n            inoutlet.reconcileInput(version);\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n\n  /** @hidden */\n  static reflectEachInlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null,\n                                      callback: (this: S, inlet: Inlet<I>, name: string, index: number) => T | void,\n                                      thisArg?: S): T | undefined {\n    let index = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          const inletDescriptor = streamletClass._inlets[name]!;\n          let inlet: Inlet<I> | null;\n          if (inletDescriptor instanceof InletDescriptor) {\n            inlet = AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            inlet = AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n          } else {\n            inlet = null;\n          }\n          const result = callback.call(thisArg, inlet, inletDescriptor.name, index);\n          if (result !== void 0) {\n            return result;\n          }\n          index += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return void 0;\n  }\n\n  /** @hidden */\n  static reflectEachOutlet<I, O, T, S>(streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null,\n                                       callback: (this: S, outlet: Outlet<O>, name: string, index: number) => T | void,\n                                       thisArg?: S): T | undefined {\n    let index = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          const outletDescriptor = streamletClass._outlets[name]!;\n          let outlet: Outlet<O> | null;\n          if (outletDescriptor instanceof OutletDescriptor) {\n            outlet = AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            outlet = AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n          } else {\n            outlet = null;\n          }\n          const result = callback.call(thisArg, outlet, outletDescriptor.name, index);\n          if (result !== void 0) {\n            return result;\n          }\n          index += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return void 0;\n  }\n\n  /** @hidden */\n  static reflectInletCount(streamletClass: StreamletClass | null): number {\n    let count = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const _ in streamletClass._inlets) {\n          count += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return count;\n  }\n\n  /** @hidden */\n  static reflectOutletCount(streamletClass: StreamletClass | null): number {\n    let count = 0;\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const _ in streamletClass._outlets) {\n          count += 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return count;\n  }\n\n  /** @hidden */\n  static reflectInletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): [string, Inlet<I>] | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        for (const name in streamletClass._inlets) {\n          if (index === 0) {\n            const inletDescriptor = streamletClass._inlets[name]!;\n            if (inletDescriptor instanceof InletDescriptor) {\n              return [inletDescriptor.name, AbstractStreamlet.reflectInletField(streamlet, inletDescriptor)];\n            } else if (inletDescriptor instanceof InoutletDescriptor) {\n              return [inletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor)];\n            } else {\n              return null;\n            }\n          }\n          index -= 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectOutletIndex<I, O>(index: number, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): [string, Outlet<O>] | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        for (const name in streamletClass._outlets) {\n          if (index === 0) {\n            const outletDescriptor = streamletClass._outlets[name]!;\n            if (outletDescriptor instanceof OutletDescriptor) {\n              return [outletDescriptor.name, AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor)];\n            } else if (outletDescriptor instanceof InoutletDescriptor) {\n              return [outletDescriptor.name, AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor)];\n            } else {\n              return null;\n            }\n          }\n          index -= 1;\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectInletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): Inlet<I> | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_inlets\")) {\n        const inletDescriptor = streamletClass._inlets![key];\n        if (inletDescriptor !== void 0) {\n          if (inletDescriptor instanceof InletDescriptor) {\n            return AbstractStreamlet.reflectInletField(streamlet, inletDescriptor);\n          } else if (inletDescriptor instanceof InoutletDescriptor) {\n            return AbstractStreamlet.reflectInoutletField(streamlet, inletDescriptor);\n          } else {\n            return null;\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectOutletKey<I, O>(key: string, streamlet: Streamlet<I, O>, streamletClass: StreamletClass | null): Outlet<O> | null {\n    while (streamletClass) {\n      if (streamletClass.hasOwnProperty(\"_outlets\")) {\n        const outletDescriptor = streamletClass._outlets![key];\n        if (outletDescriptor !== void 0) {\n          if (outletDescriptor instanceof OutletDescriptor) {\n            return AbstractStreamlet.reflectOutletField(streamlet, outletDescriptor);\n          } else if (outletDescriptor instanceof InoutletDescriptor) {\n            return AbstractStreamlet.reflectInoutletField(streamlet, outletDescriptor);\n          } else {\n            return null;\n          }\n        }\n      }\n      streamletClass = (streamletClass as any).__proto__ as StreamletClass | null;\n    }\n    return null;\n  }\n\n  /** @hidden */\n  static reflectInletField<I, O>(streamlet: Streamlet<I, O>, inletDescriptor: InletDescriptor): Inlet<I> {\n    if (inletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueInletField(streamlet, inletDescriptor.key);\n    } else if (inletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapInletField(streamlet, inletDescriptor.key);\n    } else {\n      throw new TypeError(inletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I> {\n    let inlet = (streamlet as any)[key] as Inlet<I> | undefined;\n    if (!inlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        inlet = streamlet.inlet();\n      } else {\n        inlet = new StreamletInlet<I>(streamlet);\n      }\n      (streamlet as any)[key] = inlet;\n    }\n    return inlet;\n  }\n\n  /** @hidden */\n  static reflectMapInletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inlet<I> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static reflectOutletField<I, O>(streamlet: Streamlet<I, O>, outletDescriptor: OutletDescriptor): Outlet<O> {\n    if (outletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueOutletField(streamlet, outletDescriptor.key);\n    } else if (outletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapOutletField(streamlet, outletDescriptor.key);\n    } else {\n      throw new TypeError(outletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O> {\n    let outlet = (streamlet as any)[key] as Outlet<O> | undefined;\n    if (!outlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        outlet = streamlet.outlet();\n      } else {\n        outlet = new StreamletOutlet<O>(streamlet);\n      }\n      (streamlet as any)[key] = outlet;\n    }\n    return outlet;\n  }\n\n  /** @hidden */\n  static reflectMapOutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Outlet<O> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static reflectInoutletField<I, O>(streamlet: Streamlet<I, O>, inoutletDescriptor: InoutletDescriptor): Inoutlet<I, O> {\n    if (inoutletDescriptor.type === \"value\") {\n      return AbstractStreamlet.reflectValueInoutletField(streamlet, inoutletDescriptor.key);\n    } else if (inoutletDescriptor.type === \"map\") {\n      return AbstractStreamlet.reflectMapInoutletField(streamlet, inoutletDescriptor.key);\n    } else {\n      throw new TypeError(inoutletDescriptor.type);\n    }\n  }\n\n  /** @hidden */\n  static reflectValueInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O> {\n    let inoutlet = (streamlet as any)[key] as Inoutlet<I, O> | undefined;\n    if (!inoutlet) {\n      if (streamlet instanceof AbstractStreamlet) {\n        inoutlet = streamlet.inoutlet();\n      } else {\n        inoutlet = new StreamletInoutlet<I, O>(streamlet);\n      }\n      (streamlet as any)[key] = inoutlet;\n    }\n    return inoutlet;\n  }\n\n  /** @hidden */\n  static reflectMapInoutletField<I, O>(streamlet: Streamlet<I, O>, key: string): Inoutlet<I, O> {\n    return null as any; // TODO\n  }\n\n  /** @hidden */\n  static init(streamletClass: StreamletClass): void {\n    if (!streamletClass.hasOwnProperty(\"_inlets\")) {\n      streamletClass._inlets = {};\n    }\n    if (!streamletClass.hasOwnProperty(\"_outlets\")) {\n      streamletClass._outlets = {};\n    }\n    if (!streamletClass.hasOwnProperty(\"_inoutlets\")) {\n      streamletClass._inoutlets = {};\n    }\n  }\n\n  /** @hidden */\n  static decorateInlet(options: InletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const inletDescriptor = new InletDescriptor(key, name, type);\n    target._inlets![name] = inletDescriptor;\n  }\n\n  /** @hidden */\n  static decorateOutlet(options: OutletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const outletDescriptor = new OutletDescriptor(key, name, type);\n    target._outlets![name] = outletDescriptor;\n  }\n\n  /** @hidden */\n  static decorateInoutlet(options: InoutletOptions, target: StreamletClass, key: string): void {\n    AbstractStreamlet.init(target);\n    const name = options.name !== void 0 ? options.name : key;\n    const type = options.type !== void 0 ? options.type : \"value\";\n    const inoutletDescriptor = new InoutletDescriptor(key, name, type);\n    target._inlets![name] = inoutletDescriptor;\n    target._outlets![name] = inoutletDescriptor;\n    target._inoutlets![name] = inoutletDescriptor;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InletOptions} from \"./Inlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function In(name: string): PropertyDecorator;\nexport function In(options: InletOptions): PropertyDecorator;\nexport function In(target: unknown, key: string): void;\nexport function In(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as InletOptions;\n    }\n    return AbstractStreamlet.decorateInlet.bind(void 0, target as InletOptions);\n  } else {\n    AbstractStreamlet.decorateInlet({}, target as StreamletClass, key!);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {OutletOptions} from \"./Outlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function Out(name: string): PropertyDecorator;\nexport function Out(options: OutletOptions): PropertyDecorator;\nexport function Out(target: unknown, key: string): void;\nexport function Out(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as OutletOptions;\n    }\n    return AbstractStreamlet.decorateOutlet.bind(void 0, target as OutletOptions);\n  } else {\n    AbstractStreamlet.decorateOutlet({}, target as StreamletClass, key!);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {InoutletOptions} from \"./Inoutlet\";\nimport {StreamletClass, AbstractStreamlet} from \"./AbstractStreamlet\";\n\nexport function Inout(name: string): PropertyDecorator;\nexport function Inout(options: InoutletOptions): PropertyDecorator;\nexport function Inout(target: unknown, key: string): void;\nexport function Inout(target: unknown, key?: string): PropertyDecorator | void {\n  if (arguments.length === 1) {\n    if (typeof target === \"string\") {\n      target = {name: target} as InoutletOptions;\n    }\n    return AbstractStreamlet.decorateInoutlet.bind(void 0, target as InoutletOptions);\n  } else {\n    AbstractStreamlet.decorateInoutlet({}, target as StreamletClass, key!);\n  }\n}\n"],"names":["KeyEffect","Cursor","BTree"],"mappings":"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"}