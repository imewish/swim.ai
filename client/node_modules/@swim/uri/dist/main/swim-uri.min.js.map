{"version":3,"sources":["../../../../../node_modules/tslib/tslib.es6.js","../../main/UriException.ts","../../main/Uri.ts","../../main/UriScheme.ts","../../main/UriAuthority.ts","../../main/UriUser.ts","../../main/UriHost.ts","../../main/UriHostName.ts","../../main/UriHostIPv4.ts","../../main/UriHostIPv6.ts","../../main/UriHostUndefined.ts","../../main/UriPort.ts","../../main/UriPath.ts","../../main/UriPathSegment.ts","../../main/UriPathSlash.ts","../../main/UriPathEmpty.ts","../../main/UriPathBuilder.ts","../../main/UriQuery.ts","../../main/UriQueryParam.ts","../../main/UriQueryUndefined.ts","../../main/UriQueryBuilder.ts","../../main/UriFragment.ts","../../main/UriParser.ts","../../main/UriAbsoluteParser.ts","../../main/UriSchemeParser.ts","../../main/UriAuthorityParser.ts","../../main/UriUserParser.ts","../../main/UriHostParser.ts","../../main/UriHostAddressParser.ts","../../main/UriHostLiteralParser.ts","../../main/UriPortParser.ts","../../main/UriPathParser.ts","../../main/UriQueryParser.ts","../../main/UriFragmentParser.ts","../../main/UriForm.ts","../../main/UriCache.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","UriException","message","_this","_super","call","Diagnostic","diagnostic","toString","Error","Uri","scheme","authority","path","query","fragment","_scheme","_authority","_path","_query","_fragment","isDefined","isEmpty","Scheme","fromAny","copy","schemePart","parse","schemeName","name","from","Authority","authorityPart","user","userPart","username","password","host","hostPart","hostAddress","hostName","address","hostIPv4","hostIPv6","port","portPart","portNumber","components","_i","arguments","length","Path","apply","pathPart","pathName","parentPath","parent","basePath","base","appendedPath","appended","appendedSlash","appendedSegment","segment","prependedPath","prepended","prependedSlash","prependedSegment","Query","queryPart","updatedQuery","key","value","updated","removedQuery","removed","appendedQuery","prependedQuery","Fragment","fragmentPart","fragmentIdentifier","identifier","endpoint","resolve","relative","removeDotSegments","isAbsolute","merge","unresolve","absolute","equals","undefined","unmerge","toAny","uri","compareTo","that","order","localeCompare","hashCode","_hashCode","Murmur3","hash","debug","output","write","display","_string","Format","empty","_empty","TypeError","part","number","standardParser","_standardParser","Parser","string","parseAbsoluteString","isUnreservedChar","c","isSubDelimChar","isSchemeChar","isUserInfoChar","isUserChar","isHostChar","isPathChar","isQueryChar","isParamChar","isFragmentChar","isAlpha","toLowerCase","writeScheme","i","n","charCodeAt","writeUserInfo","userInfo","writeEncoded","writeUser","writeHost","writeHostLiteral","writePathSegment","writeQuery","writeParam","param","writeFragment","writePctEncoded","Base16","lowercase","encodeDigit","form","_form","Form","UriScheme","_name","_undefined","cache","get","put","parseSchemeString","_cache","HashGenCacheMap","UriAuthority","_user","_host","_port","User","_username","Host","ipv4","ipv6","Port","parseAuthorityString","UriUser","_password","_hashSeed","seed","mash","mix","parseUserString","UriHost","HostUndefined","HostName","HostIPv4","HostIPv6","parseHostString","UriHostName","_address","UriHostIPv4","UriHostIPv6","UriHostUndefined","UriPort","num","_number","valueOf","displayNumber","parsePortString","UriPath","defineProperty","tail","index","head","builder","PathBuilder","addPath","addSegment","bind","isRelative","foot","isSubpathOf","a","push","addSlash","slash","rest","next","pop","prev","root","PathEmpty","_slash","PathSlash","cacheSegment","PathSegment","isArray","parsePathString","segmentCache","_segmentCache","HashGenCacheSet","pathForm","_pathForm","PathForm","UriPathSegment","_head","_tail","setTail","dealias","UriPathSlash","UriPathEmpty","UriPathBuilder","_first","_last","_size","_aliased","component","size","aliased","first","last","xi","xs","xn","UriQuery","has","QueryBuilder","addParam","addQuery","add","params","QueryUndefined","cacheKey","QueryParam","parseQueryString","keyCache","_keyCache","UriQueryParam","_key","_value","UriQueryUndefined","UriQueryBuilder","k","key_1","value_1","UriFragment","_identifier","parseFragmentString","UriParser","pathEmpty","pathBuilder","queryBuilder","absoluteParser","AbsoluteParser","parseAbsolute","input","Unicode","stringInput","parser","isCont","isError","error","unexpected","schemeParser","SchemeParser","parseScheme","authorityParser","AuthorityParser","parseAuthority","userParser","UserParser","parseUser","hostParser","HostParser","parseHost","hostAddressParser","HostAddressParser","parseHostAddress","hostLiteralParser","HostLiteralParser","parseHostLiteral","portParser","PortParser","parsePort","pathParser","PathParser","parsePath","queryParser","QueryParser","parseQuery","fragmentParser","FragmentParser","parseFragment","UriAbsoluteParser","step","feed","look","clone","isDone","expected","asError","done","UriSchemeParser","Utf8","decodedString","UriAuthorityParser","UriUserParser","usernameOutput","passwordOutput","c1","isDigit","decodeDigit","UriHostParser","UriHostAddressParser","x","Base10","UriHostLiteralParser","UriPortParser","UriPathParser","UriQueryParser","keyOutput","valueOutput","UriFragmentParser","UriForm","unit","_unit","mold","object","item","Text","concat","cast","target","stringValue","UriCache","_base","_resolveCache","_unresolveCache"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/uri/dist/main/swim-uri.min.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Diagnostic} from \"@swim/codec\";\n\nexport class UriException extends Error {\n  readonly diagnostic?: Diagnostic;\n\n  constructor(message?: Diagnostic | string) {\n    super(message instanceof Diagnostic ? message.message() || void 0 : message);\n    if (message instanceof Diagnostic) {\n      this.diagnostic = message;\n    }\n    (this as any).__proto__ = UriException.prototype;\n  }\n\n  toString(): string {\n    if (this.diagnostic) {\n      return this.diagnostic.toString();\n    } else {\n      return super.toString();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3} from \"@swim/util\";\nimport {Output, Format, Debug, Display, Base16} from \"@swim/codec\";\nimport {Form} from \"@swim/structure\";\nimport {UriException} from \"./UriException\";\nimport {AnyUriScheme, UriScheme} from \"./UriScheme\";\nimport {AnyUriAuthority, UriAuthorityInit, UriAuthority} from \"./UriAuthority\";\nimport {AnyUriUser, UriUser} from \"./UriUser\";\nimport {AnyUriHost, UriHost} from \"./UriHost\";\nimport {UriHostName} from \"./UriHostName\";\nimport {UriHostIPv4} from \"./UriHostIPv4\";\nimport {UriHostIPv6} from \"./UriHostIPv6\";\nimport {UriHostUndefined} from \"./UriHostUndefined\";\nimport {AnyUriPort, UriPort} from \"./UriPort\";\nimport {AnyUriPath, UriPath} from \"./UriPath\";\nimport {UriPathSegment} from \"./UriPathSegment\";\nimport {UriPathSlash} from \"./UriPathSlash\";\nimport {UriPathEmpty} from \"./UriPathEmpty\";\nimport {UriPathBuilder} from \"./UriPathBuilder\";\nimport {AnyUriQuery, UriQuery} from \"./UriQuery\";\nimport {UriQueryParam} from \"./UriQueryParam\";\nimport {UriQueryUndefined} from \"./UriQueryUndefined\";\nimport {UriQueryBuilder} from \"./UriQueryBuilder\";\nimport {AnyUriFragment, UriFragment} from \"./UriFragment\";\nimport {UriParser} from \"./UriParser\";\nimport {UriForm} from \"./UriForm\";\nimport {UriPathForm} from \"./UriPathForm\";\n\nexport type AnyUri = Uri | UriInit | string;\n\nexport interface UriInit extends UriAuthorityInit {\n  scheme?: AnyUriScheme;\n  authority?: AnyUriAuthority;\n  path?: AnyUriPath;\n  query?: AnyUriQuery;\n  fragment?: AnyUriFragment;\n}\n\nexport class Uri implements Comparable<Uri>, HashCode, Debug, Display {\n  /** @hidden */\n  readonly _scheme: UriScheme;\n  /** @hidden */\n  readonly _authority: UriAuthority;\n  /** @hidden */\n  readonly _path: UriPath;\n  /** @hidden */\n  readonly _query: UriQuery;\n  /** @hidden */\n  readonly _fragment: UriFragment;\n  /** @hidden */\n  _string?: string;\n  /** @hidden */\n  _hashCode?: number;\n\n  /** @hidden */\n  constructor(scheme: UriScheme, authority: UriAuthority, path: UriPath,\n              query: UriQuery, fragment: UriFragment) {\n    this._scheme = scheme;\n    this._authority = authority;\n    this._path = path;\n    this._query = query;\n    this._fragment = fragment;\n  }\n\n  isDefined(): boolean {\n    return this._scheme.isDefined() || this._authority.isDefined() || this._path.isDefined()\n        || this._query.isDefined() || this._fragment.isDefined();\n  }\n\n  isEmpty(): boolean {\n    return !this._scheme.isDefined() && !this._authority.isDefined() && this._path.isEmpty()\n        && !this._query.isDefined() && !this._fragment.isDefined();\n  }\n\n  scheme(): UriScheme;\n  scheme(scheme: AnyUriScheme): Uri;\n  scheme(scheme?: AnyUriScheme): UriScheme | Uri {\n    if (scheme === void 0) {\n      return this._scheme;\n    } else {\n      scheme = Uri.Scheme.fromAny(scheme);\n      if (scheme !== this._scheme) {\n        return this.copy(scheme, this._authority, this._path, this._query, this._fragment);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  schemePart(): string;\n  schemePart(scheme: string): Uri;\n  schemePart(scheme?: string): string | Uri {\n    if (scheme === void 0) {\n      return this._scheme.toString();\n    } else {\n      return this.scheme(Uri.Scheme.parse(scheme));\n    }\n  }\n\n  schemeName(): string;\n  schemeName(scheme: string): Uri;\n  schemeName(scheme?: string): string | Uri {\n    if (scheme === void 0) {\n      return this._scheme.name();\n    } else {\n      return this.scheme(Uri.Scheme.from(scheme));\n    }\n  }\n\n  authority(): UriAuthority;\n  authority(authority: AnyUriAuthority): Uri;\n  authority(authority?: AnyUriAuthority): UriAuthority | Uri {\n    if (authority === void 0) {\n      return this._authority;\n    } else {\n      authority = Uri.Authority.fromAny(authority);\n      if (authority !== this._authority) {\n        return this.copy(this._scheme, authority, this._path, this._query, this._fragment);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  authorityPart(): string;\n  authorityPart(authority: string): Uri;\n  authorityPart(authority?: string): string | Uri {\n    if (authority === void 0) {\n      return this._authority.toString();\n    } else {\n      return this.authority(Uri.Authority.parse(authority));\n    }\n  }\n\n  user(): UriUser;\n  user(user: AnyUriUser): Uri;\n  user(user?: AnyUriUser): UriUser | Uri {\n    if (user === void 0) {\n      return this._authority.user();\n    } else {\n      return this.authority(this._authority.user(user));\n    }\n  }\n\n  userPart(): string;\n  userPart(user: string): Uri;\n  userPart(user?: string): string | Uri {\n    if (user === void 0) {\n      return this._authority.userPart();\n    } else {\n      return this.authority(this._authority.userPart(user));\n    }\n  }\n\n  username(): string;\n  username(username: string, password?: string | null): Uri;\n  username(username?: string, password?: string | null): string | Uri {\n    if (username === void 0) {\n      return this._authority.username();\n    } else {\n      return this.authority(this._authority.username(username, password));\n    }\n  }\n\n  password(): string | null;\n  password(password: string | null): Uri;\n  password(password?: string | null): string | null | Uri {\n    if (password === void 0) {\n      return this._authority.password();\n    } else {\n      return this.authority(this._authority.password(password));\n    }\n  }\n\n  host(): UriHost;\n  host(host: AnyUriHost): Uri;\n  host(host?: AnyUriHost): UriHost | Uri {\n    if (host === void 0) {\n      return this._authority.host();\n    } else {\n      return this.authority(this._authority.host(host));\n    }\n  }\n\n  hostPart(): string;\n  hostPart(host: string): Uri;\n  hostPart(host?: string): string | Uri {\n    if (host === void 0) {\n      return this._authority.hostPart();\n    } else {\n      return this.authority(this._authority.hostPart(host));\n    }\n  }\n\n  hostAddress(): string {\n    return this._authority.hostAddress();\n  }\n\n  hostName(): string | null;\n  hostName(address: string): Uri;\n  hostName(address?: string): string | null | Uri {\n    if (address === void 0) {\n      return this._authority.hostName();\n    } else {\n      return this.authority(this._authority.hostName(address));\n    }\n  }\n\n  hostIPv4(): string | null;\n  hostIPv4(address: string): Uri;\n  hostIPv4(address?: string): string | null | Uri {\n    if (address === void 0) {\n      return this._authority.hostIPv4();\n    } else {\n      return this.authority(this._authority.hostIPv4(address));\n    }\n  }\n\n  hostIPv6(): string | null;\n  hostIPv6(address: string): Uri;\n  hostIPv6(address?: string): string | null | Uri {\n    if (address === void 0) {\n      return this._authority.hostIPv6();\n    } else {\n      return this.authority(this._authority.hostIPv6(address));\n    }\n  }\n\n  port(): UriPort;\n  port(port: AnyUriPort): Uri;\n  port(port?: AnyUriPort): UriPort | Uri {\n    if (port === void 0) {\n      return this._authority.port();\n    } else {\n      return this.authority(this._authority.port(port));\n    }\n  }\n\n  portPart(): string;\n  portPart(port: string): Uri;\n  portPart(port?: string): string | Uri {\n    if (port === void 0) {\n      return this._authority.portPart();\n    } else {\n      return this.authority(this._authority.portPart(port));\n    }\n  }\n\n  portNumber(): number;\n  portNumber(port: number): Uri;\n  portNumber(port?: number): number | Uri {\n    if (port === void 0) {\n      return this._authority.portNumber();\n    } else {\n      return this.authority(this._authority.portNumber(port));\n    }\n  }\n\n  path(): UriPath;\n  path(...components: AnyUriPath[]): Uri;\n  path(...components: AnyUriPath[]): UriPath | Uri {\n    if (arguments.length === 0) {\n      return this._path;\n    } else {\n      const path = Uri.Path.from.apply(void 0, components);\n      if (path !== this._path) {\n        return this.copy(this._scheme, this._authority, path, this._query, this._fragment);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  pathPart(): string;\n  pathPart(path: string): Uri;\n  pathPart(path?: string): string | Uri {\n    if (path === void 0) {\n      return this._path.toString();\n    } else {\n      return this.path(Uri.Path.parse(path));\n    }\n  }\n\n  pathName(): string;\n  pathName(name: string): Uri;\n  pathName(name?: string): string | Uri {\n    if (name === void 0) {\n      return this._path.name();\n    } else {\n      return this.path(this._path.name(name));\n    }\n  }\n\n  parentPath(): UriPath {\n    return this._path.parent();\n  }\n\n  basePath(): UriPath {\n    return this._path.base();\n  }\n\n  parent(): Uri {\n    return Uri.from(this._scheme, this._authority, this._path.parent());\n  }\n\n  base(): Uri {\n    return Uri.from(this._scheme, this._authority, this._path.base());\n  }\n\n  appendedPath(...components: AnyUriPath[]): Uri {\n    return this.path(this._path.appended.apply(this._path, arguments));\n  }\n\n  appendedSlash(): Uri {\n    return this.path(this._path.appendedSlash());\n  }\n\n  appendedSegment(segment: string): Uri {\n    return this.path(this._path.appendedSegment(segment));\n  }\n\n  prependedPath(...components: AnyUriPath[]): Uri {\n    return this.path(this._path.prepended.apply(this._path, arguments));\n  }\n\n  prependedSlash(): Uri {\n    return this.path(this._path.prependedSlash());\n  }\n\n  prependedSegment(segment: string): Uri {\n    return this.path(this._path.prependedSegment(segment));\n  }\n\n  query(): UriQuery;\n  query(query: AnyUriQuery): Uri;\n  query(query?: AnyUriQuery): UriQuery | Uri {\n    if (query === void 0) {\n      return this._query;\n    } else {\n      query = Uri.Query.fromAny(query);\n      if (query !== this._query) {\n        return this.copy(this._scheme, this._authority, this._path, query, this._fragment);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  queryPart(): string;\n  queryPart(query: string): Uri;\n  queryPart(query?: string): string | Uri {\n    if (query === void 0) {\n      return this._query.toString();\n    } else {\n      return this.query(Uri.Query.parse(query));\n    }\n  }\n\n  updatedQuery(key: string, value: string): Uri {\n    return this.query(this._query.updated(key, value));\n  }\n\n  removedQuery(key: string): Uri {\n    return this.query(this._query.removed(key));\n  }\n\n  appendedQuery(key: string | null, value: string): Uri;\n  appendedQuery(params: AnyUriQuery): Uri;\n  appendedQuery(key: AnyUriQuery | null, value?: string): Uri {\n    return this.query(this._query.appended(key as any, value as any));\n  }\n\n  prependedQuery(key: string | null, value: string): Uri;\n  prependedQuery(params: AnyUriQuery): Uri;\n  prependedQuery(key: AnyUriQuery | null, value?: string): Uri {\n    return this.query(this._query.prepended(key as any, value as any));\n  }\n\n  fragment(): UriFragment;\n  fragment(fragment: AnyUriFragment): Uri;\n  fragment(fragment?: AnyUriFragment): UriFragment | Uri {\n    if (fragment === void 0) {\n      return this._fragment;\n    } else {\n      fragment = Uri.Fragment.fromAny(fragment);\n      if (fragment !== this._fragment) {\n        return Uri.from(this._scheme, this._authority, this._path, this._query, fragment);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  fragmentPart(): string | null;\n  fragmentPart(fragment: string): Uri;\n  fragmentPart(fragment?: string): string  | null| Uri {\n    if (fragment === void 0) {\n      return this._fragment.toString();\n    } else {\n      return this.fragment(Uri.Fragment.parse(fragment));\n    }\n  }\n\n  fragmentIdentifier(): string | null;\n  fragmentIdentifier(identifier: string | null): Uri;\n  fragmentIdentifier(identifier?: string | null): string | null | Uri {\n    if (identifier === void 0) {\n      return this._fragment.identifier();\n    } else {\n      return this.fragment(Uri.Fragment.from(identifier));\n    }\n  }\n\n  endpoint(): Uri {\n    if (this._path.isDefined() || this._query.isDefined() || this._fragment.isDefined()) {\n      return Uri.from(this._scheme, this._authority);\n    } else {\n      return this;\n    }\n  }\n\n  resolve(relative: AnyUri): Uri {\n    relative = Uri.fromAny(relative);\n    if (relative._scheme.isDefined()) {\n      return this.copy(relative._scheme,\n                       relative._authority,\n                       relative._path.removeDotSegments(),\n                       relative._query,\n                       relative._fragment);\n    } else if (relative._authority.isDefined()) {\n      return this.copy(this._scheme,\n                       relative._authority,\n                       relative._path.removeDotSegments(),\n                       relative._query,\n                       relative._fragment);\n    } else if (relative._path.isEmpty()) {\n      return this.copy(this._scheme,\n                       this._authority,\n                       this._path,\n                       relative._query.isDefined() ? relative._query : this._query,\n                       relative._fragment);\n    } else if (relative._path.isAbsolute()) {\n      return this.copy(this._scheme,\n                       this._authority,\n                       relative._path.removeDotSegments(),\n                       relative._query,\n                       relative._fragment);\n    } else {\n      return this.copy(this._scheme,\n                       this._authority,\n                       this.merge(relative._path).removeDotSegments(),\n                       relative._query,\n                       relative._fragment);\n    }\n  }\n\n  /** @hidden */\n  merge(relative: UriPath): UriPath {\n    if (this._authority.isDefined() && this._path.isEmpty()) {\n      return relative.prependedSlash();\n    } else if (this._path.isEmpty()) {\n      return relative;\n    } else {\n      return this._path.merge(relative);\n    }\n  }\n\n  unresolve(absolute: AnyUri): Uri {\n    absolute = Uri.fromAny(absolute);\n    if (!this._scheme.equals(absolute._scheme) || !this._authority.equals(absolute._authority)) {\n      return absolute;\n    } else {\n      return Uri.from(Uri.Scheme.undefined(),\n                      Uri.Authority.undefined(),\n                      this._path.unmerge(absolute._path),\n                      absolute._query,\n                      absolute._fragment);\n    }\n  }\n\n  protected copy(scheme: UriScheme, authority: UriAuthority, path: UriPath,\n                 query: UriQuery, fragment: UriFragment): Uri {\n    return Uri.from(scheme, authority, path, query, fragment);\n  }\n\n  toAny(): {scheme?: string, username?: string, password?: string, host?: string,\n            port?: number, path: string[], query?: {[key: string]: string},\n            fragment?: string} {\n    const uri = {} as {scheme?: string, username?: string, password?: string, host?: string,\n                       port?: number, path: string[], query?: {[key: string]: string},\n                       fragment?: string};\n    uri.scheme = this._scheme.toAny();\n    this._authority.toAny(uri);\n    uri.path = this._path.toAny();\n    uri.query = this._query.toAny();\n    uri.fragment = this._fragment.toAny();\n    return uri;\n  }\n\n  compareTo(that: Uri): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Uri) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this.toString());\n    }\n    return this._hashCode;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Uri\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    if (this._string != null) {\n      output = output.write(this._string);\n    } else {\n      if (this._scheme.isDefined()) {\n        output.display(this._scheme).write(58/*':'*/);\n      }\n      if (this._authority.isDefined()) {\n        output = output.write(47/*'/'*/).write(47/*'/'*/).display(this._authority);\n      }\n      output.display(this._path);\n      if (this._query.isDefined()) {\n        output = output.write(63/*'?'*/).display(this._query);\n      }\n      if (this._fragment.isDefined()) {\n        output = output.write(35/*'#'*/).display(this._fragment);\n      }\n    }\n  }\n\n  toString(): string {\n    if (this._string === void 0) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n\n  private static _empty?: Uri;\n\n  private static _standardParser?: UriParser;\n\n  static empty(): Uri {\n    if (Uri._empty === void 0) {\n      Uri._empty = new Uri(Uri.Scheme.undefined(), Uri.Authority.undefined(), Uri.Path.empty(),\n                           Uri.Query.undefined(), Uri.Fragment.undefined());\n    }\n    return Uri._empty;\n  }\n\n  static from(scheme: UriScheme = Uri.Scheme.undefined(),\n              authority: UriAuthority = Uri.Authority.undefined(),\n              path: UriPath = Uri.Path.empty(),\n              query: UriQuery = Uri.Query.undefined(),\n              fragment: UriFragment = Uri.Fragment.undefined()): Uri {\n    if (scheme.isDefined() || authority.isDefined() || path.isDefined()\n        || query.isDefined() || fragment.isDefined()) {\n      return new Uri(scheme, authority, path, query, fragment);\n    } else {\n      return Uri.empty();\n    }\n  }\n\n  static fromAny(uri: AnyUri | null | undefined): Uri {\n    if (uri === null || uri === void 0) {\n      return Uri.empty();\n    } else if (uri instanceof Uri) {\n      return uri;\n    } else if (typeof uri === \"object\") {\n      const scheme = Uri.Scheme.fromAny(uri.scheme);\n      const authority = Uri.Authority.fromAny(uri.authority || uri);\n      const path = Uri.Path.fromAny(uri.path);\n      const query = Uri.Query.fromAny(uri.query);\n      const fragment = Uri.Fragment.fromAny(uri.fragment);\n      if (scheme.isDefined() || authority.isDefined() || path.isDefined()\n          || query.isDefined() || fragment.isDefined()) {\n        return new Uri(scheme, authority, path, query, fragment);\n      } else {\n        return Uri.empty();\n      }\n    } else if (typeof uri === \"string\") {\n      return Uri.parse(uri);\n    } else {\n      throw new TypeError(\"\" + uri);\n    }\n  }\n\n  static scheme(scheme: AnyUriScheme): Uri {\n    scheme = Uri.Scheme.fromAny(scheme);\n    return Uri.from(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static schemePart(part: string): Uri {\n    const scheme = Uri.Scheme.parse(part);\n    return Uri.from(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static schemeName(name: string): Uri {\n    const scheme = Uri.Scheme.from(name);\n    return Uri.from(scheme, void 0, void 0, void 0, void 0);\n  }\n\n  static authority(authority: AnyUriAuthority): Uri {\n    authority = Uri.Authority.fromAny(authority);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static authorityPart(part: string): Uri {\n    const authority = Uri.Authority.parse(part);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static user(user: AnyUriUser): Uri {\n    const authority = Uri.Authority.user(user);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static userPart(part: string): Uri {\n    const authority = Uri.Authority.userPart(part);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static username(username: string, password?: string | null): Uri {\n    const authority = Uri.Authority.username(username, password);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static password(password: string): Uri {\n    const authority = Uri.Authority.password(password);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static host(host: AnyUriHost): Uri {\n    const authority = Uri.Authority.host(host);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostPart(part: string): Uri {\n    const authority = Uri.Authority.hostPart(part);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostName(address: string): Uri {\n    const authority = Uri.Authority.hostName(address);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostIPv4(address: string): Uri {\n    const authority = Uri.Authority.hostIPv4(address);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static hostIPv6(address: string): Uri {\n    const authority = Uri.Authority.hostIPv6(address);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static port(port: AnyUriPort): Uri {\n    const authority = Uri.Authority.port(port);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static portPart(part: string): Uri {\n    const authority = Uri.Authority.portPart(part);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static portNumber(number: number): Uri {\n    const authority = Uri.Authority.portNumber(number);\n    return Uri.from(void 0, authority, void 0, void 0, void 0);\n  }\n\n  static path(...components: AnyUriPath[]): Uri {\n    const path = Uri.Path.from.apply(void 0, components);\n    return Uri.from(void 0, void 0, path, void 0, void 0);\n  }\n\n  static pathPart(part: string): Uri {\n    const path = Uri.Path.parse(part);\n    return Uri.from(void 0, void 0, path, void 0, void 0);\n  }\n\n  static query(query: AnyUriQuery): Uri {\n    query = Uri.Query.fromAny(query);\n    return Uri.from(void 0, void 0, void 0, query, void 0);\n  }\n\n  static queryPart(part: string): Uri {\n    const query = Uri.Query.parse(part);\n    return Uri.from(void 0, void 0, void 0, query, void 0);\n  }\n\n  static fragment(fragment: AnyUriFragment): Uri {\n    fragment = Uri.Fragment.fromAny(fragment);\n    return Uri.from(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  static fragmentPart(part: string): Uri {\n    const fragment = Uri.Fragment.parse(part);\n    return Uri.from(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  static fragmentIdentifier(identifier: string): Uri {\n    const fragment = Uri.Fragment.from(identifier);\n    return Uri.from(void 0, void 0, void 0, void 0, fragment);\n  }\n\n  static standardParser(): UriParser {\n    if (!this._standardParser) {\n      this._standardParser = new Uri.Parser();\n    }\n    return this._standardParser;\n  }\n\n  static parse(string: string): Uri {\n    return Uri.standardParser().parseAbsoluteString(string);\n  }\n\n  /** @hidden */\n  static isUnreservedChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c === 45/*'-'*/ || c === 46/*'.'*/\n        || c === 95/*'_'*/ || c === 126/*'~'*/;\n  }\n\n  /** @hidden */\n  static isSubDelimChar(c: number): boolean {\n    return c === 33/*'!'*/ || c === 36/*'$'*/\n        || c === 38/*'&'*/ || c === 40/*'('*/\n        || c === 41/*')'*/ || c === 42/*'*'*/\n        || c === 43/*'+'*/ || c === 44/*','*/\n        || c === 59/*';'*/ || c === 61/*'='*/\n        || c === 39/*'\\''*/;\n  }\n\n  /** @hidden */\n  static isSchemeChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c === 43/*'+'*/ || c === 45/*'-'*/\n        || c === 46/*'.'*/;\n  }\n\n  /** @hidden */\n  static isUserInfoChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 58/*':'*/;\n  }\n\n  /** @hidden */\n  static isUserChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c);\n  }\n\n  /** @hidden */\n  static isHostChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c);\n  }\n\n  /** @hidden */\n  static isPathChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 58/*':'*/ || c === 64/*'@'*/;\n  }\n\n  /** @hidden */\n  static isQueryChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 47/*'/'*/ || c === 58/*':'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/;\n  }\n\n  /** @hidden */\n  static isParamChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || c === 33/*'!'*/ || c === 36/*'$'*/\n        || c === 40/*'('*/ || c === 41/*')'*/\n        || c === 42/*'*'*/ || c === 43/*'+'*/\n        || c === 44/*','*/ || c === 47/*'/'*/\n        || c === 58/*':'*/ || c === 59/*';'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/\n        || c === 39/*'\\''*/;\n  }\n\n  /** @hidden */\n  static isFragmentChar(c: number): boolean {\n    return Uri.isUnreservedChar(c)\n        || Uri.isSubDelimChar(c)\n        || c === 47/*'/'*/ || c === 58/*':'*/\n        || c === 63/*'?'*/ || c === 64/*'@'*/;\n  }\n\n  /** @hidden */\n  static isAlpha(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/;\n  }\n\n  /** @hidden */\n  static toLowerCase(c: number): number {\n    if (c >= 65/*'A'*/ && c <= 90/*'Z'*/) {\n      return c + (97/*'a'*/ - 65/*'A'*/);\n    } else {\n      return c;\n    }\n  }\n\n  /** @hidden */\n  static writeScheme(scheme: string, output: Output): void {\n    for (let i = 0, n = scheme.length; i < n; i += 1) {\n      const c = scheme.charCodeAt(i);\n      if (i > 0 && Uri.isSchemeChar(c) || i === 0 && Uri.isAlpha(c)) {\n        output = output.write(c);\n      } else {\n        throw new UriException(\"Invalid scheme: \" + scheme);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeUserInfo(userInfo: string, output: Output): void {\n    for (let i = 0, n = userInfo.length; i < n; i += 1) {\n      const c = userInfo.charCodeAt(i);\n      if (Uri.isUserInfoChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeUser(user: string, output: Output): void {\n    for (let i = 0, n = user.length; i < n; i += 1) {\n      const c = user.charCodeAt(i);\n      if (Uri.isUserChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeHost(address: string, output: Output): void {\n    for (let i = 0, n = address.length; i < n; i += 1) {\n      const c = address.charCodeAt(i);\n      if (Uri.isHostChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeHostLiteral(address: string, output: Output): void {\n    for (let i = 0, n = address.length; i < n; i += 1) {\n      const c = address.charCodeAt(i);\n      if (Uri.isHostChar(c) || c === 58/*':'*/) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writePathSegment(segment: string, output: Output): void {\n    for (let i = 0, n = segment.length; i < n; i += 1) {\n      const c = segment.charCodeAt(i);\n      if (Uri.isPathChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeQuery(query: string, output: Output): void {\n    for (let i = 0, n = query.length; i < n; i += 1) {\n      const c = query.charCodeAt(i);\n      if (Uri.isQueryChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeParam(param: string, output: Output): void {\n    for (let i = 0, n = param.length; i < n; i += 1) {\n      const c = param.charCodeAt(i);\n      if (Uri.isParamChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeFragment(fragment: string, output: Output): void {\n    for (let i = 0, n = fragment.length; i < n; i += 1) {\n      const c = fragment.charCodeAt(i);\n      if (Uri.isFragmentChar(c)) {\n        output = output.write(c);\n      } else {\n        Uri.writeEncoded(c, output);\n      }\n    }\n  }\n\n  /** @hidden */\n  static writeEncoded(c: number, output: Output): void {\n    if (c === 0x00) { // modified UTF-8\n      Uri.writePctEncoded(0xC0, output);\n      Uri.writePctEncoded(0x80, output);\n    } else if (c >= 0x00 && c <= 0x7F) { // U+0000..U+007F\n      Uri.writePctEncoded(c, output);\n    } else if (c >= 0x80 && c <= 0x07FF) { // U+0080..U+07FF\n      Uri.writePctEncoded(0xC0 | (c >>> 6), output);\n      Uri.writePctEncoded(0x80 | (c & 0x3F), output);\n    } else if (c >= 0x0800 && c <= 0xFFFF    // U+0800..U+D7FF\n            || c >= 0xE000 && c <= 0xFFFF) { // U+E000..U+FFFF\n      Uri.writePctEncoded(0xE0 | (c >>> 12), output);\n      Uri.writePctEncoded(0x80 | (c >>>  6 & 0x3F), output);\n      Uri.writePctEncoded(0x80 | (c        & 0x3F), output);\n    } else if (c >= 0x10000 && c <= 0x10FFFF) { // U+10000..U+10FFFF\n      Uri.writePctEncoded(0xF0 | (c >>> 18), output);\n      Uri.writePctEncoded(0x80 | (c >>> 12 & 0x3F), output);\n      Uri.writePctEncoded(0x80 | (c >>>  6 & 0x3F), output);\n      Uri.writePctEncoded(0x80 | (c        & 0x3F), output);\n    } else { // surrogate or invalid code point\n      Uri.writePctEncoded(0xEF, output);\n      Uri.writePctEncoded(0xBF, output);\n      Uri.writePctEncoded(0xBD, output);\n    }\n  }\n\n  /** @hidden */\n  static writePctEncoded(c: number, output: Output) {\n    output = output.write(37/*'%'*/)\n          .write(Base16.lowercase().encodeDigit(c >>> 4 & 0xF))\n          .write(Base16.lowercase().encodeDigit(c       & 0xF));\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Scheme: typeof UriScheme; // defined by UriScheme\n  /** @hidden */\n  static Authority: typeof UriAuthority; // defined by UriAuthority\n  /** @hidden */\n  static User: typeof UriUser; // defined by UriUser\n  /** @hidden */\n  static Host: typeof UriHost; // defined by UriHost\n  /** @hidden */\n  static HostName: typeof UriHostName; // defined by UriHostName\n  /** @hidden */\n  static HostIPv4: typeof UriHostIPv4; // defined by UriHostIPv4\n  /** @hidden */\n  static HostIPv6: typeof UriHostIPv6; // defined by UriHostIPv6\n  /** @hidden */\n  static HostUndefined: typeof UriHostUndefined; // defined by UriHostUndefined\n  /** @hidden */\n  static Port: typeof UriPort; // defined by UriPort\n  /** @hidden */\n  static Path: typeof UriPath; // defined by UriPath\n  /** @hidden */\n  static PathSegment: typeof UriPathSegment; // defined by UriPathSegment\n  /** @hidden */\n  static PathSlash: typeof UriPathSlash; // defined by UriPathSlash\n  /** @hidden */\n  static PathEmpty: typeof UriPathEmpty; // defined by UriPathEmpty\n  /** @hidden */\n  static PathBuilder: typeof UriPathBuilder; // defined by UriPathBuilder\n  /** @hidden */\n  static Query: typeof UriQuery; // defined by UriQuery\n  /** @hidden */\n  static QueryParam: typeof UriQueryParam; // defined by UriQueryParam\n  /** @hidden */\n  static QueryUndefined: typeof UriQueryUndefined; // defined by UriQueryUndefined\n  /** @hidden */\n  static QueryBuilder: typeof UriQueryBuilder; // defined by UriQueryBuilder\n  /** @hidden */\n  static Fragment: typeof UriFragment; // defined by UriFragment\n  /** @hidden */\n  static Parser: typeof UriParser; // defined by UriParser\n  /** @hidden */\n  static Form: typeof UriForm; // defined by UriForm\n  /** @hidden */\n  static PathForm: typeof UriPathForm; // defined by UriPathForm\n\n  private static _form?: Form<Uri>;\n\n  static form(): Form<Uri> {\n    if (!Uri._form) {\n      Uri._form = new Uri.Form(Uri.empty());\n    }\n    return Uri._form;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheMap} from \"@swim/util\";\nimport {Output, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\nexport type AnyUriScheme = UriScheme | string;\n\nexport class UriScheme implements Comparable<UriScheme>, HashCode, Debug, Display {\n  /** @hidden */\n  readonly _name: string;\n\n  /** @hidden */\n  constructor(name: string) {\n    this._name = name;\n  }\n\n  isDefined(): boolean {\n    return this._name.length !== 0;\n  }\n\n  name(): string {\n    return this._name;\n  }\n\n  toAny(): string | undefined {\n    return this._name.length !== 0 ? this._name : void 0;\n  }\n\n  compareTo(that: UriScheme): 0 | 1 | -1 {\n    const order = this._name.localeCompare(that._name);\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriScheme) {\n      return this._name === that._name;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.hash(this._name);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriScheme\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    Uri.writeScheme(this._name, output);\n  }\n\n  toString(): string {\n    return this._name;\n  }\n\n  private static _undefined?: UriScheme;\n\n  private static _cache?: HashGenCacheMap<string, UriScheme>;\n\n  static undefined(): UriScheme {\n    if (UriScheme._undefined === void 0) {\n      UriScheme._undefined = new UriScheme(\"\");\n    }\n    return UriScheme._undefined;\n  }\n\n  static from(name: string): UriScheme {\n    const cache = UriScheme.cache();\n    const scheme = cache.get(name);\n    if (scheme) {\n      return scheme;\n    } else {\n      return cache.put(name, new UriScheme(name));\n    }\n  }\n\n  static fromAny(scheme: AnyUriScheme | null | undefined): UriScheme {\n    if (scheme === null || scheme === void 0) {\n      return UriScheme.undefined();\n    } else if (scheme instanceof UriScheme) {\n      return scheme;\n    } else if (typeof scheme === \"string\") {\n      return UriScheme.parse(scheme);\n    } else {\n      throw new TypeError(\"\" + scheme);\n    }\n  }\n\n  static parse(string: string): UriScheme {\n    return Uri.standardParser().parseSchemeString(string);\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheMap<string, UriScheme> {\n    if (UriScheme._cache === void 0) {\n      const cacheSize = 4;\n      UriScheme._cache = new HashGenCacheMap<string, UriScheme>(cacheSize);\n    }\n    return UriScheme._cache;\n  }\n}\nUri.Scheme = UriScheme;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3} from \"@swim/util\";\nimport {Output, Format, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {AnyUriUser, UriUserInit, UriUser} from \"./UriUser\";\nimport {AnyUriHost, UriHost} from \"./UriHost\";\nimport {AnyUriPort, UriPort} from \"./UriPort\";\n\nexport type AnyUriAuthority = UriAuthority | UriAuthorityInit | string;\n\nexport interface UriAuthorityInit extends UriUserInit {\n  user?: AnyUriUser;\n  host?: AnyUriHost;\n  port?: AnyUriPort;\n}\n\nexport class UriAuthority implements Comparable<UriAuthority>, HashCode, Debug, Display {\n  /** @hidden */\n  readonly _user: UriUser;\n  /** @hidden */\n  readonly _host: UriHost;\n  /** @hidden */\n  readonly _port: UriPort;\n  /** @hidden */\n  _string?: string;\n  /** @hidden */\n  _hashCode?: number;\n\n  /** @hidden */\n  constructor(user: UriUser, host: UriHost, port: UriPort) {\n    this._user = user;\n    this._host = host;\n    this._port = port;\n  }\n\n  isDefined(): boolean {\n    return this._user.isDefined() || this._host.isDefined() || this._port.isDefined();\n  }\n\n  user(): UriUser;\n  user(user: AnyUriUser): UriAuthority;\n  user(user?: AnyUriUser): UriUser | UriAuthority {\n    if (user === void 0) {\n      return this._user;\n    } else {\n      user = Uri.User.fromAny(user);\n      if (user !== this._user) {\n        return this.copy(user, this._host, this._port);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  userPart(): string;\n  userPart(user: string): UriAuthority;\n  userPart(user?: string): string | UriAuthority {\n    if (user === void 0) {\n      return this._user.toString();\n    } else {\n      return this.user(Uri.User.parse(user));\n    }\n  }\n\n  username(): string;\n  username(username: string, password?: string | null): UriAuthority;\n  username(username?: string, password?: string | null): string | UriAuthority {\n    if (username === void 0) {\n      return this._user._username || \"\";\n    } else if (password === void 0) {\n      return this.user(this._user.username(username));\n    } else {\n      return this.user(Uri.User.from(username, password));\n    }\n  }\n\n  password(): string | null;\n  password(password: string | null): UriAuthority;\n  password(password?: string | null): string | null | UriAuthority {\n    if (password === void 0) {\n      return this._user.password();\n    } else {\n      return this.user(this._user.password(password));\n    }\n  }\n\n  host(): UriHost;\n  host(host: AnyUriHost): UriAuthority;\n  host(host?: AnyUriHost): UriHost | UriAuthority {\n    if (host === void 0) {\n      return this._host;\n    } else {\n      host = Uri.Host.fromAny(host);\n      if (host !== this._host) {\n        return this.copy(this._user, host, this._port);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  hostPart(): string;\n  hostPart(host: string): UriAuthority;\n  hostPart(host?: string): string | UriAuthority {\n    if (host === void 0) {\n      return this._host.toString();\n    } else {\n      return this.host(Uri.Host.parse(host));\n    }\n  }\n\n  hostAddress(): string {\n    return this._host.address();\n  }\n\n  hostName(): string | null;\n  hostName(address: string): UriAuthority;\n  hostName(address?: string): string | null | UriAuthority {\n    if (address === void 0) {\n      return this._host.name();\n    } else {\n      return this.host(Uri.Host.from(address));\n    }\n  }\n\n  hostIPv4(): string | null;\n  hostIPv4(address: string): UriAuthority;\n  hostIPv4(address?: string): string | null | UriAuthority {\n    if (address === void 0) {\n      return this._host.ipv4();\n    } else {\n      return this.host(Uri.Host.ipv4(address));\n    }\n  }\n\n  hostIPv6(): string | null;\n  hostIPv6(address: string): UriAuthority;\n  hostIPv6(address?: string): string | null | UriAuthority {\n    if (address === void 0) {\n      return this._host.ipv6();\n    } else {\n      return this.host(Uri.Host.ipv6(address));\n    }\n  }\n\n  port(): UriPort;\n  port(port: AnyUriPort): UriAuthority;\n  port(port?: AnyUriPort): UriPort | UriAuthority {\n    if (port === void 0) {\n      return this._port;\n    } else {\n      port = Uri.Port.fromAny(port);\n      if (port !== this._port) {\n        return this.copy(this._user, this._host, port);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  portPart(): string;\n  portPart(port: string): UriAuthority;\n  portPart(port?: string): string | UriAuthority {\n    if (port === void 0) {\n      return this._port.toString();\n    } else {\n      return this.port(Uri.Port.parse(port));\n    }\n  }\n\n  portNumber(): number;\n  portNumber(port: number): UriAuthority;\n  portNumber(port?: number): number | UriAuthority {\n    if (port === void 0) {\n      return this._port.number();\n    } else {\n      return this.port(Uri.Port.from(port));\n    }\n  }\n\n  protected copy(user: UriUser, host: UriHost, port: UriPort): UriAuthority {\n    return UriAuthority.from(user, host, port);\n  }\n\n  toAny(authority?: {username?: string, password?: string, host?: string, port?: number}):\n      {username?: string, password?: string, host?: string, port?: number} | undefined {\n    if (this.isDefined()) {\n      authority = authority || {};\n      this._user.toAny(authority);\n      if (this._host.isDefined()) {\n        authority.host = this._host.toAny();\n      }\n      if (this._port.isDefined()) {\n        authority.port = this._port.toAny();\n      }\n    }\n    return authority;\n  }\n\n  compareTo(that: UriAuthority): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriAuthority) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this.toString());\n    }\n    return this._hashCode;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriAuthority\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    if (this._string !== void 0) {\n      output = output.write(this._string);\n    } else {\n      if (this._user.isDefined()) {\n        output.display(this._user).write(64/*'@'*/);\n      }\n      output.display(this._host);\n      if (this._port.isDefined()) {\n        output = output.write(58/*':'*/).display(this._port);\n      }\n    }\n  }\n\n  toString(): string {\n    if (this._string === void 0) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n\n  private static _undefined?: UriAuthority;\n\n  static undefined(): UriAuthority {\n    if (UriAuthority._undefined === void 0) {\n      UriAuthority._undefined = new UriAuthority(Uri.User.undefined(), Uri.Host.undefined(), Uri.Port.undefined());\n    }\n    return UriAuthority._undefined;\n  }\n\n  static from(user: UriUser = Uri.User.undefined(),\n              host: UriHost = Uri.Host.undefined(),\n              port: UriPort = Uri.Port.undefined()): UriAuthority {\n    if (user.isDefined() || host.isDefined() || port.isDefined()) {\n      return new UriAuthority(user, host, port);\n    } else {\n      return UriAuthority.undefined();\n    }\n  }\n\n  static fromAny(authority: AnyUriAuthority | null | undefined): UriAuthority {\n    if (authority === null || authority === void 0) {\n      return UriAuthority.undefined();\n    } else if (authority instanceof UriAuthority) {\n      return authority;\n    } else if (typeof authority === \"object\") {\n      const user = Uri.User.fromAny(authority.user || authority);\n      const host = Uri.Host.fromAny(authority.host);\n      const port = Uri.Port.fromAny(authority.port);\n      return UriAuthority.from(user, host, port);\n    } else if (typeof authority === \"string\") {\n      return UriAuthority.parse(authority);\n    } else {\n      throw new TypeError(\"\" + authority);\n    }\n  }\n\n  static user(user: AnyUriUser): UriAuthority {\n    user = Uri.User.fromAny(user);\n    return UriAuthority.from(user, void 0, void 0);\n  }\n\n  static userPart(part: string): UriAuthority {\n    const user = Uri.User.parse(part);\n    return UriAuthority.from(user, void 0, void 0);\n  }\n\n  static username(username: string, password?: string | null): UriAuthority {\n    const user = Uri.User.from(username, password);\n    return UriAuthority.from(user, void 0, void 0);\n  }\n\n  static password(password: string): UriAuthority {\n    const user = Uri.User.from(\"\", password);\n    return UriAuthority.from(user, void 0, void 0);\n  }\n\n  static host(host: AnyUriHost): UriAuthority {\n    host = Uri.Host.fromAny(host);\n    return UriAuthority.from(void 0, host, void 0);\n  }\n\n  static hostPart(part: string): UriAuthority {\n    const host = Uri.Host.parse(part);\n    return UriAuthority.from(void 0, host, void 0);\n  }\n\n  static hostName(address: string): UriAuthority {\n    const host = Uri.Host.from(address);\n    return UriAuthority.from(void 0, host, void 0);\n  }\n\n  static hostIPv4(address: string): UriAuthority {\n    const host = Uri.Host.ipv4(address);\n    return UriAuthority.from(void 0, host, void 0);\n  }\n\n  static hostIPv6(address: string): UriAuthority {\n    const host = Uri.Host.ipv6(address);\n    return UriAuthority.from(void 0, host, void 0);\n  }\n\n  static port(port: AnyUriPort): UriAuthority {\n    port = Uri.Port.fromAny(port);\n    return UriAuthority.from(void 0, void 0, port);\n  }\n\n  static portPart(part: string): UriAuthority {\n    const port = Uri.Port.parse(part);\n    return UriAuthority.from(void 0, void 0, port);\n  }\n\n  static portNumber(number: number): UriAuthority {\n    const port = Uri.Port.from(number);\n    return UriAuthority.from(void 0, void 0, port);\n  }\n\n  static parse(string: string): UriAuthority {\n    return Uri.standardParser().parseAuthorityString(string);\n  }\n}\nUri.Authority = UriAuthority;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode, Murmur3} from \"@swim/util\";\nimport {Output, Format, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\nexport type AnyUriUser = UriUser | UriUserInit | string;\n\nexport interface UriUserInit {\n  username?: string;\n  password?: string | null;\n}\n\nexport class UriUser implements HashCode, Debug, Display {\n  /** @hidden */\n  readonly _username: string | null;\n  /** @hidden */\n  readonly _password: string | null;\n\n  /** @hidden */\n  constructor(username: string | null, password: string | null) {\n    this._username = username;\n    this._password = password;\n  }\n\n  isDefined(): boolean {\n    return this._username !== null;\n  }\n\n  username(): string;\n  username(username: string): UriUser;\n  username(username?: string): string | UriUser {\n    if (username === void 0) {\n      return this._username || \"\";\n    } else {\n      if (username !== this._username) {\n        return this.copy(username, this._password);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  password(): string | null;\n  password(password: string | null): UriUser;\n  password(password?: string | null): string | null | UriUser {\n    if (password === void 0) {\n      return this._password;\n    } else {\n      if (password !== this._password) {\n        return this.copy(this._username, password);\n      } else {\n        return this;\n      }\n    }\n  }\n\n  protected copy(username: string | null, password: string | null): UriUser {\n    return UriUser.from(username, password);\n  }\n\n  toAny(user?: {username?: string, password?: string}): {username?: string, password?: string} | undefined {\n    if (this._username !== null) {\n      user = user || {};\n      user.username = this._username;\n      if (this._password !== null) {\n        user.password = this._password;\n      }\n    }\n    return user;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriUser) {\n      return this._username === that._username && this._password === that._password;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (UriUser._hashSeed === void 0) {\n      UriUser._hashSeed = Murmur3.seed(UriUser);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(UriUser._hashSeed,\n        Murmur3.hash(this._username)), Murmur3.hash(this._password)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriUser\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    if (this._username != null) {\n      Uri.writeUser(this._username, output);\n      if (this._password != null) {\n        output = output.write(58/*':'*/);\n        Uri.writeUser(this._password, output);\n      }\n    }\n  }\n\n  toString(): string {\n    return Format.display(this);\n  }\n\n  private static _hashSeed?: number;\n\n  private static _undefined?: UriUser;\n\n  static undefined(): UriUser {\n    if (UriUser._undefined === void 0) {\n      UriUser._undefined = new UriUser(null, null);\n    }\n    return UriUser._undefined;\n  }\n\n  static from(username: string | null, password: string | null = null): UriUser {\n    if (username !== null || password !== null) {\n      return new UriUser(username || \"\", password);\n    } else {\n      return UriUser.undefined();\n    }\n  }\n\n  static fromAny(user: AnyUriUser | null | undefined): UriUser {\n    if (user === null || user === void 0) {\n      return UriUser.undefined();\n    } else if (user instanceof UriUser) {\n      return user;\n    } else if (typeof user === \"object\") {\n      const username = typeof user.username === \"string\" ? user.username : null;\n      const password = typeof user.password === \"string\" ? user.password : null;\n      return UriUser.from(username, password);\n    } else if (typeof user === \"string\") {\n      return UriUser.parse(user);\n    } else {\n      throw new TypeError(\"\" + user);\n    }\n  }\n\n  static parse(string: string): UriUser {\n    return Uri.standardParser().parseUserString(string);\n  }\n}\nUri.User = UriUser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheMap} from \"@swim/util\";\nimport {Output, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\nexport type AnyUriHost = UriHost | string;\n\nexport abstract class UriHost implements Comparable<UriHost>, HashCode, Debug, Display {\n  /** @hidden */\n  _hashCode?: number;\n\n  protected constructor() {\n    // stub\n  }\n\n  isDefined(): boolean {\n    return true;\n  }\n\n  abstract address(): string;\n\n  name(): string | null {\n    return null;\n  }\n\n  ipv4(): string | null {\n    return null;\n  }\n\n  ipv6(): string | null {\n    return null;\n  }\n\n  toAny(): string {\n    return this.toString();\n  }\n\n  compareTo(that: UriHost): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriHost) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this.toString());\n    }\n    return this._hashCode;\n  }\n\n  abstract debug(output: Output): void;\n\n  abstract display(output: Output): void;\n\n  abstract toString(): string;\n\n  private static _undefined?: UriHost;\n\n  private static _cache?: HashGenCacheMap<string, UriHost>;\n\n  static undefined(): UriHost {\n    if (UriHost._undefined === void 0) {\n      UriHost._undefined = new Uri.HostUndefined();\n    }\n    return UriHost._undefined;\n  }\n\n  static from(address: string): UriHost {\n    const cache = UriHost.cache();\n    const host = cache.get(address);\n    if (host instanceof Uri.HostName) {\n      return host;\n    } else {\n      return cache.put(address, new Uri.HostName(address));\n    }\n  }\n\n  static ipv4(address: string): UriHost {\n    const cache = UriHost.cache();\n    const host = cache.get(address);\n    if (host instanceof Uri.HostIPv4) {\n      return host;\n    } else {\n      return cache.put(address, new Uri.HostIPv4(address));\n    }\n  }\n\n  static ipv6(address: string): UriHost {\n    const cache = UriHost.cache();\n    const host = cache.get(address);\n    if (host instanceof Uri.HostIPv6) {\n      return host;\n    } else {\n      return cache.put(address, new Uri.HostIPv6(address));\n    }\n  }\n\n  static fromAny(host: AnyUriHost | null | undefined): UriHost {\n    if (host === null || host === void 0) {\n      return UriHost.undefined();\n    } else if (host instanceof UriHost) {\n      return host;\n    } else if (typeof host === \"string\") {\n      return UriHost.parse(host);\n    } else {\n      throw new TypeError(\"\" + host);\n    }\n  }\n\n  static parse(string: string): UriHost {\n    return Uri.standardParser().parseHostString(string);\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheMap<string, UriHost> {\n    if (UriHost._cache === void 0) {\n      const cacheSize = 16;\n      UriHost._cache = new HashGenCacheMap<string, UriHost>(cacheSize);\n    }\n    return UriHost._cache;\n  }\n}\nUri.Host = UriHost;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\n\n/** @hidden */\nexport class UriHostName extends UriHost {\n  /** @hidden */\n  readonly _address: string;\n\n  /** @hidden */\n  constructor(address: string) {\n    super();\n    this._address = address;\n  }\n\n  address(): string {\n    return this._address;\n  }\n\n  name(): string {\n    return this._address;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"from\")\n        .write(40/*'('*/).debug(this._address).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    Uri.writeHost(this._address, output);\n  }\n\n  toString(): string {\n    return this._address;\n  }\n}\nUri.HostName = UriHostName;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\n\n/** @hidden */\nexport class UriHostIPv4 extends UriHost {\n  /** @hidden */\n  readonly _address: string;\n\n  /** @hidden */\n  constructor(address: string) {\n    super();\n    this._address = address;\n  }\n\n  address(): string {\n    return this._address;\n  }\n\n  ipv4(): string {\n    return this._address;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"ipv4\")\n        .write(40/*'('*/).debug(this._address).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    Uri.writeHost(this._address, output);\n  }\n\n  toString(): string {\n    return this._address;\n  }\n}\nUri.HostIPv4 = UriHostIPv4;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\n\n/** @hidden */\nexport class UriHostIPv6 extends UriHost {\n  /** @hidden */\n  readonly _address: string;\n  /** @hidden */\n  _string: string;\n\n  /** @hidden */\n  constructor(address: string) {\n    super();\n    this._address = address;\n  }\n\n  address(): string {\n    return this._address;\n  }\n\n  ipv6(): string {\n    return this._address;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"ipv6\")\n        .write(40/*'('*/).debug(this._address).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    if (this._string != null) {\n      output = output.write(this._string);\n    } else {\n      output = output.write(91/*'['*/);\n      Uri.writeHostLiteral(this._address, output);\n      output = output.write(93/*']'*/);\n    }\n  }\n\n  toString(): string {\n    if (this._string == null) {\n      this._string = \"[\" + this.address + \"]\";\n    }\n    return this._string;\n  }\n}\nUri.HostIPv6 = UriHostIPv6;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\n\n/** @hidden */\nexport class UriHostUndefined extends UriHost {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  isDefined(): boolean {\n    return false;\n  }\n\n  address(): string {\n    return \"\";\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriHost\").write(46/*'.'*/).write(\"undefined\")\n        .write(40/*'('*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    // nop\n  }\n\n  toString(): string {\n    return \"\";\n  }\n}\nUri.HostUndefined = UriHostUndefined;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheMap} from \"@swim/util\";\nimport {Output, Format, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\nexport type AnyUriPort = UriPort | number | string;\n\nexport class UriPort implements Comparable<UriPort>, HashCode, Debug, Display {\n  /** @hidden */\n  readonly _number: number;\n\n  /** @hidden */\n  constructor(num: number) {\n    this._number = num;\n  }\n\n  isDefined(): boolean {\n    return this._number !== 0;\n  }\n\n  number(): number {\n    return this._number;\n  }\n\n  valueOf(): number {\n    return this._number;\n  }\n\n  toAny(): number {\n    return this._number;\n  }\n\n  compareTo(that: UriPort): 0 | 1 | -1 {\n    return this._number < that._number ? -1 : this._number > that._number ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriPort) {\n      return this._number === that._number;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (UriPort._hashSeed === void 0) {\n      UriPort._hashSeed = Murmur3.seed(UriPort);\n    }\n    return Murmur3.mash(Murmur3.mix(UriPort._hashSeed, this._number));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriPort\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"from\").write(40/*'('*/);\n      Format.displayNumber(this._number, output);\n      output = output.write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    Format.displayNumber(this._number, output);\n  }\n\n  toString(): string {\n    return \"\" + this._number;\n  }\n\n  private static _hashSeed?: number;\n\n  private static _undefined?: UriPort;\n\n  private static _cache?: HashGenCacheMap<number, UriPort>;\n\n  static undefined(): UriPort {\n    if (UriPort._undefined === void 0) {\n      UriPort._undefined = new UriPort(0);\n    }\n    return UriPort._undefined;\n  }\n\n  static from(number: number) {\n    if (number > 0) {\n      const cache = UriPort.cache();\n      const port = cache.get(number);\n      if (port !== void 0) {\n        return port;\n      } else {\n        return cache.put(number, new UriPort(number));\n      }\n    } else if (number === 0) {\n      return UriPort.undefined();\n    } else {\n      throw new TypeError(\"\" + number);\n    }\n  }\n\n  static fromAny(port: AnyUriPort | null | undefined): UriPort {\n    if (port === null || port === void 0) {\n      return UriPort.undefined();\n    } else if (port instanceof UriPort) {\n      return port;\n    } else if (typeof port === \"number\") {\n      return UriPort.from(port);\n    } else if (typeof port === \"string\") {\n      return UriPort.parse(port);\n    } else {\n      throw new TypeError(\"\" + port);\n    }\n  }\n\n  static parse(string: string): UriPort {\n    return Uri.standardParser().parsePortString(string);\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheMap<number, UriPort> {\n    if (UriPort._cache === void 0) {\n      const cacheSize = 4;\n      UriPort._cache = new HashGenCacheMap<number, UriPort>(cacheSize);\n    }\n    return UriPort._cache;\n  }\n}\nUri.Port = UriPort;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheSet} from \"@swim/util\";\nimport {Output, Debug, Display} from \"@swim/codec\";\nimport {Form} from \"@swim/structure\";\nimport {Uri} from \"./Uri\";\nimport {UriPathBuilder} from \"./UriPathBuilder\";\n\nexport type AnyUriPath = UriPath | string[] | string;\n\nexport abstract class UriPath implements Comparable<UriPath>, HashCode, Debug, Display {\n  /** @hidden */\n  _hashCode?: number;\n\n  /** @hidden */\n  protected constructor() {\n    // sealed\n  }\n\n  abstract isDefined(): boolean;\n\n  abstract isAbsolute(): boolean;\n\n  abstract isRelative(): boolean;\n\n  abstract isEmpty(): boolean;\n\n  get length(): number {\n    let n = 0;\n    let path = this as UriPath;\n    while (!path.isEmpty()) {\n      n += 1;\n      path = path.tail();\n    }\n    return n;\n  }\n\n  get(index: number): string | undefined {\n    let i = 0;\n    let path = this as UriPath;\n    while (!path.isEmpty()) {\n      if (i < index) {\n        i += 1;\n        path = path.tail();\n      } else {\n        return path.head();\n      }\n    }\n    return void 0;\n  }\n\n  abstract head(): string;\n\n  abstract tail(): UriPath;\n\n  /** @hidden */\n  abstract setTail(tail: UriPath): void;\n\n  /** @hidden */\n  abstract dealias(): UriPath;\n\n  abstract parent(): UriPath;\n\n  abstract base(): UriPath;\n\n  name(): string;\n  name(name: string): UriPath;\n  name(name?: string): string | UriPath {\n    if (name === void 0) {\n      if (this.isEmpty()) {\n        return \"\";\n      }\n      let path = this as UriPath;\n      do {\n        const tail = path.tail();\n        if (tail.isEmpty()) {\n          return path.isRelative() ? path.head() : \"\";\n        } else {\n          path = tail;\n        }\n      } while (true);\n    } else {\n      const builder = new Uri.PathBuilder();\n      builder.addPath(this.base());\n      builder.addSegment(name);\n      return builder.bind();\n    }\n  }\n\n  foot(): UriPath {\n    if (this.isEmpty()) {\n      return this;\n    }\n    let path = this as UriPath;\n    do {\n      const tail = path.tail();\n      if (tail.isEmpty()) {\n        return path;\n      } else {\n        path = tail;\n      }\n    } while (true);\n  }\n\n  isSubpathOf(b: AnyUriPath): boolean {\n    b = UriPath.fromAny(b);\n    let a = this as UriPath;\n    while (!a.isEmpty() && !b.isEmpty()) {\n      if (a.head() !== b.head()) {\n        return false;\n      }\n      a = a.tail();\n      b = b.tail();\n    }\n    return b.isEmpty();\n  }\n\n  appended(...components: AnyUriPath[]): UriPath {\n    if (arguments.length > 0) {\n      const builder = new Uri.PathBuilder();\n      builder.addPath(this);\n      builder.push.apply(builder, arguments);\n      return builder.bind();\n    } else {\n      return this;\n    }\n  }\n\n  appendedSlash(): UriPath {\n    const builder = new Uri.PathBuilder();\n    builder.addPath(this);\n    builder.addSlash();\n    return builder.bind();\n  }\n\n  appendedSegment(segment: string): UriPath {\n    const builder = new Uri.PathBuilder();\n    builder.addPath(this);\n    builder.addSegment(segment);\n    return builder.bind();\n  }\n\n  prepended(...components: AnyUriPath[]): UriPath {\n    if (arguments.length > 0) {\n      const builder = new Uri.PathBuilder();\n      builder.push.apply(builder, arguments);\n      builder.addPath(this);\n      return builder.bind();\n    } else {\n      return this;\n    }\n  }\n\n  prependedSlash(): UriPath {\n    return UriPath.slash(this);\n  }\n\n  prependedSegment(segment: string): UriPath {\n    if (this.isEmpty() || this.isAbsolute()) {\n      return UriPath.segment(segment, this);\n    } else {\n      return UriPath.segment(segment, UriPath.slash(this));\n    }\n  }\n\n  resolve(that: UriPath): UriPath {\n    if (that.isEmpty()) {\n      return this;\n    } else if (that.isAbsolute() || this.isEmpty()) {\n      return that.removeDotSegments();\n    } else {\n      return this.merge(that).removeDotSegments();\n    }\n  }\n\n  removeDotSegments(): UriPath {\n    let path = this as UriPath;\n    const builder = new Uri.PathBuilder();\n    while (!path.isEmpty()) {\n      const head = path.head();\n      if (head === \".\" || head === \"..\") {\n        path = path.tail();\n        if (!path.isEmpty()) {\n          path = path.tail();\n        }\n      } else if (path.isAbsolute()) {\n        const rest = path.tail();\n        if (!rest.isEmpty()) {\n          const next = rest.head();\n          if (next === \".\") {\n            path = rest.tail();\n            if (path.isEmpty()) {\n              path = UriPath.slash();\n            }\n          } else if (next === \"..\") {\n            path = rest.tail();\n            if (path.isEmpty()) {\n              path = UriPath.slash();\n            }\n            if (!builder.isEmpty() && !builder.pop().isAbsolute()) {\n              if (!builder.isEmpty()) {\n                builder.pop();\n              }\n            }\n          } else {\n            builder.push(head, next);\n            path = rest.tail();\n          }\n        } else {\n          builder.push(path.head());\n          path = path.tail();\n        }\n      } else {\n        builder.push(path.head());\n        path = path.tail();\n      }\n    }\n    return builder.bind();\n  }\n\n  merge(that: UriPath): UriPath {\n    if (!this.isEmpty()) {\n      const builder = new Uri.PathBuilder();\n      let prev = this as UriPath;\n      do {\n        const next = prev.tail();\n        if (!next.isEmpty()) {\n          if (prev.isAbsolute()) {\n            builder.addSlash();\n          } else {\n            builder.addSegment(prev.head());\n          }\n          prev = next;\n        } else {\n          if (prev.isAbsolute()) {\n            builder.addSlash();\n          }\n          break;\n        }\n      } while (true);\n      builder.addPath(that);\n      return builder.bind();\n    } else {\n      return that;\n    }\n  }\n\n  unmerge(relative: UriPath, root: UriPath = relative): UriPath {\n    let base = this as UriPath;\n    do {\n      if (base.isEmpty()) {\n        if (!relative.isEmpty() && !relative.tail().isEmpty()) {\n          return relative.tail();\n        } else {\n          return relative;\n        }\n      } else if (base.isRelative()) {\n        return relative;\n      } else if (relative.isRelative()) {\n        return UriPath.slash(relative);\n      } else {\n        let a = base.tail();\n        let b = relative.tail();\n        if (!a.isEmpty() && b.isEmpty()) {\n          return UriPath.slash();\n        } else if (a.isEmpty() || b.isEmpty() || a.head() !== b.head()) {\n          return b;\n        } else {\n          a = a.tail();\n          b = b.tail();\n          if (!a.isEmpty() && b.isEmpty()) {\n            return root;\n          } else {\n            base = a;\n            relative = b;\n          }\n        }\n      }\n    } while (true);\n  }\n\n  toAny(): string[] {\n    const components = [];\n    let path = this as UriPath;\n    while (!path.isEmpty()) {\n      components.push(path.head());\n      path = path.tail();\n    }\n    return components;\n  }\n\n  compareTo(that: UriPath): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriPath) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this.toString());\n    }\n    return this._hashCode;\n  }\n\n  abstract debug(output: Output): void;\n\n  display(output: Output): void {\n    let path = this as UriPath;\n    while (!path.isEmpty()) {\n      if (path.isAbsolute()) {\n        output = output.write(47/*'/'*/);\n      } else {\n        Uri.writePathSegment(path.head(), output);\n      }\n      path = path.tail();\n    }\n  }\n\n  abstract toString(): string;\n\n  private static _empty?: UriPath;\n\n  private static _slash?: UriPath;\n\n  private static _segmentCache?: HashGenCacheSet<string>;\n\n  static builder(): UriPathBuilder {\n    return new Uri.PathBuilder();\n  }\n\n  static empty(): UriPath {\n    if (UriPath._empty === void 0) {\n      UriPath._empty = new Uri.PathEmpty();\n    }\n    return UriPath._empty;\n  }\n\n  static slash(tail: UriPath = UriPath.empty()): UriPath {\n    if (tail === UriPath.empty()) {\n      if (UriPath._slash === void 0) {\n        UriPath._slash = new Uri.PathSlash(tail);\n      }\n      return UriPath._slash;\n    } else {\n      return new Uri.PathSlash(tail);\n    }\n  }\n\n  static segment(segment: string, tail: UriPath = UriPath.empty()): UriPath {\n    segment = this.cacheSegment(segment);\n    return new Uri.PathSegment(segment, tail);\n  }\n\n  static from(...components: AnyUriPath[]): UriPath {\n    const builder = new Uri.PathBuilder();\n    builder.push.apply(builder, arguments);\n    return builder.bind();\n  }\n\n  static fromAny(path: AnyUriPath | null | undefined): UriPath {\n    if (path === null || path === void 0) {\n      return UriPath.empty();\n    } else if (path instanceof UriPath) {\n      return path;\n    } else if (Array.isArray(path)) {\n      return UriPath.from.apply(void 0, arguments);\n    } else if (typeof path === \"string\") {\n      return UriPath.parse(path);\n    } else {\n      throw new TypeError(\"\" + path);\n    }\n  }\n\n  static parse(string: string): UriPath {\n    return Uri.standardParser().parsePathString(string);\n  }\n\n  /** @hidden */\n  static segmentCache(): HashGenCacheSet<string> {\n    if (UriPath._segmentCache === void 0) {\n      const segmentCacheSize = 64;\n      UriPath._segmentCache = new HashGenCacheSet<string>(segmentCacheSize);\n    }\n    return UriPath._segmentCache;\n  }\n\n  /** @hidden */\n  static cacheSegment(segment: string): string {\n    if (segment.length <= 32) {\n      return this.segmentCache().put(segment);\n    } else {\n      return segment;\n    }\n  }\n\n  private static _pathForm?: Form<UriPath>;\n\n  static pathForm(): Form<UriPath> {\n    if (!UriPath._pathForm) {\n      UriPath._pathForm = new Uri.PathForm(UriPath.empty());\n    }\n    return UriPath._pathForm;\n  }\n}\nUri.Path = UriPath;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, Format} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriPath} from \"./UriPath\";\n\n/** @hidden */\nexport class UriPathSegment extends UriPath {\n  /** @hidden */\n  readonly _head: string;\n  /** @hidden */\n  _tail: UriPath;\n  /** @hidden */\n  _string?: string;\n\n  /** @hidden */\n  constructor(head: string, tail: UriPath) {\n    super();\n    this._head = head;\n    this._tail = tail;\n  }\n\n  isDefined(): boolean {\n    return true;\n  }\n\n  isAbsolute(): boolean {\n    return false;\n  }\n\n  isRelative(): boolean {\n    return true;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  head(): string {\n    return this._head;\n  }\n\n  tail(): UriPath {\n    return this._tail;\n  }\n\n  /** @hidden */\n  setTail(tail: UriPath): void {\n    if (tail.isAbsolute()) {\n      this._tail = tail;\n    } else {\n      this._tail = UriPath.slash(tail);\n    }\n  }\n\n  /** @hidden */\n  dealias(): UriPath {\n    return new UriPathSegment(this._head, this._tail);\n  }\n\n  parent(): UriPath {\n    const tail = this._tail;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    } else {\n      const next = tail.tail();\n      if (next.isEmpty()) {\n        return UriPath.empty();\n      } else {\n        return new UriPathSegment(this._head, tail.parent());\n      }\n    }\n  }\n\n  base(): UriPath {\n    const tail = this._tail;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    } else {\n      return new UriPathSegment(this._head, tail.base());\n    }\n  }\n\n  prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment, UriPath.slash(this));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"parse\")\n        .write(40/*'('*/).write(34/*'\"'*/) .display(this).write(34/*'\"'*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    if (this._string !== void 0) {\n      output = output.write(this._string);\n    } else {\n      super.display(output);\n    }\n  }\n\n  toString(): string {\n    if (this._string === void 0) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n}\nUri.PathSegment = UriPathSegment;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, Format} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriPath} from \"./UriPath\";\n\n/** @hidden */\nexport class UriPathSlash extends UriPath {\n  /** @hidden */\n  _tail: UriPath;\n  /** @hidden */\n  _string?: string;\n\n  /** @hidden */\n  constructor(tail: UriPath) {\n    super();\n    this._tail = tail;\n  }\n\n  isDefined(): boolean {\n    return true;\n  }\n\n  isAbsolute(): boolean {\n    return true;\n  }\n\n  isRelative(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  head(): string {\n    return \"/\";\n  }\n\n  tail(): UriPath {\n    return this._tail;\n  }\n\n  /** @hidden */\n  setTail(tail: UriPath): void {\n    this._tail = tail;\n  }\n\n  /** @hidden */\n  dealias(): UriPath {\n    return new UriPathSlash(this._tail);\n  }\n\n  parent(): UriPath {\n    const tail = this._tail;\n    if (tail.isEmpty()) {\n      return UriPath.empty();\n    } else {\n      const next = tail.tail();\n      if (next.isEmpty()) {\n        return UriPath.slash();\n      } else {\n        return new UriPathSlash(tail.parent());\n      }\n    }\n  }\n\n  base(): UriPath {\n    const tail = this._tail;\n    if (tail.isEmpty()) {\n      return this;\n    } else {\n      return new UriPathSlash(tail.base());\n    }\n  }\n\n  prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment, this);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"parse\")\n        .write(40/*'('*/).write(34/*'\"'*/) .display(this).write(34/*'\"'*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    if (this._string !== void 0) {\n      output = output.write(this._string);\n    } else {\n      super.display(output);\n    }\n  }\n\n  toString(): string {\n    if (this._string === void 0) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n}\nUri.PathSlash = UriPathSlash;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {AnyUriPath, UriPath} from \"./UriPath\";\n\n/** @hidden */\nexport class UriPathEmpty extends UriPath {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  isDefined(): boolean {\n    return false;\n  }\n\n  isAbsolute(): boolean {\n    return false;\n  }\n\n  isRelative(): boolean {\n    return true;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  head(): string {\n    throw new Error(\"Empty UriPath\");\n  }\n\n  tail(): UriPath {\n    throw new Error(\"Empty UriPath\");\n  }\n\n  /** @hidden */\n  setTail(tail: UriPath): void {\n    throw new Error(\"Empty UriPath\");\n  }\n\n  /** @hidden */\n  dealias(): UriPath {\n    return this;\n  }\n\n  parent(): UriPath {\n    return this;\n  }\n\n  base(): UriPath {\n    return this;\n  }\n\n  appended(...components: AnyUriPath[]): UriPath {\n    return UriPath.from.apply(void 0, arguments);\n  }\n\n  appendedSlash(): UriPath {\n    return UriPath.slash();\n  }\n\n  appendedSegment(segment: string): UriPath {\n    return UriPath.segment(segment);\n  }\n\n  prepended(...components: AnyUriPath[]): UriPath {\n    return UriPath.from.apply(void 0, arguments);\n  }\n\n  prependedSlash(): UriPath {\n    return UriPath.slash();\n  }\n\n  prependedSegment(segment: string): UriPath {\n    return UriPath.segment(segment);\n  }\n\n  merge(that: UriPath): UriPath {\n    return that;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriPath\").write(46/*'.'*/).write(\"empty\")\n        .write(40/*'('*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    // nop\n  }\n\n  toString(): string {\n    return \"\";\n  }\n}\nUri.PathEmpty = UriPathEmpty;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Uri} from \"./Uri\";\nimport {AnyUriPath, UriPath} from \"./UriPath\";\n\nexport class UriPathBuilder implements Builder<string, UriPath> {\n  /** @hidden */\n  _first: UriPath;\n  /** @hidden */\n  _last: UriPath | null;\n  /** @hidden */\n  _size: number;\n  /** @hidden */\n  _aliased: number;\n\n  constructor() {\n    this._first = Uri.Path.empty();\n    this._last = null;\n    this._size = 0;\n    this._aliased = 0;\n  }\n\n  isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  push(...components: AnyUriPath[]): void {\n    for (let i = 0; i < components.length; i += 1) {\n      const component = components[i];\n      if (component instanceof Uri.Path) {\n        this.addPath(component);\n      } else if (Array.isArray(component)) {\n        this.push.apply(this, component);\n      } else if (component === \"/\") {\n        this.addSlash();\n      } else {\n        this.addSegment(component);\n      }\n    }\n  }\n\n  bind(): UriPath {\n    this._aliased = 0;\n    return this._first;\n  }\n\n  addSlash(): void {\n    const tail = Uri.Path.slash().dealias();\n    const size = this._size;\n    if (size === 0) {\n      this._first = tail;\n    } else {\n      this.dealias(size - 1).setTail(tail);\n    }\n    this._last = tail;\n    this._size = size + 1;\n    this._aliased += 1;\n  }\n\n  addSegment(segment: string): void {\n    const tail = Uri.Path.segment(segment, Uri.Path.empty());\n    const size = this._size;\n    if (size === 0) {\n      this._first = tail;\n    } else {\n      this.dealias(size - 1).setTail(tail);\n    }\n    this._last = tail;\n    this._size = size + 1;\n    this._aliased += 1;\n  }\n\n  addPath(path: UriPath): void {\n    if (!path.isEmpty()) {\n      let size = this._size;\n      if (size === 0) {\n        this._first = path;\n      } else {\n        this.dealias(size - 1).setTail(path);\n      }\n      size += 1;\n      do {\n        const tail = path.tail();\n        if (!tail.isEmpty()) {\n          path = tail;\n          size += 1;\n        } else {\n          break;\n        }\n      } while (true);\n      this._last = path;\n      this._size = size;\n    }\n  }\n\n  pop(): UriPath {\n    const size = this._size;\n    const aliased = this._aliased;\n    if (size === 0) {\n      throw new Error(\"Empty UriPath\");\n    } else if (size === 1) {\n      const first = this._first;\n      this._first = first.tail();\n      if (first.tail().isEmpty()) {\n        this._last = null;\n      }\n      this._size = size - 1;\n      if (aliased > 0) {\n        this._aliased = aliased - 1;\n      }\n      return first;\n    } else {\n      const last = this.dealias(size - 2);\n      last.setTail(Uri.Path.empty());\n      this._last = last;\n      this._size = size - 1;\n      this._aliased = aliased - 1;\n      return last.tail();\n    }\n  }\n\n  /** @hidden */\n  dealias(n: number): UriPath {\n    let i = 0;\n    let xi = null as UriPath | null;\n    let xs = this._first;\n    if (this._aliased <= n) {\n      while (i < this._aliased) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n      while (i <= n) {\n        const xn = xs.dealias();\n        if (i === 0) {\n          this._first = xn;\n        } else {\n          xi!.setTail(xn);\n        }\n        xi = xn;\n        xs = xs.tail();\n        i += 1;\n      }\n      if (i === this._size) {\n        this._last = xi;\n      }\n      this._aliased = i;\n    } else if (n === 0) {\n      xi = this._first;\n    } else if (n === this._size - 1) {\n      xi = this._last;\n    } else {\n      while (i <= n) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n    }\n    return xi!;\n  }\n}\nUri.PathBuilder = UriPathBuilder;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheSet} from \"@swim/util\";\nimport {Output, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriQueryBuilder} from \"./UriQueryBuilder\";\n\nexport type AnyUriQuery = UriQuery | {[key: string]: string} | string;\n\nexport abstract class UriQuery implements Comparable<UriQuery>, HashCode, Debug, Display {\n  /** @hidden */\n  _hashCode?: number;\n\n  abstract isDefined(): boolean;\n\n  abstract isEmpty(): boolean;\n\n  get length(): number {\n    let n = 0;\n    let query = this as UriQuery;\n    while (!query.isEmpty()) {\n      n += 1;\n      query = query.tail();\n    }\n    return n;\n  }\n\n  abstract head(): [string | null, string];\n\n  abstract key(): string | null;\n\n  abstract value(): string;\n\n  abstract tail(): UriQuery;\n\n  /** @hidden */\n  abstract setTail(tail: UriQuery): void;\n\n  /** @hidden */\n  abstract dealias(): UriQuery;\n\n  has(key: string): boolean {\n    let query = this as UriQuery;\n    while (!query.isEmpty()) {\n      if (key === query.key()) {\n        return true;\n      }\n      query = query.tail();\n    }\n    return false;\n  }\n\n  get(key: string): string | undefined {\n    let query = this as UriQuery;\n    while (!query.isEmpty()) {\n      if (key === query.key()) {\n        return query.value();\n      }\n      query = query.tail();\n    }\n    return void 0;\n  }\n\n  updated(key: string, value: string): UriQuery {\n    let query = this as UriQuery;\n    const builder = new Uri.QueryBuilder();\n    let updated = false;\n    while (!query.isEmpty()) {\n      if (key === query.key()) {\n        builder.addParam(key, value);\n        updated = true;\n      } else {\n        builder.addParam(query.key(), query.value());\n      }\n      query = query.tail();\n    }\n    if (!updated) {\n      builder.addParam(key, value);\n    }\n    return builder.bind();\n  }\n\n  removed(key: string): UriQuery {\n    let query = this as UriQuery;\n    const builder = new Uri.QueryBuilder();\n    let updated = false;\n    while (!query.isEmpty()) {\n      if (key === query.key()) {\n        updated = true;\n      } else {\n        builder.addParam(query.key(), query.value());\n      }\n      query = query.tail();\n    }\n    if (updated) {\n      return builder.bind();\n    } else {\n      return this;\n    }\n  }\n\n  appended(key: string | null, value: string): UriQuery;\n  appended(params: AnyUriQuery): UriQuery;\n  appended(key: AnyUriQuery | null, value?: string): UriQuery {\n    const builder = new Uri.QueryBuilder();\n    builder.addQuery(this);\n    builder.add(key as any, value as any);\n    return builder.bind();\n  }\n\n  prepended(key: string | null, value: string): UriQuery;\n  prepended(params: AnyUriQuery): UriQuery;\n  prepended(key: AnyUriQuery | null, value?: string): UriQuery {\n    const builder = new Uri.QueryBuilder();\n    builder.add(key as any, value as any);\n    builder.addQuery(this);\n    return builder.bind();\n  }\n\n  toAny(params?: {[key: string]: string}): {[key: string]: string} | undefined {\n    if (this.isDefined()) {\n      params = params || {};\n      let query = this as UriQuery;\n      let i = 0;\n      while (!query.isEmpty()) {\n        const key = query.key();\n        if (key !== null) {\n          params[key] = query.value();\n        } else {\n          params[\"$\" + i] = query.value();\n        }\n        query = query.tail();\n        i += 1;\n      }\n    }\n    return params;\n  }\n\n  compareTo(that: UriQuery): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriQuery) {\n      return this.toString() === that.toString();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this.toString());\n    }\n    return this._hashCode;\n  }\n\n  abstract debug(output: Output): void;\n\n  display(output: Output): void {\n    let query = this as UriQuery;\n    let first = true;\n    while (!query.isEmpty()) {\n      if (!first) {\n        output = output.write(38/*'&'*/);\n      } else {\n        first = false;\n      }\n      const key = query.key();\n      if (key !== null) {\n        Uri.writeParam(key, output);\n        output = output.write(61/*'='*/);\n      }\n      Uri.writeQuery(query.value(), output);\n      query = query.tail();\n    }\n  }\n\n  abstract toString(): string;\n\n  private static _undefined: UriQuery;\n\n  private static _keyCache: HashGenCacheSet<string>;\n\n  static builder(): UriQueryBuilder {\n    return new Uri.QueryBuilder();\n  }\n\n  static undefined(): UriQuery {\n    if (UriQuery._undefined === void 0) {\n      UriQuery._undefined = new Uri.QueryUndefined();\n    }\n    return UriQuery._undefined;\n  }\n\n  static param(value: string, tail?: UriQuery): UriQuery;\n  static param(key: string | null, value: string, tail?: UriQuery): UriQuery;\n  static param(key: string | null, value?: UriQuery | string, tail?: UriQuery): UriQuery {\n    if (tail === void 0) {\n      tail = value as UriQuery | undefined;\n      value = key!;\n      key = null;\n    } else if (key !== null) {\n      key = this.cacheKey(key);\n    }\n    if (tail === void 0) {\n      tail = UriQuery.undefined();\n    }\n    return new Uri.QueryParam(key, value as string, tail);\n  }\n\n  static from(key: string | null, value: string): UriQuery;\n  static from(params: AnyUriQuery): UriQuery;\n  static from(key: AnyUriQuery | null, value?: string): UriQuery {\n    const builder = new Uri.QueryBuilder();\n    builder.add(key as any, value as any);\n    return builder.bind();\n  }\n\n  static fromAny(query: AnyUriQuery | null | undefined): UriQuery {\n    if (query === null || query === void 0) {\n      return UriQuery.undefined();\n    } else if (query instanceof UriQuery) {\n      return query;\n    } else if (typeof query === \"object\") {\n      const builder = new Uri.QueryBuilder();\n      builder.add(query);\n      return builder.bind();\n    } else if (typeof query === \"string\") {\n      return UriQuery.parse(query);\n    } else {\n      throw new TypeError(\"\" + query);\n    }\n  }\n\n  static parse(string: string): UriQuery {\n    return Uri.standardParser().parseQueryString(string);\n  }\n\n  /** @hidden */\n  static keyCache(): HashGenCacheSet<string> {\n    if (UriQuery._keyCache === void 0) {\n      const keyCacheSize = 64;\n      UriQuery._keyCache = new HashGenCacheSet<string>(keyCacheSize);\n    }\n    return UriQuery._keyCache;\n  }\n\n  /** @hidden */\n  static cacheKey(key: string): string {\n    if (key.length <= 32) {\n      return UriQuery.keyCache().put(key);\n    } else {\n      return key;\n    }\n  }\n}\nUri.Query = UriQuery;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, Format} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriQuery} from \"./UriQuery\";\n\n/** @hidden */\nexport class UriQueryParam extends UriQuery {\n  /** @hidden */\n  readonly _key: string | null;\n  /** @hidden */\n  _value: string;\n  /** @hidden */\n  _tail: UriQuery;\n  /** @hidden */\n  _string?: string;\n\n  constructor(key: string | null, value: string, tail: UriQuery) {\n    super();\n    this._key = key;\n    this._value = value;\n    this._tail = tail;\n  }\n\n  isDefined(): boolean {\n    return true;\n  }\n\n  isEmpty(): boolean {\n    return false;\n  }\n\n  head(): [string | null, string] {\n    return [this._key, this._value];\n  }\n\n  key(): string | null {\n    return this._key;\n  }\n\n  value(): string {\n    return this._value;\n  }\n\n  tail(): UriQuery {\n    return this._tail;\n  }\n\n  /** @hidden */\n  setTail(tail: UriQuery): void {\n    this._tail = tail;\n  }\n\n  /** @hidden */\n  dealias(): UriQuery {\n    return new UriQueryParam(this._key, this._value, this._tail);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriQuery\").write(46/*'.'*/).write(\"parse\")\n        .write(40/*'('*/).write(34/*'\"'*/) .display(this).write(34/*'\"'*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    if (this._string !== void 0) {\n      output = output.write(this._string);\n    } else {\n      super.display(output);\n    }\n  }\n\n  toString(): string {\n    if (this._string === void 0) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n}\nUri.QueryParam = UriQueryParam;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {AnyUriQuery, UriQuery} from \"./UriQuery\";\n\n/** @hidden */\nexport class UriQueryUndefined extends UriQuery {\n  isDefined(): boolean {\n    return false;\n  }\n\n  isEmpty(): boolean {\n    return true;\n  }\n\n  head(): [string | null, string] {\n    throw new Error(\"Undefined Query\");\n  }\n\n  key(): string | null {\n    throw new Error(\"Undefined Query\");\n  }\n\n  value(): string {\n    throw new Error(\"Undefined Query\");\n  }\n\n  tail(): UriQuery {\n    throw new Error(\"Undefined Query\");\n  }\n\n  /** @hidden */\n  setTail(tail: UriQuery): void {\n    throw new Error(\"Undefined Query\");\n  }\n\n  /** @hidden */\n  dealias(): UriQuery {\n    return this;\n  }\n\n  updated(key: string, value: string): UriQuery {\n    return UriQuery.param(key, value, this);\n  }\n\n  removed(key: string): UriQuery {\n    return this;\n  }\n\n  appended(key: string | null, value: string): UriQuery;\n  appended(params: AnyUriQuery): UriQuery;\n  appended(key: AnyUriQuery | null, value?: string): UriQuery {\n    return UriQuery.from(key as any, value as any);\n  }\n\n  prepended(key: string | null, value: string): UriQuery;\n  prepended(params: AnyUriQuery): UriQuery;\n  prepended(key: AnyUriQuery | null, value?: string): UriQuery {\n    return UriQuery.from(key as any, value as any);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriQuery\").write(46/*'.'*/).write(\"undefined\")\n        .write(40/*'('*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    // nop\n  }\n\n  toString(): string {\n    return \"\";\n  }\n}\nUri.QueryUndefined = UriQueryUndefined;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {PairBuilder} from \"@swim/util\";\nimport {Uri} from \"./Uri\";\nimport {AnyUriQuery, UriQuery} from \"./UriQuery\";\n\nexport class UriQueryBuilder implements PairBuilder<string | null, string, UriQuery> {\n  /** @hidden */\n  _first: UriQuery;\n  /** @hidden */\n  _last: UriQuery | null;\n  /** @hidden */\n  _size: number;\n  /** @hidden */\n  _aliased: number;\n\n  constructor() {\n    this._first = Uri.Query.undefined();\n    this._last = null;\n    this._size = 0;\n    this._aliased = 0;\n  }\n\n  isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  add(key: string | null, value: string): void;\n  add(params: AnyUriQuery): void;\n  add(key: AnyUriQuery | null, value?: string): void {\n    if (value !== void 0) {\n      this.addParam(key as string | null, value);\n    } else if (typeof key === \"string\") {\n      this.addParam(null, key);\n    } else if (key instanceof Uri.Query) {\n      this.addQuery(key);\n    } else {\n      const params = key!;\n      for (const k in params) {\n        let key = k as string | null;\n        const value = params[k];\n        if (k.charCodeAt(0) === 36/*'$'*/) {\n          key = null;\n        }\n        this.addParam(key, value);\n      }\n    }\n  }\n\n  bind(): UriQuery {\n    this._aliased = 0;\n    return this._first;\n  }\n\n  addParam(value: string): void;\n  addParam(key: string | null, value: string): void;\n  addParam(key: string | null, value?: string): void {\n    if (value === void 0) {\n      value = key!;\n      key = null;\n    }\n    const tail = Uri.Query.param(key, value, Uri.Query.undefined());\n    const size = this._size;\n    if (size === 0) {\n      this._first = tail;\n    } else {\n      this.dealias(size - 1).setTail(tail);\n    }\n    this._last = tail;\n    this._size = size + 1;\n    this._aliased += 1;\n  }\n\n  addQuery(query: UriQuery): void {\n    if (!query.isEmpty()) {\n      let size = this._size;\n      if (size === 0) {\n        this._first = query;\n      } else {\n        this.dealias(size - 1).setTail(query);\n      }\n      size += 1;\n      do {\n        const tail = query.tail();\n        if (!tail.isEmpty()) {\n          query = tail;\n          size += 1;\n        } else {\n          break;\n        }\n      } while (true);\n      this._last = query;\n      this._size = size;\n    }\n  }\n\n  /** @hidden */\n  dealias(n: number): UriQuery {\n    let i = 0;\n    let xi = null as UriQuery | null;\n    let xs = this._first;\n    if (this._aliased <= n) {\n      while (i < this._aliased) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n      while (i <= n) {\n        const xn = xs.dealias();\n        if (i === 0) {\n          this._first = xn;\n        } else {\n          xi!.setTail(xn);\n        }\n        xi = xn;\n        xs = xs.tail();\n        i += 1;\n      }\n      if (i === this._size) {\n        this._last = xi;\n      }\n      this._aliased = i;\n    } else if (n === 0) {\n      xi = this._first;\n    } else if (n === this._size - 1) {\n      xi = this._last;\n    } else {\n      while (i <= n) {\n        xi = xs;\n        xs = xs.tail();\n        i += 1;\n      }\n    }\n    return xi!;\n  }\n}\nUri.QueryBuilder = UriQueryBuilder;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Murmur3, HashGenCacheMap} from \"@swim/util\";\nimport {Output, Format, Debug, Display} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\n\nexport type AnyUriFragment = UriFragment | string;\n\nexport class UriFragment implements Comparable<UriFragment>, HashCode, Debug, Display {\n  /** @hidden */\n  readonly _identifier: string | null;\n  /** @hidden */\n  _string?: string;\n\n  /** @hidden */\n  constructor(identifier: string | null) {\n    this._identifier = identifier;\n  }\n\n  isDefined(): boolean {\n    return this._identifier !== null;\n  }\n\n  identifier(): string | null {\n    return this._identifier;\n  }\n\n  toAny(): string | undefined {\n    return this._identifier !== null ? this._identifier : void 0;\n  }\n\n  compareTo(that: UriFragment): 0 | 1 | -1 {\n    const order = this.toString().localeCompare(that.toString());\n    return order < 0 ? -1 : order > 0 ? 1 : 0;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof UriFragment) {\n      return this._identifier === that._identifier;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.hash(this._identifier);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"UriFragment\").write(46/*'.'*/);\n    if (this.isDefined()) {\n      output = output.write(\"parse\").write(40/*'('*/).write(34/*'\"'*/).display(this).write(34/*'\"'*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"undefined\").write(40/*'('*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    if (this._string !== void 0) {\n      output = output.write(this._string);\n    } else if (this._identifier !== null) {\n      Uri.writeFragment(this._identifier, output);\n    }\n  }\n\n  toString(): string {\n    if (this._string == null) {\n      this._string = Format.display(this);\n    }\n    return this._string;\n  }\n\n  private static _undefined?: UriFragment;\n\n  private static _cache?: HashGenCacheMap<string, UriFragment>;\n\n  static undefined(): UriFragment {\n    if (UriFragment._undefined === void 0) {\n      UriFragment._undefined = new UriFragment(null);\n    }\n    return UriFragment._undefined;\n  }\n\n  static from(identifier: string | null): UriFragment {\n    if (identifier !== null) {\n      const cache = UriFragment.cache();\n      const fragment = cache.get(identifier);\n      if (fragment) {\n        return fragment;\n      } else {\n        return cache.put(identifier, new UriFragment(identifier));\n      }\n    } else {\n      return UriFragment.undefined();\n    }\n  }\n\n  static fromAny(fragment: AnyUriFragment | null | undefined): UriFragment {\n    if (fragment === null || fragment === void 0) {\n      return UriFragment.undefined();\n    } else if (fragment instanceof UriFragment) {\n      return fragment;\n    } else if (typeof fragment === \"string\") {\n      return UriFragment.parse(fragment);\n    } else {\n      throw new TypeError(\"\" + fragment);\n    }\n  }\n\n  static parse(string: string): UriFragment {\n    return Uri.standardParser().parseFragmentString(string);\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheMap<string, UriFragment> {\n    if (UriFragment._cache === void 0) {\n      const cacheSize = 32;\n      UriFragment._cache = new HashGenCacheMap<string, UriFragment>(cacheSize);\n    }\n    return UriFragment._cache;\n  }\n}\nUri.Fragment = UriFragment;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser, Diagnostic, Unicode} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriScheme} from \"./UriScheme\";\nimport {UriAuthority} from \"./UriAuthority\";\nimport {UriUser} from \"./UriUser\";\nimport {UriHost} from \"./UriHost\";\nimport {UriPort} from \"./UriPort\";\nimport {UriPath} from \"./UriPath\";\nimport {UriPathBuilder} from \"./UriPathBuilder\";\nimport {UriQuery} from \"./UriQuery\";\nimport {UriQueryBuilder} from \"./UriQueryBuilder\";\nimport {UriFragment} from \"./UriFragment\";\nimport {UriAbsoluteParser} from \"./UriAbsoluteParser\";\nimport {UriSchemeParser} from \"./UriSchemeParser\";\nimport {UriAuthorityParser} from \"./UriAuthorityParser\";\nimport {UriUserParser} from \"./UriUserParser\";\nimport {UriHostParser} from \"./UriHostParser\";\nimport {UriHostAddressParser} from \"./UriHostAddressParser\";\nimport {UriHostLiteralParser} from \"./UriHostLiteralParser\";\nimport {UriPortParser} from \"./UriPortParser\";\nimport {UriPathParser} from \"./UriPathParser\";\nimport {UriQueryParser} from \"./UriQueryParser\";\nimport {UriFragmentParser} from \"./UriFragmentParser\";\n\nexport class UriParser {\n  absolute(scheme?: UriScheme, authority?: UriAuthority, path?: UriPath,\n           query?: UriQuery, fragment?: UriFragment): Uri {\n    return Uri.from(scheme, authority, path, query, fragment);\n  }\n\n  scheme(name: string): UriScheme {\n    return Uri.Scheme.from(name);\n  }\n\n  authority(user?: UriUser, host?: UriHost, port?: UriPort): UriAuthority {\n    return Uri.Authority.from(user, host, port);\n  }\n\n  user(username: string | null, password?: string | null): UriUser {\n    return Uri.User.from(username, password);\n  }\n\n  hostName(address: string): UriHost {\n    return Uri.Host.from(address);\n  }\n\n  hostIPv4(address: string): UriHost {\n    return Uri.Host.ipv4(address);\n  }\n\n  hostIPv6(address: string): UriHost {\n    return Uri.Host.ipv6(address);\n  }\n\n  port(number: number): UriPort {\n    return Uri.Port.from(number);\n  }\n\n  pathEmpty(): UriPath {\n    return Uri.Path.empty();\n  }\n\n  pathBuilder(): UriPathBuilder {\n    return new Uri.PathBuilder();\n  }\n\n  queryBuilder(): UriQueryBuilder {\n    return new Uri.QueryBuilder();\n  }\n\n  fragment(identifier: string | null): UriFragment {\n    return Uri.Fragment.from(identifier);\n  }\n\n  absoluteParser(): Parser<Uri> {\n    return new UriParser.AbsoluteParser(this);\n  }\n\n  parseAbsolute(input: Input): Parser<Uri> {\n    return UriParser.AbsoluteParser.parse(input, this);\n  }\n\n  parseAbsoluteString(string: string): Uri {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseAbsolute(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  schemeParser(): Parser<UriScheme> {\n    return new UriParser.SchemeParser(this);\n  }\n\n  parseScheme(input: Input): Parser<UriScheme> {\n    return UriParser.SchemeParser.parse(input, this);\n  }\n\n  parseSchemeString(string: string): UriScheme {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseScheme(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  authorityParser(): Parser<UriAuthority> {\n    return new UriParser.AuthorityParser(this);\n  }\n\n  parseAuthority(input: Input): Parser<UriAuthority> {\n    return UriParser.AuthorityParser.parse(input, this);\n  }\n\n  parseAuthorityString(string: string): UriAuthority {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseAuthority(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  userParser(): Parser<UriUser> {\n    return new UriParser.UserParser(this);\n  }\n\n  parseUser(input: Input): Parser<UriUser> {\n    return UriParser.UserParser.parse(input, this);\n  }\n\n  parseUserString(string: string): UriUser {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseUser(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  hostParser(): Parser<UriHost> {\n    return new UriParser.HostParser(this);\n  }\n\n  parseHost(input: Input): Parser<UriHost> {\n    return UriParser.HostParser.parse(input, this);\n  }\n\n  parseHostString(string: string): UriHost {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseHost(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  hostAddressParser(): Parser<UriHost> {\n    return new UriParser.HostAddressParser(this);\n  }\n\n  parseHostAddress(input: Input): Parser<UriHost> {\n    return UriParser.HostAddressParser.parse(input, this);\n  }\n\n  hostLiteralParser(): Parser<UriHost> {\n    return new UriParser.HostLiteralParser(this);\n  }\n\n  parseHostLiteral(input: Input): Parser<UriHost> {\n    return UriParser.HostLiteralParser.parse(input, this);\n  }\n\n  portParser(): Parser<UriPort> {\n    return new UriParser.PortParser(this);\n  }\n\n  parsePort(input: Input): Parser<UriPort> {\n    return UriParser.PortParser.parse(input, this);\n  }\n\n  parsePortString(string: string): UriPort {\n    const input = Unicode.stringInput(string);\n    let parser = this.parsePort(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  pathParser(builder?: UriPathBuilder): Parser<UriPath> {\n    return new UriParser.PathParser(this, builder);\n  }\n\n  parsePath(input: Input, builder?: UriPathBuilder): Parser<UriPath> {\n    return UriParser.PathParser.parse(input, this, builder);\n  }\n\n  parsePathString(string: string): UriPath {\n    const input = Unicode.stringInput(string);\n    let parser = this.parsePath(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  queryParser(builder?: UriQueryBuilder): Parser<UriQuery> {\n    return new UriParser.QueryParser(this, builder);\n  }\n\n  parseQuery(input: Input, builder?: UriQueryBuilder): Parser<UriQuery> {\n    return UriParser.QueryParser.parse(input, this, builder);\n  }\n\n  parseQueryString(string: string): UriQuery {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseQuery(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  fragmentParser(): Parser<UriFragment> {\n    return new UriParser.FragmentParser(this);\n  }\n\n  parseFragment(input: Input): Parser<UriFragment> {\n    return UriParser.FragmentParser.parse(input, this);\n  }\n\n  parseFragmentString(string: string): UriFragment {\n    const input = Unicode.stringInput(string);\n    let parser = this.parseFragment(input);\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static AbsoluteParser: typeof UriAbsoluteParser; // defined by UriAbsoluteParser\n  /** @hidden */\n  static SchemeParser: typeof UriSchemeParser; // defined by UriSchemeParser\n  /** @hidden */\n  static AuthorityParser: typeof UriAuthorityParser; // defined by UriAuthorityParser\n  /** @hidden */\n  static UserParser: typeof UriUserParser; // defined by UriUserParser\n  /** @hidden */\n  static HostParser: typeof UriHostParser; // defined by UriHostParser\n  /** @hidden */\n  static HostAddressParser: typeof UriHostAddressParser; // defined by UriHostAddressParser\n  /** @hidden */\n  static HostLiteralParser: typeof UriHostLiteralParser; // defined by UriHostLiteralParser\n  /** @hidden */\n  static PortParser: typeof UriPortParser; // defined by UriPortParser\n  /** @hidden */\n  static PathParser: typeof UriPathParser; // defined by UriPathParser\n  /** @hidden */\n  static QueryParser: typeof UriQueryParser; // defined by UriQueryParser\n  /** @hidden */\n  static FragmentParser: typeof UriFragmentParser; // defined by UriFragmentParser\n}\nUri.Parser = UriParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriScheme} from \"./UriScheme\";\nimport {UriAuthority} from \"./UriAuthority\";\nimport {UriPath} from \"./UriPath\";\nimport {UriQuery} from \"./UriQuery\";\nimport {UriFragment} from \"./UriFragment\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriAbsoluteParser extends Parser<Uri> {\n  private readonly uri: UriParser;\n  private readonly schemeParser: Parser<UriScheme> | undefined;\n  private readonly authorityParser: Parser<UriAuthority> | undefined;\n  private readonly pathParser: Parser<UriPath> | undefined;\n  private readonly queryParser: Parser<UriQuery> | undefined;\n  private readonly fragmentParser: Parser<UriFragment> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, schemeParser?: Parser<UriScheme>,\n              authorityParser?: Parser<UriAuthority>, pathParser?: Parser<UriPath>,\n              queryParser?: Parser<UriQuery>, fragmentParser?: Parser<UriFragment>, step?: number) {\n    super();\n    this.uri = uri;\n    this.schemeParser = schemeParser;\n    this.authorityParser = authorityParser;\n    this.pathParser = pathParser;\n    this.queryParser = queryParser;\n    this.fragmentParser = fragmentParser;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<Uri> {\n    return UriAbsoluteParser.parse(input, this.uri, this.schemeParser, this.authorityParser,\n                                   this.pathParser, this.queryParser, this.fragmentParser, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, schemeParser?: Parser<UriScheme>,\n               authorityParser?: Parser<UriAuthority>, pathParser?: Parser<UriPath>,\n               queryParser?: Parser<UriQuery>, fragmentParser?: Parser<UriFragment>,\n               step: number = 1): Parser<Uri> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        const look = input.clone();\n        while (look.isCont() && (c = look.head(), Uri.isSchemeChar(c))) {\n          look.step();\n        }\n        if (look.isCont() && c === 58/*':'*/) {\n          step = 2;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        step = 3;\n      }\n    }\n    if (step === 2) {\n      if (!schemeParser) {\n        schemeParser = uri.parseScheme(input);\n      } else {\n        schemeParser = schemeParser.feed(input);\n      }\n      if (schemeParser.isDone()) {\n        if (input.isCont() && input.head() === 58/*':'*/) {\n          input = input.step();\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(58/*':'*/, input));\n        }\n      } else if (schemeParser.isError()) {\n        return schemeParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 47/*'/'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 63/*'?'*/) {\n          input = input.step();\n          step = 7;\n        } else if (c === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else {\n          step = 6;\n        }\n      } else if (input.isDone()) {\n        return Parser.done(uri.absolute(schemeParser && schemeParser.bind()));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont() && input.head() === 47/*'/'*/) {\n        input = input.step();\n        step = 5;\n      } else if (input.isCont()) {\n        const pathBuilder = uri.pathBuilder();\n        pathBuilder.addSlash();\n        pathParser = uri.parsePath(input, pathBuilder);\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.done(uri.absolute(schemeParser && schemeParser.bind(),\n                                        void 0,\n                                        Uri.Path.slash()));\n      }\n    }\n    if (step === 5) {\n      if (!authorityParser) {\n        authorityParser = uri.parseAuthority(input);\n      } else {\n        authorityParser = authorityParser.feed(input);\n      }\n      if (authorityParser.isDone()) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 63/*'?'*/) {\n            input = input.step();\n            step = 7;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else {\n            step = 6;\n          }\n        } else if (input.isDone()) {\n          return Parser.done(uri.absolute(schemeParser && schemeParser.bind(),\n                                          authorityParser && authorityParser.bind()));\n        }\n      } else if (authorityParser.isError()) {\n        return authorityParser.asError();\n      }\n    }\n    if (step === 6) {\n      if (!pathParser) {\n        pathParser = uri.parsePath(input);\n      } else {\n        pathParser = pathParser.feed(input);\n      }\n      if (pathParser.isDone()) {\n        if (input.isCont() && input.head() === 63/*'?'*/) {\n          input = input.step();\n          step = 7;\n        } else if (input.isCont() && input.head() === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.absolute(schemeParser && schemeParser.bind(),\n                                          authorityParser && authorityParser.bind(),\n                                          pathParser.bind()));\n        }\n      } else if (pathParser.isError()) {\n        return pathParser.asError();\n      }\n    }\n    if (step === 7) {\n      if (!queryParser) {\n        queryParser = uri.parseQuery(input);\n      } else {\n        queryParser = queryParser.feed(input);\n      }\n      if (queryParser.isDone()) {\n        if (input.isCont() && input.head() === 35/*'#'*/) {\n          input = input.step();\n          step = 8;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.absolute(schemeParser && schemeParser.bind(),\n                                          authorityParser && authorityParser.bind(),\n                                          pathParser && pathParser.bind(),\n                                          queryParser.bind()));\n        }\n      } else if (queryParser.isError()) {\n        return queryParser.asError();\n      }\n    }\n    if (step === 8) {\n      if (!fragmentParser) {\n        fragmentParser = uri.parseFragment(input);\n      } else {\n        fragmentParser = fragmentParser.feed(input);\n      }\n      if (fragmentParser.isDone()) {\n        return Parser.done(uri.absolute(schemeParser && schemeParser.bind(),\n                                        authorityParser && authorityParser.bind(),\n                                        pathParser && pathParser.bind(),\n                                        queryParser && queryParser.bind(),\n                                        fragmentParser.bind()));\n      } else if (fragmentParser.isError()) {\n        return fragmentParser.asError();\n      }\n    }\n    return new UriAbsoluteParser(uri, schemeParser, authorityParser, pathParser,\n                                 queryParser, fragmentParser, step);\n  }\n}\nUriParser.AbsoluteParser = UriAbsoluteParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriScheme} from \"./UriScheme\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriSchemeParser extends Parser<UriScheme> {\n  private readonly uri: UriParser;\n  private readonly output: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, output?: Output<string>, step?: number) {\n    super();\n    this.uri = uri;\n    this.output = output;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriScheme> {\n    return UriSchemeParser.parse(input, this.uri, this.output, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, output?: Output<string>, step: number = 1): Parser<UriScheme> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont() && (c = input.head(), Uri.isAlpha(c))) {\n        input = input.step();\n        output = output || Utf8.decodedString();\n        output = output.write(Uri.toLowerCase(c));\n        step = 2;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(\"scheme\", input));\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Uri.isSchemeChar(c))) {\n        input = input.step();\n        output!.write(Uri.toLowerCase(c));\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(uri.scheme(output!.bind()));\n      }\n    }\n    return new UriSchemeParser(uri, output, step);\n  }\n}\nUriParser.SchemeParser = UriSchemeParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Diagnostic, Parser} from \"@swim/codec\";\nimport {UriAuthority} from \"./UriAuthority\";\nimport {UriUser} from \"./UriUser\";\nimport {UriHost} from \"./UriHost\";\nimport {UriPort} from \"./UriPort\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriAuthorityParser extends Parser<UriAuthority> {\n  private readonly uri: UriParser;\n  private readonly userParser: Parser<UriUser> | undefined;\n  private readonly hostParser: Parser<UriHost> | undefined;\n  private readonly portParser: Parser<UriPort> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>,\n              portParser?: Parser<UriPort>, step?: number) {\n    super();\n    this.uri = uri;\n    this.userParser = userParser;\n    this.hostParser = hostParser;\n    this.portParser = portParser;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriAuthority> {\n    return UriAuthorityParser.parse(input, this.uri, this.userParser, this.hostParser,\n                                    this.portParser, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, userParser?: Parser<UriUser>, hostParser?: Parser<UriHost>,\n               portParser?: Parser<UriPort>, step: number = 1): Parser<UriAuthority> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        const look = input.clone();\n        while (look.isCont() && (c = look.head(), c !== 64/*'@'*/ && c !== 47/*'/'*/)) {\n          look.step();\n        }\n        if (look.isCont() && c === 64/*'@'*/) {\n          step = 2;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        step = 3;\n      }\n    }\n    if (step === 2) {\n      if (!userParser) {\n        userParser = uri.parseUser(input);\n      } else {\n        userParser = userParser.feed(input);\n      }\n      if (userParser.isDone()) {\n        if (input.isCont() && input.head() === 64/*'@'*/) {\n          input = input.step();\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n        }\n      } else if (userParser.isError()) {\n        return userParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (!hostParser) {\n        hostParser = uri.parseHost(input);\n      } else {\n        hostParser = hostParser.feed(input);\n      }\n      if (hostParser.isDone()) {\n        if (input.isCont() && input.head() === 58/*':'*/) {\n          input = input.step();\n          step = 4;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.authority(userParser && userParser.bind(),\n                                           hostParser.bind()));\n        }\n      } else if (hostParser.isError()) {\n        return hostParser.asError();\n      }\n    }\n    if (step === 4) {\n      if (!portParser) {\n        portParser = uri.parsePort(input);\n      } else {\n        portParser = portParser.feed(input);\n      }\n      if (portParser.isDone()) {\n        return Parser.done(uri.authority(userParser && userParser.bind(),\n                                         hostParser!.bind(),\n                                         portParser.bind()));\n      } else if (portParser.isError()) {\n        return portParser.asError();\n      }\n    }\n    return new UriAuthorityParser(uri, userParser, hostParser, portParser, step);\n  }\n}\nUriParser.AuthorityParser = UriAuthorityParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base16, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriUser} from \"./UriUser\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriUserParser extends Parser<UriUser> {\n  private readonly uri: UriParser;\n  private readonly usernameOutput: Output<string> | undefined;\n  private readonly passwordOutput: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, usernameOutput?: Output<string>,\n              passwordOutput?: Output<string>, c1?: number, step?: number) {\n    super();\n    this.uri = uri;\n    this.usernameOutput = usernameOutput;\n    this.passwordOutput = passwordOutput;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriUser> {\n    return UriUserParser.parse(input, this.uri, this.usernameOutput,\n                               this.passwordOutput, this.c1, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, usernameOutput?: Output<string>,\n               passwordOutput?: Output<string>, c1: number = 0, step: number = 1): Parser<UriUser> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        usernameOutput = usernameOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isUserChar(c))) {\n          input = input.step();\n          usernameOutput!.write(c);\n        }\n        if (input.isCont() && c === 58/*':'*/) {\n          input = input.step();\n          step = 4;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.user(usernameOutput.bind()));\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          usernameOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 4) {\n        passwordOutput = passwordOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isUserInfoChar(c))) {\n          input = input.step();\n          passwordOutput.write(c);\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 5;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.user(usernameOutput!.bind(), passwordOutput.bind()));\n        }\n      }\n      if (step === 5) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          passwordOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 4;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriUserParser(uri, usernameOutput, passwordOutput, c1, step);\n  }\n}\nUriParser.UserParser = UriUserParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser} from \"@swim/codec\";\nimport {UriHost} from \"./UriHost\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriHostParser extends Parser<UriHost> {\n  private readonly uri: UriParser;\n\n  constructor(uri: UriParser) {\n    super();\n    this.uri = uri;\n  }\n\n  feed(input: Input): Parser<UriHost> {\n    return UriHostParser.parse(input, this.uri);\n  }\n\n  static parse(input: Input, uri: UriParser): Parser<UriHost> {\n    if (input.isCont()) {\n      const c = input.head();\n      if (c === 91/*'['*/) {\n        return uri.parseHostLiteral(input);\n      } else {\n        return uri.parseHostAddress(input);\n      }\n    } else if (input.isDone()) {\n      return Parser.done(uri.hostName(\"\"));\n    }\n    return new UriHostParser(uri);\n  }\n}\nUriParser.HostParser = UriHostParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base10, Base16, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriHostAddressParser extends Parser<UriHost> {\n  private readonly uri: UriParser;\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly x: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, output?: Output<string>, c1?: number, x?: number, step?: number) {\n    super();\n    this.uri = uri;\n    this.output = output;\n    this.c1 = c1;\n    this.x = x;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriHost> {\n    return UriHostAddressParser.parse(input, this.uri, this.output, this.c1, this.x, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, output?: Output<string>,\n               c1: number = 0, x: number = 0, step: number = 1): Parser<UriHost> {\n    let c = 0;\n    output = output || Utf8.decodedString();\n    while (step <= 4) {\n      while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {\n        input = input.step();\n        output = output.write(c);\n        x = 10 * x + Base10.decodeDigit(c);\n      }\n      if (input.isCont()) {\n        if (c === 46/*'.'*/ && step < 4 && x <= 255) {\n          input = input.step();\n          output = output.write(c);\n          x = 0;\n          step += 1;\n        } else if (!Uri.isHostChar(c) && c !== 37/*'%'*/ && step === 4 && x <= 255) {\n          return Parser.done(uri.hostIPv4(output.bind()));\n        } else {\n          x = 0;\n          step = 5;\n          break;\n        }\n      } else if (!input.isEmpty()) {\n        if (step === 4 && x <= 255) {\n          return Parser.done(uri.hostIPv4(output.bind()));\n        } else {\n          return Parser.done(uri.hostName(output.bind()));\n        }\n      } else {\n        break;\n      }\n    }\n    do {\n      if (step === 5) {\n        while (input.isCont() && (c = input.head(), Uri.isHostChar(c))) {\n          input = input.step();\n          output!.write(Uri.toLowerCase(c));\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.hostName(output!.bind()));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 7;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 7) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          output!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 5;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriHostAddressParser(uri, output, c1, x, step);\n  }\n}\nUriParser.HostAddressParser = UriHostAddressParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriHost} from \"./UriHost\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriHostLiteralParser extends Parser<UriHost> {\n  private readonly uri: UriParser;\n  private readonly output: Output<string> | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, output?: Output<string>, step?: number) {\n    super();\n    this.uri = uri;\n    this.output = output;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriHost> {\n    return UriHostLiteralParser.parse(input, this.uri, this.output, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, output?: Output<string>, step: number = 1): Parser<UriHost> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont() && input.head() === 91/*'['*/) {\n        input = input.step();\n        step = 2;\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(91/*'['*/, input));\n      }\n    }\n    if (step === 2) {\n      output = output || Utf8.decodedString();\n      while (input.isCont() && (c = input.head(), Uri.isHostChar(c) || c === 58/*':'*/)) {\n        input = input.step();\n        output = output.write(Uri.toLowerCase(c));\n      }\n      if (input.isCont() && c === 93/*']'*/) {\n        input = input.step();\n        return Parser.done(uri.hostIPv6(output.bind()));\n      } else if (!input.isEmpty()) {\n        return Parser.error(Diagnostic.expected(93/*']'*/, input));\n      }\n    }\n    return new UriHostLiteralParser(uri, output, step);\n  }\n}\nUriParser.HostLiteralParser = UriHostLiteralParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser, Base10} from \"@swim/codec\";\nimport {UriPort} from \"./UriPort\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriPortParser extends Parser<UriPort> {\n  private readonly uri: UriParser;\n  private readonly number: number | undefined;\n\n  constructor(uri: UriParser, number?: number) {\n    super();\n    this.uri = uri;\n    this.number = number;\n  }\n\n  feed(input: Input): Parser<UriPort> {\n    return UriPortParser.parse(input, this.uri, this.number);\n  }\n\n  static parse(input: Input, uri: UriParser, number: number = 0): Parser<UriPort> {\n    let c = 0;\n    while (input.isCont() && (c = input.head(), Base10.isDigit(c))) {\n      input = input.step();\n      number = 10 * number + Base10.decodeDigit(c);\n    }\n    if (!input.isEmpty()) {\n      return Parser.done(uri.port(number));\n    }\n    return new UriPortParser(uri, number);\n  }\n}\nUriParser.PortParser = UriPortParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base16, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriPath} from \"./UriPath\";\nimport {UriPathBuilder} from \"./UriPathBuilder\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriPathParser extends Parser<UriPath> {\n  private readonly uri: UriParser;\n  private readonly builder: UriPathBuilder | undefined;\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, builder?: UriPathBuilder, output?: Output<string>,\n              c1?: number, step?: number) {\n    super();\n    this.uri = uri;\n    this.builder = builder;\n    this.output = output;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriPath> {\n    return UriPathParser.parse(input, this.uri, this.builder, this.output, this.c1, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, builder?: UriPathBuilder, output?: Output<string>,\n               c1: number = 0, step: number = 1): Parser<UriPath> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Uri.isPathChar(c))) {\n          output = output || Utf8.decodedString();\n          input = input.step();\n          output = output.write(c);\n        }\n        if (input.isCont() && c === 47/*'/'*/) {\n          input = input.step();\n          builder = builder || uri.pathBuilder();\n          if (output) {\n            builder.addSegment(output.bind());\n            output = void 0;\n          }\n          builder.addSlash();\n          continue;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          if (output) {\n            builder = builder || uri.pathBuilder();\n            builder.addSegment(output.bind());\n          }\n          if (builder) {\n            return Parser.done(builder.bind());\n          } else {\n            return Parser.done(uri.pathEmpty());\n          }\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          output = output || Utf8.decodedString();\n          input = input.step();\n          output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriPathParser(uri, builder, output, c1, step);\n  }\n}\nUriParser.PathParser = UriPathParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base16, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriQuery} from \"./UriQuery\";\nimport {UriQueryBuilder} from \"./UriQueryBuilder\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriQueryParser extends Parser<UriQuery> {\n  private readonly uri: UriParser;\n  private readonly builder: UriQueryBuilder | undefined;\n  private readonly keyOutput: Output<string> | undefined;\n  private readonly valueOutput: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, builder?: UriQueryBuilder, keyOutput?: Output<string>,\n              valueOutput?: Output<string>, c1?: number, step?: number) {\n    super();\n    this.uri = uri;\n    this.builder = builder;\n    this.keyOutput = keyOutput;\n    this.valueOutput = valueOutput;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriQuery> {\n    return UriQueryParser.parse(input, this.uri, this.builder, this.keyOutput,\n                                this.valueOutput, this.c1, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, builder?: UriQueryBuilder, keyOutput?: Output<string>,\n               valueOutput?: Output<string>, c1: number = 0, step: number = 1): Parser<UriQuery> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        keyOutput = keyOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isParamChar(c))) {\n          input = input.step();\n          keyOutput.write(c);\n        }\n        if (input.isCont() && c === 61/*'='*/) {\n          input = input.step();\n          step = 4;\n        } else if (input.isCont() && c === 38/*'&'*/) {\n          input = input.step();\n          builder = builder || uri.queryBuilder();\n          builder.addParam(keyOutput.bind());\n          keyOutput = void 0;\n          continue;\n        } else if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          builder = builder || uri.queryBuilder();\n          builder.addParam(keyOutput.bind());\n          return Parser.done(builder.bind());\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          keyOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 4) {\n        valueOutput = valueOutput || Utf8.decodedString();\n        while (input.isCont() && (c = input.head(), Uri.isParamChar(c) || c === 61/*'='*/)) {\n          input = input.step();\n          valueOutput.write(c);\n        }\n        if (input.isCont() && c === 38/*'&'*/) {\n          input = input.step();\n          builder = builder || uri.queryBuilder();\n          builder.addParam(keyOutput!.bind(), valueOutput.bind());\n          keyOutput = void 0;\n          valueOutput = void 0;\n          step = 1;\n          continue;\n        } else if (input.isCont() && c === 38/*'%'*/) {\n          input = input.step();\n          step = 5;\n        } else if (!input.isEmpty()) {\n          builder = builder || uri.queryBuilder();\n          builder.addParam(keyOutput!.bind(), valueOutput.bind());\n          return Parser.done(builder.bind());\n        }\n      }\n      if (step === 5) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 6;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 6) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          valueOutput!.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 4;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriQueryParser(uri, builder, keyOutput, valueOutput, c1, step);\n  }\n}\nUriParser.QueryParser = UriQueryParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base16, Utf8} from \"@swim/codec\";\nimport {Uri} from \"./Uri\";\nimport {UriFragment} from \"./UriFragment\";\nimport {UriParser} from \"./UriParser\";\n\n/** @hidden */\nexport class UriFragmentParser extends Parser<UriFragment> {\n  private readonly uri: UriParser;\n  private readonly output: Output<string> | undefined;\n  private readonly c1: number | undefined;\n  private readonly step: number | undefined;\n\n  constructor(uri: UriParser, output?: Output<string>, c1?: number, step?: number) {\n    super();\n    this.uri = uri;\n    this.output = output;\n    this.c1 = c1;\n    this.step = step;\n  }\n\n  feed(input: Input): Parser<UriFragment> {\n    return UriFragmentParser.parse(input, this.uri, this.output, this.c1, this.step);\n  }\n\n  static parse(input: Input, uri: UriParser, output?: Output<string>,\n               c1: number = 0, step: number = 1): Parser<UriFragment> {\n    let c = 0;\n    output = output || Utf8.decodedString();\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Uri.isFragmentChar(c))) {\n          input = input.step();\n          output = output.write(c);\n        }\n        if (input.isCont() && c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else if (!input.isEmpty()) {\n          return Parser.done(uri.fragment(output.bind()));\n        }\n      }\n      if (step === 2) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          c1 = c;\n          step = 3;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont() && (c = input.head(), Base16.isDigit(c))) {\n          input = input.step();\n          output = output.write((Base16.decodeDigit(c1) << 4) | Base16.decodeDigit(c));\n          c1 = 0;\n          step = 1;\n          continue;\n        } else if (!input.isEmpty()) {\n          return Parser.error(Diagnostic.expected(\"hex digit\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new UriFragmentParser(uri, output, c1, step);\n  }\n}\nUriParser.FragmentParser = UriFragmentParser;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Text, Form} from \"@swim/structure\";\nimport {Uri} from \"./Uri\";\n\n/** @hidden */\nexport class UriForm extends Form<Uri> {\n  /** @hidden */\n  readonly _unit: Uri | undefined;\n\n  constructor(unit?: Uri ) {\n    super();\n    this._unit = unit;\n  }\n\n  unit(): Uri | undefined;\n  unit(unit: Uri | undefined): Form<Uri>;\n  unit(unit?: Uri | undefined): Uri | undefined | Form<Uri> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new UriForm(unit);\n    }\n  }\n\n  mold(object: Uri, item?: Item): Item {\n    if (item === void 0) {\n      return Text.from(object.toString());\n    } else {\n      return item.concat(Text.from(object.toString()));\n    }\n  }\n\n  cast(item: Item, object?: Uri): Uri | undefined {\n    const value = item.target();\n    try {\n      const string = value.stringValue();\n      if (typeof string === \"string\") {\n        return Uri.parse(string);\n      }\n    } catch (error) {\n      // swallow\n    }\n    return void 0;\n  }\n}\nUri.Form = UriForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashGenCacheMap} from \"@swim/util\";\nimport {AnyUri, Uri} from \"./Uri\";\n\nexport class UriCache {\n  /** @hidden */\n  _base: Uri;\n  /** @hidden */\n  _resolveCache: HashGenCacheMap<Uri, Uri>;\n  /** @hidden */\n  _unresolveCache: HashGenCacheMap<Uri, Uri>;\n\n  constructor(base: Uri, size: number = 32) {\n    this._base = base;\n    this._resolveCache = new HashGenCacheMap(size);\n    this._unresolveCache = new HashGenCacheMap(size);\n  }\n\n  resolve(relative: AnyUri): Uri {\n    relative = Uri.fromAny(relative);\n    let absolute = this._resolveCache.get(relative);\n    if (absolute === undefined) {\n      absolute = this._base.resolve(relative);\n      this._resolveCache.put(relative, absolute);\n    }\n    return absolute;\n  }\n\n  unresolve(absolute: AnyUri): Uri {\n    absolute = Uri.fromAny(absolute);\n    let relative = this._unresolveCache.get(absolute);\n    if (relative === undefined) {\n      relative = this._base.unresolve(absolute);\n      this._unresolveCache.put(absolute, relative);\n    }\n    return relative;\n  }\n}\n"]}