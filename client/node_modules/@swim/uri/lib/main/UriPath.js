import { Murmur3, HashGenCacheSet } from "@swim/util";
import { Uri } from "./Uri";
var UriPath = (function () {
    function UriPath() {
    }
    Object.defineProperty(UriPath.prototype, "length", {
        get: function () {
            var n = 0;
            var path = this;
            while (!path.isEmpty()) {
                n += 1;
                path = path.tail();
            }
            return n;
        },
        enumerable: true,
        configurable: true
    });
    UriPath.prototype.get = function (index) {
        var i = 0;
        var path = this;
        while (!path.isEmpty()) {
            if (i < index) {
                i += 1;
                path = path.tail();
            }
            else {
                return path.head();
            }
        }
        return void 0;
    };
    UriPath.prototype.name = function (name) {
        if (name === void 0) {
            if (this.isEmpty()) {
                return "";
            }
            var path = this;
            do {
                var tail = path.tail();
                if (tail.isEmpty()) {
                    return path.isRelative() ? path.head() : "";
                }
                else {
                    path = tail;
                }
            } while (true);
        }
        else {
            var builder = new Uri.PathBuilder();
            builder.addPath(this.base());
            builder.addSegment(name);
            return builder.bind();
        }
    };
    UriPath.prototype.foot = function () {
        if (this.isEmpty()) {
            return this;
        }
        var path = this;
        do {
            var tail = path.tail();
            if (tail.isEmpty()) {
                return path;
            }
            else {
                path = tail;
            }
        } while (true);
    };
    UriPath.prototype.isSubpathOf = function (b) {
        b = UriPath.fromAny(b);
        var a = this;
        while (!a.isEmpty() && !b.isEmpty()) {
            if (a.head() !== b.head()) {
                return false;
            }
            a = a.tail();
            b = b.tail();
        }
        return b.isEmpty();
    };
    UriPath.prototype.appended = function () {
        var components = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            components[_i] = arguments[_i];
        }
        if (arguments.length > 0) {
            var builder = new Uri.PathBuilder();
            builder.addPath(this);
            builder.push.apply(builder, arguments);
            return builder.bind();
        }
        else {
            return this;
        }
    };
    UriPath.prototype.appendedSlash = function () {
        var builder = new Uri.PathBuilder();
        builder.addPath(this);
        builder.addSlash();
        return builder.bind();
    };
    UriPath.prototype.appendedSegment = function (segment) {
        var builder = new Uri.PathBuilder();
        builder.addPath(this);
        builder.addSegment(segment);
        return builder.bind();
    };
    UriPath.prototype.prepended = function () {
        var components = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            components[_i] = arguments[_i];
        }
        if (arguments.length > 0) {
            var builder = new Uri.PathBuilder();
            builder.push.apply(builder, arguments);
            builder.addPath(this);
            return builder.bind();
        }
        else {
            return this;
        }
    };
    UriPath.prototype.prependedSlash = function () {
        return UriPath.slash(this);
    };
    UriPath.prototype.prependedSegment = function (segment) {
        if (this.isEmpty() || this.isAbsolute()) {
            return UriPath.segment(segment, this);
        }
        else {
            return UriPath.segment(segment, UriPath.slash(this));
        }
    };
    UriPath.prototype.resolve = function (that) {
        if (that.isEmpty()) {
            return this;
        }
        else if (that.isAbsolute() || this.isEmpty()) {
            return that.removeDotSegments();
        }
        else {
            return this.merge(that).removeDotSegments();
        }
    };
    UriPath.prototype.removeDotSegments = function () {
        var path = this;
        var builder = new Uri.PathBuilder();
        while (!path.isEmpty()) {
            var head = path.head();
            if (head === "." || head === "..") {
                path = path.tail();
                if (!path.isEmpty()) {
                    path = path.tail();
                }
            }
            else if (path.isAbsolute()) {
                var rest = path.tail();
                if (!rest.isEmpty()) {
                    var next = rest.head();
                    if (next === ".") {
                        path = rest.tail();
                        if (path.isEmpty()) {
                            path = UriPath.slash();
                        }
                    }
                    else if (next === "..") {
                        path = rest.tail();
                        if (path.isEmpty()) {
                            path = UriPath.slash();
                        }
                        if (!builder.isEmpty() && !builder.pop().isAbsolute()) {
                            if (!builder.isEmpty()) {
                                builder.pop();
                            }
                        }
                    }
                    else {
                        builder.push(head, next);
                        path = rest.tail();
                    }
                }
                else {
                    builder.push(path.head());
                    path = path.tail();
                }
            }
            else {
                builder.push(path.head());
                path = path.tail();
            }
        }
        return builder.bind();
    };
    UriPath.prototype.merge = function (that) {
        if (!this.isEmpty()) {
            var builder = new Uri.PathBuilder();
            var prev = this;
            do {
                var next = prev.tail();
                if (!next.isEmpty()) {
                    if (prev.isAbsolute()) {
                        builder.addSlash();
                    }
                    else {
                        builder.addSegment(prev.head());
                    }
                    prev = next;
                }
                else {
                    if (prev.isAbsolute()) {
                        builder.addSlash();
                    }
                    break;
                }
            } while (true);
            builder.addPath(that);
            return builder.bind();
        }
        else {
            return that;
        }
    };
    UriPath.prototype.unmerge = function (relative, root) {
        if (root === void 0) { root = relative; }
        var base = this;
        do {
            if (base.isEmpty()) {
                if (!relative.isEmpty() && !relative.tail().isEmpty()) {
                    return relative.tail();
                }
                else {
                    return relative;
                }
            }
            else if (base.isRelative()) {
                return relative;
            }
            else if (relative.isRelative()) {
                return UriPath.slash(relative);
            }
            else {
                var a = base.tail();
                var b = relative.tail();
                if (!a.isEmpty() && b.isEmpty()) {
                    return UriPath.slash();
                }
                else if (a.isEmpty() || b.isEmpty() || a.head() !== b.head()) {
                    return b;
                }
                else {
                    a = a.tail();
                    b = b.tail();
                    if (!a.isEmpty() && b.isEmpty()) {
                        return root;
                    }
                    else {
                        base = a;
                        relative = b;
                    }
                }
            }
        } while (true);
    };
    UriPath.prototype.toAny = function () {
        var components = [];
        var path = this;
        while (!path.isEmpty()) {
            components.push(path.head());
            path = path.tail();
        }
        return components;
    };
    UriPath.prototype.compareTo = function (that) {
        var order = this.toString().localeCompare(that.toString());
        return order < 0 ? -1 : order > 0 ? 1 : 0;
    };
    UriPath.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof UriPath) {
            return this.toString() === that.toString();
        }
        return false;
    };
    UriPath.prototype.hashCode = function () {
        if (this._hashCode === void 0) {
            this._hashCode = Murmur3.hash(this.toString());
        }
        return this._hashCode;
    };
    UriPath.prototype.display = function (output) {
        var path = this;
        while (!path.isEmpty()) {
            if (path.isAbsolute()) {
                output = output.write(47);
            }
            else {
                Uri.writePathSegment(path.head(), output);
            }
            path = path.tail();
        }
    };
    UriPath.builder = function () {
        return new Uri.PathBuilder();
    };
    UriPath.empty = function () {
        if (UriPath._empty === void 0) {
            UriPath._empty = new Uri.PathEmpty();
        }
        return UriPath._empty;
    };
    UriPath.slash = function (tail) {
        if (tail === void 0) { tail = UriPath.empty(); }
        if (tail === UriPath.empty()) {
            if (UriPath._slash === void 0) {
                UriPath._slash = new Uri.PathSlash(tail);
            }
            return UriPath._slash;
        }
        else {
            return new Uri.PathSlash(tail);
        }
    };
    UriPath.segment = function (segment, tail) {
        if (tail === void 0) { tail = UriPath.empty(); }
        segment = this.cacheSegment(segment);
        return new Uri.PathSegment(segment, tail);
    };
    UriPath.from = function () {
        var components = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            components[_i] = arguments[_i];
        }
        var builder = new Uri.PathBuilder();
        builder.push.apply(builder, arguments);
        return builder.bind();
    };
    UriPath.fromAny = function (path) {
        if (path === null || path === void 0) {
            return UriPath.empty();
        }
        else if (path instanceof UriPath) {
            return path;
        }
        else if (Array.isArray(path)) {
            return UriPath.from.apply(void 0, arguments);
        }
        else if (typeof path === "string") {
            return UriPath.parse(path);
        }
        else {
            throw new TypeError("" + path);
        }
    };
    UriPath.parse = function (string) {
        return Uri.standardParser().parsePathString(string);
    };
    UriPath.segmentCache = function () {
        if (UriPath._segmentCache === void 0) {
            var segmentCacheSize = 64;
            UriPath._segmentCache = new HashGenCacheSet(segmentCacheSize);
        }
        return UriPath._segmentCache;
    };
    UriPath.cacheSegment = function (segment) {
        if (segment.length <= 32) {
            return this.segmentCache().put(segment);
        }
        else {
            return segment;
        }
    };
    UriPath.pathForm = function () {
        if (!UriPath._pathForm) {
            UriPath._pathForm = new Uri.PathForm(UriPath.empty());
        }
        return UriPath._pathForm;
    };
    return UriPath;
}());
export { UriPath };
Uri.Path = UriPath;
//# sourceMappingURL=UriPath.js.map