import { __extends } from "tslib";
import { Envelope, CommandMessage, AuthRequest } from "@swim/warp";
import { RemoteHost } from "./RemoteHost";
var WebSocketHost = (function (_super) {
    __extends(WebSocketHost, _super);
    function WebSocketHost(context, hostUri, options) {
        if (options === void 0) { options = {}; }
        return _super.call(this, context, hostUri, options) || this;
    }
    Object.defineProperty(WebSocketHost.prototype, "WebSocket", {
        get: function () {
            return this._options.WebSocket
                || typeof WebSocket !== "undefined" && WebSocket
                || typeof require === "function" && require("ws")
                || void 0;
        },
        enumerable: true,
        configurable: true
    });
    WebSocketHost.prototype.isConnected = function () {
        return this._socket ? this._socket.readyState === this._socket.OPEN : false;
    };
    WebSocketHost.prototype.open = function () {
        this.clearReconnect();
        if (!this._socket) {
            var WebSocket_1 = this.WebSocket;
            if (!WebSocket_1) {
                throw new Error("WebSocket undefined");
            }
            var hostUri = this._hostUri;
            var schemeName = hostUri.schemeName();
            if (schemeName === "warp" || schemeName === "swim") {
                hostUri = hostUri.scheme("ws");
            }
            else if (schemeName === "warps" || schemeName === "swims") {
                hostUri = hostUri.scheme("wss");
            }
            if (this._options.protocols) {
                this._socket = new WebSocket_1(hostUri.toString(), this._options.protocols);
            }
            else {
                this._socket = new WebSocket_1(hostUri.toString());
            }
            this._socket.onopen = this.onWebSocketOpen.bind(this);
            this._socket.onmessage = this.onWebSocketMessage.bind(this);
            this._socket.onclose = this.onWebSocketClose.bind(this);
            this._socket.onerror = this.onWebSocketError.bind(this);
        }
    };
    WebSocketHost.prototype.close = function () {
        this.clearReconnect();
        this.clearIdle();
        if (this._socket) {
            this._socket.close();
            if (!this._context.isOnline()) {
                this.onWebSocketClose();
            }
        }
        else {
            _super.prototype.close.call(this);
        }
    };
    WebSocketHost.prototype.push = function (envelope) {
        if (this.isConnected()) {
            this.clearIdle();
            var text = envelope.toRecon();
            this._socket.send(text);
            this.watchIdle();
        }
        else if (envelope instanceof CommandMessage) {
            if (this._sendBuffer.length < this.sendBufferSize()) {
                this._sendBuffer.push(envelope);
            }
            else {
                throw new Error("send buffer overflow");
            }
            this.open();
        }
    };
    WebSocketHost.prototype.onWebSocketOpen = function () {
        if (this.isConnected()) {
            var credentials = this.credentials();
            if (credentials.isDefined()) {
                var request = new AuthRequest(credentials);
                this.push(request);
            }
            this.onConnect();
            var envelope = void 0;
            while ((envelope = this._sendBuffer.shift()) && this.isConnected()) {
                this.push(envelope);
            }
            this.watchIdle();
        }
        else {
            this.close();
        }
    };
    WebSocketHost.prototype.onWebSocketMessage = function (message) {
        var data = message.data;
        if (typeof data === "string") {
            var envelope = Envelope.parseRecon(data);
            if (envelope) {
                this.onEnvelope(envelope);
            }
            else {
                this.onUnknownEnvelope(data);
            }
        }
    };
    WebSocketHost.prototype.onWebSocketClose = function () {
        if (this._socket) {
            this._socket.onopen = null;
            this._socket.onmessage = null;
            this._socket.onclose = null;
            this._socket.onerror = null;
            this._socket = void 0;
        }
        this.onDisconnect();
        this.clearIdle();
        if (!this.isIdle()) {
            if (this._context.isOnline()) {
                this.reconnect();
            }
        }
        else {
            this.close();
        }
    };
    WebSocketHost.prototype.onWebSocketError = function () {
        if (this._socket) {
            this._socket.close();
            if (!this._context.isOnline()) {
                this.onWebSocketClose();
            }
            else {
                this.onError();
            }
        }
    };
    return WebSocketHost;
}(RemoteHost));
export { WebSocketHost };
//# sourceMappingURL=WebSocketHost.js.map