import { Cursor } from "@swim/util";
import { Value, Form } from "@swim/structure";
import { Inlet, Outlet } from "@swim/streamlet";
import { MapValueFunction } from "@swim/streamlet";
import { WatchValueFunction } from "@swim/streamlet";
import { Uri } from "@swim/uri";
import { DownlinkContext } from "./DownlinkContext";
import { DownlinkOwner } from "./DownlinkOwner";
import { DownlinkType, DownlinkObserver, DownlinkInit, Downlink } from "./Downlink";
import { ValueDownlinkModel } from "./ValueDownlinkModel";
export declare type ValueDownlinkWillSet<V extends VU, VU = V> = (newValue: V, downlink: ValueDownlink<V, VU>) => V | void;
export declare type VaueDownlinkDidSet<V extends VU, VU = V> = (newValue: V, oldValue: V, downlink: ValueDownlink<V, VU>) => void;
export interface ValueDownlinkObserver<V extends VU, VU = V> extends DownlinkObserver {
    willSet?: ValueDownlinkWillSet<V, VU>;
    didSet?: VaueDownlinkDidSet<V, VU>;
}
export interface ValueDownlinkInit<V extends VU, VU = V> extends ValueDownlinkObserver<V, VU>, DownlinkInit {
    valueForm?: Form<V, VU>;
}
export declare class ValueDownlink<V extends VU, VU = V> extends Downlink implements Inlet<V>, Outlet<V> {
    _observers: ReadonlyArray<ValueDownlinkObserver<V, VU>> | null;
    _model: ValueDownlinkModel | null;
    _valueForm: Form<V, VU>;
    _state0: Value;
    _input: Outlet<V> | null;
    _outputs: ReadonlyArray<Inlet<V>> | null;
    _version: number;
    constructor(context: DownlinkContext, owner?: DownlinkOwner, init?: ValueDownlinkInit<V, VU>, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<ValueDownlinkObserver<V, VU>> | ValueDownlinkObserver<V, VU> | null, valueForm?: Form<V, VU>, state0?: Value);
    protected copy(context: DownlinkContext, owner: DownlinkOwner | undefined, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<ValueDownlinkObserver<V, VU>> | null, valueForm?: Form<V, VU>, state0?: Value): this;
    type(): DownlinkType;
    valueForm(): Form<V, VU>;
    valueForm<V2 extends V2U, V2U = V2>(valueForm: Form<V2, V2U>): ValueDownlink<V2, V2U>;
    get(): V;
    set(newObject: VU): void;
    setState(state: Value): void;
    observe(observer: ValueDownlinkObserver<V, VU>): this;
    willSet(willSet: ValueDownlinkWillSet<V, VU>): this;
    didSet(didSet: VaueDownlinkDidSet<V, VU>): this;
    valueWillSet(newValue: Value): Value;
    valueDidSet(newValue: Value, oldValue: Value): void;
    initialState(): Value;
    initialState(state0: Value): this;
    protected didAliasModel(): void;
    open(): this;
    input(): Outlet<V> | null;
    bindInput(input: Outlet<V> | null): void;
    unbindInput(): void;
    disconnectInputs(): void;
    outputIterator(): Cursor<Inlet<V>>;
    bindOutput(output: Inlet<V>): void;
    unbindOutput(output: Inlet<V>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    invalidateOutput(): void;
    invalidateInput(): void;
    invalidate(): void;
    reconcileOutput(version: number): void;
    reconcileInput(version: number): void;
    reconcile(version: number): void;
    protected willInvalidate(): void;
    protected onInvalidate(): void;
    protected didInvalidate(): void;
    protected willReconcile(version: number): void;
    protected onReconcile(version: number): void;
    protected didReconcile(version: number): void;
    memoize(): Outlet<V>;
    map<V2>(func: MapValueFunction<V, V2>): Outlet<V2>;
    watch(func: WatchValueFunction<V>): this;
}
//# sourceMappingURL=ValueDownlink.d.ts.map