import { Cursor, Map, OrderedMap } from "@swim/util";
import { BTree } from "@swim/collections";
import { Value, Form } from "@swim/structure";
import { Inlet, Outlet, KeyEffect, MapInlet, MapOutlet, KeyOutlet } from "@swim/streamlet";
import { FilterFieldsFunction } from "@swim/streamlet";
import { MapValueFunction } from "@swim/streamlet";
import { MapFieldValuesFunction } from "@swim/streamlet";
import { WatchValueFunction } from "@swim/streamlet";
import { WatchFieldsFunction } from "@swim/streamlet";
import { Uri } from "@swim/uri";
import { DownlinkContext } from "./DownlinkContext";
import { DownlinkOwner } from "./DownlinkOwner";
import { DownlinkType, DownlinkObserver, DownlinkInit, Downlink } from "./Downlink";
import { MapDownlinkModel } from "./MapDownlinkModel";
export declare type MapDownlinkWillUpdate<K extends KU, V extends VU, KU = K, VU = V> = (key: K, newValue: V, downlink: MapDownlink<K, V, KU, VU>) => V | void;
export declare type MapDownlinkDidUpdate<K extends KU, V extends VU, KU = K, VU = V> = (key: K, newValue: V, oldValue: V, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkWillRemove<K extends KU, V extends VU, KU = K, VU = V> = (key: K, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkDidRemove<K extends KU, V extends VU, KU = K, VU = V> = (key: K, oldValue: V, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkWillDrop<K extends KU, V extends VU, KU = K, VU = V> = (lower: number, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkDidDrop<K extends KU, V extends VU, KU = K, VU = V> = (lower: number, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkWillTake<K extends KU, V extends VU, KU = K, VU = V> = (upper: number, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkDidTake<K extends KU, V extends VU, KU = K, VU = V> = (upper: number, downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkWillClear<K extends KU, V extends VU, KU = K, VU = V> = (downlink: MapDownlink<K, V, KU, VU>) => void;
export declare type MapDownlinkDidClear<K extends KU, V extends VU, KU = K, VU = V> = (downlink: MapDownlink<K, V, KU, VU>) => void;
export interface MapDownlinkObserver<K extends KU, V extends VU, KU = K, VU = V> extends DownlinkObserver {
    willUpdate?: MapDownlinkWillUpdate<K, V, KU, VU>;
    didUpdate?: MapDownlinkDidUpdate<K, V, KU, VU>;
    willRemove?: MapDownlinkWillRemove<K, V, KU, VU>;
    didRemove?: MapDownlinkDidRemove<K, V, KU, VU>;
    willDrop?: MapDownlinkWillDrop<K, V, KU, VU>;
    didDrop?: MapDownlinkDidDrop<K, V, KU, VU>;
    willTake?: MapDownlinkWillTake<K, V, KU, VU>;
    didTake?: MapDownlinkDidTake<K, V, KU, VU>;
    willClear?: MapDownlinkWillClear<K, V, KU, VU>;
    didClear?: MapDownlinkDidClear<K, V, KU, VU>;
}
export interface MapDownlinkInit<K extends KU, V extends VU, KU = K, VU = V> extends MapDownlinkObserver<K, V, KU, VU>, DownlinkInit {
    keyForm?: Form<K, KU>;
    valueForm?: Form<V, VU>;
}
export declare class MapDownlink<K extends KU, V extends VU, KU = K, VU = V> extends Downlink implements OrderedMap<K, V>, MapInlet<K, V, Map<K, V>>, MapOutlet<K, V, MapDownlink<K, V, KU, VU>> {
    _observers: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>> | null;
    _model: MapDownlinkModel | null;
    _keyForm: Form<K, KU>;
    _valueForm: Form<V, VU>;
    _state0: BTree<Value, Value> | undefined;
    protected _input: MapOutlet<K, V, Map<K, V>> | null;
    protected _effects: BTree<K, KeyEffect>;
    protected _outlets: BTree<K, KeyOutlet<K, V>>;
    protected _outputs: ReadonlyArray<Inlet<MapDownlink<K, V>>> | null;
    protected _version: number;
    constructor(context: DownlinkContext, owner?: DownlinkOwner, init?: MapDownlinkInit<K, V, KU, VU>, hostUri?: Uri, nodeUri?: Uri, laneUri?: Uri, prio?: number, rate?: number, body?: Value, flags?: number, observers?: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>> | MapDownlinkObserver<K, V, KU, VU> | null, keyForm?: Form<K, KU>, valueForm?: Form<V, VU>, state0?: BTree<Value, Value>);
    protected copy(context: DownlinkContext, owner: DownlinkOwner | undefined, hostUri: Uri, nodeUri: Uri, laneUri: Uri, prio: number, rate: number, body: Value, flags: number, observers: ReadonlyArray<MapDownlinkObserver<K, V, KU, VU>> | null, keyForm?: Form<K, KU>, valueForm?: Form<V, VU>, state0?: BTree<Value, Value>): this;
    type(): DownlinkType;
    keyForm(): Form<K, KU>;
    keyForm<K2 extends K2U, K2U = K2>(keyForm: Form<K2, K2U>): MapDownlink<K2, V, K2U, VU>;
    valueForm(): Form<V, VU>;
    valueForm<V2 extends V2U, V2U = V2>(valueForm: Form<V2, V2U>): MapDownlink<K, V2, KU, V2U>;
    get size(): number;
    isEmpty(): boolean;
    has(key: KU): boolean;
    get(): MapDownlink<K, V, KU, VU>;
    get(key: KU): V;
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(keyObject: K): K | undefined;
    nextValue(keyObject: K): V | undefined;
    nextEntry(keyObject: K): [K, V] | undefined;
    previousKey(keyObject: K): K | undefined;
    previousValue(keyObject: K): V | undefined;
    previousEntry(keyObject: K): [K, V] | undefined;
    set(key: KU, newValue: VU): this;
    delete(key: KU): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T, S = unknown>(callback: (this: S, key: K, value: V, downlink: MapDownlink<K, V, KU, VU>) => T | void, thisArg?: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    entries(): Cursor<[K, V]>;
    snapshot(): BTree<Value, Value>;
    setState(state: BTree<Value, Value>): void;
    observe(observer: MapDownlinkObserver<K, V, KU, VU>): this;
    willUpdate(willUpdate: MapDownlinkWillUpdate<K, V, KU, VU>): this;
    didUpdate(didUpdate: MapDownlinkDidUpdate<K, V, KU, VU>): this;
    willRemove(willRemove: MapDownlinkWillRemove<K, V, KU, VU>): this;
    didRemove(didRemove: MapDownlinkDidRemove<K, V, KU, VU>): this;
    willDrop(willDrop: MapDownlinkWillDrop<K, V, KU, VU>): this;
    didDrop(didDrop: MapDownlinkDidDrop<K, V, KU, VU>): this;
    willTake(willTake: MapDownlinkWillTake<K, V, KU, VU>): this;
    didTake(didTake: MapDownlinkDidTake<K, V, KU, VU>): this;
    willClear(willClear: MapDownlinkWillClear<K, V, KU, VU>): this;
    didClear(didClear: MapDownlinkDidClear<K, V, KU, VU>): this;
    mapWillUpdate(key: Value, newValue: Value): Value;
    mapDidUpdate(key: Value, newValue: Value, oldValue: Value): void;
    mapWillRemove(key: Value): void;
    mapDidRemove(key: Value, oldValue: Value): void;
    mapWillDrop(lower: number): void;
    mapDidDrop(lower: number): void;
    mapWillTake(upper: number): void;
    mapDidTake(upper: number): void;
    mapWillClear(): void;
    mapDidClear(): void;
    initialState(): BTree<Value, Value> | null;
    initialState(state0: BTree<Value, Value> | null): this;
    protected didAliasModel(): void;
    open(): this;
    keyIterator(): Cursor<K>;
    input(): MapOutlet<K, V, Map<K, V>> | null;
    bindInput(input: MapOutlet<K, V, Map<K, V>>): void;
    unbindInput(): void;
    disconnectInputs(): void;
    outlet(key: K): Outlet<V>;
    outputIterator(): Cursor<Inlet<MapDownlink<K, V>>>;
    bindOutput(output: Inlet<MapDownlink<K, V>>): void;
    unbindOutput(output: Inlet<MapDownlink<K, V>>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    invalidateOutputKey(key: K, effect: KeyEffect): void;
    invalidateInputKey(key: K, effect: KeyEffect): void;
    invalidateKey(key: K, effect: KeyEffect): void;
    invalidateOutput(): void;
    invalidateInput(): void;
    invalidate(): void;
    reconcileOutputKey(key: K, version: number): void;
    reconcileInputKey(key: K, version: number): void;
    reconcileKey(key: K, version: number): void;
    reconcileOutput(version: number): void;
    reconcileInput(version: number): void;
    reconcile(version: number): void;
    protected willInvalidateKey(key: K, effect: KeyEffect): void;
    protected onInvalidateKey(key: K, effect: KeyEffect): void;
    protected didInvalidateKey(key: K, effect: KeyEffect): void;
    protected willInvalidate(): void;
    protected onInvalidate(): void;
    protected didInvalidate(): void;
    protected willReconcileKey(key: K, effect: KeyEffect, version: number): void;
    protected onReconcileKey(key: K, effect: KeyEffect, version: number): void;
    protected didReconcileKey(key: K, effect: KeyEffect, version: number): void;
    protected willReconcile(version: number): void;
    protected onReconcile(version: number): void;
    protected didReconcile(version: number): void;
    memoize(): MapOutlet<K, V, MapDownlink<K, V, KU, VU>>;
    filter(func: FilterFieldsFunction<K, V>): MapOutlet<K, V, Map<K, V>>;
    map<O2>(func: MapValueFunction<MapDownlink<K, V, KU, VU>, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<K, V, V2>): MapOutlet<K, V2, Map<K, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<MapDownlink<K, V, KU, VU>>): this;
    watch(func: WatchFieldsFunction<K, V>): this;
}
//# sourceMappingURL=MapDownlink.d.ts.map