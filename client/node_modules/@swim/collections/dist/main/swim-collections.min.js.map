{"version":3,"sources":["../../../../../node_modules/tslib/tslib.es6.js","../../main/KeysCursor.ts","../../main/ValuesCursor.ts","../../main/NodeCursor.ts","../../main/BTreeContext.ts","../../main/BTree.ts","../../main/BTreePage.ts","../../main/BTreeLeaf.ts","../../main/BTreeNode.ts","../../main/BTreeNodeCursor.ts","../../main/STreeContext.ts","../../main/STree.ts","../../main/STreePage.ts","../../main/STreeLeaf.ts","../../main/STreeNode.ts","../../main/STreeNodeCursor.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","KeysCursor","cursor","_this","_super","call","_cursor","isEmpty","head","step","skip","count","hasNext","nextIndex","next","_a","value","done","hasPrevious","previousIndex","previous","delete","Cursor","ValuesCursor","NodeCursor","pages","index","pageIndex","pageCursor","_pages","_index","_pageIndex","_pageCursor","length","Error","page","pageSize","reversePageCursor","set","newValue","BTreeContext","compare","x","y","Objects","pageShouldSplit","arity","pageSplitSize","pageShouldMerge","BTree","root","Page","empty","defineProperty","size","has","key","get","getEntry","firstKey","entry","firstEntry","firstValue","lastKey","lastEntry","lastValue","nextKey","nextEntry","nextValue","previousKey","previousEntry","previousValue","oldRoot","newRoot","updated","balanced","removed","drop","lower","take","upper","clear","copy","cleared","reduced","identity","accumulator","combiner","fold","forEach","callback","thisArg","keys","values","entries","reverseKeys","reverseValues","reverseEntries","clone","tree","BTreePage","_empty","Leaf","BTreeLeaf","slots","_slots","_fold","minKey","maxKey","lookup","updatedSlot","insertedSlot","oldSlots","newSlots","slice","newLeaf","n","i","removedSlot","split","newPages","newLeftPage","splitLeft","newRightPage","splitRight","newKnots","newNode","slot","result","array","lo","hi","mid","order","knots","Node","BTreeNode","_knots","_size","xx","oldPage","newPage","updatedPageSplit","updatedPage","oldKnots","newSize","oldPages","updatedPageMerge","midPages","midKnots","replacedPage","removedPage","newArity","BTreeNodeCursor","subCursor","STreeContext","identify","id","Uint8Array","Random","fillBytes","STree","RangeError","insert","inserted","remove","push","newValues","_i","arguments","pop","oldValue","unshift","shift","move","fromIndex","toIndex","splice","start","deleteCount","Math","min","max","deleted","isFinite","STreePage","STreeLeaf","updatedItem","oldItems","oldSlot","insertedItem","offset","STreeNode","subIndex","STreeNodeCursor"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/collections/dist/main/swim-collections.min.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\n\n/** @hidden */\nexport class KeysCursor<K, V> extends Cursor<K> {\n  private readonly _cursor: Cursor<[K, V]>;\n\n  constructor(cursor: Cursor<[K, V]>) {\n    super();\n    this._cursor = cursor;\n  }\n\n  isEmpty(): boolean {\n    return this._cursor.isEmpty();\n  }\n\n  head(): K {\n    return this._cursor.head()[0];\n  }\n\n  step(): void {\n    this._cursor.step();\n  }\n\n  skip(count: number): void {\n    this._cursor.skip(count);\n  }\n\n  hasNext(): boolean {\n    return this._cursor.hasNext();\n  }\n\n  nextIndex(): number {\n    return this._cursor.nextIndex();\n  }\n\n  next(): {value?: K, done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && value[0], done};\n  }\n\n  hasPrevious(): boolean {\n    return this._cursor.hasPrevious();\n  }\n\n  previousIndex(): number {\n    return this._cursor.previousIndex();\n  }\n\n  previous(): {value?: K, done: boolean} {\n    const {value, done} = this._cursor.previous();\n    return {value: value && value[0], done};\n  }\n\n  delete(): void {\n    this._cursor.delete();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\n\n/** @hidden */\nexport class ValuesCursor<K, V> extends Cursor<V> {\n  private readonly _cursor: Cursor<[K, V]>;\n\n  constructor(cursor: Cursor<[K, V]>) {\n    super();\n    this._cursor = cursor;\n  }\n\n  isEmpty(): boolean {\n    return this._cursor.isEmpty();\n  }\n\n  head(): V {\n    return this._cursor.head()[1];\n  }\n\n  step(): void {\n    this._cursor.step();\n  }\n\n  skip(count: number): void {\n    this._cursor.skip(count);\n  }\n\n  hasNext(): boolean {\n    return this._cursor.hasNext();\n  }\n\n  nextIndex(): number {\n    return this._cursor.nextIndex();\n  }\n\n  next(): {value?: V, done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && value[1], done};\n  }\n\n  hasPrevious(): boolean {\n    return this._cursor.hasPrevious();\n  }\n\n  previousIndex(): number {\n    return this._cursor.previousIndex();\n  }\n\n  previous(): {value?: V, done: boolean} {\n    const {value, done} = this._cursor.previous();\n    return {value: value && value[1], done};\n  }\n\n  delete(): void {\n    this._cursor.delete();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\n\n/** @hidden */\nexport abstract class NodeCursor<T, P> extends Cursor<T> {\n  /** @hidden */\n  readonly _pages: P[];\n  /** @hidden */\n  _index: number;\n  /** @hidden */\n  _pageIndex: number;\n  /** @hidden */\n  _pageCursor: Cursor<T> | undefined;\n\n  constructor(pages: P[], index: number = 0, pageIndex: number = 0, pageCursor?: Cursor<T>) {\n    super();\n    this._pages = pages;\n    this._index = index;\n    this._pageIndex = pageIndex;\n    this._pageCursor = pageCursor;\n  }\n\n  protected abstract pageSize(page: P): number;\n\n  protected abstract pageCursor(page: P): Cursor<T>;\n\n  protected abstract reversePageCursor(page: P): Cursor<T>;\n\n  isEmpty(): boolean {\n    do {\n      if (this._pageCursor) {\n        if (!this._pageCursor.isEmpty()) {\n          return false;\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else if (this._pageIndex < this._pages.length) {\n        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);\n        this._pageIndex += 1;\n      } else {\n        this._pageIndex = this._pages.length;\n        return true;\n      }\n    } while (true);\n  }\n\n  head(): T {\n    do {\n      if (this._pageCursor) {\n        if (!this._pageCursor.isEmpty()) {\n          return this._pageCursor.head();\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else {\n        if (this._pageIndex < this._pages.length) {\n          this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);\n          this._pageIndex += 1;\n        } else {\n          this._pageIndex = this._pages.length;\n          throw new Error(\"empty\");\n        }\n      }\n    } while (true);\n  }\n\n  step(): void {\n    do {\n      if (this._pageCursor) {\n        if (!this._pageCursor.isEmpty()) {\n          this._index += 1;\n          return;\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else {\n        if (this._pageIndex < this._pages.length) {\n          this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);\n          this._pageIndex += 1;\n        } else {\n          this._pageIndex = this._pages.length;\n          throw new Error(\"empty\");\n        }\n      }\n    } while (true);\n  }\n\n  skip(count: number): void {\n    while (count > 0) {\n      if (this._pageCursor) {\n        if (this._pageCursor.hasNext()) {\n          this._index += 1;\n          count -= 1;\n          this._pageCursor.next();\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else if (this._pageIndex < this._pages.length) {\n        const page = this._pages[this._pageIndex];\n        const pageSize = this.pageSize(page);\n        this._pageIndex += 1;\n        if (pageSize < count) {\n          this._pageCursor = this.pageCursor(page);\n          if (count > 0) {\n            this._index += count;\n            this._pageCursor!.skip(count);\n            count = 0;\n          }\n          break;\n        } else {\n          this._index += pageSize;\n          count -= pageSize;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  hasNext(): boolean {\n    do {\n      if (this._pageCursor) {\n        if (this._pageCursor.hasNext()) {\n          return true;\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else if (this._pageIndex < this._pages.length) {\n        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);\n        this._pageIndex += 1;\n      } else {\n        this._pageIndex = this._pages.length;\n        return false;\n      }\n    } while (true);\n  }\n\n  nextIndex(): number {\n    return this._index;\n  }\n\n  next(): {value?: T, done: boolean} {\n    do {\n      if (this._pageCursor) {\n        if (this._pageCursor.hasNext()) {\n          this._index += 1;\n          return this._pageCursor.next();\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else {\n        if (this._pageIndex < this._pages.length) {\n          this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);\n          this._pageIndex += 1;\n        } else {\n          this._pageIndex = this._pages.length;\n          return {done: true};\n        }\n      }\n    } while (true);\n  }\n\n  hasPrevious(): boolean {\n    do {\n      if (this._pageCursor) {\n        if (this._pageCursor.hasPrevious()) {\n          return true;\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else if (this._pageIndex > 0) {\n        this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);\n        this._pageIndex -= 1;\n      } else {\n        this._pageIndex = 0;\n        return false;\n      }\n    } while (true);\n  }\n\n  previousIndex(): number {\n    return this._index - 1;\n  }\n\n  previous(): {value?: T, done: boolean} {\n    do {\n      if (this._pageCursor) {\n        if (this._pageCursor.hasPrevious()) {\n          this._index -= 1;\n          return this._pageCursor.previous();\n        } else {\n          this._pageCursor = void 0;\n        }\n      } else if (this._pageIndex > 0) {\n        this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);\n        this._pageIndex -= 1;\n      } else {\n        this._pageIndex = 0;\n        return {done: true};\n      }\n    } while (true);\n  }\n\n  set(newValue: T): void {\n    this._pageCursor!.set(newValue);\n  }\n\n  delete(): void {\n    this._pageCursor!.delete();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Objects} from \"@swim/util\";\nimport {BTreePage} from \"./BTreePage\";\n\n/** @hidden */\nexport abstract class BTreeContext<K, V> {\n  pageSplitSize: number;\n\n  compare(x: K, y: K): number {\n    return Objects.compare(x, y);\n  }\n\n  pageShouldSplit(page: BTreePage<K, V, unknown>): boolean {\n    return page.arity > this.pageSplitSize;\n  }\n\n  pageShouldMerge(page: BTreePage<K, V, unknown>): boolean {\n    return page.arity < this.pageSplitSize >>> 1;\n  }\n}\nBTreeContext.prototype.pageSplitSize = 32;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor, ReducedMap} from \"@swim/util\";\nimport {BTreeContext} from \"./BTreeContext\";\nimport {BTreePage} from \"./BTreePage\";\nimport {BTreeLeaf} from \"./BTreeLeaf\";\nimport {BTreeNode} from \"./BTreeNode\";\nimport {BTreeNodeCursor} from \"./BTreeNodeCursor\";\n\nexport class BTree<K = unknown, V = unknown, U = unknown> extends BTreeContext<K, V> implements ReducedMap<K, V, U> {\n  root: BTreePage<K, V, U>;\n\n  constructor(root: BTreePage<K, V, U> = BTree.Page.empty()) {\n    super();\n    this.root = root;\n  }\n\n  get size(): number {\n    return this.root.size;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  has(key: K): boolean {\n    return this.root.has(key, this);\n  }\n\n  get(key: K): V | undefined {\n    return this.root.get(key, this);\n  }\n\n  getEntry(index: number): [K, V] | undefined {\n    return this.root.getEntry(index);\n  }\n\n  firstKey(): K | undefined {\n    const entry = this.root.firstEntry();\n    if (entry) {\n      return entry[0];\n    } else {\n      return void 0;\n    }\n  }\n\n  firstValue(): V | undefined {\n    const entry = this.root.firstEntry();\n    if (entry) {\n      return entry[1];\n    } else {\n      return void 0;\n    }\n  }\n\n  firstEntry(): [K, V] | undefined {\n    return this.root.firstEntry();\n  }\n\n  lastKey(): K | undefined {\n    const entry = this.root.lastEntry();\n    if (entry) {\n      return entry[0];\n    } else {\n      return void 0;\n    }\n  }\n\n  lastValue(): V | undefined {\n    const entry = this.root.lastEntry();\n    if (entry) {\n      return entry[1];\n    } else {\n      return void 0;\n    }\n  }\n\n  lastEntry(): [K, V] | undefined {\n    return this.root.lastEntry();\n  }\n\n  nextKey(key: K): K | undefined {\n    const entry = this.root.nextEntry(key, this);\n    if (entry) {\n      return entry[0];\n    } else {\n      return void 0;\n    }\n  }\n\n  nextValue(key: K): V | undefined {\n    const entry = this.root.nextEntry(key, this);\n    if (entry) {\n      return entry[1];\n    } else {\n      return void 0;\n    }\n  }\n\n  nextEntry(key: K): [K, V] | undefined {\n    return this.root.nextEntry(key, this);\n  }\n\n  previousKey(key: K): K | undefined {\n    const entry = this.root.previousEntry(key, this);\n    if (entry) {\n      return entry[0];\n    } else {\n      return void 0;\n    }\n  }\n\n  previousValue(key: K): V | undefined {\n    const entry = this.root.previousEntry(key, this);\n    if (entry) {\n      return entry[1];\n    } else {\n      return void 0;\n    }\n  }\n\n  previousEntry(key: K): [K, V] | undefined {\n    return this.root.previousEntry(key, this);\n  }\n\n  set(key: K, newValue: V): this {\n    const oldRoot = this.root;\n    let newRoot = this.root.updated(key, newValue, this);\n    if (oldRoot !== newRoot) {\n      if (newRoot.size > oldRoot.size) {\n        newRoot = newRoot.balanced(this);\n      }\n      this.root = newRoot;\n    }\n    return this;\n  }\n\n  delete(key: K): boolean {\n    const oldRoot = this.root;\n    const newRoot = this.root.removed(key, this);\n    if (oldRoot !== newRoot) {\n      this.root = newRoot;\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  drop(lower: number): this {\n    if (lower > 0 && this.root.size > 0) {\n      if (lower < this.root.size) {\n        this.root = this.root.drop(lower, this);\n      } else {\n        this.root = BTree.Page.empty();\n      }\n    }\n    return this;\n  }\n\n  take(upper: number): this {\n    if (upper < this.root.size && this.root.size > 0) {\n      if (upper > 0) {\n        this.root = this.root.take(upper, this);\n      } else {\n        this.root = BTree.Page.empty();\n      }\n    }\n    return this;\n  }\n\n  clear(): void {\n    this.root = BTree.Page.empty();\n  }\n\n  updated(key: K, newValue: V): BTree<K, V> {\n    const oldRoot = this.root;\n    let newRoot = oldRoot.updated(key, newValue, this);\n    if (oldRoot !== newRoot) {\n      if (newRoot.size > oldRoot.size) {\n        newRoot = newRoot.balanced(this);\n      }\n      return this.copy(newRoot);\n    } else {\n      return this;\n    }\n  }\n\n  removed(key: K): BTree<K, V> {\n    const oldRoot = this.root;\n    const newRoot = oldRoot.removed(key, this);\n    if (oldRoot !== newRoot) {\n      return this.copy(newRoot);\n    } else {\n      return this;\n    }\n  }\n\n  cleared(): BTree<K, V> {\n    if (!this.root.isEmpty()) {\n      return this.copy(BTree.Page.empty());\n    } else {\n      return this;\n    }\n  }\n\n  reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): U {\n    const oldRoot = this.root;\n    const newRoot = oldRoot.reduced(identity, accumulator, combiner);\n    if (oldRoot !== newRoot) {\n      this.root = newRoot;\n    }\n    return newRoot.fold()!;\n  }\n\n  forEach<T, S = unknown>(callback: (this: S,\n                                     key: K,\n                                     value: V,\n                                     tree: BTree<K, V>) => T | void,\n                          thisArg?: S): T | undefined {\n    return this.root.forEach(callback, thisArg, this);\n  }\n\n  keys(): Cursor<K> {\n    return this.root.keys();\n  }\n\n  values(): Cursor<V> {\n    return this.root.values();\n  }\n\n  entries(): Cursor<[K, V]> {\n    return this.root.entries();\n  }\n\n  reverseKeys(): Cursor<K> {\n    return this.root.reverseKeys();\n  }\n\n  reverseValues(): Cursor<V> {\n    return this.root.reverseValues();\n  }\n\n  reverseEntries(): Cursor<[K, V]> {\n    return this.root.reverseEntries();\n  }\n\n  clone(): BTree<K, V> {\n    return this.copy(this.root);\n  }\n\n  protected copy(root: BTreePage<K, V, U>): BTree<K, V, U> {\n    const tree = new BTree(root);\n    if (tree.compare !== this.compare) {\n      tree.compare = this.compare;\n    }\n    if (tree.pageSplitSize !== this.pageSplitSize) {\n      tree.pageSplitSize = this.pageSplitSize;\n    }\n    return tree;\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Page: typeof BTreePage; // defined by BTreePage\n  /** @hidden */\n  static Leaf: typeof BTreeLeaf; // defined by BTreeLeaf\n  /** @hidden */\n  static Node: typeof BTreeNode; // defined by BTreeNode\n  /** @hidden */\n  static NodeCursor: typeof BTreeNodeCursor; // defined by BTreeNodeCursor\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {KeysCursor} from \"./KeysCursor\";\nimport {ValuesCursor} from \"./ValuesCursor\";\nimport {BTreeContext} from \"./BTreeContext\";\nimport {BTree} from \"./BTree\";\nimport {BTreeLeaf} from \"./BTreeLeaf\";\n\n/** @hidden */\nexport abstract class BTreePage<K, V, U> {\n  abstract get arity(): number;\n\n  abstract get size(): number;\n\n  abstract isEmpty(): boolean;\n\n  abstract fold(): U | undefined;\n\n  abstract minKey(): K;\n\n  abstract maxKey(): K;\n\n  abstract has(key: K, tree: BTreeContext<K, V>): boolean;\n\n  abstract get(key: K, tree: BTreeContext<K, V>): V | undefined;\n\n  abstract getEntry(index: number): [K, V] | undefined;\n\n  abstract firstEntry(): [K, V] | undefined;\n\n  abstract lastEntry(): [K, V] | undefined;\n\n  abstract nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;\n\n  abstract previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;\n\n  abstract updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;\n\n  abstract split(index: number): BTreePage<K, V, U>;\n\n  abstract splitLeft(index: number): BTreePage<K, V, U>;\n\n  abstract splitRight(index: number): BTreePage<K, V, U>;\n\n  abstract reduced(identity: U, accumulator: (result: U, element: V) => U,\n                   combiner: (result: U, result2: U) => U): BTreePage<K, V, U>;\n\n  abstract forEach<T, S>(callback: (this: S,\n                                    key: K,\n                                    value: V,\n                                    tree: BTree<K, V>) => T | void,\n                         thisArg: S,\n                         tree: BTree<K, V>): T | undefined;\n\n  keys(): Cursor<K> {\n    return new KeysCursor(this.entries());\n  }\n\n  values(): Cursor<V> {\n    return new ValuesCursor(this.entries());\n  }\n\n  abstract entries(): Cursor<[K, V]>;\n\n  reverseKeys(): Cursor<K> {\n    return new KeysCursor(this.reverseEntries());\n  }\n\n  reverseValues(): Cursor<V> {\n    return new ValuesCursor(this.reverseEntries());\n  }\n\n  abstract reverseEntries(): Cursor<[K, V]>;\n\n  private static _empty: BTreeLeaf<unknown, unknown, unknown>;\n\n  static empty<K, V, U>(): BTreeLeaf<K, V, U> {\n    if (!BTreePage._empty) {\n      BTreePage._empty = new BTree.Leaf([], void 0);\n    }\n    return BTreePage._empty as BTreeLeaf<K, V, U>;\n  }\n}\nBTree.Page = BTreePage;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {BTreeContext} from \"./BTreeContext\";\nimport {BTree} from \"./BTree\";\nimport {BTreePage} from \"./BTreePage\";\nimport {BTreeNode} from \"./BTreeNode\";\n\n/** @hidden */\nexport class BTreeLeaf<K, V, U> extends BTreePage<K, V, U> {\n  readonly _slots: [K, V][];\n  readonly _fold: U | undefined;\n\n  constructor(slots: [K, V][], fold: U | undefined) {\n    super();\n    this._slots = slots;\n    this._fold = fold;\n  }\n\n  get arity(): number {\n    return this._slots.length;\n  }\n\n  get size(): number {\n    return this._slots.length;\n  }\n\n  isEmpty(): boolean {\n    return this._slots.length === 0;\n  }\n\n  fold(): U | undefined {\n    return this._fold;\n  }\n\n  minKey(): K {\n    return this._slots[0][0];\n  }\n\n  maxKey(): K {\n    return this._slots[this._slots.length - 1][0];\n  }\n\n  has(key: K, tree: BTreeContext<K, V>): boolean {\n    return this.lookup(key, tree) >= 0;\n  }\n\n  get(key: K, tree: BTreeContext<K, V>): V | undefined {\n    const x = this.lookup(key, tree);\n    if (x >= 0) {\n      return this._slots[x][1];\n    } else {\n      return void 0;\n    }\n  }\n\n  getEntry(index: number): [K, V] | undefined {\n    return this._slots[index];\n  }\n\n  firstEntry(): [K, V] | undefined {\n    if (this._slots.length) {\n      return this._slots[0];\n    } else {\n      return void 0;\n    }\n  }\n\n  lastEntry(): [K, V] | undefined {\n    if (this._slots.length) {\n      return this._slots[this._slots.length - 1];\n    } else {\n      return void 0;\n    }\n  }\n\n  nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    return this._slots[x];\n  }\n\n  previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x -= 1;\n    } else {\n      x = -(x + 2);\n    }\n    return this._slots[x];\n  }\n\n  updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      return this.updatedSlot(x, key, newValue);\n    } else {\n      x = -(x + 1);\n      return this.insertedSlot(x, key, newValue);\n    }\n  }\n\n  private updatedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    if (newValue !== oldSlots[x][1]) {\n      const newSlots = oldSlots.slice(0);\n      newSlots[x] = [key, newValue];\n      return this.newLeaf(newSlots, void 0);\n    } else {\n      return this;\n    }\n  }\n\n  private insertedSlot(x: number, key: K, newValue: V): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    const n = oldSlots.length + 1;\n    const newSlots = new Array<[K, V]>(n);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    newSlots[x] = [key, newValue];\n    for (let i = x; i < n - 1; i += 1) {\n      newSlots[i + 1] = oldSlots[i];\n    }\n    return this.newLeaf(newSlots, void 0);\n  }\n\n  removed(key: K, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    const x = this.lookup(key, tree);\n    if (x >= 0) {\n      if (this._slots.length > 1) {\n        return this.removedSlot(x);\n      } else {\n        return BTreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  private removedSlot(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    const newSlots = new Array<[K, V]>(oldSlots.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    for (let i = x; i < newSlots.length; i += 1) {\n      newSlots[i] = oldSlots[i + 1];\n    }\n    return this.newLeaf(newSlots, void 0);\n  }\n\n  drop(lower: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    if (lower > 0) {\n      const oldSlots = this._slots;\n      if (lower < oldSlots.length) {\n        const size = oldSlots.length - lower;\n        const newSlots = new Array<[K, V]>(size);\n        for (let i = 0; i < size; i += 1) {\n          newSlots[i] = oldSlots[i + lower];\n        }\n        return this.newLeaf(newSlots, void 0);\n      } else {\n        return BTreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  take(upper: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    if (upper < oldSlots.length) {\n      if (upper > 0) {\n        const newSlots = new Array<[K, V]>(upper);\n        for (let i = 0; i < upper; i += 1) {\n          newSlots[i] = oldSlots[i];\n        }\n        return this.newLeaf(newSlots, void 0);\n      } else {\n        return BTreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    const n = this._slots.length;\n    if (n > 1 && tree.pageShouldSplit(this)) {\n      const x = n >>> 1;\n      return this.split(x);\n    } else {\n      return this;\n    }\n  }\n\n  split(x: number): BTreeNode<K, V, U> {\n    const newPages = new Array<BTreePage<K, V, U>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<K>(1);\n    newKnots[0] = newRightPage.minKey();\n\n    return this.newNode(newPages, newKnots, void 0, this._slots.length);\n  }\n\n  splitLeft(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    const newSlots = new Array<[K, V]>(x);\n    for (let i = 0; i < x; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    return this.newLeaf(newSlots, void 0);\n  }\n\n  splitRight(x: number): BTreeLeaf<K, V, U> {\n    const oldSlots = this._slots;\n    const y = oldSlots.length - x;\n    const newSlots = new Array<[K, V]>(y);\n    for (let i = 0; i < y; i += 1) {\n      newSlots[i] = oldSlots[i + x];\n    }\n    return this.newLeaf(newSlots, void 0);\n  }\n\n  reduced(identity: U, accumulator: (result: U, element: V) => U,\n          combiner: (result: U, result2: U) => U): BTreeLeaf<K, V, U> {\n    if (this._fold === void 0) {\n      const slots = this._slots;\n      let fold = identity;\n      for (let i = 0, n = slots.length; i < n; i += 1) {\n        fold = accumulator(fold, slots[i][1]);\n      }\n      return this.newLeaf(slots, fold);\n    } else {\n      return this;\n    }\n  }\n\n  forEach<T, S>(callback: (this: S,\n                           key: K,\n                           value: V,\n                           tree: BTree<K, V>) => T | void,\n                thisArg: S,\n                tree: BTree<K, V>): T | undefined {\n    const slots = this._slots;\n    for (let i = 0, n = slots.length; i < n; i += 1) {\n      const slot = slots[i];\n      const result = callback.call(thisArg, slot[0], slot[1], tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  entries(): Cursor<[K, V]> {\n    return Cursor.array(this._slots);\n  }\n\n  reverseEntries(): Cursor<[K, V]> {\n    return Cursor.array(this._slots, this._slots.length);\n  }\n\n  private lookup(key: K, tree: BTreeContext<K, V>): number {\n    let lo = 0;\n    let hi = this._slots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      const order = tree.compare(key, this._slots[mid][0]);\n      if (order > 0) {\n        lo = mid + 1;\n      } else if (order < 0) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n\n  protected newLeaf(slots: [K, V][], fold: U | undefined): BTreeLeaf<K, V, U> {\n    return new BTreeLeaf(slots, fold);\n  }\n\n  protected newNode(pages: BTreePage<K, V, U>[], knots: K[], fold: U | undefined, size: number): BTreeNode<K, V, U> {\n    return new BTree.Node(pages, knots, fold, size);\n  }\n}\nBTree.Leaf = BTreeLeaf;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {BTreeContext} from \"./BTreeContext\";\nimport {BTree} from \"./BTree\";\nimport {BTreePage} from \"./BTreePage\";\n\n/** @hidden */\nexport class BTreeNode<K, V, U> extends BTreePage<K, V, U> {\n  readonly _pages: BTreePage<K, V, U>[];\n  readonly _knots: K[];\n  readonly _fold: U | undefined;\n  readonly _size: number;\n\n  constructor(pages: BTreePage<K, V, U>[], knots: K[], fold: U | undefined, size: number) {\n    super();\n    this._pages = pages;\n    this._knots = knots;\n    this._fold = fold;\n    this._size = size;\n  }\n\n  get arity(): number {\n    return this._pages.length;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  fold(): U | undefined {\n    return this._fold;\n  }\n\n  minKey(): K {\n    return this._pages[0].minKey();\n  }\n\n  maxKey(): K {\n    return this._pages[this._pages.length - 1].maxKey();\n  }\n\n  has(key: K, tree: BTreeContext<K, V>): boolean {\n    let xx = this.lookup(key, tree);\n    if (xx > 0) {\n      xx += 1;\n    } else if (xx < 0) {\n      xx = -(xx + 1);\n    } else {\n      return true;\n    }\n    return this._pages[xx].has(key, tree);\n  }\n\n  get(key: K, tree: BTreeContext<K, V>): V | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    return this._pages[x].get(key, tree);\n  }\n\n  getEntry(x: number): [K, V] | undefined {\n    const pages = this._pages;\n    for (let i = 0, n = pages.length; i < n; i += 1) {\n      const page = pages[i];\n      if (x < page.size) {\n        return page.getEntry(x);\n      } else {\n        x -= page.size;\n      }\n    }\n    return void 0;\n  }\n\n  firstEntry(): [K, V] | undefined {\n    const pages = this._pages;\n    if (pages.length) {\n      return pages[0].firstEntry();\n    } else {\n      return void 0;\n    }\n  }\n\n  lastEntry(): [K, V] | undefined {\n    const pages = this._pages;\n    if (pages.length) {\n      return pages[pages.length - 1].lastEntry();\n    } else {\n      return void 0;\n    }\n  }\n\n  nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const pages = this._pages;\n    let entry = pages[x].nextEntry(key, tree);\n    if (entry === void 0 && x + 1 < pages.length) {\n      entry = pages[x + 1].nextEntry(key, tree);\n    }\n    return entry;\n  }\n\n  previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const pages = this._pages;\n    let entry = pages[x].previousEntry(key, tree);\n    if (entry === void 0 && x > 0) {\n      entry = pages[x - 1].previousEntry(key, tree);\n    }\n    return entry;\n  }\n\n  updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeNode<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const oldPage = this._pages[x];\n    const newPage = oldPage.updated(key, newValue, tree);\n    if (oldPage !== newPage) {\n      if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {\n        return this.updatedPageSplit(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else {\n      return this;\n    }\n  }\n\n  private updatedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const newPages = oldPages.slice(0);\n    newPages[x] = newPage;\n\n    const oldKnots = this._knots;\n    let newKnots: K[];\n    if (oldKnots.length > 0) {\n      newKnots = oldKnots.slice(0);\n      if (x > 0) {\n        newKnots[x - 1] = newPage.minKey();\n      }\n    } else {\n      newKnots = [];\n    }\n\n    const newSize = this._size - oldPage.size + newPage.size;\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  private updatedPageSplit(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length + 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n\n    const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);\n    const newRightPage = newPage.splitRight(newPage.arity >>> 1);\n    newPages[x] = newLeftPage;\n    newPages[x + 1] = newRightPage;\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + 1] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<K>(oldPages.length);\n    if (x > 0) {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i];\n      }\n      newKnots[x - 1] = newLeftPage.minKey();\n      newKnots[x] = newRightPage.minKey();\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i + 1] = oldKnots[i];\n      }\n    } else {\n      newKnots[0] = newRightPage.minKey();\n      for (let i = 0; i < oldKnots.length; i += 1) {\n        newKnots[i + 1] = oldKnots[i];\n      }\n    }\n\n    const newSize = this._size - oldPage.size + newPage.size;\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  private updatedPageMerge(x: number, newPage: BTreeNode<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const midPages = newPage._pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length + midPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n    for (let i = 0; i < midPages.length; i += 1) {\n      newPages[i + x] = midPages[i];\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + midPages.length - 1] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const midKnots = newPage._knots;\n    const newKnots = new Array<K>(newPages.length - 1);\n    if (x > 0) {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i];\n      }\n      newKnots[x - 1] = midPages[0].minKey();\n      for (let i = 0; i < midKnots.length; i += 1) {\n        newKnots[i + x] = midKnots[i];\n      }\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i + midKnots.length] = oldKnots[i];\n      }\n    } else {\n      for (let i = 0; i < midKnots.length; i += 1) {\n        newKnots[i] = midKnots[i];\n      }\n      newKnots[midKnots.length] = oldPages[1].minKey();\n      for (let i = 1; i < oldKnots.length; i += 1) {\n        newKnots[i + midKnots.length] = oldKnots[i];\n      }\n    }\n\n    const newSize = this._size - oldPage.size + newPage.size;\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    let x = this.lookup(key, tree);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const oldPage = this._pages[x];\n    const newPage = oldPage.removed(key, tree);\n    if (oldPage !== newPage) {\n      return this.replacedPage(x, newPage, oldPage, tree);\n    } else {\n      return this;\n    }\n  }\n\n  private replacedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>,\n                       tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (!newPage.isEmpty()) {\n      if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {\n        return this.updatedPageMerge(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else if (this._pages.length > 2) {\n      return this.removedPage(x, newPage, oldPage);\n    } else if (this._pages.length > 1) {\n      if (x === 0) {\n        return this._pages[1];\n      } else {\n        return this._pages[0];\n      }\n    } else {\n      return BTreePage.empty();\n    }\n  }\n\n  private removedPage(x: number, newPage: BTreePage<K, V, U>, oldPage: BTreePage<K, V, U>): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const newPages = new Array<BTreePage<K, V, U>>(oldPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i - 1] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<K>(oldKnots.length - 1);\n    if (x > 0) {\n      for (let i = 0; i < x - 1; i += 1) {\n        newKnots[i] = oldKnots[i];\n      }\n      for (let i = x; i < oldKnots.length; i += 1) {\n        newKnots[i - 1] = oldKnots[i];\n      }\n    } else {\n      for (let i = 1; i < oldKnots.length; i += 1) {\n        newKnots[i - 1] = oldKnots[i];\n      }\n    }\n\n    const newSize = this._size - oldPage.size;\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (lower > 0) {\n      let newSize = this._size;\n      if (lower < newSize) {\n        const oldPages = this._pages;\n        let x = 0;\n        while (x < oldPages.length) {\n          const size = oldPages[x].size;\n          if (size <= lower) {\n            newSize -= size;\n            lower -= size;\n            x += 1;\n          } else {\n            break;\n          }\n        }\n        const newArity = oldPages.length - x;\n        if (newArity > 1) {\n          let newNode: BTreeNode<K, V, U>;\n          if (x > 0) {\n            const newPages = new Array<BTreePage<K, V, U>>(newArity);\n            for (let i = 0; i < newArity; i += 1) {\n              newPages[i] = oldPages[i + x];\n            }\n            const newKnots = new Array<K>(newArity - 1);\n            for (let i = 0; i < newKnots.length; i += 1) {\n              newKnots[i] = this._knots[i + x];\n            }\n            newNode = this.newNode(newPages, newKnots, void 0, newSize);\n          } else {\n            newNode = this;\n          }\n          if (lower > 0) {\n            const oldPage = oldPages[x];\n            const newPage = oldPage.drop(lower, tree);\n            return newNode.replacedPage(0, newPage, oldPage, tree);\n          } else {\n            return newNode;\n          }\n        } else {\n          return oldPages[x].drop(lower, tree);\n        }\n      } else {\n        return BTreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U> {\n    if (upper < this._size) {\n      if (upper > 0) {\n        const oldPages = this._pages;\n        let x = 0;\n        let newSize = 0;\n        while (x < oldPages.length && upper > 0) {\n          const size = oldPages[x].size;\n          newSize += size;\n          x += 1;\n          if (size <= upper) {\n            upper -= size;\n          } else {\n            break;\n          }\n        }\n        const newArity = upper === 0 ? x : x + 1;\n        if (newArity > 1) {\n          let newNode: BTreeNode<K, V, U>;\n          if (x < oldPages.length) {\n            const newPages = new Array<BTreePage<K, V, U>>(newArity);\n            for (let i = 0; i < newArity; i += 1) {\n              newPages[i] = oldPages[i];\n            }\n            const newKnots = new Array<K>(newArity - 1);\n            for (let i = 0; i < newKnots.length; i += 1) {\n              newKnots[i] = this._knots[i];\n            }\n            newNode = this.newNode(newPages, newKnots, void 0, newSize);\n          } else {\n            newNode = this;\n          }\n          if (upper > 0) {\n            const oldPage = oldPages[x - 1];\n            const newPage = oldPage.take(upper, tree);\n            return newNode.replacedPage(x - 1, newPage, oldPage, tree);\n          } else {\n            return newNode;\n          }\n        } else if (upper > 0) {\n          return oldPages[0].take(upper, tree);\n        } else {\n          return oldPages[0];\n        }\n      } else {\n        return BTreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  balanced(tree: BTreeContext<K, V>): BTreeNode<K, V, U> {\n    if (this._pages.length > 1 && tree.pageShouldSplit(this)) {\n      const x = this._knots.length >>> 1;\n      return this.split(x);\n    } else {\n      return this;\n    }\n  }\n\n  split(x: number): BTreeNode<K, V, U> {\n    const newPages = new Array<BTreePage<K, V, U>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<K>(1);\n    newKnots[0] = newRightPage.minKey();\n\n    return this.newNode(newPages, newKnots, void 0, this._size);\n  }\n\n  splitLeft(x: number): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const newPages = new Array<BTreePage<K, V, U>>(x + 1);\n    for (let i = 0; i < x + 1; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<K>(x);\n    for (let i = 0; i < x; i += 1) {\n      newKnots[i] = oldKnots[i];\n    }\n\n    let newSize = 0;\n    for (let i = 0; i <= x; i += 1) {\n      newSize += newPages[i].size;\n    }\n\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  splitRight(x: number): BTreeNode<K, V, U> {\n    const oldPages = this._pages;\n    const newArity = oldPages.length - (x + 1);\n    const newPages = new Array<BTreePage<K, V, U>>(newArity);\n    for (let i = 0; i < newArity; i += 1) {\n      newPages[i] = oldPages[i + (x + 1)];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<K>(newArity - 1);\n    for (let i = 0; i < newKnots.length; i += 1) {\n      newKnots[i] = oldKnots[i + (x + 1)];\n    }\n\n    let newSize = 0;\n    for (let i = 0; i < newArity; i += 1) {\n      newSize += newPages[i].size;\n    }\n\n    return this.newNode(newPages, newKnots, void 0, newSize);\n  }\n\n  reduced(identity: U, accumulator: (result: U, element: V) => U,\n          combiner: (result: U, result2: U) => U): BTreeNode<K, V, U> {\n    if (this._fold === void 0) {\n      const oldPages = this._pages;\n      const n = oldPages.length;\n      const newPages = new Array<BTreePage<K, V, U>>(n);\n      for (let i = 0; i < n; i += 1) {\n        newPages[i] = oldPages[i].reduced(identity, accumulator, combiner);\n      }\n      // assert n > 0;\n      let fold: U = newPages[0].fold()!;\n      for (let i = 1; i < n; i += 1) {\n        fold = combiner(fold, newPages[i].fold()!);\n      }\n      return this.newNode(newPages, this._knots, fold, this._size);\n    } else {\n      return this;\n    }\n  }\n\n  forEach<T, S>(callback: (this: S,\n                           key: K,\n                           value: V,\n                           tree: BTree<K, V>) => T | void,\n                thisArg: S,\n                tree: BTree<K, V>): T | undefined {\n    const pages = this._pages;\n    for (let i = 0, n = pages.length; i < n; i += 1) {\n      const result = pages[i].forEach(callback, thisArg, tree);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  entries(): Cursor<[K, V]> {\n    return new BTree.NodeCursor(this._pages);\n  }\n\n  reverseEntries(): Cursor<[K, V]> {\n    return new BTree.NodeCursor(this._pages, this._size, this._pages.length);\n  }\n\n  private lookup(key: K, tree: BTreeContext<K, V>): number {\n    let lo = 0;\n    let hi = this._knots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      const order = tree.compare(key, this._knots[mid]);\n      if (order > 0) {\n        lo = mid + 1;\n      } else if (order < 0) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n\n  protected newNode(pages: BTreePage<K, V, U>[], knots: K[], fold: U | undefined, size: number): BTreeNode<K, V, U> {\n    return new BTreeNode(pages, knots, fold, size);\n  }\n}\nBTree.Node = BTreeNode;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {NodeCursor} from \"./NodeCursor\";\nimport {BTree} from \"./BTree\";\nimport {BTreePage} from \"./BTreePage\";\n\nexport class BTreeNodeCursor<K, V, U> extends NodeCursor<[K, V], BTreePage<K, V, U>> {\n  constructor(pages: BTreePage<K, V, U>[], index?: number, pageIndex?: number,\n              subCursor?: Cursor<[K, V]>) {\n    super(pages, index, pageIndex, subCursor);\n  }\n\n  protected pageSize(page: BTreePage<K, V, U>): number {\n    return page.size;\n  }\n\n  protected pageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]> {\n    return page.entries();\n  }\n\n  protected reversePageCursor(page: BTreePage<K, V, U>): Cursor<[K, V]> {\n    return page.reverseEntries();\n  }\n}\nBTree.NodeCursor = BTreeNodeCursor;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Random, Objects} from \"@swim/util\";\nimport {STreePage} from \"./STreePage\";\n\n/** @hidden */\nexport abstract class STreeContext<V, I> {\n  pageSplitSize: number;\n \n  identify(value: V): I {\n    const id = new Uint8Array(6);\n    Random.fillBytes(id);\n    return id as unknown as I;\n  }\n\n  compare(x: I, y: I): number {\n    return Objects.compare(x, y);\n  }\n\n  pageShouldSplit(page: STreePage<V, I>): boolean {\n    return page.arity > this.pageSplitSize;\n  }\n\n  pageShouldMerge(page: STreePage<V, I>): boolean {\n    return page.arity < this.pageSplitSize >>> 1;\n  }\n}\nSTreeContext.prototype.pageSplitSize = 32;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {STreeContext} from \"./STreeContext\";\nimport {STreePage} from \"./STreePage\";\nimport {STreeLeaf} from \"./STreeLeaf\";\nimport {STreeNode} from \"./STreeNode\";\nimport {STreeNodeCursor} from \"./STreeNodeCursor\";\n\nexport class STree<V = unknown, I = unknown> extends STreeContext<V, I> {\n  root: STreePage<V, I>;\n\n  constructor(root: STreePage<V, I> = STree.Page.empty()) {\n    super();\n    this.root = root;\n  }\n\n  get length(): number {\n    return this.root.size;\n  }\n\n  isEmpty(): boolean {\n    return this.root.isEmpty();\n  }\n\n  get(index: number, id?: I): V | undefined {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        return void 0;\n      }\n    }\n    return this.root.get(index);\n  }\n\n  getEntry(index: number, id?: I): [I, V] | undefined {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        return void 0;\n      }\n    }\n    return this.root.getEntry(index);\n  }\n\n  set(index: number, newValue: V, id?: I): this {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (index < 0 || index >= oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.updated(index, newValue, this);\n    return this;\n  }\n\n  insert(index: number, newValue: V, id?: I): this {\n    const oldRoot = this.root;\n    if (index < 0 || index > oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.inserted(index, newValue, id, this).balanced(this);\n    return this;\n  }\n\n  remove(index: number, id?: I): this {\n    if (id !== void 0) {\n      index = this.lookup(id, index);\n      if (index < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (index < 0 || index > oldRoot.size) {\n      throw new RangeError(\"\" + index);\n    }\n    this.root = oldRoot.removed(index, this);\n    return this;\n  }\n\n  push(...newValues: V[]): number {\n    let newRoot = this.root;\n    for (let i = 0; i < newValues.length; i += 1) {\n      newRoot = newRoot.inserted(newRoot.size, newValues[i], void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return newRoot.size;\n  }\n\n  pop(): V | undefined {\n    const oldRoot = this.root;\n    const index = oldRoot.size - 1;\n    if (index >= 0) {\n      const oldValue = oldRoot.get(index);\n      this.root = oldRoot.removed(index, this);\n      return oldValue;\n    } else {\n      return void 0;\n    }\n  }\n\n  unshift(...newValues: V[]): number {\n    let newRoot = this.root;\n    for (let i = newValues.length - 1; i >= 0; i -= 1) {\n      newRoot = newRoot.inserted(0, newValues[i], void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return newRoot.size;\n  }\n\n  shift(): V | undefined {\n    const oldRoot = this.root;\n    if (oldRoot.size > 0) {\n      const oldValue = oldRoot.get(0);\n      this.root = oldRoot.removed(0, this);\n      return oldValue;\n    } else {\n      return void 0;\n    }\n  }\n\n  move(fromIndex: number, toIndex: number, id?: I): this {\n    if (id !== void 0) {\n      fromIndex = this.lookup(id, fromIndex);\n      if (fromIndex < 0) {\n        throw new RangeError(\"\" + id);\n      }\n    }\n    const oldRoot = this.root;\n    if (fromIndex < 0 || fromIndex >= oldRoot.size) {\n      throw new RangeError(\"\" + fromIndex);\n    }\n    if (toIndex < 0 || toIndex >= oldRoot.size) {\n      throw new RangeError(\"\" + toIndex);\n    }\n    if (fromIndex !== toIndex) {\n      const entry = oldRoot.getEntry(fromIndex)!;\n      this.root = oldRoot.removed(fromIndex, this)\n                         .inserted(toIndex, entry[1], entry[0], this)\n                         .balanced(this);\n    }\n    return this;\n  }\n\n  splice(start: number, deleteCount?: number, ...newValues: V[]): V[] {\n    let newRoot = this.root;\n    if (start < 0) {\n      start = newRoot.size + start;\n    }\n    start = Math.min(Math.max(0, start), newRoot.size);\n    if (deleteCount === void 0) {\n      deleteCount = newRoot.size - start;\n    }\n    const deleted = [] as V[];\n    for (let i = start, n = start + deleteCount; i < n; i += 1) {\n      deleted.push(newRoot.get(start)!);\n      newRoot = newRoot.removed(start, this);\n    }\n    for (let i = 0; i < newValues.length; i += 1) {\n      newRoot = newRoot.inserted(start + i, newValues[i], void 0, this).balanced(this);\n    }\n    this.root = newRoot;\n    return deleted;\n  }\n\n  drop(lower: number): this {\n    const oldRoot = this.root;\n    if (lower > 0 && oldRoot.size > 0) {\n      if (lower < oldRoot.size) {\n        this.root = oldRoot.drop(lower, this);\n      } else {\n        this.root = STree.Page.empty();\n      }\n    }\n    return this;\n  }\n\n  take(upper: number): this {\n    const oldRoot = this.root;\n    if (upper < oldRoot.size && oldRoot.size > 0) {\n      if (upper > 0) {\n        this.root = oldRoot.take(upper, this);\n      } else {\n        this.root = STree.Page.empty();\n      }\n    }\n    return this;\n  }\n\n  clear(): void {\n    this.root = STree.Page.empty();\n  }\n\n  forEach<T, S = unknown>(callback: (this: S,\n                                     value: V,\n                                     index: number,\n                                     tree: STree<V, I>,\n                                     id: I) => T | void,\n                          thisArg?: S): T | undefined {\n    return this.root.forEach(callback, thisArg, 0, this);\n  }\n\n  keys(): Cursor<I> {\n    return this.root.keys();\n  }\n\n  values(): Cursor<V> {\n    return this.root.values();\n  }\n\n  entries(): Cursor<[I, V]> {\n    return this.root.entries();\n  }\n\n  reverseKeys(): Cursor<I> {\n    return this.root.reverseKeys();\n  }\n\n  reverseValues(): Cursor<V> {\n    return this.root.reverseValues();\n  }\n\n  reverseEntries(): Cursor<[I, V]> {\n    return this.root.reverseEntries();\n  }\n\n  clone(): STree<V, I> {\n    return this.copy(this.root);\n  }\n\n  protected copy(root: STreePage<V, I>): STree<V, I> {\n    const tree = new STree(root);\n    if (tree.identify !== this.identify) {\n      tree.identify = this.identify;\n    }\n    if (tree.compare !== this.compare) {\n      tree.compare = this.compare;\n    }\n    if (tree.pageSplitSize !== this.pageSplitSize) {\n      tree.pageSplitSize = this.pageSplitSize;\n    }\n    return tree;\n  }\n\n  lookup(id: I, start: number = 0): number {\n    const root = this.root;\n    start = Math.min(Math.max(0, start), root.size - 1);\n    let index = start;\n    do {\n      const entry = root.getEntry(index);\n      if (entry && this.compare(entry[0], id) === 0) {\n        return index;\n      }\n      index = (index + 1) % root.size;\n    } while (isFinite(index) && index !== start);\n    return -1;\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Page: typeof STreePage; // defined by STreePage\n  /** @hidden */\n  static Leaf: typeof STreeLeaf; // defined by STreeLeaf\n  /** @hidden */\n  static Node: typeof STreeNode; // defined by STreeNode\n  /** @hidden */\n  static NodeCursor: typeof STreeNodeCursor; // defined by STreeNodeCursor\n}\nSTree.prototype.pageSplitSize = 32;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {KeysCursor} from \"./KeysCursor\";\nimport {ValuesCursor} from \"./ValuesCursor\";\nimport {STreeContext} from \"./STreeContext\";\nimport {STree} from \"./STree\";\nimport {STreeLeaf} from \"./STreeLeaf\";\n\n/** @hidden */\nexport abstract class STreePage<V = unknown, I = unknown> {\n  abstract get arity(): number;\n\n  abstract get size(): number;\n\n  abstract isEmpty(): boolean;\n\n  abstract get(index: number): V | undefined;\n\n  abstract getEntry(index: number): [I, V] | undefined;\n\n  abstract updated(index: number, newValue: V, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract balanced(tree: STreeContext<V, I>): STreePage<V, I>;\n\n  abstract split(index: number): STreePage<V, I>;\n\n  abstract splitLeft(index: number): STreePage<V, I>;\n\n  abstract splitRight(index: number): STreePage<V, I>;\n\n  abstract forEach<T, S>(callback: (this: S,\n                                    value: V,\n                                    index: number,\n                                    tree: STree<V, I>,\n                                    id: I) => T | void,\n                         thisArg: S,\n                         offset: number,\n                         tree: STree<V, I>): T | undefined;\n\n  keys(): Cursor<I> {\n    return new KeysCursor(this.entries());\n  }\n\n  values(): Cursor<V> {\n    return new ValuesCursor(this.entries());\n  }\n\n  abstract entries(): Cursor<[I, V]>;\n\n  reverseKeys(): Cursor<I> {\n    return new KeysCursor(this.reverseEntries());\n  }\n\n  reverseValues(): Cursor<V> {\n    return new ValuesCursor(this.reverseEntries());\n  }\n\n  abstract reverseEntries(): Cursor<[I, V]>;\n\n  private static _empty: STreeLeaf<unknown, unknown>;\n\n  static empty<V, I>(): STreeLeaf<V, I> {\n    if (!STreePage._empty) {\n      STreePage._empty = new STree.Leaf([]);\n    }\n    return STreePage._empty as STreeLeaf<V, I>;\n  }\n}\nSTree.Page = STreePage;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {STreeContext} from \"./STreeContext\";\nimport {STree} from \"./STree\";\nimport {STreePage} from \"./STreePage\";\nimport {STreeNode} from \"./STreeNode\";\n\n/** @hidden */\nexport class STreeLeaf<V, I> extends STreePage<V, I> {\n  readonly _slots: [I, V][];\n\n  constructor(slots: [I, V][]) {\n    super();\n    this._slots = slots;\n  }\n\n  get arity(): number {\n    return this._slots.length;\n  }\n\n  get size(): number {\n    return this._slots.length;\n  }\n\n  isEmpty(): boolean {\n    return this._slots.length === 0;\n  }\n\n  get(index: number): V | undefined {\n    const slot = this._slots[index];\n    if (slot) {\n      return slot[1];\n    } else {\n      return void 0;\n    }\n  }\n\n  getEntry(index: number): [I, V] | undefined {\n    return this._slots[index];\n  }\n\n  updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index >= this._slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.updatedItem(index, newValue);\n  }\n\n  private updatedItem(index: number, newValue: V): STreeLeaf<V, I> {\n    const oldItems = this._slots;\n    const oldSlot = oldItems[index];\n    if (newValue !== oldSlot[1]) {\n      const newValues = oldItems.slice(0);\n      newValues[index] = [oldSlot[0], newValue];\n      return new STreeLeaf(newValues);\n    } else {\n      return this;\n    }\n  }\n\n  inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index > this._slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    return this.insertedItem(index, newValue, id, tree);\n  }\n\n  private insertedItem(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (id === void 0) {\n      id = tree.identify(newValue);\n    }\n    const oldSlots = this._slots;\n    const newSlots = new Array<[I, V]>(oldSlots.length + 1);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    newSlots[index] = [id, newValue];\n    for (let i = index; i < oldSlots.length; i += 1) {\n      newSlots[i + 1] = oldSlots[i];\n    }\n    return new STreeLeaf(newSlots);\n  }\n\n  removed(index: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    if (index < 0 || index >= this._slots.length) {\n      throw new RangeError(\"\" + index);\n    }\n    if (this._slots.length > 1) {\n      return this.removedSlot(index);\n    } else {\n      return STreePage.empty();\n    }\n  }\n\n  private removedSlot(index: number): STreeLeaf<V, I> {\n    const oldSlots = this._slots;\n    const newSlots = new Array<[I, V]>(oldSlots.length - 1);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    for (let i = index; i < newSlots.length; i += 1) {\n      newSlots[i] = oldSlots[i + 1];\n    }\n    return new STreeLeaf(newSlots);\n  }\n\n  drop(lower: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    const oldSlots = this._slots;\n    if (lower > 0 && oldSlots.length > 0) {\n      if (lower < oldSlots.length) {\n        const size = oldSlots.length - lower;\n        const newSlots = new Array<[I, V]>(size);\n        for (let i = 0; i < size; i += 1) {\n          newSlots[i] = oldSlots[i + lower];\n        }\n        return new STreeLeaf(newSlots);\n      } else {\n        return STreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  take(upper: number, tree: STreeContext<V, I>): STreeLeaf<V, I> {\n    const oldSlots = this._slots;\n    if (upper < oldSlots.length && oldSlots.length > 0) {\n      if (upper > 0) {\n        const newSlots = new Array<[I, V]>(upper);\n        for (let i = 0; i < upper; i += 1) {\n          newSlots[i] = oldSlots[i];\n        }\n        return new STreeLeaf(newSlots);\n      } else {\n        return STreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  balanced(tree: STreeContext<V, I>): STreePage<V, I> {\n    const size = this._slots.length;\n    if (size > 1 && tree.pageShouldSplit(this)) {\n      return this.split(size >>> 1);\n    } else {\n      return this;\n    }\n  }\n\n  split(index: number): STreeNode<V, I> {\n    const newPages = new Array<STreePage<V, I>>(2);\n    const newLeftPage = this.splitLeft(index);\n    const newRightPage = this.splitRight(index);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<number>(1);\n    newKnots[0] = index;\n\n    return new STree.Node(newPages, newKnots, this._slots.length);\n  }\n\n  splitLeft(index: number): STreeLeaf<V, I> {\n    const oldSlots = this._slots;\n    const newSlots = new Array<[I, V]>(index);\n    for (let i = 0; i < index; i += 1) {\n      newSlots[i] = oldSlots[i];\n    }\n    return new STreeLeaf(newSlots);\n  }\n\n  splitRight(index: number): STreeLeaf<V, I> {\n    const oldSlots = this._slots;\n    const newSize = oldSlots.length - index;\n    const newSlots = new Array<[I, V]>(newSize);\n    for (let i = 0; i < newSize; i += 1) {\n      newSlots[i] = oldSlots[i + index];\n    }\n    return new STreeLeaf(newSlots);\n  }\n\n  forEach<T, S>(callback: (this: S,\n                           value: V,\n                           index: number,\n                           tree: STree<V, I>,\n                           id: I) => T | void,\n                thisArg: S,\n                offset: number,\n                tree: STree<V, I>): T | undefined {\n    for (let i = 0; i < this._slots.length; i += 1) {\n      const slot = this._slots[i];\n      const result = callback.call(thisArg, slot[1], offset + i, tree, slot[0]);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return void 0;\n  }\n\n  entries(): Cursor<[I, V]> {\n    return Cursor.array(this._slots);\n  }\n\n  reverseEntries(): Cursor<[I, V]> {\n    return Cursor.array(this._slots, this._slots.length);\n  }\n}\nSTree.Leaf = STreeLeaf;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {STreeContext} from \"./STreeContext\";\nimport {STree} from \"./STree\";\nimport {STreePage} from \"./STreePage\";\n\n/** @hidden */\nexport class STreeNode<V, I> extends STreePage<V, I> {\n  readonly _pages: STreePage<V, I>[];\n  readonly _knots: number[];\n  readonly _size: number;\n\n  constructor(pages: STreePage<V, I>[], knots?: number[], size?: number) {\n    super();\n    this._pages = pages;\n    if (knots === void 0 || size === void 0) {\n      knots = new Array<number>(pages.length - 1);\n      size = 0;\n      for (let i = 0, n  = knots.length; i < n; i += 1) {\n        size += pages[i].size;\n        knots[i] = size;\n      }\n      size += pages[knots.length].size;\n    }\n    this._knots = knots;\n    this._size = size;\n  }\n\n  get arity(): number {\n    return this._pages.length;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  isEmpty(): boolean {\n    return this._size === 0;\n  }\n\n  get(index: number): V | undefined {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this._knots[x - 1];\n    return this._pages[x].get(i);\n  }\n\n  getEntry(index: number): [I, V] | undefined {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this._knots[x - 1];\n    return this._pages[x].getEntry(i);\n  }\n\n  updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeNode<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const i = x === 0 ? index : index - this._knots[x - 1];\n    const oldPage = this._pages[x];\n    const newPage = oldPage.updated(i, newValue, tree);\n    if (oldPage !== newPage) {\n      if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {\n        return this.updatedPageSplit(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else {\n      return this;\n    }\n  }\n\n  private updatedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const newPages = oldPages.slice(0);\n    newPages[x] = newPage;\n\n    const oldKnots = this._knots;\n    let newKnots: number[];\n    let newSize: number;\n    if (oldPages.length - 1 > 0) {\n      newKnots = oldKnots.slice(0);\n      if (x > 0) {\n        newSize = oldKnots[x - 1];\n      } else {\n        newSize = 0;\n      }\n      for (let i = x; i < newKnots.length; i += 1) {\n        newSize += newPages[i].size;\n        newKnots[i] = newSize;\n      }\n      newSize += newPages[newKnots.length].size;\n    } else {\n      newKnots = [];\n      newSize = 0;\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  private updatedPageSplit(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length + 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n\n    const newLeftPage = newPage.splitLeft(newPage.arity >>> 1);\n    const newRightPage = newPage.splitRight(newPage.arity >>> 1);\n    newPages[x] = newLeftPage;\n    newPages[x + 1] = newRightPage;\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + 1] = oldPages[i];\n    }\n\n    return new STreeNode(newPages);\n  }\n\n  private updatedPageMerge(x: number, newPage: STreeNode<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const midPages = newPage._pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length + midPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n    for (let i = 0; i < midPages.length; i += 1) {\n      newPages[i + x] = midPages[i];\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i + midPages.length - 1] = oldPages[i];\n    }\n\n    return new STreeNode(newPages);\n  }\n\n  inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeNode<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const subIndex = x === 0 ? index : index - this._knots[x - 1];\n    const oldPage = this._pages[x];\n    const newPage = oldPage.inserted(subIndex, newValue, id, tree);\n    if (oldPage !== newPage) {\n      if (tree.pageShouldSplit(newPage)) {\n        return this.updatedPageSplit(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else {\n      return this;\n    }\n  }\n\n  removed(index: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    let x = this.lookup(index);\n    if (x >= 0) {\n      x += 1;\n    } else {\n      x = -(x + 1);\n    }\n    const subIndex = x === 0 ? index : index - this._knots[x - 1];\n    const oldPage = this._pages[x];\n    const newPage = oldPage.removed(subIndex, tree);\n    if (oldPage !== newPage) {\n      return this.replacedPage(x, newPage, oldPage, tree);\n    } else {\n      return this;\n    }\n  }\n\n  private replacedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>,\n                       tree: STreeContext<V, I>): STreePage<V, I> {\n    if (!newPage.isEmpty()) {\n      if (newPage instanceof STreeNode && tree.pageShouldMerge(newPage)) {\n        return this.updatedPageMerge(x, newPage, oldPage);\n      } else {\n        return this.updatedPage(x, newPage, oldPage);\n      }\n    } else if (this._pages.length > 2) {\n      return this.removedPage(x, newPage, oldPage);\n    } else if (this._pages.length > 1) {\n      if (x === 0) {\n        return this._pages[1];\n      } else {\n        return this._pages[0];\n      }\n    } else {\n      return STreePage.empty();\n    }\n  }\n\n  private removedPage(x: number, newPage: STreePage<V, I>, oldPage: STreePage<V, I>): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const newPages = new Array<STreePage<V, I>>(oldPages.length - 1);\n    for (let i = 0; i < x; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n    for (let i = x + 1; i < oldPages.length; i += 1) {\n      newPages[i - 1] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<number>(oldKnots.length - 1);\n    let newSize: number;\n    if (x > 0) {\n      for (let i = 0; i < x; i += 1) {\n        newKnots[i] = oldKnots[i];\n      }\n      newSize = oldKnots[x - 1];\n    } else {\n      newSize = 0;\n    }\n    for (let i = x; i < newKnots.length; i += 1) {\n      newSize += newPages[i].size;\n      newKnots[i] = newSize;\n    }\n    newSize += newPages[newKnots.length].size;\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    if (lower > 0) {\n      if (lower < this._size) {\n        let x = this.lookup(lower);\n        if (x >= 0) {\n          x += 1;\n        } else {\n          x = -(x + 1);\n        }\n        lower = x === 0 ? lower : lower - this._knots[x - 1];\n        const oldPages = this._pages;\n        const n = oldPages.length - x;\n        if (n > 1) {\n          let newNode: STreeNode<V, I>;\n          if (x > 0) {\n            const newPages = new Array<STreePage<V, I>>(n);\n            for (let i = 0; i < n; i += 1) {\n              newPages[i] = oldPages[i + x];\n            }\n            newNode = new STreeNode(newPages);\n          } else {\n            newNode = this;\n          }\n          if (lower > 0) {\n            const oldPage = oldPages[x];\n            const newPage = oldPage.drop(lower, tree);\n            return newNode.replacedPage(0, newPage, oldPage, tree);\n          } else {\n            return newNode;\n          }\n        } else {\n          return oldPages[x].drop(lower, tree);\n        }\n      } else {\n        return STreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  take(upper: number, tree: STreeContext<V, I>): STreePage<V, I> {\n    if (upper < this._size) {\n      if (upper > 0) {\n        let x = this.lookup(upper);\n        if (x >= 0) {\n          x += 1;\n        } else {\n          x = -(x + 1);\n        }\n        upper = x === 0 ? upper : upper - this._knots[x - 1];\n        const oldPages = this._pages;\n        const n = upper === 0 ? x : x + 1;\n        if (n > 1) {\n          let newNode: STreeNode<V, I>;\n          if (x < oldPages.length) {\n            const newPages = new Array<STreePage<V, I>>(n);\n            for (let i = 0; i < n; i += 1) {\n              newPages[i] = oldPages[i];\n            }\n            const newKnots = new Array<number>(n - 1);\n            for (let i = 0; i < newKnots.length; i += 1) {\n              newKnots[i] = this._knots[i];\n            }\n            const newSize = newKnots[n - 2] + newPages[n - 1].size;\n            newNode = new STreeNode(newPages, newKnots, newSize);\n          } else {\n            newNode = this;\n          }\n          if (upper > 0) {\n            const oldPage = oldPages[x];\n            const newPage = oldPage.take(upper, tree);\n            return newNode.replacedPage(x, newPage, oldPage, tree);\n          } else {\n            return newNode;\n          }\n        } else if (upper > 0) {\n          return oldPages[0].take(upper, tree);\n        } else {\n          return oldPages[0];\n        }\n      } else {\n        return STreePage.empty();\n      }\n    } else {\n      return this;\n    }\n  }\n\n  balanced(tree: STreeContext<V, I>): STreeNode<V, I> {\n    if (this._pages.length > 1 && tree.pageShouldSplit(this)) {\n      const x = this._knots.length >>> 1;\n      return this.split(x);\n    } else {\n      return this;\n    }\n  }\n\n  split(x: number): STreeNode<V, I> {\n    const newPages = new Array<STreePage<V, I>>(2);\n    const newLeftPage = this.splitLeft(x);\n    const newRightPage = this.splitRight(x);\n    newPages[0] = newLeftPage;\n    newPages[1] = newRightPage;\n\n    const newKnots = new Array<number>(1);\n    newKnots[0] = newLeftPage._size;\n\n    return new STreeNode(newPages, newKnots, this._size);\n  }\n\n  splitLeft(x: number): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const newPages = new Array<STreePage<V, I>>(x + 1);\n    for (let i = 0; i < x + 1; i += 1) {\n      newPages[i] = oldPages[i];\n    }\n\n    const oldKnots = this._knots;\n    const newKnots = new Array<number>(x);\n    for (let i = 0; i < x; i += 1) {\n      newKnots[i] = oldKnots[i];\n    }\n\n    let newSize = 0;\n    for (let i = 0; i <= x; i += 1) {\n      newSize += newPages[i].size;\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  splitRight(x: number): STreeNode<V, I> {\n    const oldPages = this._pages;\n    const y = oldPages.length - (x + 1);\n    const newPages = new Array<STreePage<V, I>>(y);\n    for (let i = 0; i < y; i += 1) {\n      newPages[i] = oldPages[i + (x + 1)];\n    }\n\n    const newKnots = new Array<number>(y - 1);\n    let newSize;\n    if (y > 0) {\n      newSize = newPages[0].size;\n      for (let i = 1; i < y; i += 1) {\n        newKnots[i - 1] = newSize;\n        newSize += newPages[i].size;\n      }\n    } else {\n      newSize = 0;\n    }\n\n    return new STreeNode(newPages, newKnots, newSize);\n  }\n\n  forEach<T, S>(callback: (this: S,\n                           value: V,\n                           index: number,\n                           tree: STree<V, I>,\n                           id: I) => T | void,\n                thisArg: S,\n                offset: number,\n                tree: STree<V, I>): T | undefined {\n    for (let i = 0; i < this._pages.length; i += 1) {\n      const page = this._pages[i];\n      const result = page.forEach(callback, thisArg, offset, tree);\n      if (result !== void 0) {\n        return result;\n      }\n      offset += page.size;\n    }\n    return void 0;\n  }\n\n  entries(): Cursor<[I, V]> {\n    return new STree.NodeCursor(this._pages);\n  }\n\n  reverseEntries(): Cursor<[I, V]> {\n    return new STree.NodeCursor(this._pages, this._size, this._pages.length);\n  }\n\n  private lookup(index: number): number {\n    let lo = 0;\n    let hi = this._knots.length - 1;\n    while (lo <= hi) {\n      const mid = (lo + hi) >>> 1;\n      if (index > this._knots[mid]) {\n        lo = mid + 1;\n      } else if (index < this._knots[mid]) {\n        hi = mid - 1;\n      } else {\n        return mid;\n      }\n    }\n    return -(lo + 1);\n  }\n}\nSTree.Node = STreeNode;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {NodeCursor} from \"./NodeCursor\";\nimport {STree} from \"./STree\";\nimport {STreePage} from \"./STreePage\";\n\n/** @hidden */\nexport class STreeNodeCursor<V, I> extends NodeCursor<[I, V], STreePage<V, I>> {\n  constructor(pages: STreePage<V, I>[], index?: number, pageIndex?: number,\n              subCursor?: Cursor<[I, V]>) {\n    super(pages, index, pageIndex, subCursor);\n  }\n\n  protected pageSize(page: STreePage<V, I>): number {\n    return page.size;\n  }\n\n  protected pageCursor(page: STreePage<V, I>): Cursor<[I, V]> {\n    return page.entries();\n  }\n\n  protected reversePageCursor(page: STreePage<V, I>): Cursor<[I, V]> {\n    return page.reverseEntries();\n  }\n}\nSTree.NodeCursor = STreeNodeCursor;\n"]}