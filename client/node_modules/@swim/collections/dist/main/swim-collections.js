(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@swim/util')) :
    typeof define === 'function' && define.amd ? define(['exports', '@swim/util'], factory) :
    (global = global || self, factory(global.swim = global.swim || {}, global.swim));
}(this, (function (exports, util) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var KeysCursor = (function (_super) {
        __extends(KeysCursor, _super);
        function KeysCursor(cursor) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            return _this;
        }
        KeysCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        KeysCursor.prototype.head = function () {
            return this._cursor.head()[0];
        };
        KeysCursor.prototype.step = function () {
            this._cursor.step();
        };
        KeysCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        KeysCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        KeysCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        KeysCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value[0], done: done };
        };
        KeysCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        KeysCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        KeysCursor.prototype.previous = function () {
            var _a = this._cursor.previous(), value = _a.value, done = _a.done;
            return { value: value && value[0], done: done };
        };
        KeysCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return KeysCursor;
    }(util.Cursor));

    var ValuesCursor = (function (_super) {
        __extends(ValuesCursor, _super);
        function ValuesCursor(cursor) {
            var _this = _super.call(this) || this;
            _this._cursor = cursor;
            return _this;
        }
        ValuesCursor.prototype.isEmpty = function () {
            return this._cursor.isEmpty();
        };
        ValuesCursor.prototype.head = function () {
            return this._cursor.head()[1];
        };
        ValuesCursor.prototype.step = function () {
            this._cursor.step();
        };
        ValuesCursor.prototype.skip = function (count) {
            this._cursor.skip(count);
        };
        ValuesCursor.prototype.hasNext = function () {
            return this._cursor.hasNext();
        };
        ValuesCursor.prototype.nextIndex = function () {
            return this._cursor.nextIndex();
        };
        ValuesCursor.prototype.next = function () {
            var _a = this._cursor.next(), value = _a.value, done = _a.done;
            return { value: value && value[1], done: done };
        };
        ValuesCursor.prototype.hasPrevious = function () {
            return this._cursor.hasPrevious();
        };
        ValuesCursor.prototype.previousIndex = function () {
            return this._cursor.previousIndex();
        };
        ValuesCursor.prototype.previous = function () {
            var _a = this._cursor.previous(), value = _a.value, done = _a.done;
            return { value: value && value[1], done: done };
        };
        ValuesCursor.prototype.delete = function () {
            this._cursor.delete();
        };
        return ValuesCursor;
    }(util.Cursor));

    var NodeCursor = (function (_super) {
        __extends(NodeCursor, _super);
        function NodeCursor(pages, index, pageIndex, pageCursor) {
            if (index === void 0) { index = 0; }
            if (pageIndex === void 0) { pageIndex = 0; }
            var _this = _super.call(this) || this;
            _this._pages = pages;
            _this._index = index;
            _this._pageIndex = pageIndex;
            _this._pageCursor = pageCursor;
            return _this;
        }
        NodeCursor.prototype.isEmpty = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        return false;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                    this._pageIndex += 1;
                }
                else {
                    this._pageIndex = this._pages.length;
                    return true;
                }
            } while (true);
        };
        NodeCursor.prototype.head = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        return this._pageCursor.head();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        throw new Error("empty");
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.step = function () {
            do {
                if (this._pageCursor) {
                    if (!this._pageCursor.isEmpty()) {
                        this._index += 1;
                        return;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        throw new Error("empty");
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.skip = function (count) {
            while (count > 0) {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        this._index += 1;
                        count -= 1;
                        this._pageCursor.next();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    var page = this._pages[this._pageIndex];
                    var pageSize = this.pageSize(page);
                    this._pageIndex += 1;
                    if (pageSize < count) {
                        this._pageCursor = this.pageCursor(page);
                        if (count > 0) {
                            this._index += count;
                            this._pageCursor.skip(count);
                            count = 0;
                        }
                        break;
                    }
                    else {
                        this._index += pageSize;
                        count -= pageSize;
                    }
                }
                else {
                    break;
                }
            }
        };
        NodeCursor.prototype.hasNext = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        return true;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex < this._pages.length) {
                    this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                    this._pageIndex += 1;
                }
                else {
                    this._pageIndex = this._pages.length;
                    return false;
                }
            } while (true);
        };
        NodeCursor.prototype.nextIndex = function () {
            return this._index;
        };
        NodeCursor.prototype.next = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasNext()) {
                        this._index += 1;
                        return this._pageCursor.next();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else {
                    if (this._pageIndex < this._pages.length) {
                        this._pageCursor = this.pageCursor(this._pages[this._pageIndex]);
                        this._pageIndex += 1;
                    }
                    else {
                        this._pageIndex = this._pages.length;
                        return { done: true };
                    }
                }
            } while (true);
        };
        NodeCursor.prototype.hasPrevious = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasPrevious()) {
                        return true;
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex > 0) {
                    this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);
                    this._pageIndex -= 1;
                }
                else {
                    this._pageIndex = 0;
                    return false;
                }
            } while (true);
        };
        NodeCursor.prototype.previousIndex = function () {
            return this._index - 1;
        };
        NodeCursor.prototype.previous = function () {
            do {
                if (this._pageCursor) {
                    if (this._pageCursor.hasPrevious()) {
                        this._index -= 1;
                        return this._pageCursor.previous();
                    }
                    else {
                        this._pageCursor = void 0;
                    }
                }
                else if (this._pageIndex > 0) {
                    this._pageCursor = this.reversePageCursor(this._pages[this._pageIndex - 1]);
                    this._pageIndex -= 1;
                }
                else {
                    this._pageIndex = 0;
                    return { done: true };
                }
            } while (true);
        };
        NodeCursor.prototype.set = function (newValue) {
            this._pageCursor.set(newValue);
        };
        NodeCursor.prototype.delete = function () {
            this._pageCursor.delete();
        };
        return NodeCursor;
    }(util.Cursor));

    var BTreeContext = (function () {
        function BTreeContext() {
        }
        BTreeContext.prototype.compare = function (x, y) {
            return util.Objects.compare(x, y);
        };
        BTreeContext.prototype.pageShouldSplit = function (page) {
            return page.arity > this.pageSplitSize;
        };
        BTreeContext.prototype.pageShouldMerge = function (page) {
            return page.arity < this.pageSplitSize >>> 1;
        };
        return BTreeContext;
    }());
    BTreeContext.prototype.pageSplitSize = 32;

    var BTree = (function (_super) {
        __extends(BTree, _super);
        function BTree(root) {
            if (root === void 0) { root = BTree.Page.empty(); }
            var _this = _super.call(this) || this;
            _this.root = root;
            return _this;
        }
        Object.defineProperty(BTree.prototype, "size", {
            get: function () {
                return this.root.size;
            },
            enumerable: true,
            configurable: true
        });
        BTree.prototype.isEmpty = function () {
            return this.root.isEmpty();
        };
        BTree.prototype.has = function (key) {
            return this.root.has(key, this);
        };
        BTree.prototype.get = function (key) {
            return this.root.get(key, this);
        };
        BTree.prototype.getEntry = function (index) {
            return this.root.getEntry(index);
        };
        BTree.prototype.firstKey = function () {
            var entry = this.root.firstEntry();
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.firstValue = function () {
            var entry = this.root.firstEntry();
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.firstEntry = function () {
            return this.root.firstEntry();
        };
        BTree.prototype.lastKey = function () {
            var entry = this.root.lastEntry();
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.lastValue = function () {
            var entry = this.root.lastEntry();
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.lastEntry = function () {
            return this.root.lastEntry();
        };
        BTree.prototype.nextKey = function (key) {
            var entry = this.root.nextEntry(key, this);
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.nextValue = function (key) {
            var entry = this.root.nextEntry(key, this);
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.nextEntry = function (key) {
            return this.root.nextEntry(key, this);
        };
        BTree.prototype.previousKey = function (key) {
            var entry = this.root.previousEntry(key, this);
            if (entry) {
                return entry[0];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.previousValue = function (key) {
            var entry = this.root.previousEntry(key, this);
            if (entry) {
                return entry[1];
            }
            else {
                return void 0;
            }
        };
        BTree.prototype.previousEntry = function (key) {
            return this.root.previousEntry(key, this);
        };
        BTree.prototype.set = function (key, newValue) {
            var oldRoot = this.root;
            var newRoot = this.root.updated(key, newValue, this);
            if (oldRoot !== newRoot) {
                if (newRoot.size > oldRoot.size) {
                    newRoot = newRoot.balanced(this);
                }
                this.root = newRoot;
            }
            return this;
        };
        BTree.prototype.delete = function (key) {
            var oldRoot = this.root;
            var newRoot = this.root.removed(key, this);
            if (oldRoot !== newRoot) {
                this.root = newRoot;
                return true;
            }
            else {
                return false;
            }
        };
        BTree.prototype.drop = function (lower) {
            if (lower > 0 && this.root.size > 0) {
                if (lower < this.root.size) {
                    this.root = this.root.drop(lower, this);
                }
                else {
                    this.root = BTree.Page.empty();
                }
            }
            return this;
        };
        BTree.prototype.take = function (upper) {
            if (upper < this.root.size && this.root.size > 0) {
                if (upper > 0) {
                    this.root = this.root.take(upper, this);
                }
                else {
                    this.root = BTree.Page.empty();
                }
            }
            return this;
        };
        BTree.prototype.clear = function () {
            this.root = BTree.Page.empty();
        };
        BTree.prototype.updated = function (key, newValue) {
            var oldRoot = this.root;
            var newRoot = oldRoot.updated(key, newValue, this);
            if (oldRoot !== newRoot) {
                if (newRoot.size > oldRoot.size) {
                    newRoot = newRoot.balanced(this);
                }
                return this.copy(newRoot);
            }
            else {
                return this;
            }
        };
        BTree.prototype.removed = function (key) {
            var oldRoot = this.root;
            var newRoot = oldRoot.removed(key, this);
            if (oldRoot !== newRoot) {
                return this.copy(newRoot);
            }
            else {
                return this;
            }
        };
        BTree.prototype.cleared = function () {
            if (!this.root.isEmpty()) {
                return this.copy(BTree.Page.empty());
            }
            else {
                return this;
            }
        };
        BTree.prototype.reduced = function (identity, accumulator, combiner) {
            var oldRoot = this.root;
            var newRoot = oldRoot.reduced(identity, accumulator, combiner);
            if (oldRoot !== newRoot) {
                this.root = newRoot;
            }
            return newRoot.fold();
        };
        BTree.prototype.forEach = function (callback, thisArg) {
            return this.root.forEach(callback, thisArg, this);
        };
        BTree.prototype.keys = function () {
            return this.root.keys();
        };
        BTree.prototype.values = function () {
            return this.root.values();
        };
        BTree.prototype.entries = function () {
            return this.root.entries();
        };
        BTree.prototype.reverseKeys = function () {
            return this.root.reverseKeys();
        };
        BTree.prototype.reverseValues = function () {
            return this.root.reverseValues();
        };
        BTree.prototype.reverseEntries = function () {
            return this.root.reverseEntries();
        };
        BTree.prototype.clone = function () {
            return this.copy(this.root);
        };
        BTree.prototype.copy = function (root) {
            var tree = new BTree(root);
            if (tree.compare !== this.compare) {
                tree.compare = this.compare;
            }
            if (tree.pageSplitSize !== this.pageSplitSize) {
                tree.pageSplitSize = this.pageSplitSize;
            }
            return tree;
        };
        return BTree;
    }(BTreeContext));

    var BTreePage = (function () {
        function BTreePage() {
        }
        BTreePage.prototype.keys = function () {
            return new KeysCursor(this.entries());
        };
        BTreePage.prototype.values = function () {
            return new ValuesCursor(this.entries());
        };
        BTreePage.prototype.reverseKeys = function () {
            return new KeysCursor(this.reverseEntries());
        };
        BTreePage.prototype.reverseValues = function () {
            return new ValuesCursor(this.reverseEntries());
        };
        BTreePage.empty = function () {
            if (!BTreePage._empty) {
                BTreePage._empty = new BTree.Leaf([], void 0);
            }
            return BTreePage._empty;
        };
        return BTreePage;
    }());
    BTree.Page = BTreePage;

    var BTreeLeaf = (function (_super) {
        __extends(BTreeLeaf, _super);
        function BTreeLeaf(slots, fold) {
            var _this = _super.call(this) || this;
            _this._slots = slots;
            _this._fold = fold;
            return _this;
        }
        Object.defineProperty(BTreeLeaf.prototype, "arity", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BTreeLeaf.prototype, "size", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        BTreeLeaf.prototype.isEmpty = function () {
            return this._slots.length === 0;
        };
        BTreeLeaf.prototype.fold = function () {
            return this._fold;
        };
        BTreeLeaf.prototype.minKey = function () {
            return this._slots[0][0];
        };
        BTreeLeaf.prototype.maxKey = function () {
            return this._slots[this._slots.length - 1][0];
        };
        BTreeLeaf.prototype.has = function (key, tree) {
            return this.lookup(key, tree) >= 0;
        };
        BTreeLeaf.prototype.get = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                return this._slots[x][1];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.getEntry = function (index) {
            return this._slots[index];
        };
        BTreeLeaf.prototype.firstEntry = function () {
            if (this._slots.length) {
                return this._slots[0];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.lastEntry = function () {
            if (this._slots.length) {
                return this._slots[this._slots.length - 1];
            }
            else {
                return void 0;
            }
        };
        BTreeLeaf.prototype.nextEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            return this._slots[x];
        };
        BTreeLeaf.prototype.previousEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x -= 1;
            }
            else {
                x = -(x + 2);
            }
            return this._slots[x];
        };
        BTreeLeaf.prototype.updated = function (key, newValue, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                return this.updatedSlot(x, key, newValue);
            }
            else {
                x = -(x + 1);
                return this.insertedSlot(x, key, newValue);
            }
        };
        BTreeLeaf.prototype.updatedSlot = function (x, key, newValue) {
            var oldSlots = this._slots;
            if (newValue !== oldSlots[x][1]) {
                var newSlots = oldSlots.slice(0);
                newSlots[x] = [key, newValue];
                return this.newLeaf(newSlots, void 0);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.insertedSlot = function (x, key, newValue) {
            var oldSlots = this._slots;
            var n = oldSlots.length + 1;
            var newSlots = new Array(n);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            newSlots[x] = [key, newValue];
            for (var i = x; i < n - 1; i += 1) {
                newSlots[i + 1] = oldSlots[i];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.removed = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                if (this._slots.length > 1) {
                    return this.removedSlot(x);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.removedSlot = function (x) {
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length - 1);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            for (var i = x; i < newSlots.length; i += 1) {
                newSlots[i] = oldSlots[i + 1];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                var oldSlots = this._slots;
                if (lower < oldSlots.length) {
                    var size = oldSlots.length - lower;
                    var newSlots = new Array(size);
                    for (var i = 0; i < size; i += 1) {
                        newSlots[i] = oldSlots[i + lower];
                    }
                    return this.newLeaf(newSlots, void 0);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.take = function (upper, tree) {
            var oldSlots = this._slots;
            if (upper < oldSlots.length) {
                if (upper > 0) {
                    var newSlots = new Array(upper);
                    for (var i = 0; i < upper; i += 1) {
                        newSlots[i] = oldSlots[i];
                    }
                    return this.newLeaf(newSlots, void 0);
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.balanced = function (tree) {
            var n = this._slots.length;
            if (n > 1 && tree.pageShouldSplit(this)) {
                var x = n >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newRightPage.minKey();
            return this.newNode(newPages, newKnots, void 0, this._slots.length);
        };
        BTreeLeaf.prototype.splitLeft = function (x) {
            var oldSlots = this._slots;
            var newSlots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.splitRight = function (x) {
            var oldSlots = this._slots;
            var y = oldSlots.length - x;
            var newSlots = new Array(y);
            for (var i = 0; i < y; i += 1) {
                newSlots[i] = oldSlots[i + x];
            }
            return this.newLeaf(newSlots, void 0);
        };
        BTreeLeaf.prototype.reduced = function (identity, accumulator, combiner) {
            if (this._fold === void 0) {
                var slots = this._slots;
                var fold = identity;
                for (var i = 0, n = slots.length; i < n; i += 1) {
                    fold = accumulator(fold, slots[i][1]);
                }
                return this.newLeaf(slots, fold);
            }
            else {
                return this;
            }
        };
        BTreeLeaf.prototype.forEach = function (callback, thisArg, tree) {
            var slots = this._slots;
            for (var i = 0, n = slots.length; i < n; i += 1) {
                var slot = slots[i];
                var result = callback.call(thisArg, slot[0], slot[1], tree);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        BTreeLeaf.prototype.entries = function () {
            return util.Cursor.array(this._slots);
        };
        BTreeLeaf.prototype.reverseEntries = function () {
            return util.Cursor.array(this._slots, this._slots.length);
        };
        BTreeLeaf.prototype.lookup = function (key, tree) {
            var lo = 0;
            var hi = this._slots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                var order = tree.compare(key, this._slots[mid][0]);
                if (order > 0) {
                    lo = mid + 1;
                }
                else if (order < 0) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        BTreeLeaf.prototype.newLeaf = function (slots, fold) {
            return new BTreeLeaf(slots, fold);
        };
        BTreeLeaf.prototype.newNode = function (pages, knots, fold, size) {
            return new BTree.Node(pages, knots, fold, size);
        };
        return BTreeLeaf;
    }(BTreePage));
    BTree.Leaf = BTreeLeaf;

    var BTreeNode = (function (_super) {
        __extends(BTreeNode, _super);
        function BTreeNode(pages, knots, fold, size) {
            var _this = _super.call(this) || this;
            _this._pages = pages;
            _this._knots = knots;
            _this._fold = fold;
            _this._size = size;
            return _this;
        }
        Object.defineProperty(BTreeNode.prototype, "arity", {
            get: function () {
                return this._pages.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(BTreeNode.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        BTreeNode.prototype.isEmpty = function () {
            return this._size === 0;
        };
        BTreeNode.prototype.fold = function () {
            return this._fold;
        };
        BTreeNode.prototype.minKey = function () {
            return this._pages[0].minKey();
        };
        BTreeNode.prototype.maxKey = function () {
            return this._pages[this._pages.length - 1].maxKey();
        };
        BTreeNode.prototype.has = function (key, tree) {
            var xx = this.lookup(key, tree);
            if (xx > 0) {
                xx += 1;
            }
            else if (xx < 0) {
                xx = -(xx + 1);
            }
            else {
                return true;
            }
            return this._pages[xx].has(key, tree);
        };
        BTreeNode.prototype.get = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            return this._pages[x].get(key, tree);
        };
        BTreeNode.prototype.getEntry = function (x) {
            var pages = this._pages;
            for (var i = 0, n = pages.length; i < n; i += 1) {
                var page = pages[i];
                if (x < page.size) {
                    return page.getEntry(x);
                }
                else {
                    x -= page.size;
                }
            }
            return void 0;
        };
        BTreeNode.prototype.firstEntry = function () {
            var pages = this._pages;
            if (pages.length) {
                return pages[0].firstEntry();
            }
            else {
                return void 0;
            }
        };
        BTreeNode.prototype.lastEntry = function () {
            var pages = this._pages;
            if (pages.length) {
                return pages[pages.length - 1].lastEntry();
            }
            else {
                return void 0;
            }
        };
        BTreeNode.prototype.nextEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var pages = this._pages;
            var entry = pages[x].nextEntry(key, tree);
            if (entry === void 0 && x + 1 < pages.length) {
                entry = pages[x + 1].nextEntry(key, tree);
            }
            return entry;
        };
        BTreeNode.prototype.previousEntry = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var pages = this._pages;
            var entry = pages[x].previousEntry(key, tree);
            if (entry === void 0 && x > 0) {
                entry = pages[x - 1].previousEntry(key, tree);
            }
            return entry;
        };
        BTreeNode.prototype.updated = function (key, newValue, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var oldPage = this._pages[x];
            var newPage = oldPage.updated(key, newValue, tree);
            if (oldPage !== newPage) {
                if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.updatedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = oldPages.slice(0);
            newPages[x] = newPage;
            var oldKnots = this._knots;
            var newKnots;
            if (oldKnots.length > 0) {
                newKnots = oldKnots.slice(0);
                if (x > 0) {
                    newKnots[x - 1] = newPage.minKey();
                }
            }
            else {
                newKnots = [];
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.updatedPageSplit = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length + 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            var newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
            var newRightPage = newPage.splitRight(newPage.arity >>> 1);
            newPages[x] = newLeftPage;
            newPages[x + 1] = newRightPage;
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldPages.length);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newKnots[x - 1] = newLeftPage.minKey();
                newKnots[x] = newRightPage.minKey();
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i + 1] = oldKnots[i];
                }
            }
            else {
                newKnots[0] = newRightPage.minKey();
                for (var i = 0; i < oldKnots.length; i += 1) {
                    newKnots[i + 1] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.updatedPageMerge = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var midPages = newPage._pages;
            var newPages = new Array(oldPages.length + midPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = 0; i < midPages.length; i += 1) {
                newPages[i + x] = midPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + midPages.length - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var midKnots = newPage._knots;
            var newKnots = new Array(newPages.length - 1);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newKnots[x - 1] = midPages[0].minKey();
                for (var i = 0; i < midKnots.length; i += 1) {
                    newKnots[i + x] = midKnots[i];
                }
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i + midKnots.length] = oldKnots[i];
                }
            }
            else {
                for (var i = 0; i < midKnots.length; i += 1) {
                    newKnots[i] = midKnots[i];
                }
                newKnots[midKnots.length] = oldPages[1].minKey();
                for (var i = 1; i < oldKnots.length; i += 1) {
                    newKnots[i + midKnots.length] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size + newPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.removed = function (key, tree) {
            var x = this.lookup(key, tree);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var oldPage = this._pages[x];
            var newPage = oldPage.removed(key, tree);
            if (oldPage !== newPage) {
                return this.replacedPage(x, newPage, oldPage, tree);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.replacedPage = function (x, newPage, oldPage, tree) {
            if (!newPage.isEmpty()) {
                if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {
                    return this.updatedPageMerge(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else if (this._pages.length > 2) {
                return this.removedPage(x, newPage, oldPage);
            }
            else if (this._pages.length > 1) {
                if (x === 0) {
                    return this._pages[1];
                }
                else {
                    return this._pages[0];
                }
            }
            else {
                return BTreePage.empty();
            }
        };
        BTreeNode.prototype.removedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldKnots.length - 1);
            if (x > 0) {
                for (var i = 0; i < x - 1; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                for (var i = x; i < oldKnots.length; i += 1) {
                    newKnots[i - 1] = oldKnots[i];
                }
            }
            else {
                for (var i = 1; i < oldKnots.length; i += 1) {
                    newKnots[i - 1] = oldKnots[i];
                }
            }
            var newSize = this._size - oldPage.size;
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                var newSize = this._size;
                if (lower < newSize) {
                    var oldPages = this._pages;
                    var x = 0;
                    while (x < oldPages.length) {
                        var size = oldPages[x].size;
                        if (size <= lower) {
                            newSize -= size;
                            lower -= size;
                            x += 1;
                        }
                        else {
                            break;
                        }
                    }
                    var newArity = oldPages.length - x;
                    if (newArity > 1) {
                        var newNode = void 0;
                        if (x > 0) {
                            var newPages = new Array(newArity);
                            for (var i = 0; i < newArity; i += 1) {
                                newPages[i] = oldPages[i + x];
                            }
                            var newKnots = new Array(newArity - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i + x];
                            }
                            newNode = this.newNode(newPages, newKnots, void 0, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (lower > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.drop(lower, tree);
                            return newNode.replacedPage(0, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else {
                        return oldPages[x].drop(lower, tree);
                    }
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.take = function (upper, tree) {
            if (upper < this._size) {
                if (upper > 0) {
                    var oldPages = this._pages;
                    var x = 0;
                    var newSize = 0;
                    while (x < oldPages.length && upper > 0) {
                        var size = oldPages[x].size;
                        newSize += size;
                        x += 1;
                        if (size <= upper) {
                            upper -= size;
                        }
                        else {
                            break;
                        }
                    }
                    var newArity = upper === 0 ? x : x + 1;
                    if (newArity > 1) {
                        var newNode = void 0;
                        if (x < oldPages.length) {
                            var newPages = new Array(newArity);
                            for (var i = 0; i < newArity; i += 1) {
                                newPages[i] = oldPages[i];
                            }
                            var newKnots = new Array(newArity - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i];
                            }
                            newNode = this.newNode(newPages, newKnots, void 0, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (upper > 0) {
                            var oldPage = oldPages[x - 1];
                            var newPage = oldPage.take(upper, tree);
                            return newNode.replacedPage(x - 1, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else if (upper > 0) {
                        return oldPages[0].take(upper, tree);
                    }
                    else {
                        return oldPages[0];
                    }
                }
                else {
                    return BTreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.balanced = function (tree) {
            if (this._pages.length > 1 && tree.pageShouldSplit(this)) {
                var x = this._knots.length >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newRightPage.minKey();
            return this.newNode(newPages, newKnots, void 0, this._size);
        };
        BTreeNode.prototype.splitLeft = function (x) {
            var oldPages = this._pages;
            var newPages = new Array(x + 1);
            for (var i = 0; i < x + 1; i += 1) {
                newPages[i] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            var newSize = 0;
            for (var i = 0; i <= x; i += 1) {
                newSize += newPages[i].size;
            }
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.splitRight = function (x) {
            var oldPages = this._pages;
            var newArity = oldPages.length - (x + 1);
            var newPages = new Array(newArity);
            for (var i = 0; i < newArity; i += 1) {
                newPages[i] = oldPages[i + (x + 1)];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(newArity - 1);
            for (var i = 0; i < newKnots.length; i += 1) {
                newKnots[i] = oldKnots[i + (x + 1)];
            }
            var newSize = 0;
            for (var i = 0; i < newArity; i += 1) {
                newSize += newPages[i].size;
            }
            return this.newNode(newPages, newKnots, void 0, newSize);
        };
        BTreeNode.prototype.reduced = function (identity, accumulator, combiner) {
            if (this._fold === void 0) {
                var oldPages = this._pages;
                var n = oldPages.length;
                var newPages = new Array(n);
                for (var i = 0; i < n; i += 1) {
                    newPages[i] = oldPages[i].reduced(identity, accumulator, combiner);
                }
                var fold = newPages[0].fold();
                for (var i = 1; i < n; i += 1) {
                    fold = combiner(fold, newPages[i].fold());
                }
                return this.newNode(newPages, this._knots, fold, this._size);
            }
            else {
                return this;
            }
        };
        BTreeNode.prototype.forEach = function (callback, thisArg, tree) {
            var pages = this._pages;
            for (var i = 0, n = pages.length; i < n; i += 1) {
                var result = pages[i].forEach(callback, thisArg, tree);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        BTreeNode.prototype.entries = function () {
            return new BTree.NodeCursor(this._pages);
        };
        BTreeNode.prototype.reverseEntries = function () {
            return new BTree.NodeCursor(this._pages, this._size, this._pages.length);
        };
        BTreeNode.prototype.lookup = function (key, tree) {
            var lo = 0;
            var hi = this._knots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                var order = tree.compare(key, this._knots[mid]);
                if (order > 0) {
                    lo = mid + 1;
                }
                else if (order < 0) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        BTreeNode.prototype.newNode = function (pages, knots, fold, size) {
            return new BTreeNode(pages, knots, fold, size);
        };
        return BTreeNode;
    }(BTreePage));
    BTree.Node = BTreeNode;

    var BTreeNodeCursor = (function (_super) {
        __extends(BTreeNodeCursor, _super);
        function BTreeNodeCursor(pages, index, pageIndex, subCursor) {
            return _super.call(this, pages, index, pageIndex, subCursor) || this;
        }
        BTreeNodeCursor.prototype.pageSize = function (page) {
            return page.size;
        };
        BTreeNodeCursor.prototype.pageCursor = function (page) {
            return page.entries();
        };
        BTreeNodeCursor.prototype.reversePageCursor = function (page) {
            return page.reverseEntries();
        };
        return BTreeNodeCursor;
    }(NodeCursor));
    BTree.NodeCursor = BTreeNodeCursor;

    var STreeContext = (function () {
        function STreeContext() {
        }
        STreeContext.prototype.identify = function (value) {
            var id = new Uint8Array(6);
            util.Random.fillBytes(id);
            return id;
        };
        STreeContext.prototype.compare = function (x, y) {
            return util.Objects.compare(x, y);
        };
        STreeContext.prototype.pageShouldSplit = function (page) {
            return page.arity > this.pageSplitSize;
        };
        STreeContext.prototype.pageShouldMerge = function (page) {
            return page.arity < this.pageSplitSize >>> 1;
        };
        return STreeContext;
    }());
    STreeContext.prototype.pageSplitSize = 32;

    var STree = (function (_super) {
        __extends(STree, _super);
        function STree(root) {
            if (root === void 0) { root = STree.Page.empty(); }
            var _this = _super.call(this) || this;
            _this.root = root;
            return _this;
        }
        Object.defineProperty(STree.prototype, "length", {
            get: function () {
                return this.root.size;
            },
            enumerable: true,
            configurable: true
        });
        STree.prototype.isEmpty = function () {
            return this.root.isEmpty();
        };
        STree.prototype.get = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    return void 0;
                }
            }
            return this.root.get(index);
        };
        STree.prototype.getEntry = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    return void 0;
                }
            }
            return this.root.getEntry(index);
        };
        STree.prototype.set = function (index, newValue, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (index < 0 || index >= oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.updated(index, newValue, this);
            return this;
        };
        STree.prototype.insert = function (index, newValue, id) {
            var oldRoot = this.root;
            if (index < 0 || index > oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.inserted(index, newValue, id, this).balanced(this);
            return this;
        };
        STree.prototype.remove = function (index, id) {
            if (id !== void 0) {
                index = this.lookup(id, index);
                if (index < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (index < 0 || index > oldRoot.size) {
                throw new RangeError("" + index);
            }
            this.root = oldRoot.removed(index, this);
            return this;
        };
        STree.prototype.push = function () {
            var newValues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newValues[_i] = arguments[_i];
            }
            var newRoot = this.root;
            for (var i = 0; i < newValues.length; i += 1) {
                newRoot = newRoot.inserted(newRoot.size, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return newRoot.size;
        };
        STree.prototype.pop = function () {
            var oldRoot = this.root;
            var index = oldRoot.size - 1;
            if (index >= 0) {
                var oldValue = oldRoot.get(index);
                this.root = oldRoot.removed(index, this);
                return oldValue;
            }
            else {
                return void 0;
            }
        };
        STree.prototype.unshift = function () {
            var newValues = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                newValues[_i] = arguments[_i];
            }
            var newRoot = this.root;
            for (var i = newValues.length - 1; i >= 0; i -= 1) {
                newRoot = newRoot.inserted(0, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return newRoot.size;
        };
        STree.prototype.shift = function () {
            var oldRoot = this.root;
            if (oldRoot.size > 0) {
                var oldValue = oldRoot.get(0);
                this.root = oldRoot.removed(0, this);
                return oldValue;
            }
            else {
                return void 0;
            }
        };
        STree.prototype.move = function (fromIndex, toIndex, id) {
            if (id !== void 0) {
                fromIndex = this.lookup(id, fromIndex);
                if (fromIndex < 0) {
                    throw new RangeError("" + id);
                }
            }
            var oldRoot = this.root;
            if (fromIndex < 0 || fromIndex >= oldRoot.size) {
                throw new RangeError("" + fromIndex);
            }
            if (toIndex < 0 || toIndex >= oldRoot.size) {
                throw new RangeError("" + toIndex);
            }
            if (fromIndex !== toIndex) {
                var entry = oldRoot.getEntry(fromIndex);
                this.root = oldRoot.removed(fromIndex, this)
                    .inserted(toIndex, entry[1], entry[0], this)
                    .balanced(this);
            }
            return this;
        };
        STree.prototype.splice = function (start, deleteCount) {
            var newValues = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                newValues[_i - 2] = arguments[_i];
            }
            var newRoot = this.root;
            if (start < 0) {
                start = newRoot.size + start;
            }
            start = Math.min(Math.max(0, start), newRoot.size);
            if (deleteCount === void 0) {
                deleteCount = newRoot.size - start;
            }
            var deleted = [];
            for (var i = start, n = start + deleteCount; i < n; i += 1) {
                deleted.push(newRoot.get(start));
                newRoot = newRoot.removed(start, this);
            }
            for (var i = 0; i < newValues.length; i += 1) {
                newRoot = newRoot.inserted(start + i, newValues[i], void 0, this).balanced(this);
            }
            this.root = newRoot;
            return deleted;
        };
        STree.prototype.drop = function (lower) {
            var oldRoot = this.root;
            if (lower > 0 && oldRoot.size > 0) {
                if (lower < oldRoot.size) {
                    this.root = oldRoot.drop(lower, this);
                }
                else {
                    this.root = STree.Page.empty();
                }
            }
            return this;
        };
        STree.prototype.take = function (upper) {
            var oldRoot = this.root;
            if (upper < oldRoot.size && oldRoot.size > 0) {
                if (upper > 0) {
                    this.root = oldRoot.take(upper, this);
                }
                else {
                    this.root = STree.Page.empty();
                }
            }
            return this;
        };
        STree.prototype.clear = function () {
            this.root = STree.Page.empty();
        };
        STree.prototype.forEach = function (callback, thisArg) {
            return this.root.forEach(callback, thisArg, 0, this);
        };
        STree.prototype.keys = function () {
            return this.root.keys();
        };
        STree.prototype.values = function () {
            return this.root.values();
        };
        STree.prototype.entries = function () {
            return this.root.entries();
        };
        STree.prototype.reverseKeys = function () {
            return this.root.reverseKeys();
        };
        STree.prototype.reverseValues = function () {
            return this.root.reverseValues();
        };
        STree.prototype.reverseEntries = function () {
            return this.root.reverseEntries();
        };
        STree.prototype.clone = function () {
            return this.copy(this.root);
        };
        STree.prototype.copy = function (root) {
            var tree = new STree(root);
            if (tree.identify !== this.identify) {
                tree.identify = this.identify;
            }
            if (tree.compare !== this.compare) {
                tree.compare = this.compare;
            }
            if (tree.pageSplitSize !== this.pageSplitSize) {
                tree.pageSplitSize = this.pageSplitSize;
            }
            return tree;
        };
        STree.prototype.lookup = function (id, start) {
            if (start === void 0) { start = 0; }
            var root = this.root;
            start = Math.min(Math.max(0, start), root.size - 1);
            var index = start;
            do {
                var entry = root.getEntry(index);
                if (entry && this.compare(entry[0], id) === 0) {
                    return index;
                }
                index = (index + 1) % root.size;
            } while (isFinite(index) && index !== start);
            return -1;
        };
        return STree;
    }(STreeContext));
    STree.prototype.pageSplitSize = 32;

    var STreePage = (function () {
        function STreePage() {
        }
        STreePage.prototype.keys = function () {
            return new KeysCursor(this.entries());
        };
        STreePage.prototype.values = function () {
            return new ValuesCursor(this.entries());
        };
        STreePage.prototype.reverseKeys = function () {
            return new KeysCursor(this.reverseEntries());
        };
        STreePage.prototype.reverseValues = function () {
            return new ValuesCursor(this.reverseEntries());
        };
        STreePage.empty = function () {
            if (!STreePage._empty) {
                STreePage._empty = new STree.Leaf([]);
            }
            return STreePage._empty;
        };
        return STreePage;
    }());
    STree.Page = STreePage;

    var STreeLeaf = (function (_super) {
        __extends(STreeLeaf, _super);
        function STreeLeaf(slots) {
            var _this = _super.call(this) || this;
            _this._slots = slots;
            return _this;
        }
        Object.defineProperty(STreeLeaf.prototype, "arity", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(STreeLeaf.prototype, "size", {
            get: function () {
                return this._slots.length;
            },
            enumerable: true,
            configurable: true
        });
        STreeLeaf.prototype.isEmpty = function () {
            return this._slots.length === 0;
        };
        STreeLeaf.prototype.get = function (index) {
            var slot = this._slots[index];
            if (slot) {
                return slot[1];
            }
            else {
                return void 0;
            }
        };
        STreeLeaf.prototype.getEntry = function (index) {
            return this._slots[index];
        };
        STreeLeaf.prototype.updated = function (index, newValue, tree) {
            if (index < 0 || index >= this._slots.length) {
                throw new RangeError("" + index);
            }
            return this.updatedItem(index, newValue);
        };
        STreeLeaf.prototype.updatedItem = function (index, newValue) {
            var oldItems = this._slots;
            var oldSlot = oldItems[index];
            if (newValue !== oldSlot[1]) {
                var newValues = oldItems.slice(0);
                newValues[index] = [oldSlot[0], newValue];
                return new STreeLeaf(newValues);
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.inserted = function (index, newValue, id, tree) {
            if (index < 0 || index > this._slots.length) {
                throw new RangeError("" + index);
            }
            return this.insertedItem(index, newValue, id, tree);
        };
        STreeLeaf.prototype.insertedItem = function (index, newValue, id, tree) {
            if (id === void 0) {
                id = tree.identify(newValue);
            }
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length + 1);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            newSlots[index] = [id, newValue];
            for (var i = index; i < oldSlots.length; i += 1) {
                newSlots[i + 1] = oldSlots[i];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.removed = function (index, tree) {
            if (index < 0 || index >= this._slots.length) {
                throw new RangeError("" + index);
            }
            if (this._slots.length > 1) {
                return this.removedSlot(index);
            }
            else {
                return STreePage.empty();
            }
        };
        STreeLeaf.prototype.removedSlot = function (index) {
            var oldSlots = this._slots;
            var newSlots = new Array(oldSlots.length - 1);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            for (var i = index; i < newSlots.length; i += 1) {
                newSlots[i] = oldSlots[i + 1];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.drop = function (lower, tree) {
            var oldSlots = this._slots;
            if (lower > 0 && oldSlots.length > 0) {
                if (lower < oldSlots.length) {
                    var size = oldSlots.length - lower;
                    var newSlots = new Array(size);
                    for (var i = 0; i < size; i += 1) {
                        newSlots[i] = oldSlots[i + lower];
                    }
                    return new STreeLeaf(newSlots);
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.take = function (upper, tree) {
            var oldSlots = this._slots;
            if (upper < oldSlots.length && oldSlots.length > 0) {
                if (upper > 0) {
                    var newSlots = new Array(upper);
                    for (var i = 0; i < upper; i += 1) {
                        newSlots[i] = oldSlots[i];
                    }
                    return new STreeLeaf(newSlots);
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.balanced = function (tree) {
            var size = this._slots.length;
            if (size > 1 && tree.pageShouldSplit(this)) {
                return this.split(size >>> 1);
            }
            else {
                return this;
            }
        };
        STreeLeaf.prototype.split = function (index) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(index);
            var newRightPage = this.splitRight(index);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = index;
            return new STree.Node(newPages, newKnots, this._slots.length);
        };
        STreeLeaf.prototype.splitLeft = function (index) {
            var oldSlots = this._slots;
            var newSlots = new Array(index);
            for (var i = 0; i < index; i += 1) {
                newSlots[i] = oldSlots[i];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.splitRight = function (index) {
            var oldSlots = this._slots;
            var newSize = oldSlots.length - index;
            var newSlots = new Array(newSize);
            for (var i = 0; i < newSize; i += 1) {
                newSlots[i] = oldSlots[i + index];
            }
            return new STreeLeaf(newSlots);
        };
        STreeLeaf.prototype.forEach = function (callback, thisArg, offset, tree) {
            for (var i = 0; i < this._slots.length; i += 1) {
                var slot = this._slots[i];
                var result = callback.call(thisArg, slot[1], offset + i, tree, slot[0]);
                if (result !== void 0) {
                    return result;
                }
            }
            return void 0;
        };
        STreeLeaf.prototype.entries = function () {
            return util.Cursor.array(this._slots);
        };
        STreeLeaf.prototype.reverseEntries = function () {
            return util.Cursor.array(this._slots, this._slots.length);
        };
        return STreeLeaf;
    }(STreePage));
    STree.Leaf = STreeLeaf;

    var STreeNode = (function (_super) {
        __extends(STreeNode, _super);
        function STreeNode(pages, knots, size) {
            var _this = _super.call(this) || this;
            _this._pages = pages;
            if (knots === void 0 || size === void 0) {
                knots = new Array(pages.length - 1);
                size = 0;
                for (var i = 0, n = knots.length; i < n; i += 1) {
                    size += pages[i].size;
                    knots[i] = size;
                }
                size += pages[knots.length].size;
            }
            _this._knots = knots;
            _this._size = size;
            return _this;
        }
        Object.defineProperty(STreeNode.prototype, "arity", {
            get: function () {
                return this._pages.length;
            },
            enumerable: true,
            configurable: true
        });
        Object.defineProperty(STreeNode.prototype, "size", {
            get: function () {
                return this._size;
            },
            enumerable: true,
            configurable: true
        });
        STreeNode.prototype.isEmpty = function () {
            return this._size === 0;
        };
        STreeNode.prototype.get = function (index) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            return this._pages[x].get(i);
        };
        STreeNode.prototype.getEntry = function (index) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            return this._pages[x].getEntry(i);
        };
        STreeNode.prototype.updated = function (index, newValue, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var i = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.updated(i, newValue, tree);
            if (oldPage !== newPage) {
                if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.updatedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = oldPages.slice(0);
            newPages[x] = newPage;
            var oldKnots = this._knots;
            var newKnots;
            var newSize;
            if (oldPages.length - 1 > 0) {
                newKnots = oldKnots.slice(0);
                if (x > 0) {
                    newSize = oldKnots[x - 1];
                }
                else {
                    newSize = 0;
                }
                for (var i = x; i < newKnots.length; i += 1) {
                    newSize += newPages[i].size;
                    newKnots[i] = newSize;
                }
                newSize += newPages[newKnots.length].size;
            }
            else {
                newKnots = [];
                newSize = 0;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.updatedPageSplit = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length + 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            var newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
            var newRightPage = newPage.splitRight(newPage.arity >>> 1);
            newPages[x] = newLeftPage;
            newPages[x + 1] = newRightPage;
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + 1] = oldPages[i];
            }
            return new STreeNode(newPages);
        };
        STreeNode.prototype.updatedPageMerge = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var midPages = newPage._pages;
            var newPages = new Array(oldPages.length + midPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = 0; i < midPages.length; i += 1) {
                newPages[i + x] = midPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i + midPages.length - 1] = oldPages[i];
            }
            return new STreeNode(newPages);
        };
        STreeNode.prototype.inserted = function (index, newValue, id, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var subIndex = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.inserted(subIndex, newValue, id, tree);
            if (oldPage !== newPage) {
                if (tree.pageShouldSplit(newPage)) {
                    return this.updatedPageSplit(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.removed = function (index, tree) {
            var x = this.lookup(index);
            if (x >= 0) {
                x += 1;
            }
            else {
                x = -(x + 1);
            }
            var subIndex = x === 0 ? index : index - this._knots[x - 1];
            var oldPage = this._pages[x];
            var newPage = oldPage.removed(subIndex, tree);
            if (oldPage !== newPage) {
                return this.replacedPage(x, newPage, oldPage, tree);
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.replacedPage = function (x, newPage, oldPage, tree) {
            if (!newPage.isEmpty()) {
                if (newPage instanceof STreeNode && tree.pageShouldMerge(newPage)) {
                    return this.updatedPageMerge(x, newPage, oldPage);
                }
                else {
                    return this.updatedPage(x, newPage, oldPage);
                }
            }
            else if (this._pages.length > 2) {
                return this.removedPage(x, newPage, oldPage);
            }
            else if (this._pages.length > 1) {
                if (x === 0) {
                    return this._pages[1];
                }
                else {
                    return this._pages[0];
                }
            }
            else {
                return STreePage.empty();
            }
        };
        STreeNode.prototype.removedPage = function (x, newPage, oldPage) {
            var oldPages = this._pages;
            var newPages = new Array(oldPages.length - 1);
            for (var i = 0; i < x; i += 1) {
                newPages[i] = oldPages[i];
            }
            for (var i = x + 1; i < oldPages.length; i += 1) {
                newPages[i - 1] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(oldKnots.length - 1);
            var newSize;
            if (x > 0) {
                for (var i = 0; i < x; i += 1) {
                    newKnots[i] = oldKnots[i];
                }
                newSize = oldKnots[x - 1];
            }
            else {
                newSize = 0;
            }
            for (var i = x; i < newKnots.length; i += 1) {
                newSize += newPages[i].size;
                newKnots[i] = newSize;
            }
            newSize += newPages[newKnots.length].size;
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.drop = function (lower, tree) {
            if (lower > 0) {
                if (lower < this._size) {
                    var x = this.lookup(lower);
                    if (x >= 0) {
                        x += 1;
                    }
                    else {
                        x = -(x + 1);
                    }
                    lower = x === 0 ? lower : lower - this._knots[x - 1];
                    var oldPages = this._pages;
                    var n = oldPages.length - x;
                    if (n > 1) {
                        var newNode = void 0;
                        if (x > 0) {
                            var newPages = new Array(n);
                            for (var i = 0; i < n; i += 1) {
                                newPages[i] = oldPages[i + x];
                            }
                            newNode = new STreeNode(newPages);
                        }
                        else {
                            newNode = this;
                        }
                        if (lower > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.drop(lower, tree);
                            return newNode.replacedPage(0, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else {
                        return oldPages[x].drop(lower, tree);
                    }
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.take = function (upper, tree) {
            if (upper < this._size) {
                if (upper > 0) {
                    var x = this.lookup(upper);
                    if (x >= 0) {
                        x += 1;
                    }
                    else {
                        x = -(x + 1);
                    }
                    upper = x === 0 ? upper : upper - this._knots[x - 1];
                    var oldPages = this._pages;
                    var n = upper === 0 ? x : x + 1;
                    if (n > 1) {
                        var newNode = void 0;
                        if (x < oldPages.length) {
                            var newPages = new Array(n);
                            for (var i = 0; i < n; i += 1) {
                                newPages[i] = oldPages[i];
                            }
                            var newKnots = new Array(n - 1);
                            for (var i = 0; i < newKnots.length; i += 1) {
                                newKnots[i] = this._knots[i];
                            }
                            var newSize = newKnots[n - 2] + newPages[n - 1].size;
                            newNode = new STreeNode(newPages, newKnots, newSize);
                        }
                        else {
                            newNode = this;
                        }
                        if (upper > 0) {
                            var oldPage = oldPages[x];
                            var newPage = oldPage.take(upper, tree);
                            return newNode.replacedPage(x, newPage, oldPage, tree);
                        }
                        else {
                            return newNode;
                        }
                    }
                    else if (upper > 0) {
                        return oldPages[0].take(upper, tree);
                    }
                    else {
                        return oldPages[0];
                    }
                }
                else {
                    return STreePage.empty();
                }
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.balanced = function (tree) {
            if (this._pages.length > 1 && tree.pageShouldSplit(this)) {
                var x = this._knots.length >>> 1;
                return this.split(x);
            }
            else {
                return this;
            }
        };
        STreeNode.prototype.split = function (x) {
            var newPages = new Array(2);
            var newLeftPage = this.splitLeft(x);
            var newRightPage = this.splitRight(x);
            newPages[0] = newLeftPage;
            newPages[1] = newRightPage;
            var newKnots = new Array(1);
            newKnots[0] = newLeftPage._size;
            return new STreeNode(newPages, newKnots, this._size);
        };
        STreeNode.prototype.splitLeft = function (x) {
            var oldPages = this._pages;
            var newPages = new Array(x + 1);
            for (var i = 0; i < x + 1; i += 1) {
                newPages[i] = oldPages[i];
            }
            var oldKnots = this._knots;
            var newKnots = new Array(x);
            for (var i = 0; i < x; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            var newSize = 0;
            for (var i = 0; i <= x; i += 1) {
                newSize += newPages[i].size;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.splitRight = function (x) {
            var oldPages = this._pages;
            var y = oldPages.length - (x + 1);
            var newPages = new Array(y);
            for (var i = 0; i < y; i += 1) {
                newPages[i] = oldPages[i + (x + 1)];
            }
            var newKnots = new Array(y - 1);
            var newSize;
            if (y > 0) {
                newSize = newPages[0].size;
                for (var i = 1; i < y; i += 1) {
                    newKnots[i - 1] = newSize;
                    newSize += newPages[i].size;
                }
            }
            else {
                newSize = 0;
            }
            return new STreeNode(newPages, newKnots, newSize);
        };
        STreeNode.prototype.forEach = function (callback, thisArg, offset, tree) {
            for (var i = 0; i < this._pages.length; i += 1) {
                var page = this._pages[i];
                var result = page.forEach(callback, thisArg, offset, tree);
                if (result !== void 0) {
                    return result;
                }
                offset += page.size;
            }
            return void 0;
        };
        STreeNode.prototype.entries = function () {
            return new STree.NodeCursor(this._pages);
        };
        STreeNode.prototype.reverseEntries = function () {
            return new STree.NodeCursor(this._pages, this._size, this._pages.length);
        };
        STreeNode.prototype.lookup = function (index) {
            var lo = 0;
            var hi = this._knots.length - 1;
            while (lo <= hi) {
                var mid = (lo + hi) >>> 1;
                if (index > this._knots[mid]) {
                    lo = mid + 1;
                }
                else if (index < this._knots[mid]) {
                    hi = mid - 1;
                }
                else {
                    return mid;
                }
            }
            return -(lo + 1);
        };
        return STreeNode;
    }(STreePage));
    STree.Node = STreeNode;

    var STreeNodeCursor = (function (_super) {
        __extends(STreeNodeCursor, _super);
        function STreeNodeCursor(pages, index, pageIndex, subCursor) {
            return _super.call(this, pages, index, pageIndex, subCursor) || this;
        }
        STreeNodeCursor.prototype.pageSize = function (page) {
            return page.size;
        };
        STreeNodeCursor.prototype.pageCursor = function (page) {
            return page.entries();
        };
        STreeNodeCursor.prototype.reversePageCursor = function (page) {
            return page.reverseEntries();
        };
        return STreeNodeCursor;
    }(NodeCursor));
    STree.NodeCursor = STreeNodeCursor;

    exports.BTree = BTree;
    exports.BTreeContext = BTreeContext;
    exports.BTreeLeaf = BTreeLeaf;
    exports.BTreeNode = BTreeNode;
    exports.BTreeNodeCursor = BTreeNodeCursor;
    exports.BTreePage = BTreePage;
    exports.KeysCursor = KeysCursor;
    exports.NodeCursor = NodeCursor;
    exports.STree = STree;
    exports.STreeContext = STreeContext;
    exports.STreeLeaf = STreeLeaf;
    exports.STreeNode = STreeNode;
    exports.STreeNodeCursor = STreeNodeCursor;
    exports.STreePage = STreePage;
    exports.ValuesCursor = ValuesCursor;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=swim-collections.js.map