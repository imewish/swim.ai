import { __extends } from "tslib";
import { Cursor } from "@swim/util";
import { BTree } from "./BTree";
import { BTreePage } from "./BTreePage";
var BTreeLeaf = (function (_super) {
    __extends(BTreeLeaf, _super);
    function BTreeLeaf(slots, fold) {
        var _this = _super.call(this) || this;
        _this._slots = slots;
        _this._fold = fold;
        return _this;
    }
    Object.defineProperty(BTreeLeaf.prototype, "arity", {
        get: function () {
            return this._slots.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BTreeLeaf.prototype, "size", {
        get: function () {
            return this._slots.length;
        },
        enumerable: true,
        configurable: true
    });
    BTreeLeaf.prototype.isEmpty = function () {
        return this._slots.length === 0;
    };
    BTreeLeaf.prototype.fold = function () {
        return this._fold;
    };
    BTreeLeaf.prototype.minKey = function () {
        return this._slots[0][0];
    };
    BTreeLeaf.prototype.maxKey = function () {
        return this._slots[this._slots.length - 1][0];
    };
    BTreeLeaf.prototype.has = function (key, tree) {
        return this.lookup(key, tree) >= 0;
    };
    BTreeLeaf.prototype.get = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            return this._slots[x][1];
        }
        else {
            return void 0;
        }
    };
    BTreeLeaf.prototype.getEntry = function (index) {
        return this._slots[index];
    };
    BTreeLeaf.prototype.firstEntry = function () {
        if (this._slots.length) {
            return this._slots[0];
        }
        else {
            return void 0;
        }
    };
    BTreeLeaf.prototype.lastEntry = function () {
        if (this._slots.length) {
            return this._slots[this._slots.length - 1];
        }
        else {
            return void 0;
        }
    };
    BTreeLeaf.prototype.nextEntry = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        return this._slots[x];
    };
    BTreeLeaf.prototype.previousEntry = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x -= 1;
        }
        else {
            x = -(x + 2);
        }
        return this._slots[x];
    };
    BTreeLeaf.prototype.updated = function (key, newValue, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            return this.updatedSlot(x, key, newValue);
        }
        else {
            x = -(x + 1);
            return this.insertedSlot(x, key, newValue);
        }
    };
    BTreeLeaf.prototype.updatedSlot = function (x, key, newValue) {
        var oldSlots = this._slots;
        if (newValue !== oldSlots[x][1]) {
            var newSlots = oldSlots.slice(0);
            newSlots[x] = [key, newValue];
            return this.newLeaf(newSlots, void 0);
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.insertedSlot = function (x, key, newValue) {
        var oldSlots = this._slots;
        var n = oldSlots.length + 1;
        var newSlots = new Array(n);
        for (var i = 0; i < x; i += 1) {
            newSlots[i] = oldSlots[i];
        }
        newSlots[x] = [key, newValue];
        for (var i = x; i < n - 1; i += 1) {
            newSlots[i + 1] = oldSlots[i];
        }
        return this.newLeaf(newSlots, void 0);
    };
    BTreeLeaf.prototype.removed = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            if (this._slots.length > 1) {
                return this.removedSlot(x);
            }
            else {
                return BTreePage.empty();
            }
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.removedSlot = function (x) {
        var oldSlots = this._slots;
        var newSlots = new Array(oldSlots.length - 1);
        for (var i = 0; i < x; i += 1) {
            newSlots[i] = oldSlots[i];
        }
        for (var i = x; i < newSlots.length; i += 1) {
            newSlots[i] = oldSlots[i + 1];
        }
        return this.newLeaf(newSlots, void 0);
    };
    BTreeLeaf.prototype.drop = function (lower, tree) {
        if (lower > 0) {
            var oldSlots = this._slots;
            if (lower < oldSlots.length) {
                var size = oldSlots.length - lower;
                var newSlots = new Array(size);
                for (var i = 0; i < size; i += 1) {
                    newSlots[i] = oldSlots[i + lower];
                }
                return this.newLeaf(newSlots, void 0);
            }
            else {
                return BTreePage.empty();
            }
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.take = function (upper, tree) {
        var oldSlots = this._slots;
        if (upper < oldSlots.length) {
            if (upper > 0) {
                var newSlots = new Array(upper);
                for (var i = 0; i < upper; i += 1) {
                    newSlots[i] = oldSlots[i];
                }
                return this.newLeaf(newSlots, void 0);
            }
            else {
                return BTreePage.empty();
            }
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.balanced = function (tree) {
        var n = this._slots.length;
        if (n > 1 && tree.pageShouldSplit(this)) {
            var x = n >>> 1;
            return this.split(x);
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.split = function (x) {
        var newPages = new Array(2);
        var newLeftPage = this.splitLeft(x);
        var newRightPage = this.splitRight(x);
        newPages[0] = newLeftPage;
        newPages[1] = newRightPage;
        var newKnots = new Array(1);
        newKnots[0] = newRightPage.minKey();
        return this.newNode(newPages, newKnots, void 0, this._slots.length);
    };
    BTreeLeaf.prototype.splitLeft = function (x) {
        var oldSlots = this._slots;
        var newSlots = new Array(x);
        for (var i = 0; i < x; i += 1) {
            newSlots[i] = oldSlots[i];
        }
        return this.newLeaf(newSlots, void 0);
    };
    BTreeLeaf.prototype.splitRight = function (x) {
        var oldSlots = this._slots;
        var y = oldSlots.length - x;
        var newSlots = new Array(y);
        for (var i = 0; i < y; i += 1) {
            newSlots[i] = oldSlots[i + x];
        }
        return this.newLeaf(newSlots, void 0);
    };
    BTreeLeaf.prototype.reduced = function (identity, accumulator, combiner) {
        if (this._fold === void 0) {
            var slots = this._slots;
            var fold = identity;
            for (var i = 0, n = slots.length; i < n; i += 1) {
                fold = accumulator(fold, slots[i][1]);
            }
            return this.newLeaf(slots, fold);
        }
        else {
            return this;
        }
    };
    BTreeLeaf.prototype.forEach = function (callback, thisArg, tree) {
        var slots = this._slots;
        for (var i = 0, n = slots.length; i < n; i += 1) {
            var slot = slots[i];
            var result = callback.call(thisArg, slot[0], slot[1], tree);
            if (result !== void 0) {
                return result;
            }
        }
        return void 0;
    };
    BTreeLeaf.prototype.entries = function () {
        return Cursor.array(this._slots);
    };
    BTreeLeaf.prototype.reverseEntries = function () {
        return Cursor.array(this._slots, this._slots.length);
    };
    BTreeLeaf.prototype.lookup = function (key, tree) {
        var lo = 0;
        var hi = this._slots.length - 1;
        while (lo <= hi) {
            var mid = (lo + hi) >>> 1;
            var order = tree.compare(key, this._slots[mid][0]);
            if (order > 0) {
                lo = mid + 1;
            }
            else if (order < 0) {
                hi = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(lo + 1);
    };
    BTreeLeaf.prototype.newLeaf = function (slots, fold) {
        return new BTreeLeaf(slots, fold);
    };
    BTreeLeaf.prototype.newNode = function (pages, knots, fold, size) {
        return new BTree.Node(pages, knots, fold, size);
    };
    return BTreeLeaf;
}(BTreePage));
export { BTreeLeaf };
BTree.Leaf = BTreeLeaf;
//# sourceMappingURL=BTreeLeaf.js.map