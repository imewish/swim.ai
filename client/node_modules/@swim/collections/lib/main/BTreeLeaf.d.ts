import { Cursor } from "@swim/util";
import { BTreeContext } from "./BTreeContext";
import { BTree } from "./BTree";
import { BTreePage } from "./BTreePage";
import { BTreeNode } from "./BTreeNode";
export declare class BTreeLeaf<K, V, U> extends BTreePage<K, V, U> {
    readonly _slots: [K, V][];
    readonly _fold: U | undefined;
    constructor(slots: [K, V][], fold: U | undefined);
    get arity(): number;
    get size(): number;
    isEmpty(): boolean;
    fold(): U | undefined;
    minKey(): K;
    maxKey(): K;
    has(key: K, tree: BTreeContext<K, V>): boolean;
    get(key: K, tree: BTreeContext<K, V>): V | undefined;
    getEntry(index: number): [K, V] | undefined;
    firstEntry(): [K, V] | undefined;
    lastEntry(): [K, V] | undefined;
    nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    private updatedSlot;
    private insertedSlot;
    removed(key: K, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    private removedSlot;
    drop(lower: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    take(upper: number, tree: BTreeContext<K, V>): BTreeLeaf<K, V, U>;
    balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    split(x: number): BTreeNode<K, V, U>;
    splitLeft(x: number): BTreeLeaf<K, V, U>;
    splitRight(x: number): BTreeLeaf<K, V, U>;
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): BTreeLeaf<K, V, U>;
    forEach<T, S>(callback: (this: S, key: K, value: V, tree: BTree<K, V>) => T | void, thisArg: S, tree: BTree<K, V>): T | undefined;
    entries(): Cursor<[K, V]>;
    reverseEntries(): Cursor<[K, V]>;
    private lookup;
    protected newLeaf(slots: [K, V][], fold: U | undefined): BTreeLeaf<K, V, U>;
    protected newNode(pages: BTreePage<K, V, U>[], knots: K[], fold: U | undefined, size: number): BTreeNode<K, V, U>;
}
//# sourceMappingURL=BTreeLeaf.d.ts.map