import { Cursor } from "@swim/util";
import { BTreeContext } from "./BTreeContext";
import { BTree } from "./BTree";
import { BTreeLeaf } from "./BTreeLeaf";
export declare abstract class BTreePage<K, V, U> {
    abstract get arity(): number;
    abstract get size(): number;
    abstract isEmpty(): boolean;
    abstract fold(): U | undefined;
    abstract minKey(): K;
    abstract maxKey(): K;
    abstract has(key: K, tree: BTreeContext<K, V>): boolean;
    abstract get(key: K, tree: BTreeContext<K, V>): V | undefined;
    abstract getEntry(index: number): [K, V] | undefined;
    abstract firstEntry(): [K, V] | undefined;
    abstract lastEntry(): [K, V] | undefined;
    abstract nextEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    abstract previousEntry(key: K, tree: BTreeContext<K, V>): [K, V] | undefined;
    abstract updated(key: K, newValue: V, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract removed(key: K, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract drop(lower: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract take(upper: number, tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract balanced(tree: BTreeContext<K, V>): BTreePage<K, V, U>;
    abstract split(index: number): BTreePage<K, V, U>;
    abstract splitLeft(index: number): BTreePage<K, V, U>;
    abstract splitRight(index: number): BTreePage<K, V, U>;
    abstract reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): BTreePage<K, V, U>;
    abstract forEach<T, S>(callback: (this: S, key: K, value: V, tree: BTree<K, V>) => T | void, thisArg: S, tree: BTree<K, V>): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    abstract entries(): Cursor<[K, V]>;
    reverseKeys(): Cursor<K>;
    reverseValues(): Cursor<V>;
    abstract reverseEntries(): Cursor<[K, V]>;
    private static _empty;
    static empty<K, V, U>(): BTreeLeaf<K, V, U>;
}
//# sourceMappingURL=BTreePage.d.ts.map