import { Cursor, ReducedMap } from "@swim/util";
import { BTreeContext } from "./BTreeContext";
import { BTreePage } from "./BTreePage";
import { BTreeLeaf } from "./BTreeLeaf";
import { BTreeNode } from "./BTreeNode";
import { BTreeNodeCursor } from "./BTreeNodeCursor";
export declare class BTree<K = unknown, V = unknown, U = unknown> extends BTreeContext<K, V> implements ReducedMap<K, V, U> {
    root: BTreePage<K, V, U>;
    constructor(root?: BTreePage<K, V, U>);
    get size(): number;
    isEmpty(): boolean;
    has(key: K): boolean;
    get(key: K): V | undefined;
    getEntry(index: number): [K, V] | undefined;
    firstKey(): K | undefined;
    firstValue(): V | undefined;
    firstEntry(): [K, V] | undefined;
    lastKey(): K | undefined;
    lastValue(): V | undefined;
    lastEntry(): [K, V] | undefined;
    nextKey(key: K): K | undefined;
    nextValue(key: K): V | undefined;
    nextEntry(key: K): [K, V] | undefined;
    previousKey(key: K): K | undefined;
    previousValue(key: K): V | undefined;
    previousEntry(key: K): [K, V] | undefined;
    set(key: K, newValue: V): this;
    delete(key: K): boolean;
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    updated(key: K, newValue: V): BTree<K, V>;
    removed(key: K): BTree<K, V>;
    cleared(): BTree<K, V>;
    reduced(identity: U, accumulator: (result: U, element: V) => U, combiner: (result: U, result2: U) => U): U;
    forEach<T, S = unknown>(callback: (this: S, key: K, value: V, tree: BTree<K, V>) => T | void, thisArg?: S): T | undefined;
    keys(): Cursor<K>;
    values(): Cursor<V>;
    entries(): Cursor<[K, V]>;
    reverseKeys(): Cursor<K>;
    reverseValues(): Cursor<V>;
    reverseEntries(): Cursor<[K, V]>;
    clone(): BTree<K, V>;
    protected copy(root: BTreePage<K, V, U>): BTree<K, V, U>;
    static Page: typeof BTreePage;
    static Leaf: typeof BTreeLeaf;
    static Node: typeof BTreeNode;
    static NodeCursor: typeof BTreeNodeCursor;
}
//# sourceMappingURL=BTree.d.ts.map