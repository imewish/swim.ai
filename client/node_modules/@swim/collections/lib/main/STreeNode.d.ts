import { Cursor } from "@swim/util";
import { STreeContext } from "./STreeContext";
import { STree } from "./STree";
import { STreePage } from "./STreePage";
export declare class STreeNode<V, I> extends STreePage<V, I> {
    readonly _pages: STreePage<V, I>[];
    readonly _knots: number[];
    readonly _size: number;
    constructor(pages: STreePage<V, I>[], knots?: number[], size?: number);
    get arity(): number;
    get size(): number;
    isEmpty(): boolean;
    get(index: number): V | undefined;
    getEntry(index: number): [I, V] | undefined;
    updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeNode<V, I>;
    private updatedPage;
    private updatedPageSplit;
    private updatedPageMerge;
    inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeNode<V, I>;
    removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;
    private replacedPage;
    private removedPage;
    drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;
    take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;
    balanced(tree: STreeContext<V, I>): STreeNode<V, I>;
    split(x: number): STreeNode<V, I>;
    splitLeft(x: number): STreeNode<V, I>;
    splitRight(x: number): STreeNode<V, I>;
    forEach<T, S>(callback: (this: S, value: V, index: number, tree: STree<V, I>, id: I) => T | void, thisArg: S, offset: number, tree: STree<V, I>): T | undefined;
    entries(): Cursor<[I, V]>;
    reverseEntries(): Cursor<[I, V]>;
    private lookup;
}
//# sourceMappingURL=STreeNode.d.ts.map