import { Cursor } from "@swim/util";
import { STreeContext } from "./STreeContext";
import { STreePage } from "./STreePage";
import { STreeLeaf } from "./STreeLeaf";
import { STreeNode } from "./STreeNode";
import { STreeNodeCursor } from "./STreeNodeCursor";
export declare class STree<V = unknown, I = unknown> extends STreeContext<V, I> {
    root: STreePage<V, I>;
    constructor(root?: STreePage<V, I>);
    get length(): number;
    isEmpty(): boolean;
    get(index: number, id?: I): V | undefined;
    getEntry(index: number, id?: I): [I, V] | undefined;
    set(index: number, newValue: V, id?: I): this;
    insert(index: number, newValue: V, id?: I): this;
    remove(index: number, id?: I): this;
    push(...newValues: V[]): number;
    pop(): V | undefined;
    unshift(...newValues: V[]): number;
    shift(): V | undefined;
    move(fromIndex: number, toIndex: number, id?: I): this;
    splice(start: number, deleteCount?: number, ...newValues: V[]): V[];
    drop(lower: number): this;
    take(upper: number): this;
    clear(): void;
    forEach<T, S = unknown>(callback: (this: S, value: V, index: number, tree: STree<V, I>, id: I) => T | void, thisArg?: S): T | undefined;
    keys(): Cursor<I>;
    values(): Cursor<V>;
    entries(): Cursor<[I, V]>;
    reverseKeys(): Cursor<I>;
    reverseValues(): Cursor<V>;
    reverseEntries(): Cursor<[I, V]>;
    clone(): STree<V, I>;
    protected copy(root: STreePage<V, I>): STree<V, I>;
    lookup(id: I, start?: number): number;
    static Page: typeof STreePage;
    static Leaf: typeof STreeLeaf;
    static Node: typeof STreeNode;
    static NodeCursor: typeof STreeNodeCursor;
}
//# sourceMappingURL=STree.d.ts.map