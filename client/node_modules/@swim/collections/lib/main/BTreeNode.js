import { __extends } from "tslib";
import { BTree } from "./BTree";
import { BTreePage } from "./BTreePage";
var BTreeNode = (function (_super) {
    __extends(BTreeNode, _super);
    function BTreeNode(pages, knots, fold, size) {
        var _this = _super.call(this) || this;
        _this._pages = pages;
        _this._knots = knots;
        _this._fold = fold;
        _this._size = size;
        return _this;
    }
    Object.defineProperty(BTreeNode.prototype, "arity", {
        get: function () {
            return this._pages.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BTreeNode.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    BTreeNode.prototype.isEmpty = function () {
        return this._size === 0;
    };
    BTreeNode.prototype.fold = function () {
        return this._fold;
    };
    BTreeNode.prototype.minKey = function () {
        return this._pages[0].minKey();
    };
    BTreeNode.prototype.maxKey = function () {
        return this._pages[this._pages.length - 1].maxKey();
    };
    BTreeNode.prototype.has = function (key, tree) {
        var xx = this.lookup(key, tree);
        if (xx > 0) {
            xx += 1;
        }
        else if (xx < 0) {
            xx = -(xx + 1);
        }
        else {
            return true;
        }
        return this._pages[xx].has(key, tree);
    };
    BTreeNode.prototype.get = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        return this._pages[x].get(key, tree);
    };
    BTreeNode.prototype.getEntry = function (x) {
        var pages = this._pages;
        for (var i = 0, n = pages.length; i < n; i += 1) {
            var page = pages[i];
            if (x < page.size) {
                return page.getEntry(x);
            }
            else {
                x -= page.size;
            }
        }
        return void 0;
    };
    BTreeNode.prototype.firstEntry = function () {
        var pages = this._pages;
        if (pages.length) {
            return pages[0].firstEntry();
        }
        else {
            return void 0;
        }
    };
    BTreeNode.prototype.lastEntry = function () {
        var pages = this._pages;
        if (pages.length) {
            return pages[pages.length - 1].lastEntry();
        }
        else {
            return void 0;
        }
    };
    BTreeNode.prototype.nextEntry = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        var pages = this._pages;
        var entry = pages[x].nextEntry(key, tree);
        if (entry === void 0 && x + 1 < pages.length) {
            entry = pages[x + 1].nextEntry(key, tree);
        }
        return entry;
    };
    BTreeNode.prototype.previousEntry = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        var pages = this._pages;
        var entry = pages[x].previousEntry(key, tree);
        if (entry === void 0 && x > 0) {
            entry = pages[x - 1].previousEntry(key, tree);
        }
        return entry;
    };
    BTreeNode.prototype.updated = function (key, newValue, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        var oldPage = this._pages[x];
        var newPage = oldPage.updated(key, newValue, tree);
        if (oldPage !== newPage) {
            if (oldPage.size !== newPage.size && tree.pageShouldSplit(newPage)) {
                return this.updatedPageSplit(x, newPage, oldPage);
            }
            else {
                return this.updatedPage(x, newPage, oldPage);
            }
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.updatedPage = function (x, newPage, oldPage) {
        var oldPages = this._pages;
        var newPages = oldPages.slice(0);
        newPages[x] = newPage;
        var oldKnots = this._knots;
        var newKnots;
        if (oldKnots.length > 0) {
            newKnots = oldKnots.slice(0);
            if (x > 0) {
                newKnots[x - 1] = newPage.minKey();
            }
        }
        else {
            newKnots = [];
        }
        var newSize = this._size - oldPage.size + newPage.size;
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.updatedPageSplit = function (x, newPage, oldPage) {
        var oldPages = this._pages;
        var newPages = new Array(oldPages.length + 1);
        for (var i = 0; i < x; i += 1) {
            newPages[i] = oldPages[i];
        }
        var newLeftPage = newPage.splitLeft(newPage.arity >>> 1);
        var newRightPage = newPage.splitRight(newPage.arity >>> 1);
        newPages[x] = newLeftPage;
        newPages[x + 1] = newRightPage;
        for (var i = x + 1; i < oldPages.length; i += 1) {
            newPages[i + 1] = oldPages[i];
        }
        var oldKnots = this._knots;
        var newKnots = new Array(oldPages.length);
        if (x > 0) {
            for (var i = 0; i < x - 1; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            newKnots[x - 1] = newLeftPage.minKey();
            newKnots[x] = newRightPage.minKey();
            for (var i = x; i < oldKnots.length; i += 1) {
                newKnots[i + 1] = oldKnots[i];
            }
        }
        else {
            newKnots[0] = newRightPage.minKey();
            for (var i = 0; i < oldKnots.length; i += 1) {
                newKnots[i + 1] = oldKnots[i];
            }
        }
        var newSize = this._size - oldPage.size + newPage.size;
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.updatedPageMerge = function (x, newPage, oldPage) {
        var oldPages = this._pages;
        var midPages = newPage._pages;
        var newPages = new Array(oldPages.length + midPages.length - 1);
        for (var i = 0; i < x; i += 1) {
            newPages[i] = oldPages[i];
        }
        for (var i = 0; i < midPages.length; i += 1) {
            newPages[i + x] = midPages[i];
        }
        for (var i = x + 1; i < oldPages.length; i += 1) {
            newPages[i + midPages.length - 1] = oldPages[i];
        }
        var oldKnots = this._knots;
        var midKnots = newPage._knots;
        var newKnots = new Array(newPages.length - 1);
        if (x > 0) {
            for (var i = 0; i < x - 1; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            newKnots[x - 1] = midPages[0].minKey();
            for (var i = 0; i < midKnots.length; i += 1) {
                newKnots[i + x] = midKnots[i];
            }
            for (var i = x; i < oldKnots.length; i += 1) {
                newKnots[i + midKnots.length] = oldKnots[i];
            }
        }
        else {
            for (var i = 0; i < midKnots.length; i += 1) {
                newKnots[i] = midKnots[i];
            }
            newKnots[midKnots.length] = oldPages[1].minKey();
            for (var i = 1; i < oldKnots.length; i += 1) {
                newKnots[i + midKnots.length] = oldKnots[i];
            }
        }
        var newSize = this._size - oldPage.size + newPage.size;
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.removed = function (key, tree) {
        var x = this.lookup(key, tree);
        if (x >= 0) {
            x += 1;
        }
        else {
            x = -(x + 1);
        }
        var oldPage = this._pages[x];
        var newPage = oldPage.removed(key, tree);
        if (oldPage !== newPage) {
            return this.replacedPage(x, newPage, oldPage, tree);
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.replacedPage = function (x, newPage, oldPage, tree) {
        if (!newPage.isEmpty()) {
            if (newPage instanceof BTreeNode && tree.pageShouldMerge(newPage)) {
                return this.updatedPageMerge(x, newPage, oldPage);
            }
            else {
                return this.updatedPage(x, newPage, oldPage);
            }
        }
        else if (this._pages.length > 2) {
            return this.removedPage(x, newPage, oldPage);
        }
        else if (this._pages.length > 1) {
            if (x === 0) {
                return this._pages[1];
            }
            else {
                return this._pages[0];
            }
        }
        else {
            return BTreePage.empty();
        }
    };
    BTreeNode.prototype.removedPage = function (x, newPage, oldPage) {
        var oldPages = this._pages;
        var newPages = new Array(oldPages.length - 1);
        for (var i = 0; i < x; i += 1) {
            newPages[i] = oldPages[i];
        }
        for (var i = x + 1; i < oldPages.length; i += 1) {
            newPages[i - 1] = oldPages[i];
        }
        var oldKnots = this._knots;
        var newKnots = new Array(oldKnots.length - 1);
        if (x > 0) {
            for (var i = 0; i < x - 1; i += 1) {
                newKnots[i] = oldKnots[i];
            }
            for (var i = x; i < oldKnots.length; i += 1) {
                newKnots[i - 1] = oldKnots[i];
            }
        }
        else {
            for (var i = 1; i < oldKnots.length; i += 1) {
                newKnots[i - 1] = oldKnots[i];
            }
        }
        var newSize = this._size - oldPage.size;
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.drop = function (lower, tree) {
        if (lower > 0) {
            var newSize = this._size;
            if (lower < newSize) {
                var oldPages = this._pages;
                var x = 0;
                while (x < oldPages.length) {
                    var size = oldPages[x].size;
                    if (size <= lower) {
                        newSize -= size;
                        lower -= size;
                        x += 1;
                    }
                    else {
                        break;
                    }
                }
                var newArity = oldPages.length - x;
                if (newArity > 1) {
                    var newNode = void 0;
                    if (x > 0) {
                        var newPages = new Array(newArity);
                        for (var i = 0; i < newArity; i += 1) {
                            newPages[i] = oldPages[i + x];
                        }
                        var newKnots = new Array(newArity - 1);
                        for (var i = 0; i < newKnots.length; i += 1) {
                            newKnots[i] = this._knots[i + x];
                        }
                        newNode = this.newNode(newPages, newKnots, void 0, newSize);
                    }
                    else {
                        newNode = this;
                    }
                    if (lower > 0) {
                        var oldPage = oldPages[x];
                        var newPage = oldPage.drop(lower, tree);
                        return newNode.replacedPage(0, newPage, oldPage, tree);
                    }
                    else {
                        return newNode;
                    }
                }
                else {
                    return oldPages[x].drop(lower, tree);
                }
            }
            else {
                return BTreePage.empty();
            }
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.take = function (upper, tree) {
        if (upper < this._size) {
            if (upper > 0) {
                var oldPages = this._pages;
                var x = 0;
                var newSize = 0;
                while (x < oldPages.length && upper > 0) {
                    var size = oldPages[x].size;
                    newSize += size;
                    x += 1;
                    if (size <= upper) {
                        upper -= size;
                    }
                    else {
                        break;
                    }
                }
                var newArity = upper === 0 ? x : x + 1;
                if (newArity > 1) {
                    var newNode = void 0;
                    if (x < oldPages.length) {
                        var newPages = new Array(newArity);
                        for (var i = 0; i < newArity; i += 1) {
                            newPages[i] = oldPages[i];
                        }
                        var newKnots = new Array(newArity - 1);
                        for (var i = 0; i < newKnots.length; i += 1) {
                            newKnots[i] = this._knots[i];
                        }
                        newNode = this.newNode(newPages, newKnots, void 0, newSize);
                    }
                    else {
                        newNode = this;
                    }
                    if (upper > 0) {
                        var oldPage = oldPages[x - 1];
                        var newPage = oldPage.take(upper, tree);
                        return newNode.replacedPage(x - 1, newPage, oldPage, tree);
                    }
                    else {
                        return newNode;
                    }
                }
                else if (upper > 0) {
                    return oldPages[0].take(upper, tree);
                }
                else {
                    return oldPages[0];
                }
            }
            else {
                return BTreePage.empty();
            }
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.balanced = function (tree) {
        if (this._pages.length > 1 && tree.pageShouldSplit(this)) {
            var x = this._knots.length >>> 1;
            return this.split(x);
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.split = function (x) {
        var newPages = new Array(2);
        var newLeftPage = this.splitLeft(x);
        var newRightPage = this.splitRight(x);
        newPages[0] = newLeftPage;
        newPages[1] = newRightPage;
        var newKnots = new Array(1);
        newKnots[0] = newRightPage.minKey();
        return this.newNode(newPages, newKnots, void 0, this._size);
    };
    BTreeNode.prototype.splitLeft = function (x) {
        var oldPages = this._pages;
        var newPages = new Array(x + 1);
        for (var i = 0; i < x + 1; i += 1) {
            newPages[i] = oldPages[i];
        }
        var oldKnots = this._knots;
        var newKnots = new Array(x);
        for (var i = 0; i < x; i += 1) {
            newKnots[i] = oldKnots[i];
        }
        var newSize = 0;
        for (var i = 0; i <= x; i += 1) {
            newSize += newPages[i].size;
        }
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.splitRight = function (x) {
        var oldPages = this._pages;
        var newArity = oldPages.length - (x + 1);
        var newPages = new Array(newArity);
        for (var i = 0; i < newArity; i += 1) {
            newPages[i] = oldPages[i + (x + 1)];
        }
        var oldKnots = this._knots;
        var newKnots = new Array(newArity - 1);
        for (var i = 0; i < newKnots.length; i += 1) {
            newKnots[i] = oldKnots[i + (x + 1)];
        }
        var newSize = 0;
        for (var i = 0; i < newArity; i += 1) {
            newSize += newPages[i].size;
        }
        return this.newNode(newPages, newKnots, void 0, newSize);
    };
    BTreeNode.prototype.reduced = function (identity, accumulator, combiner) {
        if (this._fold === void 0) {
            var oldPages = this._pages;
            var n = oldPages.length;
            var newPages = new Array(n);
            for (var i = 0; i < n; i += 1) {
                newPages[i] = oldPages[i].reduced(identity, accumulator, combiner);
            }
            var fold = newPages[0].fold();
            for (var i = 1; i < n; i += 1) {
                fold = combiner(fold, newPages[i].fold());
            }
            return this.newNode(newPages, this._knots, fold, this._size);
        }
        else {
            return this;
        }
    };
    BTreeNode.prototype.forEach = function (callback, thisArg, tree) {
        var pages = this._pages;
        for (var i = 0, n = pages.length; i < n; i += 1) {
            var result = pages[i].forEach(callback, thisArg, tree);
            if (result !== void 0) {
                return result;
            }
        }
        return void 0;
    };
    BTreeNode.prototype.entries = function () {
        return new BTree.NodeCursor(this._pages);
    };
    BTreeNode.prototype.reverseEntries = function () {
        return new BTree.NodeCursor(this._pages, this._size, this._pages.length);
    };
    BTreeNode.prototype.lookup = function (key, tree) {
        var lo = 0;
        var hi = this._knots.length - 1;
        while (lo <= hi) {
            var mid = (lo + hi) >>> 1;
            var order = tree.compare(key, this._knots[mid]);
            if (order > 0) {
                lo = mid + 1;
            }
            else if (order < 0) {
                hi = mid - 1;
            }
            else {
                return mid;
            }
        }
        return -(lo + 1);
    };
    BTreeNode.prototype.newNode = function (pages, knots, fold, size) {
        return new BTreeNode(pages, knots, fold, size);
    };
    return BTreeNode;
}(BTreePage));
export { BTreeNode };
BTree.Node = BTreeNode;
//# sourceMappingURL=BTreeNode.js.map