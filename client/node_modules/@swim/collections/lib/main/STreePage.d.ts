import { Cursor } from "@swim/util";
import { STreeContext } from "./STreeContext";
import { STree } from "./STree";
import { STreeLeaf } from "./STreeLeaf";
export declare abstract class STreePage<V = unknown, I = unknown> {
    abstract get arity(): number;
    abstract get size(): number;
    abstract isEmpty(): boolean;
    abstract get(index: number): V | undefined;
    abstract getEntry(index: number): [I, V] | undefined;
    abstract updated(index: number, newValue: V, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract removed(index: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract drop(lower: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract take(upper: number, tree: STreeContext<V, I>): STreePage<V, I>;
    abstract balanced(tree: STreeContext<V, I>): STreePage<V, I>;
    abstract split(index: number): STreePage<V, I>;
    abstract splitLeft(index: number): STreePage<V, I>;
    abstract splitRight(index: number): STreePage<V, I>;
    abstract forEach<T, S>(callback: (this: S, value: V, index: number, tree: STree<V, I>, id: I) => T | void, thisArg: S, offset: number, tree: STree<V, I>): T | undefined;
    keys(): Cursor<I>;
    values(): Cursor<V>;
    abstract entries(): Cursor<[I, V]>;
    reverseKeys(): Cursor<I>;
    reverseValues(): Cursor<V>;
    abstract reverseEntries(): Cursor<[I, V]>;
    private static _empty;
    static empty<V, I>(): STreeLeaf<V, I>;
}
//# sourceMappingURL=STreePage.d.ts.map