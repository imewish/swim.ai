import { Cursor } from "@swim/util";
import { STreeContext } from "./STreeContext";
import { STree } from "./STree";
import { STreePage } from "./STreePage";
import { STreeNode } from "./STreeNode";
export declare class STreeLeaf<V, I> extends STreePage<V, I> {
    readonly _slots: [I, V][];
    constructor(slots: [I, V][]);
    get arity(): number;
    get size(): number;
    isEmpty(): boolean;
    get(index: number): V | undefined;
    getEntry(index: number): [I, V] | undefined;
    updated(index: number, newValue: V, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    private updatedItem;
    inserted(index: number, newValue: V, id: I | undefined, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    private insertedItem;
    removed(index: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    private removedSlot;
    drop(lower: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    take(upper: number, tree: STreeContext<V, I>): STreeLeaf<V, I>;
    balanced(tree: STreeContext<V, I>): STreePage<V, I>;
    split(index: number): STreeNode<V, I>;
    splitLeft(index: number): STreeLeaf<V, I>;
    splitRight(index: number): STreeLeaf<V, I>;
    forEach<T, S>(callback: (this: S, value: V, index: number, tree: STree<V, I>, id: I) => T | void, thisArg: S, offset: number, tree: STree<V, I>): T | undefined;
    entries(): Cursor<[I, V]>;
    reverseEntries(): Cursor<[I, V]>;
}
//# sourceMappingURL=STreeLeaf.d.ts.map