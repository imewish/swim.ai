(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = global || self, factory(global.swim = global.swim || {}));
}(this, (function (exports) { 'use strict';

    function codePointAt(index) {
        var size = this.length;
        index = index ? Number(index) : 0;
        if (index !== index) {
            index = 0;
        }
        if (index >= 0 && index < size) {
            var c1 = this.charCodeAt(index);
            if (c1 <= 0xd7ff || c1 >= 0xe000) {
                return c1;
            }
            else if (c1 <= 0xdbff && index + 1 < size) {
                var c2 = this.charCodeAt(index + 1);
                if (c2 >= 0xdc00 && c2 <= 0xdfff) {
                    return ((c1 & 0x03ff) << 10 + c2 & 0x03ff) + 0x10000;
                }
            }
        }
        return void 0;
    }
    function offsetByCodePoints(index, count) {
        if (count > 0) {
            var size = this.length;
            while (count > 0 && index < size) {
                var c1 = this.charCodeAt(index);
                if (c1 <= 0xd7ff || c1 >= 0xe000) {
                    index += 1;
                }
                else if (c1 <= 0xdbff && index + 1 < size) {
                    var c2 = this.charCodeAt(index + 1);
                    if (c2 >= 0xdc00 && c2 <= 0xdfff) {
                        index += 2;
                    }
                    else {
                        index += 1;
                    }
                }
                else {
                    index += 1;
                }
                count -= 1;
            }
        }
        else if (count < 0) {
            while (count < 0 && index > 0) {
                var c2 = this.charCodeAt(index - 1);
                if (c2 <= 0xd7ff || c2 >= 0xe000) {
                    index -= 1;
                }
                else if (c2 >= 0xdc00 && c2 <= 0xdfff && index - 1 > 0) {
                    var c1 = this.charCodeAt(index - 2);
                    if (c1 >= 0xd800 && c1 <= 0xdfff) {
                        index -= 2;
                    }
                    else {
                        index -= 1;
                    }
                }
                else {
                    index -= 1;
                }
                count -= 1;
            }
        }
        return index;
    }
    if (!String.prototype.codePointAt) {
        Object.defineProperty(String.prototype, "codePointAt", {
            value: codePointAt,
            configurable: true,
            writable: true,
        });
    }
    if (!String.prototype.offsetByCodePoints) {
        Object.defineProperty(String.prototype, "offsetByCodePoints", {
            value: offsetByCodePoints,
            configurable: true,
            writable: true,
        });
    }

    (function (ByteOrder) {
        ByteOrder["BigEndian"] = "BE";
        ByteOrder["LittleEndian"] = "LE";
    })(exports.ByteOrder || (exports.ByteOrder = {}));
    function nativeOrder() {
        var bom = new ArrayBuffer(2);
        new Uint16Array(bom)[0] = 0xfeff;
        var b = new Uint8Array(bom);
        if (b[0] === 0xfe && b[1] === 0xff) {
            return "BE";
        }
        else if (b[0] === 0xff && b[1] === 0xfe) {
            return "LE";
        }
        else {
            throw new Error();
        }
    }
    var NativeOrder = nativeOrder();

    var crypto = (typeof window !== "undefined" &&
        (window.crypto || window.msCrypto));
    function fillBytesCrypto(typedArray) {
        crypto.getRandomValues(typedArray);
    }
    function fillBytesMath(typedArray) {
        if (typedArray instanceof Int8Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 128 - Math.round(Math.random() * 256);
            }
        }
        else if (typedArray instanceof Uint8Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 256);
            }
        }
        else if (typedArray instanceof Int16Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 32768 - Math.round(Math.random() * 65536);
            }
        }
        else if (typedArray instanceof Uint16Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 65536);
            }
        }
        else if (typedArray instanceof Int32Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = 2147483648 - Math.round(Math.random() * 4294967296);
            }
        }
        else if (typedArray instanceof Uint32Array) {
            for (var i = 0; i < typedArray.length; i += 1) {
                typedArray[i] = Math.round(Math.random() * 4294967296);
            }
        }
        else {
            throw new TypeError("" + typedArray);
        }
    }
    var Random = (function () {
        function Random() {
        }
        Random.fillBytes = crypto ? fillBytesCrypto : fillBytesMath;
        return Random;
    }());

    var hashArrayBuffer = new ArrayBuffer(8);
    var hashFloat64Array = new Float64Array(hashArrayBuffer);
    var hashInt32Array = new Int32Array(hashArrayBuffer);
    function rotl(value, distance) {
        return (value << distance) | (value >>> (32 - distance));
    }
    var Murmur3 = (function () {
        function Murmur3() {
        }
        Murmur3.seed = function (value) {
            if (typeof value === "object" && value) {
                if (value.constructor && typeof value.constructor.name === "string") {
                    value = value.constructor.name;
                }
                else {
                    value = value.toString();
                }
            }
            return Murmur3.hash(value);
        };
        Murmur3.hash = function (value) {
            if (value instanceof Uint8Array || typeof value === "string") {
                return Murmur3.mash(Murmur3.mix(0, value));
            }
            else if (typeof value === "number") {
                if (~~value === value) {
                    return ~~value;
                }
                hashFloat64Array[0] = value;
                return hashInt32Array[0] ^ hashInt32Array[1];
            }
            else if (typeof value === "boolean") {
                return value ? 3 : 2;
            }
            else if (value === null) {
                return 1;
            }
            else if (value === undefined) {
                return 0;
            }
            else {
                throw new TypeError("" + value);
            }
        };
        Murmur3.mixUint8ArrayBE = function (code, array) {
            var offset = 0;
            var limit = array.length;
            while (offset + 3 < limit) {
                var word = (array[offset] & 0xff) << 24 | (array[offset + 1] & 0xff) << 16
                    | (array[offset + 2] & 0xff) << 8 | array[offset + 3] & 0xff;
                code = Murmur3.mix(code, word);
                offset += 4;
            }
            if (offset < limit) {
                var word = (array[offset] & 0xff) << 24;
                if (offset + 1 < limit) {
                    word |= (array[offset + 1] & 0xff) << 16;
                    if (offset + 2 < limit) {
                        word |= (array[offset + 2] & 0xff) << 8;
                    }
                }
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ limit;
        };
        Murmur3.mixUInt8ArrayLE = function (code, array) {
            var offset = 0;
            var limit = array.length;
            while (offset + 3 < limit) {
                var word = array[offset] & 0xff | (array[offset + 1] & 0xff) << 8
                    | (array[offset + 2] & 0xff) << 16 | (array[offset + 3] & 0xff) << 24;
                code = Murmur3.mix(code, word);
                offset += 4;
            }
            if (offset < limit) {
                var word = array[offset] & 0xff;
                if (offset + 1 < limit) {
                    word |= (array[offset + 1] & 0xff) << 8;
                    if (offset + 2 < limit) {
                        word |= (array[offset + 2] & 0xff) << 16;
                    }
                }
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ limit;
        };
        Murmur3.mixStringBE = function (code, string) {
            var word = 0;
            var k = 32;
            var i = 0;
            var n = string.length;
            var utf8Length = 0;
            while (i < n) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c >= 0 && c <= 0x7f) {
                    k -= 8;
                    word |= c << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 1;
                }
                else if (c >= 0x80 && c <= 0x7ff) {
                    k -= 8;
                    word |= (0xc0 | (c >>> 6)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 2;
                }
                else if (c >= 0x0800 && c <= 0xffff ||
                    c >= 0xe000 && c <= 0xffff) {
                    k -= 8;
                    word |= (0xe0 | (c >>> 12)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 3;
                }
                else if (c >= 0x10000 && c <= 0x10ffff) {
                    k -= 8;
                    word |= (0xf0 | (c >>> 18)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 12) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= (0x80 | (c & 0x3f)) << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 4;
                }
                else {
                    k -= 8;
                    word |= 0xef << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= 0xbf << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    k -= 8;
                    word |= 0xbd << k;
                    if (k === 0) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 32;
                    }
                    utf8Length += 3;
                }
                i = string.offsetByCodePoints(i, 1);
            }
            if (k !== 32) {
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ utf8Length;
        };
        Murmur3.mixStringLE = function (code, string) {
            var word = 0;
            var k = 0;
            var i = 0;
            var n = string.length;
            var utf8Length = 0;
            while (i < n) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c >= 0 && c <= 0x7f) {
                    word |= c << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 1;
                }
                else if (c >= 0x80 && c <= 0x7ff) {
                    word |= (0xc0 | (c >>> 6)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 2;
                }
                else if (c >= 0x0800 && c <= 0xffff ||
                    c >= 0xe000 && c <= 0xffff) {
                    word |= (0xe0 | (c >>> 12)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 3;
                }
                else if (c >= 0x10000 && c <= 0x10ffff) {
                    word |= (0xf0 | (c >>> 18)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 12) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | ((c >>> 6) & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= (0x80 | (c & 0x3f)) << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 4;
                }
                else {
                    word |= 0xef << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= 0xbf << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    word |= 0xbd << k;
                    k += 8;
                    if (k === 32) {
                        code = Murmur3.mix(code, word);
                        word = 0;
                        k = 0;
                    }
                    utf8Length += 3;
                }
                i = string.offsetByCodePoints(i, 1);
            }
            if (k !== 32) {
                word = ((word & 0xffff) * 0xcc9e2d51) + (((word >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                word = rotl(word, 15);
                word = ((word & 0xffff) * 0x1b873593) + (((word >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= word;
            }
            return code ^ utf8Length;
        };
        Murmur3.mix = function (code, value) {
            if (typeof value === "number") {
                value = ((value & 0xffff) * 0xcc9e2d51) + (((value >>> 16) * 0xcc9e2d51 & 0xffff) << 16) & 0xffffffff;
                value = rotl(value, 15);
                value = ((value & 0xffff) * 0x1b873593) + (((value >>> 16) * 0x1b873593 & 0xffff) << 16) & 0xffffffff;
                code ^= value;
                code = rotl(code, 13);
                code = ((code & 0xffff) * 5) + (((code >>> 16) * 5 & 0xffff) << 16) & 0xffffffff;
                code = ((code & 0xffff) + 0x6b64) + (((code >>> 16) + 0xe654 & 0xffff) << 16);
                return code;
            }
            else if (typeof value === "string") {
                if (NativeOrder === "BE") {
                    return Murmur3.mixStringBE(code, value);
                }
                else if (NativeOrder === "LE") {
                    return Murmur3.mixStringLE(code, value);
                }
            }
            else if (value instanceof Uint8Array) {
                if (NativeOrder === "BE") {
                    return Murmur3.mixUint8ArrayBE(code, value);
                }
                else if (NativeOrder === "LE") {
                    return Murmur3.mixUInt8ArrayLE(code, value);
                }
            }
            throw new TypeError("" + value);
        };
        Murmur3.mash = function (code) {
            code ^= code >>> 16;
            code = ((code & 0xffff) * 0x85ebca6b) + (((code >>> 16) * 0x85ebca6b & 0xffff) << 16) & 0xffffffff;
            code ^= code >>> 13;
            code = ((code & 0xffff) * 0xc2b2ae35) + (((code >>> 16) * 0xc2b2ae35 & 0xffff) << 16) & 0xffffffff;
            code ^= code >>> 16;
            return code >>> 0;
        };
        return Murmur3;
    }());

    var Objects = (function () {
        function Objects() {
        }
        Objects.compare = function (x, y) {
            if (x instanceof Date) {
                x = x.getTime();
            }
            if (y instanceof Date) {
                y = y.getTime();
            }
            if (x === void 0) {
                if (y === void 0) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else if (x === null) {
                if (y === void 0) {
                    return -1;
                }
                else if (y === null) {
                    return 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "number") {
                if (y === void 0 || y === null) {
                    return -1;
                }
                else if (typeof y === "number") {
                    return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "string") {
                if (y === void 0 || y === null || typeof y === "number") {
                    return -1;
                }
                else if (typeof y === "string") {
                    return x < y ? -1 : x > y ? 1 : 0;
                }
                else {
                    return 1;
                }
            }
            else if (typeof x === "object" && typeof x.compareTo === "function") {
                var order = x.compareTo(y);
                return order < 0 ? -1 : order > 0 ? 1 : 0;
            }
            else if (Array.isArray(x)) {
                if (y === void 0 || y === null || typeof y === "number" || typeof y === "string") {
                    return -1;
                }
                else if (Array.isArray(y)) {
                    return Objects.compareArray(x, y);
                }
                else {
                    return 1;
                }
            }
            else {
                if (y === void 0 || y === null || typeof y === "number" || typeof y === "string" || Array.isArray(y)) {
                    return -1;
                }
                else {
                    return Objects.compareObject(x, y);
                }
            }
        };
        Objects.compareArray = function (x, y) {
            var p = x.length;
            var q = y.length;
            var order = 0;
            for (var i = 0, n = Math.min(p, q); i < n && order === 0; i += 1) {
                order = Objects.compare(x[i], y[i]);
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
        };
        Objects.compareObject = function (x, y) {
            var xKeys = Object.keys(x);
            var yKeys = Object.keys(y);
            var p = xKeys.length;
            var q = yKeys.length;
            var n = Math.min(p, q);
            var order = 0;
            for (var i = 0; i < n && order === 0; i += 1) {
                var xKey = xKeys[i];
                var yKey = yKeys[i];
                order = Objects.compare(xKey, yKey);
                if (order === 0) {
                    order = Objects.compare(x[xKey], y[yKey]);
                }
            }
            return order !== 0 ? order : p > q ? 1 : p < q ? -1 : 0;
        };
        Objects.equal = function (x, y) {
            if (x instanceof Date) {
                x = x.getTime();
            }
            if (y instanceof Date) {
                y = y.getTime();
            }
            if (x === y) {
                return true;
            }
            else if (typeof x === "number") {
                if (typeof y === "number") {
                    return isNaN(x) && isNaN(y);
                }
            }
            else if (typeof x === "object" && x && typeof x.equals === "function") {
                return x.equals(y);
            }
            else if (Array.isArray(x)) {
                if (Array.isArray(y)) {
                    return Objects.equalArray(x, y);
                }
            }
            else if (typeof x === "object" && x) {
                if (typeof y === "object" && y) {
                    return Objects.equalObject(x, y);
                }
            }
            return false;
        };
        Objects.equalArray = function (x, y) {
            var n = x.length;
            if (n !== y.length) {
                return false;
            }
            for (var i = 0; i < n; i += 1) {
                if (!Objects.equal(x[i], y[i])) {
                    return false;
                }
            }
            return true;
        };
        Objects.equalObject = function (x, y) {
            var xKeys = Object.keys(x);
            var yKeys = Object.keys(y);
            var n = xKeys.length;
            if (n !== yKeys.length) {
                return false;
            }
            for (var i = 0; i < n; i += 1) {
                var key = xKeys[i];
                if (key !== yKeys[i] || !Objects.equal(x[key], y[key])) {
                    return false;
                }
            }
            return true;
        };
        Objects.hash = function (x) {
            if (x === void 0 || x === null || typeof x === "boolean"
                || typeof x === "number" || typeof x === "string") {
                return Murmur3.hash(x);
            }
            else if (typeof x === "object" && typeof x.hashCode === "function") {
                return x.hashCode();
            }
            else if (Array.isArray(x)) {
                return Objects.hashArray(x);
            }
            else if (typeof x === "object") {
                return Objects.hashObject(x);
            }
            else {
                throw new TypeError("" + x);
            }
        };
        Objects.hashArray = function (x) {
            var h = 0;
            var n = x.length;
            for (var i = 0; i < n; i += 1) {
                h = Murmur3.mix(h, Objects.hash(x[i]));
            }
            return Murmur3.mash(h);
        };
        Objects.hashObject = function (x) {
            var h = 0;
            var keys = Object.keys(x);
            var n = keys.length;
            for (var i = 0; i < n; i += 1) {
                var key = keys[i];
                h = Murmur3.mix(Murmur3.mix(h, Murmur3.hash(key)), x[key]);
            }
            return Murmur3.mash(h);
        };
        return Objects;
    }());

    var FromAny = {
        is: function (object) {
            if (typeof object === "object" && object || typeof object === "function") {
                return typeof object.fromAny === "function";
            }
            return false;
        },
    };
    var ToAny = {
        is: function (object) {
            if (typeof object === "object" && object) {
                return typeof object.toAny === "function";
            }
            return false;
        },
    };

    var Cursor = (function () {
        function Cursor() {
        }
        Cursor.prototype.set = function (newValue) {
            throw new Error("immutable");
        };
        Cursor.prototype.delete = function () {
            throw new Error("immutable");
        };
        Cursor.empty = function () {
            if (!Cursor._empty) {
                Cursor._empty = new Cursor.Empty();
            }
            return Cursor._empty;
        };
        Cursor.unary = function (value) {
            return new Cursor.Unary(value);
        };
        Cursor.array = function (array, index, limit) {
            if (index === void 0) { index = 0; }
            if (limit === void 0) { limit = array.length; }
            return new Cursor.Array(array, index, limit);
        };
        return Cursor;
    }());

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var CursorEmpty = (function (_super) {
        __extends(CursorEmpty, _super);
        function CursorEmpty() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        CursorEmpty.prototype.isEmpty = function () {
            return true;
        };
        CursorEmpty.prototype.head = function () {
            throw new Error("empty");
        };
        CursorEmpty.prototype.step = function () {
            throw new Error("empty");
        };
        CursorEmpty.prototype.skip = function (count) {
        };
        CursorEmpty.prototype.hasNext = function () {
            return false;
        };
        CursorEmpty.prototype.nextIndex = function () {
            return 0;
        };
        CursorEmpty.prototype.next = function () {
            return { done: true };
        };
        CursorEmpty.prototype.hasPrevious = function () {
            return false;
        };
        CursorEmpty.prototype.previousIndex = function () {
            return -1;
        };
        CursorEmpty.prototype.previous = function () {
            return { done: true };
        };
        return CursorEmpty;
    }(Cursor));
    Cursor.Empty = CursorEmpty;

    var CursorUnary = (function (_super) {
        __extends(CursorUnary, _super);
        function CursorUnary(value) {
            var _this = _super.call(this) || this;
            _this._value = value;
            _this._index = 0;
            return _this;
        }
        CursorUnary.prototype.isEmpty = function () {
            return this._index !== 0;
        };
        CursorUnary.prototype.head = function () {
            if (this._index === 0) {
                return this._value;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorUnary.prototype.step = function () {
            if (this._index === 0) {
                this._index = 1;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorUnary.prototype.skip = function (count) {
            this._index = Math.min(Math.max(0, this._index + count), 1);
        };
        CursorUnary.prototype.hasNext = function () {
            return this._index === 0;
        };
        CursorUnary.prototype.nextIndex = function () {
            return this._index;
        };
        CursorUnary.prototype.next = function () {
            if (this._index === 0) {
                this._index = 1;
                return { value: this._value, done: true };
            }
            else {
                return { done: true };
            }
        };
        CursorUnary.prototype.hasPrevious = function () {
            return this._index === 1;
        };
        CursorUnary.prototype.previousIndex = function () {
            return this._index - 1;
        };
        CursorUnary.prototype.previous = function () {
            if (this._index === 1) {
                this._index = 0;
                return { value: this._value, done: true };
            }
            else {
                return { done: true };
            }
        };
        return CursorUnary;
    }(Cursor));
    Cursor.Unary = CursorUnary;

    var CursorArray = (function (_super) {
        __extends(CursorArray, _super);
        function CursorArray(array, index, limit) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._index = index;
            _this._limit = limit;
            return _this;
        }
        CursorArray.prototype.isEmpty = function () {
            return this._index >= this._limit;
        };
        CursorArray.prototype.head = function () {
            if (this._index < this._limit) {
                return this._array[this._index];
            }
            else {
                throw new Error("empty");
            }
        };
        CursorArray.prototype.step = function () {
            if (this._index < this._limit) {
                this._index = 1;
            }
            else {
                throw new Error("empty");
            }
        };
        CursorArray.prototype.skip = function (count) {
            this._index = Math.min(this._index + count, this._limit);
        };
        CursorArray.prototype.hasNext = function () {
            return this._index < this._limit;
        };
        CursorArray.prototype.nextIndex = function () {
            return this._index;
        };
        CursorArray.prototype.next = function () {
            var index = this._index;
            if (index < this._limit) {
                this._index = index + 1;
                return { value: this._array[index], done: this._index === this._limit };
            }
            else {
                this._index = this._limit;
                return { done: true };
            }
        };
        CursorArray.prototype.hasPrevious = function () {
            return this._index > 0;
        };
        CursorArray.prototype.previousIndex = function () {
            return this._index - 1;
        };
        CursorArray.prototype.previous = function () {
            var index = this._index - 1;
            if (index >= 0) {
                this._index = index;
                return { value: this._array[index], done: index === 0 };
            }
            else {
                this._index = 0;
                return { done: true };
            }
        };
        return CursorArray;
    }(Cursor));
    Cursor.Array = CursorArray;

    var AssertException = (function (_super) {
        __extends(AssertException, _super);
        function AssertException(message) {
            var _this = _super.call(this, message) || this;
            _this.__proto__ = AssertException.prototype;
            return _this;
        }
        return AssertException;
    }(Error));

    var assert = function (condition, message) {
        if (!condition) {
            throw new AssertException(message);
        }
    };
    assert.ok = function (condition, message) {
        if (!condition) {
            throw new AssertException(message);
        }
    };
    assert.notOk = function (condition, message) {
        if (condition) {
            throw new AssertException(message);
        }
    };
    assert.equal = function (lhs, rhs, message) {
        if (!Objects.equal(lhs, rhs)) {
            throw new AssertException(message);
        }
    };
    assert.notEqual = function (lhs, rhs, message) {
        if (Objects.equal(lhs, rhs)) {
            throw new AssertException(message);
        }
    };
    assert.identity = function (lhs, rhs, message) {
        if (lhs !== rhs) {
            throw new AssertException(message);
        }
    };
    assert.notIdentity = function (lhs, rhs, message) {
        if (lhs === rhs) {
            throw new AssertException(message);
        }
    };
    assert.compareLessThan = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) < 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotLessThan = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) < 0) {
            throw new AssertException(message);
        }
    };
    assert.compareLessThanOrEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) <= 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotLessThanOrEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) <= 0) {
            throw new AssertException(message);
        }
    };
    assert.compareEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) === 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) === 0) {
            throw new AssertException(message);
        }
    };
    assert.compareGreaterThanOrEqual = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) >= 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotGreaterThanOrEqual = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) >= 0) {
            throw new AssertException(message);
        }
    };
    assert.compareGreaterThan = function (lhs, rhs, message) {
        if (!(Objects.compare(lhs, rhs) > 0)) {
            throw new AssertException(message);
        }
    };
    assert.compareNotGreaterThan = function (lhs, rhs, message) {
        if (Objects.compare(lhs, rhs) > 0) {
            throw new AssertException(message);
        }
    };

    var Severity = (function () {
        function Severity(level, label) {
            this._level = level;
            this._label = label;
        }
        Severity.prototype.level = function () {
            return this._level;
        };
        Severity.prototype.label = function (label) {
            if (label === void 0) {
                return this._label;
            }
            else {
                return Severity.create(this._level, label);
            }
        };
        Severity.prototype.isTrace = function () {
            return this._level === Severity.TRACE_LEVEL;
        };
        Severity.prototype.isDebug = function () {
            return this._level === Severity.DEBUG_LEVEL;
        };
        Severity.prototype.isInfo = function () {
            return this._level === Severity.INFO_LEVEL;
        };
        Severity.prototype.isNote = function () {
            return this._level === Severity.NOTE_LEVEL;
        };
        Severity.prototype.isWarning = function () {
            return this._level === Severity.WARNING_LEVEL;
        };
        Severity.prototype.isError = function () {
            return this._level === Severity.ERROR_LEVEL;
        };
        Severity.prototype.isAlert = function () {
            return this._level === Severity.ALERT_LEVEL;
        };
        Severity.prototype.isFatal = function () {
            return this._level === Severity.FATAL_LEVEL;
        };
        Severity.prototype.compareTo = function (that) {
            if (this === that) {
                return 0;
            }
            else if (this._level < that._level) {
                return -1;
            }
            else if (this._level > that._level) {
                return 1;
            }
            else {
                return this._label.localeCompare(that._label);
            }
        };
        Severity.prototype.equals = function (that) {
            if (this === that) {
                return true;
            }
            else if (that instanceof Severity) {
                return this._level === that._level && this._label === that._label;
            }
            return false;
        };
        Severity.prototype.hashCode = function () {
            if (Severity._hashSeed === void 0) {
                Severity._hashSeed = Murmur3.seed(Severity);
            }
            return Murmur3.mash(Murmur3.mix(Murmur3.mix(Severity._hashSeed, this._level), Murmur3.hash(this._label)));
        };
        Severity.prototype.toString = function () {
            return this._label;
        };
        Severity.create = function (level, label) {
            switch (level) {
                case Severity.TRACE_LEVEL: return Severity.trace(label);
                case Severity.DEBUG_LEVEL: return Severity.debug(label);
                case Severity.INFO_LEVEL: return Severity.info(label);
                case Severity.NOTE_LEVEL: return Severity.note(label);
                case Severity.WARNING_LEVEL: return Severity.warning(label);
                case Severity.ERROR_LEVEL: return Severity.error(label);
                case Severity.ALERT_LEVEL: return Severity.alert(label);
                case Severity.FATAL_LEVEL: return Severity.fatal(label);
                default: throw new Error("" + level);
            }
        };
        Severity.trace = function (label) {
            if (label === void 0) { label = "trace"; }
            if (label === "trace") {
                if (!Severity._trace) {
                    Severity._trace = new Severity(Severity.TRACE_LEVEL, label);
                }
                return Severity._trace;
            }
            else {
                return new Severity(Severity.TRACE_LEVEL, label);
            }
        };
        Severity.debug = function (label) {
            if (label === void 0) { label = "debug"; }
            if (label === "debug") {
                if (!Severity._debug) {
                    Severity._debug = new Severity(Severity.DEBUG_LEVEL, label);
                }
                return Severity._debug;
            }
            else {
                return new Severity(Severity.DEBUG_LEVEL, label);
            }
        };
        Severity.info = function (label) {
            if (label === void 0) { label = "info"; }
            if (label === "info") {
                if (!Severity._info) {
                    Severity._info = new Severity(Severity.INFO_LEVEL, label);
                }
                return Severity._info;
            }
            else {
                return new Severity(Severity.INFO_LEVEL, label);
            }
        };
        Severity.note = function (label) {
            if (label === void 0) { label = "note"; }
            if (label === "note") {
                if (!Severity._note) {
                    Severity._note = new Severity(Severity.NOTE_LEVEL, label);
                }
                return Severity._note;
            }
            else {
                return new Severity(Severity.NOTE_LEVEL, label);
            }
        };
        Severity.warning = function (label) {
            if (label === void 0) { label = "warning"; }
            if (label === "warning") {
                if (!Severity._warning) {
                    Severity._warning = new Severity(Severity.WARNING_LEVEL, label);
                }
                return Severity._warning;
            }
            else {
                return new Severity(Severity.WARNING_LEVEL, label);
            }
        };
        Severity.error = function (label) {
            if (label === void 0) { label = "error"; }
            if (label === "error") {
                if (!Severity._error) {
                    Severity._error = new Severity(Severity.ERROR_LEVEL, label);
                }
                return Severity._error;
            }
            else {
                return new Severity(Severity.ERROR_LEVEL, label);
            }
        };
        Severity.alert = function (label) {
            if (label === void 0) { label = "alert"; }
            if (label === "alert") {
                if (!Severity._alert) {
                    Severity._alert = new Severity(Severity.ALERT_LEVEL, label);
                }
                return Severity._alert;
            }
            else {
                return new Severity(Severity.ALERT_LEVEL, label);
            }
        };
        Severity.fatal = function (label) {
            if (label === void 0) { label = "fatal"; }
            if (label === "fatal") {
                if (!Severity._fatal) {
                    Severity._fatal = new Severity(Severity.FATAL_LEVEL, label);
                }
                return Severity._fatal;
            }
            else {
                return new Severity(Severity.FATAL_LEVEL, label);
            }
        };
        Severity.TRACE_LEVEL = 0;
        Severity.DEBUG_LEVEL = 1;
        Severity.INFO_LEVEL = 2;
        Severity.NOTE_LEVEL = 3;
        Severity.WARNING_LEVEL = 4;
        Severity.ERROR_LEVEL = 5;
        Severity.ALERT_LEVEL = 6;
        Severity.FATAL_LEVEL = 7;
        return Severity;
    }());

    var HashGenCacheMap = (function () {
        function HashGenCacheMap(size) {
            this._buckets = new Array(size);
            this._gen4Hits = 0;
            this._gen3Hits = 0;
            this._gen2Hits = 0;
            this._gen1Hits = 0;
            this._misses = 0;
        }
        HashGenCacheMap.prototype.get = function (key) {
            if (this._buckets.length === 0) {
                return void 0;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return void 0;
            }
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                if (gen4Val !== void 0) {
                    this._gen4Hits += 1;
                    bucket._gen4Weight++;
                    return gen4Val;
                }
                else {
                    bucket._gen4Key = void 0;
                }
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                if (gen3Val !== void 0) {
                    this._gen3Hits += 1;
                    if (bucket._gen3Weight++ > bucket._gen4Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen3Val;
                }
                else {
                    bucket._gen3Key = void 0;
                }
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                if (gen2Val !== void 0) {
                    this._gen2Hits += 1;
                    if (bucket._gen2Weight++ > bucket._gen3Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen2Val;
                }
                else {
                    bucket._gen2Key = void 0;
                }
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                if (gen1Val !== void 0) {
                    this._gen1Hits += 1;
                    if (bucket._gen1Weight++ > bucket._gen2Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight);
                    }
                    return gen1Val;
                }
                else {
                    bucket._gen1Key = void 0;
                }
            }
            this._misses += 1;
            return void 0;
        };
        HashGenCacheMap.prototype.put = function (key, value) {
            if (this._buckets.length === 0) {
                return value;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index] || new HashGenCacheMapBucket();
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                if (gen4Val !== void 0) {
                    this._gen4Hits += 1;
                    bucket._gen4Weight++;
                    return gen4Val;
                }
                else {
                    bucket._gen4Key = void 0;
                    gen4Key = void 0;
                }
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                if (gen3Val !== void 0) {
                    this._gen3Hits += 1;
                    if (bucket._gen3Weight++ > bucket._gen4Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen3Val;
                }
                else {
                    bucket._gen3Key = void 0;
                    gen3Key = void 0;
                }
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                if (gen2Val !== void 0) {
                    this._gen2Hits += 1;
                    if (bucket._gen2Weight++ > bucket._gen3Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight);
                    }
                    return gen2Val;
                }
                else {
                    bucket._gen2Key = void 0;
                    gen2Key = void 0;
                }
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                if (gen1Val !== void 0) {
                    this._gen1Hits += 1;
                    if (bucket._gen1Weight++ > bucket._gen2Weight) {
                        this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight);
                    }
                    return gen1Val;
                }
                else {
                    bucket._gen1Key = void 0;
                    gen1Key = void 0;
                }
            }
            this._misses += 1;
            if (gen4Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen3Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen2Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            else if (gen1Key === void 0) {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, key, value, 1);
            }
            else {
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight - 1, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight - 1, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, key, value, 1);
            }
            return value;
        };
        HashGenCacheMap.prototype.remove = function (key) {
            if (this._buckets.length === 0) {
                return void 0;
            }
            var index = Math.abs(Objects.hash(key)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return void 0;
            }
            var gen4Key = bucket._gen4Key;
            if (gen4Key !== void 0 && Objects.equal(key, gen4Key)) {
                var gen4Val = bucket._gen4Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen4Val;
            }
            var gen3Key = bucket._gen3Key;
            if (gen3Key !== void 0 && Objects.equal(key, gen3Key)) {
                var gen3Val = bucket._gen3Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen3Val;
            }
            var gen2Key = bucket._gen2Key;
            if (gen2Key !== void 0 && Objects.equal(key, gen2Key)) {
                var gen2Val = bucket._gen2Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Key, bucket._gen1Val, bucket._gen1Weight, void 0, void 0, 0);
                return gen2Val;
            }
            var gen1Key = bucket._gen1Key;
            if (gen1Key !== void 0 && Objects.equal(key, gen1Key)) {
                var gen1Val = bucket._gen1Val;
                this._buckets[index] = new HashGenCacheMapBucket(bucket._gen4Key, bucket._gen4Val, bucket._gen4Weight, bucket._gen3Key, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Key, bucket._gen2Val, bucket._gen2Weight, void 0, void 0, 0);
                return gen1Val;
            }
            return void 0;
        };
        HashGenCacheMap.prototype.clear = function () {
            for (var i = 0; i < this._buckets.length; i += 1) {
                this._buckets[i] = void 0;
            }
        };
        HashGenCacheMap.prototype.hits = function () {
            return this._gen4Hits + this._gen3Hits + this._gen2Hits + this._gen1Hits;
        };
        HashGenCacheMap.prototype.hitRatio = function () {
            var hits = this.hits();
            return hits / (hits + this._misses);
        };
        return HashGenCacheMap;
    }());
    var HashGenCacheMapBucket = (function () {
        function HashGenCacheMapBucket(gen4Key, gen4Val, gen4Weight, gen3Key, gen3Val, gen3Weight, gen2Key, gen2Val, gen2Weight, gen1Key, gen1Val, gen1Weight) {
            if (gen4Weight === void 0) { gen4Weight = 0; }
            if (gen3Weight === void 0) { gen3Weight = 0; }
            if (gen2Weight === void 0) { gen2Weight = 0; }
            if (gen1Weight === void 0) { gen1Weight = 0; }
            this._gen4Key = gen4Key;
            this._gen4Val = gen4Val;
            this._gen4Weight = gen4Weight;
            this._gen3Key = gen3Key;
            this._gen3Val = gen3Val;
            this._gen3Weight = gen3Weight;
            this._gen2Key = gen2Key;
            this._gen2Val = gen2Val;
            this._gen2Weight = gen2Weight;
            this._gen1Key = gen1Key;
            this._gen1Val = gen1Val;
            this._gen1Weight = gen1Weight;
        }
        return HashGenCacheMapBucket;
    }());

    var HashGenCacheSet = (function () {
        function HashGenCacheSet(size) {
            this._buckets = new Array(size);
            this._gen4Hits = 0;
            this._gen3Hits = 0;
            this._gen2Hits = 0;
            this._gen1Hits = 0;
            this._misses = 0;
        }
        HashGenCacheSet.prototype.put = function (value) {
            if (this._buckets.length === 0) {
                return value;
            }
            var index = Math.abs(Objects.hash(value)) % this._buckets.length;
            var bucket = this._buckets[index] || new HashGenCacheSetBucket();
            var gen4Val = bucket._gen4Val;
            if (gen4Val !== void 0 && Objects.equal(value, gen4Val)) {
                this._gen4Hits += 1;
                bucket._gen4Weight++;
                return gen4Val;
            }
            var gen3Val = bucket._gen3Val;
            if (gen3Val !== void 0 && Objects.equal(value, gen3Val)) {
                this._gen3Hits += 1;
                if (bucket._gen3Weight++ > bucket._gen4Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight);
                }
                return gen3Val;
            }
            var gen2Val = bucket._gen2Val;
            if (gen2Val !== void 0 && Objects.equal(value, gen2Val)) {
                this._gen2Hits += 1;
                if (bucket._gen2Weight++ > bucket._gen3Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight);
                }
                return gen2Val;
            }
            var gen1Val = bucket._gen1Val;
            if (gen1Val !== void 0 && Objects.equal(value, gen1Val)) {
                this._gen1Hits += 1;
                if (bucket._gen1Weight++ > bucket._gen2Weight) {
                    this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, bucket._gen2Val, bucket._gen2Weight);
                }
                return gen1Val;
            }
            this._misses += 1;
            if (gen4Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen3Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen2Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            else if (gen1Val === void 0) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, value, 1);
            }
            else {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight - 1, bucket._gen3Val, bucket._gen3Weight - 1, bucket._gen1Val, bucket._gen1Weight, value, 1);
            }
            return value;
        };
        HashGenCacheSet.prototype.remove = function (value) {
            if (this._buckets.length === 0) {
                return false;
            }
            var index = Math.abs(Objects.hash(value)) % this._buckets.length;
            var bucket = this._buckets[index];
            if (!bucket) {
                return false;
            }
            var gen4Val = bucket._gen4Val;
            if (gen4Val !== void 0 && Objects.equal(value, gen4Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen3Val = bucket._gen3Val;
            if (gen3Val !== void 0 && Objects.equal(value, gen3Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen2Val, bucket._gen2Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen2Val = bucket._gen2Val;
            if (gen2Val !== void 0 && Objects.equal(value, gen2Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen1Val, bucket._gen1Weight, void 0, 0);
                return true;
            }
            var gen1Val = bucket._gen1Val;
            if (gen1Val !== void 0 && Objects.equal(value, gen1Val)) {
                this._buckets[index] = new HashGenCacheSetBucket(bucket._gen4Val, bucket._gen4Weight, bucket._gen3Val, bucket._gen3Weight, bucket._gen2Val, bucket._gen2Weight, void 0, 0);
                return true;
            }
            return false;
        };
        HashGenCacheSet.prototype.clear = function () {
            for (var i = 0; i < this._buckets.length; i += 1) {
                this._buckets[i] = void 0;
            }
        };
        HashGenCacheSet.prototype.hits = function () {
            return this._gen4Hits + this._gen3Hits + this._gen2Hits + this._gen1Hits;
        };
        HashGenCacheSet.prototype.hitRatio = function () {
            var hits = this.hits();
            return hits / (hits + this._misses);
        };
        return HashGenCacheSet;
    }());
    var HashGenCacheSetBucket = (function () {
        function HashGenCacheSetBucket(gen4Val, gen4Weight, gen3Val, gen3Weight, gen2Val, gen2Weight, gen1Val, gen1Weight) {
            if (gen4Weight === void 0) { gen4Weight = 0; }
            if (gen3Weight === void 0) { gen3Weight = 0; }
            if (gen2Weight === void 0) { gen2Weight = 0; }
            if (gen1Weight === void 0) { gen1Weight = 0; }
            this._gen4Val = gen4Val;
            this._gen4Weight = gen4Weight;
            this._gen3Val = gen3Val;
            this._gen3Weight = gen3Weight;
            this._gen2Val = gen2Val;
            this._gen2Weight = gen2Weight;
            this._gen1Val = gen1Val;
            this._gen1Weight = gen1Weight;
        }
        return HashGenCacheSetBucket;
    }());

    exports.AssertException = AssertException;
    exports.Cursor = Cursor;
    exports.CursorArray = CursorArray;
    exports.CursorEmpty = CursorEmpty;
    exports.CursorUnary = CursorUnary;
    exports.FromAny = FromAny;
    exports.HashGenCacheMap = HashGenCacheMap;
    exports.HashGenCacheSet = HashGenCacheSet;
    exports.Murmur3 = Murmur3;
    exports.NativeOrder = NativeOrder;
    exports.Objects = Objects;
    exports.Random = Random;
    exports.Severity = Severity;
    exports.ToAny = ToAny;
    exports.assert = assert;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=swim-util.js.map