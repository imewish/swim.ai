import { __extends } from "tslib";
import { Murmur3 } from "@swim/util";
import { Uri } from "@swim/uri";
import { Attr, Value, Record } from "@swim/structure";
import { Envelope } from "./Envelope";
var LaneAddressed = (function (_super) {
    __extends(LaneAddressed, _super);
    function LaneAddressed(node, lane, body) {
        var _this = _super.call(this) || this;
        _this._node = node;
        _this._lane = lane;
        _this._body = body;
        return _this;
    }
    LaneAddressed.prototype.node = function (node) {
        if (node === void 0) {
            return this._node;
        }
        else {
            node = Uri.fromAny(node);
            return this.copy(node, this._lane, this._body);
        }
    };
    LaneAddressed.prototype.lane = function (lane) {
        if (lane === void 0) {
            return this._lane;
        }
        else {
            lane = Uri.fromAny(lane);
            return this.copy(this._node, lane, this._body);
        }
    };
    LaneAddressed.prototype.body = function (body) {
        if (body === void 0) {
            return this._body;
        }
        else {
            body = Value.fromAny(body);
            return this.copy(this._node, this._lane, body);
        }
    };
    LaneAddressed.prototype.toValue = function () {
        var header = Record.create(2)
            .slot("node", this._node.toString())
            .slot("lane", this._lane.toString());
        return Attr.of(this.tag(), header).concat(this._body);
    };
    LaneAddressed.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof LaneAddressed
            && this.__proto__.constructor === that.__proto__.constructor) {
            return this._node.equals(that._node) && this._lane.equals(that._lane)
                && this._body.equals(that._body);
        }
        return false;
    };
    LaneAddressed.prototype.hashCode = function () {
        return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(Murmur3.seed(this.__proto__), this._node.hashCode()), this._lane.hashCode()), this._body.hashCode()));
    };
    LaneAddressed.prototype.debug = function (output) {
        output = output.write(this.__proto__.constructor.name).write(46).write("of").write(40)
            .debug(this._node.toString()).write(", ").debug(this._lane.toString());
        if (this._body.isDefined()) {
            output = output.write(", ").debug(this._body);
        }
        output = output.write(41);
    };
    LaneAddressed.fromValue = function (value, E) {
        var node;
        var lane;
        var header = value.header(E.tag());
        header.forEach(function (header, index) {
            var key = header.key.stringValue(void 0);
            if (key !== void 0) {
                if (key === "node") {
                    node = Uri.parse(header.toValue().stringValue(""));
                }
                else if (key === "lane") {
                    lane = Uri.parse(header.toValue().stringValue(""));
                }
            }
            else if (header instanceof Value) {
                if (index === 0) {
                    node = Uri.parse(header.stringValue(""));
                }
                else if (index === 1) {
                    lane = Uri.parse(header.stringValue(""));
                }
            }
        });
        if (node && lane) {
            var body = value.body();
            return new E(node, lane, body);
        }
        return void 0;
    };
    return LaneAddressed;
}(Envelope));
export { LaneAddressed };
//# sourceMappingURL=LaneAddressed.js.map