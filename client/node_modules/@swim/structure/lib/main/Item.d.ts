import { Comparable, HashCode, Cursor } from "@swim/util";
import { Debug, Display, Output } from "@swim/codec";
import { Field } from "./Field";
import { Attr } from "./Attr";
import { Slot } from "./Slot";
import { AnyValue, Value } from "./Value";
import { Record } from "./Record";
import { RecordMap } from "./RecordMap";
import { RecordMapView } from "./RecordMapView";
import { Data } from "./Data";
import { AnyText, Text } from "./Text";
import { AnyNum, Num } from "./Num";
import { Bool } from "./Bool";
import { Expression } from "./Expression";
import { Selector } from "./Selector";
import { Operator } from "./Operator";
import { Func } from "./Func";
import { Extant } from "./Extant";
import { Absent } from "./Absent";
import { Form } from "./Form";
import { AnyInterpreter } from "./Interpreter";
import { BinaryOperator } from "./operator/BinaryOperator";
import { UnaryOperator } from "./operator/UnaryOperator";
import { ConditionalOperator } from "./operator/ConditionalOperator";
import { OrOperator } from "./operator/OrOperator";
import { AndOperator } from "./operator/AndOperator";
import { BitwiseOrOperator } from "./operator/BitwiseOrOperator";
import { BitwiseXorOperator } from "./operator/BitwiseXorOperator";
import { BitwiseAndOperator } from "./operator/BitwiseAndOperator";
import { LtOperator } from "./operator/LtOperator";
import { LeOperator } from "./operator/LeOperator";
import { EqOperator } from "./operator/EqOperator";
import { NeOperator } from "./operator/NeOperator";
import { GeOperator } from "./operator/GeOperator";
import { GtOperator } from "./operator/GtOperator";
import { PlusOperator } from "./operator/PlusOperator";
import { MinusOperator } from "./operator/MinusOperator";
import { TimesOperator } from "./operator/TimesOperator";
import { DivideOperator } from "./operator/DivideOperator";
import { ModuloOperator } from "./operator/ModuloOperator";
import { NotOperator } from "./operator/NotOperator";
import { BitwiseNotOperator } from "./operator/BitwiseNotOperator";
import { NegativeOperator } from "./operator/NegativeOperator";
import { PositiveOperator } from "./operator/PositiveOperator";
import { InvokeOperator } from "./operator/InvokeOperator";
import { IdentitySelector } from "./selector/IdentitySelector";
import { GetSelector } from "./selector/GetSelector";
import { GetAttrSelector } from "./selector/GetAttrSelector";
import { GetItemSelector } from "./selector/GetItemSelector";
import { KeysSelector } from "./selector/KeysSelector";
import { ValuesSelector } from "./selector/ValuesSelector";
import { ChildrenSelector } from "./selector/ChildrenSelector";
import { DescendantsSelector } from "./selector/DescendantsSelector";
import { FilterSelector } from "./selector/FilterSelector";
import { LiteralSelector } from "./selector/LiteralSelector";
import { LambdaFunc } from "./func/LambdaFunc";
import { BridgeFunc } from "./func/BridgeFunc";
import { MathModule } from "./func/MathModule";
export declare type AnyItem = Item | {
    readonly $key: AnyValue;
    readonly $value: AnyValue;
} | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<unknown> | Uint8Array | string | number | boolean | null | undefined;
export declare abstract class Item implements Comparable<Item>, HashCode, Debug, Display {
    constructor();
    abstract isDefined(): boolean;
    abstract isDistinct(): boolean;
    abstract isConstant(): boolean;
    abstract get key(): Value;
    abstract toValue(): Value;
    abstract tag(): string | undefined;
    abstract target(): Value;
    abstract flattened(): Value;
    abstract unflattened(): Record;
    abstract header(tag: string): Value;
    abstract headers(tag: string): Record | undefined;
    abstract head(): Item;
    abstract tail(): Record;
    abstract body(): Value;
    abstract get length(): number;
    abstract has(key: AnyValue): boolean;
    abstract get(key: AnyValue): Value;
    abstract getAttr(key: AnyText): Value;
    abstract getSlot(key: AnyValue): Value;
    abstract getField(key: AnyValue): Field | undefined;
    abstract getItem(index: AnyNum): Item;
    updated(key: AnyValue, value: AnyValue): Record;
    updatedAttr(key: AnyText, value: AnyValue): Record;
    updatedSlot(key: AnyValue, value: AnyValue): Record;
    appended(...items: AnyItem[]): Record;
    prepended(...items: AnyItem[]): Record;
    abstract deleted(key: AnyValue): Item;
    concat(...items: AnyItem[]): Record;
    abstract conditional(thenTerm: Item, elseTerm: Item): Item;
    abstract or(that: Item): Item;
    abstract and(that: Item): Item;
    abstract bitwiseOr(that: AnyItem): Item;
    abstract bitwiseXor(that: AnyItem): Item;
    abstract bitwiseAnd(that: AnyItem): Item;
    lt(that: AnyItem): Item;
    le(that: AnyItem): Item;
    eq(that: AnyItem): Item;
    ne(that: AnyItem): Item;
    ge(that: AnyItem): Item;
    gt(that: AnyItem): Item;
    abstract plus(that: AnyItem): Item;
    abstract minus(that: AnyItem): Item;
    abstract times(that: AnyItem): Item;
    abstract divide(that: AnyItem): Item;
    abstract modulo(that: AnyItem): Item;
    abstract not(): Item;
    abstract bitwiseNot(): Item;
    abstract negative(): Item;
    abstract positive(): Item;
    abstract inverse(): Item;
    invoke(args: Value): Item;
    abstract lambda(template: Value): Value;
    filter(predicate?: AnyItem): Selector;
    max(that: Item): Item;
    min(that: Item): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    substitute(interpreter: AnyInterpreter): Item;
    abstract stringValue(): string | undefined;
    abstract stringValue<T>(orElse: T): string | T;
    abstract numberValue(): number | undefined;
    abstract numberValue<T>(orElse: T): number | T;
    abstract booleanValue(): boolean | undefined;
    abstract booleanValue<T>(orElse: T): boolean | T;
    cast<T>(form: Form<T, unknown>): T | undefined;
    cast<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;
    coerce<T>(form: Form<T, unknown>): T;
    coerce<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;
    abstract toAny(): AnyItem;
    abstract isAliased(): boolean;
    abstract isMutable(): boolean;
    abstract alias(): void;
    abstract branch(): Item;
    abstract clone(): Item;
    abstract commit(): this;
    precedence(): number;
    forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void, thisArg?: S): T | undefined;
    iterator(): Cursor<Item>;
    abstract typeOrder(): number;
    abstract compareTo(that: Item): 0 | 1 | -1;
    abstract keyEquals(key: unknown): boolean;
    abstract equals(that: unknown): boolean;
    abstract hashCode(): number;
    abstract debug(output: Output): void;
    display(output: Output): void;
    toString(): string;
    static empty(): Item;
    static extant(): Item;
    static absent(): Item;
    static fromAny(item: AnyItem): Item;
    private static _globalScope?;
    static globalScope(): Item;
    static Field: typeof Field;
    static Attr: typeof Attr;
    static Slot: typeof Slot;
    static Value: typeof Value;
    static Record: typeof Record;
    static RecordMap: typeof RecordMap;
    static RecordMapView: typeof RecordMapView;
    static Data: typeof Data;
    static Text: typeof Text;
    static Num: typeof Num;
    static Bool: typeof Bool;
    static Expression: typeof Expression;
    static Selector: typeof Selector;
    static Operator: typeof Operator;
    static Func: typeof Func;
    static Extant: typeof Extant;
    static Absent: typeof Absent;
    static BinaryOperator: typeof BinaryOperator;
    static UnaryOperator: typeof UnaryOperator;
    static ConditionalOperator: typeof ConditionalOperator;
    static OrOperator: typeof OrOperator;
    static AndOperator: typeof AndOperator;
    static BitwiseOrOperator: typeof BitwiseOrOperator;
    static BitwiseXorOperator: typeof BitwiseXorOperator;
    static BitwiseAndOperator: typeof BitwiseAndOperator;
    static LtOperator: typeof LtOperator;
    static LeOperator: typeof LeOperator;
    static EqOperator: typeof EqOperator;
    static NeOperator: typeof NeOperator;
    static GeOperator: typeof GeOperator;
    static GtOperator: typeof GtOperator;
    static PlusOperator: typeof PlusOperator;
    static MinusOperator: typeof MinusOperator;
    static TimesOperator: typeof TimesOperator;
    static DivideOperator: typeof DivideOperator;
    static ModuloOperator: typeof ModuloOperator;
    static NotOperator: typeof NotOperator;
    static BitwiseNotOperator: typeof BitwiseNotOperator;
    static NegativeOperator: typeof NegativeOperator;
    static PositiveOperator: typeof PositiveOperator;
    static InvokeOperator: typeof InvokeOperator;
    static IdentitySelector: typeof IdentitySelector;
    static GetSelector: typeof GetSelector;
    static GetAttrSelector: typeof GetAttrSelector;
    static GetItemSelector: typeof GetItemSelector;
    static KeysSelector: typeof KeysSelector;
    static ValuesSelector: typeof ValuesSelector;
    static ChildrenSelector: typeof ChildrenSelector;
    static DescendantsSelector: typeof DescendantsSelector;
    static FilterSelector: typeof FilterSelector;
    static LiteralSelector: typeof LiteralSelector;
    static LambdaFunc: typeof LambdaFunc;
    static BridgeFunc: typeof BridgeFunc;
    static MathModule: typeof MathModule;
}
//# sourceMappingURL=Item.d.ts.map