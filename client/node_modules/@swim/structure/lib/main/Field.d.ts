import { AnyItem, Item } from "./Item";
import { AnyValue, Value } from "./Value";
import { Record } from "./Record";
import { AnyText } from "./Text";
import { AnyNum } from "./Num";
export declare type AnyField = Field | {
    readonly $key: AnyValue;
    readonly $value: AnyValue;
} | {
    [key: string]: AnyValue;
};
export declare abstract class Field extends Item {
    constructor();
    isDefined(): boolean;
    isDistinct(): boolean;
    abstract get key(): Value;
    abstract get value(): Value;
    abstract setValue(value: AnyValue): Value;
    abstract updatedValue(value: AnyValue): Field;
    toValue(): Value;
    tag(): string | undefined;
    target(): Value;
    flattened(): Value;
    unflattened(): Record;
    header(tag: string): Value;
    headers(tag: string): Record | undefined;
    head(): Item;
    tail(): Record;
    body(): Value;
    get length(): number;
    has(key: AnyValue): boolean;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    deleted(key: AnyValue): Field;
    conditional(thenTerm: Field, elseTerm: Field): Field;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: Field): Field;
    or(that: AnyItem): Item;
    and(that: Field): Field;
    and(that: AnyItem): Item;
    lambda(template: Value): Value;
    stringValue(): string | undefined;
    stringValue<T>(orElse: T): string | T;
    numberValue(): number | undefined;
    numberValue<T>(orElse: T): number | T;
    booleanValue(): boolean | undefined;
    booleanValue<T>(orElse: T): boolean | T;
    abstract toAny(): AnyField;
    abstract branch(): Field;
    abstract clone(): Field;
    abstract commit(): this;
    static readonly IMMUTABLE: number;
    static of(key: AnyValue, value?: AnyValue): Field;
    static fromAny(field: AnyField): Field;
}
//# sourceMappingURL=Field.d.ts.map