import { __extends } from "tslib";
import { Murmur3, Objects } from "@swim/util";
import { Item } from "./Item";
import { Field } from "./Field";
import { Interpreter } from "./Interpreter";
var Slot = (function (_super) {
    __extends(Slot, _super);
    function Slot(key, value, flags) {
        if (value === void 0) { value = Item.Value.extant(); }
        if (flags === void 0) { flags = 0; }
        var _this = _super.call(this) || this;
        _this._key = key.commit();
        _this._value = value;
        _this._flags = flags;
        return _this;
    }
    Object.defineProperty(Slot.prototype, "key", {
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Slot.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Slot.prototype.isConstant = function () {
        return this._key.isConstant() && this._value.isConstant();
    };
    Slot.prototype.setValue = function (newValue) {
        if ((this._flags & Field.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        var oldValue = this._value;
        this._value = newValue;
        return oldValue;
    };
    Slot.prototype.updatedValue = function (value) {
        return new Slot(this._key, value);
    };
    Slot.prototype.bitwiseOr = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseOrOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.bitwiseOr(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseOr(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.bitwiseXor = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseXorOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.bitwiseXor(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseXor(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.bitwiseAnd = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseAndOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.bitwiseAnd(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseAnd(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.plus = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.PlusOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.plus(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.plus(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.minus = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.MinusOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.minus(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.minus(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.times = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.TimesOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.times(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.times(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.divide = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.DivideOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.divide(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.divide(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.modulo = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.ModuloOperator(this, that);
        }
        var newValue;
        if (that instanceof Slot && this._key.equals(that._key)) {
            newValue = this._value.modulo(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.modulo(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.not = function () {
        var newValue = this._value.not();
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.bitwiseNot = function () {
        var newValue = this._value.bitwiseNot();
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.negative = function () {
        var newValue = this._value.negative();
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.positive = function () {
        var newValue = this._value.positive();
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.inverse = function () {
        var newValue = this._value.inverse();
        if (newValue.isDefined()) {
            return new Slot(this._key, newValue);
        }
        return Item.absent();
    };
    Slot.prototype.evaluate = function (interpreter) {
        interpreter = Interpreter.fromAny(interpreter);
        var key = this._key.evaluate(interpreter).toValue();
        var value = this._value.evaluate(interpreter).toValue();
        if (key === this._key && value === this._value) {
            return this;
        }
        else if (key.isDefined() && value.isDefined()) {
            return new Slot(key, value);
        }
        return Item.absent();
    };
    Slot.prototype.substitute = function (interpreter) {
        interpreter = Interpreter.fromAny(interpreter);
        var key = this._key.substitute(interpreter).toValue();
        var value = this._value.substitute(interpreter).toValue();
        if (key === this._key && value === this._value) {
            return this;
        }
        else if (key.isDefined() && value.isDefined()) {
            return new Slot(key, value);
        }
        return Item.absent();
    };
    Slot.prototype.toAny = function () {
        var field = {};
        if (this._key instanceof Item.Text) {
            field[this._key.value] = this._value.toAny();
        }
        else {
            field.$key = this._key.toAny();
            field.$value = this._value.toAny();
        }
        return field;
    };
    Slot.prototype.isAliased = function () {
        return false;
    };
    Slot.prototype.isMutable = function () {
        return (this._flags & Field.IMMUTABLE) === 0;
    };
    Slot.prototype.alias = function () {
        this._flags |= Field.IMMUTABLE;
    };
    Slot.prototype.branch = function () {
        if ((this._flags & Field.IMMUTABLE) !== 0) {
            return new Slot(this._key, this._value, this._flags & ~Field.IMMUTABLE);
        }
        else {
            return this;
        }
    };
    Slot.prototype.clone = function () {
        return new Slot(this._key.clone(), this._value.clone());
    };
    Slot.prototype.commit = function () {
        if ((this._flags & Field.IMMUTABLE) === 0) {
            this._flags |= Field.IMMUTABLE;
            this._value.commit();
        }
        return this;
    };
    Slot.prototype.typeOrder = function () {
        return 2;
    };
    Slot.prototype.compareTo = function (that) {
        if (that instanceof Slot) {
            var order = this._key.compareTo(that._key);
            if (order === 0) {
                order = this._value.compareTo(that._value);
            }
            return order;
        }
        return Objects.compare(this.typeOrder(), that.typeOrder());
    };
    Slot.prototype.keyEquals = function (key) {
        if (typeof key === "string" && this._key instanceof Item.Text) {
            return this._key.value === key;
        }
        else if (key instanceof Field) {
            return this._key.equals(key.key);
        }
        else {
            return this._key.equals(key);
        }
    };
    Slot.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof Slot) {
            return this._key.equals(that._key) && this._value.equals(that._value);
        }
        return false;
    };
    Slot.prototype.hashCode = function () {
        if (Slot._hashSeed === void 0) {
            Slot._hashSeed = Murmur3.seed(Slot);
        }
        return Murmur3.mash(Murmur3.mix(Murmur3.mix(Slot._hashSeed, this._key.hashCode()), this._value.hashCode()));
    };
    Slot.prototype.debug = function (output) {
        output = output.write("Slot").write(46).write("of").write(40).display(this.key);
        if (!(this.value instanceof Item.Extant)) {
            output = output.write(44).write(32).display(this.value);
        }
        output = output.write(41);
    };
    Slot.prototype.display = function (output) {
        this.debug(output);
    };
    Slot.of = function (key, value) {
        key = Item.Value.fromAny(key);
        value = arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant();
        return new Slot(key, value);
    };
    return Slot;
}(Field));
export { Slot };
Item.Slot = Slot;
//# sourceMappingURL=Slot.js.map