import { __extends } from "tslib";
import { Murmur3, Objects, Random } from "@swim/util";
import { OutputSettings, Writer, Unicode, Base16, Base64 } from "@swim/codec";
import { Item } from "./Item";
import { Value } from "./Value";
import { DataOutput } from "./DataOutput";
var Data = (function (_super) {
    __extends(Data, _super);
    function Data(array, size, flags) {
        var _this = _super.call(this) || this;
        _this._array = array;
        _this._size = size;
        _this._flags = flags;
        return _this;
    }
    Data.prototype.isConstant = function () {
        return true;
    };
    Object.defineProperty(Data.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Data.prototype.getByte = function (index) {
        if (index < 0 || index >= this.size) {
            throw new RangeError("" + index);
        }
        return this._array[index];
    };
    Data.prototype.setByte = function (index, value) {
        var flags = this._flags;
        if ((flags & Data.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        else if (index < 0 || index >= this._size) {
            throw new RangeError("" + index);
        }
        if ((flags & Data.ALIASED) !== 0) {
            return this.setByteAliased(index, value);
        }
        else {
            return this.setByteMutable(index, value);
        }
    };
    Data.prototype.setByteAliased = function (index, value) {
        var n = this.size;
        var oldArray = this._array;
        var newArray = new Uint8Array(Data.expand(n));
        newArray.set(oldArray, 0);
        newArray[index] = value;
        this._array = newArray;
        this._flags &= ~Data.ALIASED;
        return this;
    };
    Data.prototype.setByteMutable = function (index, value) {
        this._array[index] = value;
        return this;
    };
    Data.prototype.addByte = function (value) {
        var flags = this._flags;
        if ((flags & Data.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        if ((flags & Data.ALIASED) !== 0) {
            return this.addByteAliased(value);
        }
        else {
            return this.addByteMutable(value);
        }
    };
    Data.prototype.addByteAliased = function (value) {
        var n = this.size;
        var oldArray = this._array;
        var newArray = new Uint8Array(Data.expand(n + 1));
        if (oldArray != null) {
            newArray.set(oldArray, 0);
        }
        newArray[n] = value;
        this._array = newArray;
        this._size = n + 1;
        this._flags &= ~Data.ALIASED;
        return this;
    };
    Data.prototype.addByteMutable = function (value) {
        var n = this.size;
        var oldArray = this._array;
        var newArray;
        if (oldArray === null || n + 1 > oldArray.length) {
            newArray = new Uint8Array(Data.expand(n + 1));
            if (oldArray !== null) {
                newArray.set(oldArray, 0);
            }
            this._array = newArray;
        }
        else {
            newArray = oldArray;
        }
        newArray[n] = value;
        this._size = n + 1;
        return this;
    };
    Data.prototype.addData = function (data) {
        var array = data._array;
        if (array !== null) {
            var size = data._size;
            if (array.length > size) {
                array = array.slice(0, size);
            }
            return this.addUint8Array(array);
        }
        else {
            return this;
        }
    };
    Data.prototype.addUint8Array = function (array) {
        var flags = this._flags;
        if ((flags & Data.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        if ((flags & Data.ALIASED) !== 0) {
            return this.addUint8ArrayAliased(array);
        }
        else {
            return this.addUint8ArrayMutable(array);
        }
    };
    Data.prototype.addUint8ArrayAliased = function (array) {
        var size = array.length;
        if (size === 0) {
            return this;
        }
        var n = this.size;
        var oldArray = this._array;
        var newArray = new Uint8Array(Data.expand(n + size));
        if (oldArray !== null) {
            newArray.set(oldArray, 0);
        }
        newArray.set(array, n);
        this._array = newArray;
        this._size = n + size;
        this._flags &= ~Data.ALIASED;
        return this;
    };
    Data.prototype.addUint8ArrayMutable = function (array) {
        var size = array.length;
        if (size === 0) {
            return this;
        }
        var n = this.size;
        var oldArray = this._array;
        var newArray;
        if (oldArray === null || n + size > oldArray.length) {
            newArray = new Uint8Array(Data.expand(n + size));
            if (oldArray !== null) {
                newArray.set(oldArray, 0);
            }
            this._array = newArray;
        }
        else {
            newArray = oldArray;
        }
        newArray.set(array, n);
        this._size = n + size;
        return this;
    };
    Data.prototype.clear = function () {
        if ((this._flags & Data.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        this._array = null;
        this._size = 0;
        this._flags = Data.ALIASED;
    };
    Data.prototype.toUint8Array = function () {
        var oldArray = this._array;
        var flags = this._flags;
        if ((flags & Data.IMMUTABLE) !== 0) {
            return oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
        }
        else if ((flags & Data.ALIASED) !== 0 || this._size !== oldArray.length) {
            var newArray = oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);
            this._array = newArray;
            this._flags &= ~Data.ALIASED;
            return newArray;
        }
        else {
            return oldArray;
        }
    };
    Data.prototype.asUint8Array = function () {
        var array;
        if (this._array && this._size > 0) {
            array = this._array;
            if (array.length !== this._size) {
                array = new Uint8Array(array.buffer, array.byteOffset, this._size);
            }
        }
        else {
            array = void 0;
        }
        return array;
    };
    Data.prototype.toAny = function () {
        return this.toUint8Array();
    };
    Data.prototype.isAliased = function () {
        return (this._flags & Data.ALIASED) !== 0;
    };
    Data.prototype.isMutable = function () {
        return (this._flags & Data.IMMUTABLE) === 0;
    };
    Data.prototype.branch = function () {
        this._flags |= Data.ALIASED;
        return new Data(this._array, this._size, Data.ALIASED);
    };
    Data.prototype.clone = function () {
        return this.branch();
    };
    Data.prototype.commit = function () {
        this._flags |= Data.IMMUTABLE;
        return this;
    };
    Data.prototype.writeBase16 = function (output, base16) {
        if (base16 === void 0) { base16 = Base16.uppercase(); }
        var array = this._array;
        var size = this._size;
        if (array !== null && size !== 0) {
            if (array.length !== size) {
                array = array.slice(0, size);
            }
            return base16.writeUint8Array(array, output);
        }
        else {
            return Writer.done();
        }
    };
    Data.prototype.toBase16 = function (base16) {
        if (base16 === void 0) { base16 = Base16.uppercase(); }
        var output = Unicode.stringOutput();
        this.writeBase16(output, base16);
        return output.bind();
    };
    Data.prototype.writeBase64 = function (output, base64) {
        if (base64 === void 0) { base64 = Base64.standard(); }
        var array = this._array;
        var size = this._size;
        if (array !== null && size !== 0) {
            if (array.length !== size) {
                array = array.slice(0, size);
            }
            return base64.writeUint8Array(array, output);
        }
        else {
            return Writer.done();
        }
    };
    Data.prototype.toBase64 = function (base64) {
        if (base64 === void 0) { base64 = Base64.standard(); }
        var output = Unicode.stringOutput();
        this.writeBase64(output, base64);
        return output.bind();
    };
    Data.prototype.typeOrder = function () {
        return 4;
    };
    Data.prototype.compareTo = function (that) {
        if (that instanceof Data) {
            var xs = this._array;
            var ys = that._array;
            var xn = this._size;
            var yn = that._size;
            var order = 0;
            var i = 0;
            do {
                if (i < xn && i < yn) {
                    order = xs[i] - ys[i];
                    i += 1;
                }
                else {
                    break;
                }
            } while (order === 0);
            if (order > 0) {
                return 1;
            }
            else if (order < 0) {
                return -1;
            }
            else if (xn > yn) {
                return 1;
            }
            else if (xn < yn) {
                return -1;
            }
            else {
                return 0;
            }
        }
        return Objects.compare(this.typeOrder(), that.typeOrder());
    };
    Data.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof Data) {
            var xs = this._array;
            var ys = that._array;
            var xn = this._size;
            if (xn !== that._size) {
                return false;
            }
            for (var i = 0; i < xn; i += 1) {
                if (xs[i] !== ys[i]) {
                    return false;
                }
            }
            return true;
        }
        return false;
    };
    Data.prototype.hashCode = function () {
        if (Data._hashSeed === void 0) {
            Data._hashSeed = Murmur3.seed(Data);
        }
        return Murmur3.mash(Murmur3.mix(Data._hashSeed, this._array || new Uint8Array(0)));
    };
    Data.prototype.debug = function (output) {
        output = output.write("Data").write(46);
        if (this._size === 0) {
            output = output.write("empty").write(40).write(41);
        }
        else {
            output = output.write("base16").write(40).write(34);
            this.writeBase16(output);
            output = output.write(34).write(41);
        }
    };
    Data.prototype.display = function (output) {
        this.debug(output);
    };
    Data.output = function (data) {
        if (!(data instanceof Data)) {
            data = Data.create(data);
        }
        return new DataOutput(data, OutputSettings.standard());
    };
    Data.empty = function () {
        if (Data._empty == null) {
            Data._empty = new Data(null, 0, Data.ALIASED | Data.IMMUTABLE);
        }
        return Data._empty;
    };
    Data.create = function (initialCapacity) {
        if (initialCapacity === void 0) {
            return new Data(null, 0, Data.ALIASED);
        }
        else {
            return new Data(new Uint8Array(initialCapacity), 0, 0);
        }
    };
    Data.wrap = function (value) {
        return new Data(value, value.length, Data.ALIASED);
    };
    Data.fromBase16 = function (input) {
        if (typeof input === "string") {
            input = Unicode.stringInput(input);
        }
        return Base16.parse(input, Data.output()).bind();
    };
    Data.fromBase64 = function (input, base64) {
        if (base64 === void 0) { base64 = Base64.standard(); }
        if (typeof input === "string") {
            input = Unicode.stringInput(input);
        }
        return base64.parse(input, Data.output()).bind();
    };
    Data.fromAny = function (value) {
        if (value instanceof Data) {
            return value;
        }
        else if (value instanceof Uint8Array) {
            return Data.wrap(value);
        }
        else {
            throw new TypeError("" + value);
        }
    };
    Data.random = function (size) {
        var array = new Uint8Array(size);
        Random.fillBytes(array);
        return Data.wrap(array);
    };
    Data.expand = function (n) {
        n = Math.max(32, n) - 1;
        n |= n >> 1;
        n |= n >> 2;
        n |= n >> 4;
        n |= n >> 8;
        n |= n >> 16;
        return n + 1;
    };
    Data.ALIASED = 1 << 0;
    Data.IMMUTABLE = 1 << 1;
    return Data;
}(Value));
export { Data };
Item.Data = Data;
//# sourceMappingURL=Data.js.map