import { Cursor, Builder } from "@swim/util";
import { Output } from "@swim/codec";
import { AnyItem, Item } from "./Item";
import { Field } from "./Field";
import { AnyValue, Value } from "./Value";
import { AnyText } from "./Text";
import { AnyNum } from "./Num";
import { AnyInterpreter } from "./Interpreter";
export declare type AnyRecord = Record | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<unknown>;
export declare abstract class Record extends Value implements Builder<Item, Record> {
    _hashCode?: number;
    constructor();
    abstract isEmpty(): boolean;
    isArray(): boolean;
    isObject(): boolean;
    abstract get length(): number;
    fieldCount(): number;
    valueCount(): number;
    isConstant(): boolean;
    tag(): string | undefined;
    target(): Value;
    flattened(): Value;
    unflattened(): Record;
    header(tag: string): Value;
    headers(tag: string): Record | undefined;
    head(): Item;
    tail(): Record;
    body(): Value;
    has(key: AnyValue): boolean;
    indexOf(item: AnyItem, index?: number): number;
    lastIndexOf(item: AnyItem, index?: number): number;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    abstract getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    abstract setItem(index: number, item: AnyItem): this;
    updated(key: AnyValue, value: AnyValue): Record;
    updatedAttr(key: AnyText, value: AnyValue): Record;
    updatedSlot(key: AnyValue, value: AnyValue): Record;
    abstract push(...items: AnyItem[]): number;
    abstract splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    abstract delete(key: AnyValue): Item;
    abstract clear(): void;
    appended(...items: AnyItem[]): Record;
    prepended(...items: AnyItem[]): Record;
    deleted(key: AnyValue): Record;
    concat(...items: AnyItem[]): Record;
    slice(lower?: number, upper?: number): Record;
    attr(key: AnyText, value?: AnyValue): this;
    slot(key: AnyValue, value?: AnyValue): this;
    item(item: AnyItem): this;
    items(...items: AnyItem[]): this;
    evaluate(interpreter: AnyInterpreter): Record;
    substitute(interpreter: AnyInterpreter): Record;
    stringValue(): string | undefined;
    stringValue<T>(orElse: T): string | T;
    toAny(): AnyValue;
    toArray(): AnyItem[];
    toObject(): {
        [key: string]: AnyValue;
    };
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Record;
    clone(): Record;
    commit(): this;
    bind(): Record;
    subRecord(lower?: number, upper?: number): Record;
    abstract forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void, thisArg?: S): T | undefined;
    iterator(): Cursor<Item>;
    typeOrder(): number;
    compareTo(that: Item): 0 | 1 | -1;
    equals(that: unknown): boolean;
    hashCode(): number;
    debug(output: Output): void;
    display(output: Output): void;
    static readonly ALIASED: number;
    static readonly IMMUTABLE: number;
    private static _hashSeed?;
    static empty(): Record;
    static create(initialCapacity?: number): Record;
    static of(...items: AnyItem[]): Record;
    static fromAny(value: AnyRecord): Record;
    static fromArray(array: {
        [index: number]: AnyItem;
        length?: number;
    }): Record;
    static fromObject(object: {
        [key: string]: AnyValue;
    }): Record;
    static expand(n: number): number;
}
//# sourceMappingURL=Record.d.ts.map