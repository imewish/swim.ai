import { Builder } from "@swim/util";
import { AnyItem, Item } from "./Item";
import { Field } from "./Field";
import { Record } from "./Record";
import { AnyText } from "./Text";
import { AnyNum } from "./Num";
export declare type AnyValue = Value | {
    readonly [key: string]: AnyValue;
} | ReadonlyArray<unknown> | Uint8Array | string | number | boolean | null | undefined;
export declare abstract class Value extends Item {
    constructor();
    isDefined(): boolean;
    isDistinct(): boolean;
    get key(): Value;
    toValue(): Value;
    tag(): string | undefined;
    target(): Value;
    flattened(): Value;
    unflattened(): Record;
    header(tag: string): Value;
    headers(tag: string): Record | undefined;
    head(): Item;
    tail(): Record;
    body(): Value;
    get length(): number;
    has(key: AnyValue): boolean;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    deleted(key: AnyValue): Value;
    conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;
    conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;
    or(that: AnyValue): Value;
    or(that: AnyItem): Item;
    and(that: AnyValue): Value;
    and(that: AnyItem): Item;
    bitwiseOr(that: AnyValue): Value;
    bitwiseOr(that: AnyItem): Item;
    bitwiseXor(that: AnyValue): Value;
    bitwiseXor(that: AnyItem): Item;
    bitwiseAnd(that: AnyValue): Value;
    bitwiseAnd(that: AnyItem): Item;
    lt(that: AnyValue): Value;
    lt(that: AnyItem): Item;
    le(that: AnyValue): Value;
    le(that: AnyItem): Item;
    eq(that: AnyValue): Value;
    eq(that: AnyItem): Item;
    ne(that: AnyValue): Value;
    ne(that: AnyItem): Item;
    ge(that: AnyValue): Value;
    ge(that: AnyItem): Item;
    gt(that: AnyValue): Value;
    gt(that: AnyItem): Item;
    plus(that: AnyValue): Value;
    plus(that: AnyItem): Item;
    minus(that: AnyValue): Value;
    minus(that: AnyItem): Item;
    times(that: AnyValue): Value;
    times(that: AnyItem): Item;
    divide(that: AnyValue): Value;
    divide(that: AnyItem): Item;
    modulo(that: AnyValue): Value;
    modulo(that: AnyItem): Item;
    not(): Value;
    bitwiseNot(): Value;
    negative(): Value;
    positive(): Value;
    inverse(): Value;
    lambda(template: Value): Value;
    stringValue(): string | undefined;
    stringValue<T>(orElse: T): string | T;
    numberValue(): number | undefined;
    numberValue<T>(orElse: T): number | T;
    booleanValue(): boolean | undefined;
    booleanValue<T>(orElse: T): boolean | T;
    abstract toAny(): AnyValue;
    isAliased(): boolean;
    isMutable(): boolean;
    alias(): void;
    branch(): Value;
    clone(): Value;
    commit(): this;
    keyEquals(key: unknown): boolean;
    static builder(): Builder<Item, Value>;
    static empty(): Value;
    static extant(): Value;
    static absent(): Value;
    static fromAny(value: AnyValue): Value;
}
//# sourceMappingURL=Value.d.ts.map