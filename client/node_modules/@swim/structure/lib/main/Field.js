import { __extends } from "tslib";
import { Item } from "./Item";
var Field = (function (_super) {
    __extends(Field, _super);
    function Field() {
        return _super.call(this) || this;
    }
    Field.prototype.isDefined = function () {
        return true;
    };
    Field.prototype.isDistinct = function () {
        return true;
    };
    Field.prototype.toValue = function () {
        return this.value;
    };
    Field.prototype.tag = function () {
        return void 0;
    };
    Field.prototype.target = function () {
        return this.value;
    };
    Field.prototype.flattened = function () {
        return Item.Value.absent();
    };
    Field.prototype.unflattened = function () {
        return Item.Record.of(this);
    };
    Field.prototype.header = function (tag) {
        return Item.Value.absent();
    };
    Field.prototype.headers = function (tag) {
        return void 0;
    };
    Field.prototype.head = function () {
        return Item.absent();
    };
    Field.prototype.tail = function () {
        return Item.Record.empty();
    };
    Field.prototype.body = function () {
        return Item.Value.absent();
    };
    Object.defineProperty(Field.prototype, "length", {
        get: function () {
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Field.prototype.has = function (key) {
        return false;
    };
    Field.prototype.get = function (key) {
        return Item.Value.absent();
    };
    Field.prototype.getAttr = function (key) {
        return Item.Value.absent();
    };
    Field.prototype.getSlot = function (key) {
        return Item.Value.absent();
    };
    Field.prototype.getField = function (key) {
        return void 0;
    };
    Field.prototype.getItem = function (index) {
        return Item.absent();
    };
    Field.prototype.deleted = function (key) {
        return this;
    };
    Field.prototype.conditional = function (thenTerm, elseTerm) {
        thenTerm = Item.fromAny(thenTerm);
        return thenTerm;
    };
    Field.prototype.or = function (that) {
        return this;
    };
    Field.prototype.and = function (that) {
        that = Item.fromAny(that);
        return that;
    };
    Field.prototype.lambda = function (template) {
        return Item.Value.absent();
    };
    Field.prototype.stringValue = function (orElse) {
        return this.value.stringValue(orElse);
    };
    Field.prototype.numberValue = function (orElse) {
        return this.value.numberValue(orElse);
    };
    Field.prototype.booleanValue = function (orElse) {
        return this.value.booleanValue(orElse);
    };
    Field.of = function (key, value) {
        var name;
        if (typeof key === "string") {
            name = key;
        }
        else if (key instanceof Item.Text) {
            name = key.value;
        }
        if (name !== void 0 && name.charCodeAt(0) === 64) {
            arguments[0] = name.slice(1);
            return Item.Attr.of.apply(undefined, arguments);
        }
        else {
            return Item.Slot.of.apply(undefined, arguments);
        }
    };
    Field.fromAny = function (field) {
        if (field instanceof Field) {
            return field;
        }
        else if (field && typeof field === "object") {
            if (field.$key !== void 0) {
                return Field.of(field.$key, field.$value);
            }
            else {
                for (var key in field) {
                    return Field.of(key, field[key]);
                }
            }
        }
        throw new TypeError("" + field);
    };
    Field.IMMUTABLE = 1 << 0;
    return Field;
}(Item));
export { Field };
Item.Field = Field;
//# sourceMappingURL=Field.js.map