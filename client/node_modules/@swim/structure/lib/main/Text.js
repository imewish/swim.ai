import { __extends } from "tslib";
import { Murmur3, Objects, HashGenCacheSet } from "@swim/util";
import { OutputSettings, Format } from "@swim/codec";
import { Item } from "./Item";
import { Value } from "./Value";
import { TextOutput } from "./TextOutput";
var Text = (function (_super) {
    __extends(Text, _super);
    function Text(value) {
        var _this = _super.call(this) || this;
        _this._value = value;
        return _this;
    }
    Text.prototype.isConstant = function () {
        return true;
    };
    Object.defineProperty(Text.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Text.prototype, "size", {
        get: function () {
            return this._value.length;
        },
        enumerable: true,
        configurable: true
    });
    Text.prototype.stringValue = function (orElse) {
        return this._value;
    };
    Text.prototype.numberValue = function (orElse) {
        try {
            return Item.Num.from(this._value).numberValue();
        }
        catch (error) {
            return orElse;
        }
    };
    Text.prototype.booleanValue = function (orElse) {
        if (this._value === "true") {
            return true;
        }
        else if (this._value === "false") {
            return false;
        }
        else {
            return orElse;
        }
    };
    Text.prototype.toAny = function () {
        return this._value;
    };
    Text.prototype.valueOf = function () {
        return this._value;
    };
    Text.prototype.plus = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Text) {
            return Text.from(this._value + that._value);
        }
        return _super.prototype.plus.call(this, that);
    };
    Text.prototype.branch = function () {
        return this;
    };
    Text.prototype.clone = function () {
        return this;
    };
    Text.prototype.commit = function () {
        return this;
    };
    Text.prototype.typeOrder = function () {
        return 5;
    };
    Text.prototype.compareTo = function (that) {
        if (that instanceof Text) {
            var order = this._value.localeCompare(that._value);
            return order < 0 ? -1 : order > 0 ? 1 : 0;
        }
        return Objects.compare(this.typeOrder(), that.typeOrder());
    };
    Text.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof Text) {
            return this._value === that._value;
        }
        return false;
    };
    Text.prototype.hashCode = function () {
        if (this._hashCode === void 0) {
            this._hashCode = Murmur3.hash(this._value);
        }
        return this._hashCode;
    };
    Text.prototype.debug = function (output) {
        output = output.write("Text").write(46);
        if (this._value.length === 0) {
            output = output.write("empty").write(40).write(41);
        }
        else {
            output = output.write("from").write(40).debug(this._value).write(41);
        }
    };
    Text.prototype.display = function (output) {
        Format.debug(this._value, output);
    };
    Text.prototype.toString = function () {
        return this._value;
    };
    Text.output = function (settings) {
        if (settings === void 0) { settings = OutputSettings.standard(); }
        return new TextOutput("", settings);
    };
    Text.empty = function () {
        if (!Text._empty) {
            Text._empty = new Text("");
        }
        return Text._empty;
    };
    Text.from = function (value) {
        var n = value.length;
        if (n === 0) {
            return Text.empty();
        }
        else {
            var text = new Text(value);
            if (n <= 64) {
                text = Text.cache().put(text);
            }
            return text;
        }
    };
    Text.fromAny = function (value) {
        if (value instanceof Text) {
            return value;
        }
        else if (typeof value === "string") {
            return Text.from(value);
        }
        else {
            throw new TypeError("" + value);
        }
    };
    Text.cache = function () {
        if (Text._cache == null) {
            var cacheSize = 128;
            Text._cache = new HashGenCacheSet(cacheSize);
        }
        return Text._cache;
    };
    return Text;
}(Value));
export { Text };
Item.Text = Text;
//# sourceMappingURL=Text.js.map