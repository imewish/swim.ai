import { __extends } from "tslib";
import { Murmur3, Objects } from "@swim/util";
import { Item } from "./Item";
import { Field } from "./Field";
import { Interpreter } from "./Interpreter";
var Attr = (function (_super) {
    __extends(Attr, _super);
    function Attr(key, value, flags) {
        if (value === void 0) { value = Item.Value.extant(); }
        if (flags === void 0) { flags = 0; }
        var _this = _super.call(this) || this;
        _this._key = key;
        _this._value = value;
        _this._flags = flags;
        return _this;
    }
    Attr.prototype.isConstant = function () {
        return this._key.isConstant() && this._value.isConstant();
    };
    Object.defineProperty(Attr.prototype, "name", {
        get: function () {
            return this._key.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attr.prototype, "key", {
        get: function () {
            return this._key;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Attr.prototype, "value", {
        get: function () {
            return this._value;
        },
        enumerable: true,
        configurable: true
    });
    Attr.prototype.setValue = function (newValue) {
        if ((this._flags & Field.IMMUTABLE) !== 0) {
            throw new Error("immutable");
        }
        var oldValue = this._value;
        this._value = newValue;
        return oldValue;
    };
    Attr.prototype.updatedValue = function (value) {
        return new Attr(this._key, value);
    };
    Attr.prototype.bitwiseOr = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseOrOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.bitwiseOr(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseOr(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.bitwiseXor = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseXorOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.bitwiseXor(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseXor(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.bitwiseAnd = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.BitwiseAndOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.bitwiseAnd(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.bitwiseAnd(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.plus = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.PlusOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.plus(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.plus(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.minus = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.MinusOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.minus(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.minus(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.times = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.TimesOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.times(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.times(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.divide = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.DivideOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.divide(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.divide(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.modulo = function (that) {
        that = Item.fromAny(that);
        if (that instanceof Item.Expression) {
            return new Item.ModuloOperator(this, that);
        }
        var newValue;
        if (that instanceof Attr && this._key.equals(that._key)) {
            newValue = this._value.modulo(that._value);
        }
        else if (that instanceof Item.Value) {
            newValue = this._value.modulo(that);
        }
        else {
            newValue = Item.Value.absent();
        }
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.not = function () {
        var newValue = this._value.not();
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.bitwiseNot = function () {
        var newValue = this._value.bitwiseNot();
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.negative = function () {
        var newValue = this._value.negative();
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.positive = function () {
        var newValue = this._value.positive();
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.inverse = function () {
        var newValue = this._value.inverse();
        if (newValue.isDefined()) {
            return new Attr(this._key, newValue);
        }
        return Item.absent();
    };
    Attr.prototype.evaluate = function (interpreter) {
        interpreter = Interpreter.fromAny(interpreter);
        var key = this._key.evaluate(interpreter).toValue();
        var value = this._value.evaluate(interpreter).toValue();
        if (key === this._key && value === this._value) {
            return this;
        }
        else if (key.isDefined() && value.isDefined()) {
            if (key instanceof Item.Text) {
                return new Attr(key, value);
            }
            else {
                return new Item.Slot(key, value);
            }
        }
        return Item.absent();
    };
    Attr.prototype.substitute = function (interpreter) {
        interpreter = Interpreter.fromAny(interpreter);
        var key = this._key.substitute(interpreter).toValue();
        var value = this._value.substitute(interpreter).toValue();
        if (key === this._key && value === this._value) {
            return this;
        }
        else if (key.isDefined() && value.isDefined()) {
            if (key instanceof Item.Text) {
                return new Attr(key, value);
            }
            else {
                return new Item.Slot(key, value);
            }
        }
        return Item.absent();
    };
    Attr.prototype.toAny = function () {
        var field = {};
        field["@" + this._key.value] = this._value.toAny();
        return field;
    };
    Attr.prototype.isAliased = function () {
        return false;
    };
    Attr.prototype.isMutable = function () {
        return (this._flags & Field.IMMUTABLE) === 0;
    };
    Attr.prototype.alias = function () {
        this._flags |= Field.IMMUTABLE;
    };
    Attr.prototype.branch = function () {
        if ((this._flags & Field.IMMUTABLE) !== 0) {
            return new Attr(this._key, this._value, this._flags & ~Field.IMMUTABLE);
        }
        else {
            return this;
        }
    };
    Attr.prototype.clone = function () {
        return new Attr(this._key.clone(), this._value.clone());
    };
    Attr.prototype.commit = function () {
        if ((this._flags & Field.IMMUTABLE) === 0) {
            this._flags |= Field.IMMUTABLE;
            this._value.commit();
        }
        return this;
    };
    Attr.prototype.typeOrder = function () {
        return 1;
    };
    Attr.prototype.compareTo = function (that) {
        if (that instanceof Attr) {
            var order = this._key.compareTo(that._key);
            if (order === 0) {
                order = this._value.compareTo(that._value);
            }
            return order;
        }
        return Objects.compare(this.typeOrder(), that.typeOrder());
    };
    Attr.prototype.keyEquals = function (key) {
        if (typeof key === "string") {
            return this._key.value === key;
        }
        else if (key instanceof Field) {
            return this._key.equals(key.key);
        }
        else {
            return this._key.equals(key);
        }
    };
    Attr.prototype.equals = function (that) {
        if (this === that) {
            return true;
        }
        else if (that instanceof Attr) {
            return this._key.equals(that._key) && this._value.equals(that._value);
        }
        return false;
    };
    Attr.prototype.hashCode = function () {
        if (Attr._hashSeed === void 0) {
            Attr._hashSeed = Murmur3.seed(Attr);
        }
        return Murmur3.mash(Murmur3.mix(Murmur3.mix(Attr._hashSeed, this._key.hashCode()), this._value.hashCode()));
    };
    Attr.prototype.debug = function (output) {
        output = output.write("Attr").write(46).write("of").write(40).display(this.key);
        if (!(this.value instanceof Item.Extant)) {
            output = output.write(44).write(32).display(this.value);
        }
        output = output.write(41);
    };
    Attr.prototype.display = function (output) {
        this.debug(output);
    };
    Attr.of = function (key, value) {
        key = Item.Text.fromAny(key);
        value = (arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant());
        return new Attr(key, value);
    };
    return Attr;
}(Field));
export { Attr };
Item.Attr = Attr;
//# sourceMappingURL=Attr.js.map