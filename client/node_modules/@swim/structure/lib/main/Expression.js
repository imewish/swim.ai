import { __extends } from "tslib";
import { Item } from "./Item";
import { Value } from "./Value";
var Expression = (function (_super) {
    __extends(Expression, _super);
    function Expression() {
        return _super.call(this) || this;
    }
    Expression.prototype.conditional = function (thenTerm, elseTerm) {
        thenTerm = Item.fromAny(thenTerm);
        elseTerm = Item.fromAny(elseTerm);
        return new Item.ConditionalOperator(this, thenTerm, elseTerm);
    };
    Expression.prototype.or = function (that) {
        that = Item.fromAny(that);
        return new Item.OrOperator(this, that);
    };
    Expression.prototype.and = function (that) {
        that = Item.fromAny(that);
        return new Item.AndOperator(this, that);
    };
    Expression.prototype.bitwiseOr = function (that) {
        that = Item.fromAny(that);
        return new Item.BitwiseOrOperator(this, that);
    };
    Expression.prototype.bitwiseXor = function (that) {
        that = Item.fromAny(that);
        return new Item.BitwiseXorOperator(this, that);
    };
    Expression.prototype.bitwiseAnd = function (that) {
        that = Item.fromAny(that);
        return new Item.BitwiseAndOperator(this, that);
    };
    Expression.prototype.lt = function (that) {
        that = Item.fromAny(that);
        return new Item.LtOperator(this, that);
    };
    Expression.prototype.le = function (that) {
        that = Item.fromAny(that);
        return new Item.LeOperator(this, that);
    };
    Expression.prototype.eq = function (that) {
        that = Item.fromAny(that);
        return new Item.EqOperator(this, that);
    };
    Expression.prototype.ne = function (that) {
        that = Item.fromAny(that);
        return new Item.NeOperator(this, that);
    };
    Expression.prototype.ge = function (that) {
        that = Item.fromAny(that);
        return new Item.GeOperator(this, that);
    };
    Expression.prototype.gt = function (that) {
        that = Item.fromAny(that);
        return new Item.GtOperator(this, that);
    };
    Expression.prototype.plus = function (that) {
        that = Item.fromAny(that);
        return new Item.PlusOperator(this, that);
    };
    Expression.prototype.minus = function (that) {
        that = Item.fromAny(that);
        return new Item.MinusOperator(this, that);
    };
    Expression.prototype.times = function (that) {
        that = Item.fromAny(that);
        return new Item.TimesOperator(this, that);
    };
    Expression.prototype.divide = function (that) {
        that = Item.fromAny(that);
        return new Item.DivideOperator(this, that);
    };
    Expression.prototype.modulo = function (that) {
        that = Item.fromAny(that);
        return new Item.ModuloOperator(this, that);
    };
    Expression.prototype.not = function () {
        return new Item.NotOperator(this);
    };
    Expression.prototype.bitwiseNot = function () {
        return new Item.BitwiseNotOperator(this);
    };
    Expression.prototype.negative = function () {
        return new Item.NegativeOperator(this);
    };
    Expression.prototype.positive = function () {
        return new Item.PositiveOperator(this);
    };
    Expression.prototype.inverse = function () {
        return new Item.DivideOperator(Item.Num.positiveOne(), this);
    };
    Expression.prototype.toAny = function () {
        return this;
    };
    return Expression;
}(Value));
export { Expression };
Item.Expression = Expression;
//# sourceMappingURL=Expression.js.map