import { Output } from "@swim/codec";
import { AnyInterpreter, Interpreter } from "./Interpreter";
import { AnyItem, Item } from "./Item";
import { AnyValue, Value } from "./Value";
import { AnyText } from "./Text";
import { AnyNum } from "./Num";
import { Expression } from "./Expression";
import { IdentitySelector } from "./selector/IdentitySelector";
import { Operator } from "./Operator";
export declare abstract class Selector extends Expression {
    constructor();
    isConstant(): boolean;
    abstract then(): Selector;
    abstract forSelected<T, S = unknown>(interpreter: Interpreter, callback: (this: S, interpreter: Interpreter) => T | undefined, thisArg?: S): T | undefined;
    abstract mapSelected<S = unknown>(interpreter: Interpreter, transform: (this: S, interpreter: Interpreter) => Item, thisArg?: S): Item;
    evaluate(interpreter: AnyInterpreter): Item;
    abstract substitute(interpreter: AnyInterpreter): Item;
    abstract andThen(then: Selector): Selector;
    get(key: AnyValue): Selector;
    getAttr(key: AnyText): Selector;
    getItem(index: AnyNum): Selector;
    keys(): Selector;
    values(): Selector;
    children(): Selector;
    descendants(): Selector;
    filter(predicate?: AnyItem): Selector;
    invoke(args: Value): Operator;
    precedence(): number;
    debug(output: Output): void;
    abstract debugThen(output: Output): void;
    abstract clone(): Selector;
    static _identity: IdentitySelector;
    private static _keys?;
    private static _values?;
    private static _children?;
    private static _descendants?;
    static identity(): Selector;
    static get(key: AnyValue): Selector;
    static getAttr(key: AnyText): Selector;
    static getItem(index: AnyNum): Selector;
    static keys(): Selector;
    static values(): Selector;
    static children(): Selector;
    static descendants(): Selector;
    static literal(item: AnyItem): Selector;
}
//# sourceMappingURL=Selector.d.ts.map