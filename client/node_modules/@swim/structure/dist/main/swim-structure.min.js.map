{"version":3,"sources":["../../main/Item.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/Field.ts","../../main/InterpreterException.ts","../../main/InterpreterSettings.ts","../../main/Interpreter.ts","../../main/Attr.ts","../../main/Slot.ts","../../main/ValueBuilder.ts","../../main/Value.ts","../../main/RecordCursor.ts","../../main/Record.ts","../../main/RecordMap.ts","../../main/RecordMapView.ts","../../main/DataOutput.ts","../../main/Data.ts","../../main/TextOutput.ts","../../main/Text.ts","../../main/Num.ts","../../main/Bool.ts","../../main/Expression.ts","../../main/Operator.ts","../../main/Selector.ts","../../main/Func.ts","../../main/Extant.ts","../../main/Absent.ts","../../main/FormException.ts","../../main/Form.ts","../../main/operator/BinaryOperator.ts","../../main/operator/UnaryOperator.ts","../../main/operator/ConditionalOperator.ts","../../main/operator/OrOperator.ts","../../main/operator/AndOperator.ts","../../main/operator/BitwiseOrOperator.ts","../../main/operator/BitwiseXorOperator.ts","../../main/operator/BitwiseAndOperator.ts","../../main/operator/LtOperator.ts","../../main/operator/LeOperator.ts","../../main/operator/EqOperator.ts","../../main/operator/NeOperator.ts","../../main/operator/GeOperator.ts","../../main/operator/GtOperator.ts","../../main/operator/PlusOperator.ts","../../main/operator/MinusOperator.ts","../../main/operator/TimesOperator.ts","../../main/operator/DivideOperator.ts","../../main/operator/ModuloOperator.ts","../../main/operator/NotOperator.ts","../../main/operator/BitwiseNotOperator.ts","../../main/operator/NegativeOperator.ts","../../main/operator/PositiveOperator.ts","../../main/operator/InvokeOperator.ts","../../main/selector/IdentitySelector.ts","../../main/selector/GetSelector.ts","../../main/selector/GetAttrSelector.ts","../../main/selector/GetItemSelector.ts","../../main/selector/KeysSelector.ts","../../main/selector/ValuesSelector.ts","../../main/selector/ChildrenSelector.ts","../../main/selector/DescendantsSelector.ts","../../main/selector/FilterSelector.ts","../../main/selector/LiteralSelector.ts","../../main/func/LambdaFunc.ts","../../main/func/BridgeFunc.ts","../../main/func/MathModule.ts","../../main/form/TagForm.ts","../../main/form/UnitForm.ts","../../main/form/StringForm.ts","../../main/form/NumberForm.ts","../../main/form/BooleanForm.ts","../../main/form/AnyForm.ts","../../main/form/ItemForm.ts","../../main/form/ValueForm.ts","../../main/collections/ValueCursor.ts","../../main/collections/ValueEntryCursor.ts"],"names":["Item","prototype","updated","key","value","record","Record","create","push","this","set","updatedAttr","setAttr","updatedSlot","setSlot","appended","items","_i","arguments","length","apply","prepended","concat","i","n","fromAny","forEach","item","lt","that","compareTo","Bool","from","absent","le","eq","equals","ne","ge","gt","invoke","args","filter","predicate","selector","Selector","literal","max","min","evaluate","interpreter","substitute","cast","form","orElse","object","coerce","unit","precedence","callback","thisArg","call","iterator","Cursor","unary","display","output","debug","toString","Format","empty","extant","Extant","Absent","Value","globalScope","_globalScope","slot","MathModule","scope","commit","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","constructor","__spreadArrays","s","il","r","k","a","j","jl","Field","_super","isDefined","isDistinct","toValue","tag","target","flattened","unflattened","of","header","headers","head","tail","body","defineProperty","has","get","getAttr","getSlot","getField","getItem","index","deleted","conditional","thenTerm","elseTerm","or","and","lambda","template","stringValue","numberValue","booleanValue","name","Text","charCodeAt","slice","Attr","undefined","Slot","field","$key","$value","TypeError","IMMUTABLE","InterpreterException","message","_this","Error","InterpreterSettings","maxScopeDepth","_maxScopeDepth","copy","canEqual","hashCode","_hashSeed","Murmur3","seed","mash","mix","write","standard","_standard","Interpreter","settings","scopeStack","scopeDepth","_settings","_scopeStack","_scopeDepth","peekScope","getScope","RangeError","pushScope","newScopeStack","oldScopeStack","expand","popScope","swapScope","newScope","oldScope","willOperate","operator","didOperate","result","willSelect","didSelect","willTransform","didTransform","objects","scopes","Math","flags","_key","_value","_flags","isConstant","setValue","newValue","oldValue","updatedValue","bitwiseOr","Expression","BitwiseOrOperator","bitwiseXor","BitwiseXorOperator","bitwiseAnd","BitwiseAndOperator","plus","PlusOperator","minus","MinusOperator","times","TimesOperator","divide","DivideOperator","modulo","ModuloOperator","not","bitwiseNot","negative","positive","inverse","toAny","isAliased","isMutable","alias","branch","clone","typeOrder","order","Objects","compare","keyEquals","ValueBuilder","_record","pushField","pushValue","bind","LtOperator","LeOperator","EqOperator","NeOperator","GeOperator","GtOperator","LambdaFunc","builder","Num","Uint8Array","Data","wrap","isArray","fromArray","fromObject","RecordCursor","lower","upper","_lower","_upper","_index","_direction","isEmpty","step","skip","count","hasNext","nextIndex","next","done","hasPrevious","previousIndex","previous","newItem","setItem","delete","splice","fieldCount","isObject","valueCount","member","modified","indexOf","lastIndexOf","subRecord","attr","changed","oldItem","recordString","itemString","toArray","toObject","array","xs","ys","_hashCode","code_1","RecordMap","initialCapacity","ALIASED","table","itemCount","_array","_table","_itemCount","_fieldCount","RecordMapView","hashTable","x","abs","setAliased","pushAliased","setMutable","updateMutable","pushMutable","oldArray","newArray","field_1","put","setAttrAliased","setAttrMutable","updateAttrMutable","field_2","setSlotAliased","setSlotMutable","updateSlotMutable","field_3","setItemAliased","setItemMutable","newItems","m","start","deleteCount","spliceAliased","spliceMutable","oldItems","deleteAliased","deleteMutable","clear","_empty","_a","_b","clearAliased","clearMutable","l","DataOutput","data","_data","isCont","isFull","isDone","isError","isPart","addByte","writeln","string","OutputSettings","Output","size","_size","getByte","setByte","setByteAliased","setByteMutable","addByteAliased","addByteMutable","addData","addUint8Array","addUint8ArrayAliased","addUint8ArrayMutable","toUint8Array","asUint8Array","buffer","byteOffset","writeBase16","base16","Base16","uppercase","writeUint8Array","Writer","toBase16","Unicode","stringOutput","writeBase64","base64","Base64","toBase64","xn","yn","fromBase16","input","stringInput","parse","fromBase64","random","Random","fillBytes","TextOutput","_string","token","String","fromCharCode","u","error","valueOf","localeCompare","hash","text","cache","_cache","HashGenCacheSet","isNaN","isInfinite","isFinite","isUint32","UINT32","isUint64","UINT64","ceil","floor","round","sqrt","pow","y","displayNumber","positiveZero","_positiveZero","negativeZero","_negativeZero","positiveOne","_positiveOne","negativeOne","_negativeOne","nan","_nan","NaN","uint32","uint64","Infinity","num","TYPE_MASK","True","False","ConditionalOperator","OrOperator","AndOperator","NotOperator","BitwiseNotOperator","NegativeOperator","PositiveOperator","Operator","selected","forSelected","andThen","GetSelector","identity","GetAttrSelector","GetItemSelector","keys","values","children","descendants","FilterSelector","InvokeOperator","debugThen","_identity","_keys","KeysSelector","_values","ValuesSelector","_children","ChildrenSelector","_descendants","DescendantsSelector","LiteralSelector","Func","_extant","cond","_absent","FormException","Form","TagForm","UnitForm","forString","_stringForm","StringForm","forNumber","_numberForm","NumberForm","forBoolean","_booleanForm","BooleanForm","forAny","_anyForm","AnyForm","forItem","_itemForm","ItemForm","forValue","_valueForm","ValueForm","BinaryOperator","operand1","operand2","_operand1","_operand2","UnaryOperator","operand","_operand","ifTerm","_ifTerm","_thenTerm","_elseTerm","argument1","argument2","func","_func","_args","state","_state","setState","IdentitySelector","then","mapSelected","transform","_then","accessor","oldField","child","oldKey","newKey","oldChild","newChild","_predicate","filterSelected","_item","bindings","_bindings","_template","arity","params","binding","arg","BridgeFunc","_max","MaxFunc","_min","MinFunc","_abs","AbsFunc","_ceil","CeilFunc","_floor","FloorFunc","_round","RoundFunc","_sqrt","SqrtFunc","_pow","PowFunc","rate","_rate","RateFunc","_random","RandomFunc","_scope","period","v0","t0","Date","now","dv","dt","t1","_tag","_form","mold","_unit","ValueCursor","cursor","_cursor","ValueEntryCursor","keyForm","valueForm","_keyForm","pair"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/structure/dist/main/swim-structure.min.js","sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Comparable, HashCode, Cursor} from \"@swim/util\";\nimport {Debug, Display, Format, Output} from \"@swim/codec\";\nimport {Field} from \"./Field\";\nimport {Attr} from \"./Attr\";\nimport {Slot} from \"./Slot\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {RecordMap} from \"./RecordMap\";\nimport {RecordMapView} from \"./RecordMapView\";\nimport {Data} from \"./Data\";\nimport {AnyText, Text} from \"./Text\";\nimport {AnyNum, Num} from \"./Num\";\nimport {Bool} from \"./Bool\";\nimport {Expression} from \"./Expression\";\nimport {Selector} from \"./Selector\";\nimport {Operator} from \"./Operator\";\nimport {Func} from \"./Func\";\nimport {Extant} from \"./Extant\";\nimport {Absent} from \"./Absent\";\nimport {Form} from \"./Form\";\nimport {AnyInterpreter} from \"./Interpreter\";\nimport {BinaryOperator} from \"./operator/BinaryOperator\";\nimport {UnaryOperator} from \"./operator/UnaryOperator\";\nimport {ConditionalOperator} from \"./operator/ConditionalOperator\";\nimport {OrOperator} from \"./operator/OrOperator\";\nimport {AndOperator} from \"./operator/AndOperator\";\nimport {BitwiseOrOperator} from \"./operator/BitwiseOrOperator\";\nimport {BitwiseXorOperator} from \"./operator/BitwiseXorOperator\";\nimport {BitwiseAndOperator} from \"./operator/BitwiseAndOperator\";\nimport {LtOperator} from \"./operator/LtOperator\";\nimport {LeOperator} from \"./operator/LeOperator\";\nimport {EqOperator} from \"./operator/EqOperator\";\nimport {NeOperator} from \"./operator/NeOperator\";\nimport {GeOperator} from \"./operator/GeOperator\";\nimport {GtOperator} from \"./operator/GtOperator\";\nimport {PlusOperator} from \"./operator/PlusOperator\";\nimport {MinusOperator} from \"./operator/MinusOperator\";\nimport {TimesOperator} from \"./operator/TimesOperator\";\nimport {DivideOperator} from \"./operator/DivideOperator\";\nimport {ModuloOperator} from \"./operator/ModuloOperator\";\nimport {NotOperator} from \"./operator/NotOperator\";\nimport {BitwiseNotOperator} from \"./operator/BitwiseNotOperator\";\nimport {NegativeOperator} from \"./operator/NegativeOperator\";\nimport {PositiveOperator} from \"./operator/PositiveOperator\";\nimport {InvokeOperator} from \"./operator/InvokeOperator\";\nimport {IdentitySelector} from \"./selector/IdentitySelector\";\nimport {GetSelector} from \"./selector/GetSelector\";\nimport {GetAttrSelector} from \"./selector/GetAttrSelector\";\nimport {GetItemSelector} from \"./selector/GetItemSelector\";\nimport {KeysSelector} from \"./selector/KeysSelector\";\nimport {ValuesSelector} from \"./selector/ValuesSelector\";\nimport {ChildrenSelector} from \"./selector/ChildrenSelector\";\nimport {DescendantsSelector} from \"./selector/DescendantsSelector\";\nimport {FilterSelector} from \"./selector/FilterSelector\";\nimport {LiteralSelector} from \"./selector/LiteralSelector\";\nimport {LambdaFunc} from \"./func/LambdaFunc\";\nimport {BridgeFunc} from \"./func/BridgeFunc\";\nimport {MathModule} from \"./func/MathModule\";\n\nexport type AnyItem = Item\n                    | {readonly $key: AnyValue, readonly $value: AnyValue}\n                    | {readonly [key: string]: AnyValue}\n                    | ReadonlyArray<unknown> // ReadonlyArray<AnyItem>\n                    | Uint8Array\n                    | string\n                    | number\n                    | boolean\n                    | null\n                    | undefined;\n\nexport abstract class Item implements Comparable<Item>, HashCode, Debug, Display {\n  /** @hidden */\n  constructor() {\n    // stub\n  }\n\n  /**\n   * Returns `true` if this `Item` is not [[Absent]].\n   */\n  abstract isDefined(): boolean;\n\n  /**\n   * Returns `true` if this `Item is neither [[Extant]] nor [[Absent]].\n   */\n  abstract isDistinct(): boolean;\n\n  /**\n   * Returns `true` if this `Item` always [[Item.evaluate evaluates]] to the\n   * same `Item`.\n   */\n  abstract isConstant(): boolean;\n\n  /**\n   * Returns the key component of this `Item`, if this `Item is a [[Field]];\n   * otherwise returns [[Absent]] if this `Item` is a `Value`.\n   */\n  abstract get key(): Value;\n\n  /**\n   * Returns the value component of this `Item`, if this `Item` is a [[Field]];\n   * otherwise returns `this` if this `Item is a `Value`.\n   */\n  abstract toValue(): Value;\n\n  /**\n   * Returns the `key` string of the first member of this `Item`, if this `Item`\n   * is a [[Record]], and its first member is an [[Attr]]; otherwise returns\n   * `undefined` if this `Item` is not a `Record`, or if this `Item` is a\n   * `Record` whose first member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure.  The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  abstract tag(): string | undefined;\n\n  /**\n   * Returns the [[Item.flattened flattened]] members of this `Item` after all\n   * attributes have been removed, if this `Item` is a [[Record]]; otherwise\n   * returns `this` if this `Item` is a non-`Record` `Value`, or returns\n   * the value component if this `Item` is a `Field`.\n   *\n   * Used to concisely get the scalar value of an attributed structure.  An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  abstract target(): Value;\n\n  /**\n   * Returns the sole member of this `Item`, if this `Item` is a [[Record]]\n   * with exactly one member, and its member is a `Value`; returns [[Extant]]\n   * if this `Item` is an empty `Record`; returns [[Absent]] if this `Item` is\n   * a `Field`; otherwise returns `this` if this `Item` is a `Record` with more\n   * than one member, or if this `Item` is a non-`Record` `Value`.\n   *\n   * Used to convert a unary `Record` into its member `Value`.  Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  abstract flattened(): Value;\n\n  /**\n   * Returns `this` if this `Item` is a [[Record]]; returns a `Record`\n   * containing just this `Item`, if this `Item` is [[Item.isDistinct\n   * distinct]]; otherwise returns an empty `Record` if this `Item` is\n   * [[Extant]] or [[Absent]].  Facilitates writing code that treats a bare\n   * `Value` equivalently to a unary `Record`.\n   */\n  abstract unflattened(): Record;\n\n  /**\n   * Returns the value of the first member of this `Item`, if this `Item` is a\n   * [[Record]], and its first member is an [[Attr]] whose `key` string is\n   * equal to `tag`; otherwise returns [[Absent]] if this `Item` is not a\n   * `Record`, or if this `Item` is a `Record` whose first member is not an\n   * `Attr`, or if this `Item` is a `Record` whose first member is an `Attr`\n   * whose `key` does not equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`.  Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  abstract header(tag: string): Value;\n\n  /**\n   * Returns the [[Item.unflattened unflattened]] [[Item.header header]] of\n   * this `Item`, if this `Item` is a [[Record]], and its first member is an\n   * [[Attr]] whose `key` string is equal to `tag`; otherwise returns\n   * `undefined`.\n   *\n   * The `headers` of the `tag` attribute of a structure are like the\n   * attributes of an XML element tag; through unlike an XML element, `tag`\n   * attribute headers are not limited to string keys and values.\n   */\n  abstract headers(tag: string): Record | undefined;\n\n  /**\n   * Returns the first member of this `Item`, if this `Item` is a non-empty\n   * [[Record]]; otherwise returns [[Absent]].\n   */\n  abstract head(): Item;\n\n  /**\n   * Returns a view of all but the first member of this `Item`, if this `Item`\n   * is a non-empty [[Record]]; otherwise returns an empty `Record` if this\n   * `Item` is not a `Record`, or if this `Item` is itself an empty `Record`.\n   */\n  abstract tail(): Record;\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Item.tail tail]] of this\n   * `Item`.  Used to recursively deconstruct a structure, terminating with its\n   * last `Value`, rather than a unary `Record` containing its last value, if\n   * the structure ends with a `Value` member.\n   */\n  abstract body(): Value;\n\n  /**\n   * Returns the number of members contained in this `Item`, if this `Item` is\n   * a [[Record]]; otherwise returns `0` if this `Item` is not a `Record`.\n   */\n  abstract get length(): number;\n\n  /**\n   * Returns `true` if this `Item` is a [[Record]] that has a [[Field]] member\n   * with a key that is equal to the given `key`; otherwise returns `false` if\n   * this `Item` is not a `Record`, or if this `Item` is a `Record`, but has no\n   * `Field` member with a key equal to the given `key`.\n   */\n  abstract has(key: AnyValue): boolean;\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Field` member\n   * with a key equal to the given `key`.\n   */\n  abstract get(key: AnyValue): Value;\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Attr` member\n   * with a key equal to the given `key`.\n   */\n  abstract getAttr(key: AnyText): Value;\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Item` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Item` is not a\n   * [[Record]], or if this `Item` is a `Record`, but has no `Slot` member\n   * with a key equal to the given `key`.\n   */\n  abstract getSlot(key: AnyValue): Value;\n\n  /**\n   * Returns the last [[Field]] member of this `Item` whose key is equal to the\n   * given `key`; returns `undefined` if this `Item` is not a [[Record]], or if\n   * this `Item` is a `Record`, but has no `Field` member with a `key` equal to\n   * the given `key`.\n   */\n  abstract getField(key: AnyValue): Field | undefined;\n\n  /**\n   * Returns the member of this `Item` at the given `index`, if this `Item` is\n   * a [[Record]], and the `index` is greater than or equal to zero, and less\n   * than the [[Record.length length]] of the `Record`; otherwise returns\n   * [[Absent]] if this `Item` is not a `Record`, or if this `Item` is a\n   * `Record`, but the `index` is out of bounds.\n   */\n  abstract getItem(index: AnyNum): Item;\n\n  updated(key: AnyValue, value: AnyValue): Record {\n    const record = Item.Record.create(2);\n    record.push(this);\n    record.set(key, value);\n    return record;\n  }\n\n  updatedAttr(key: AnyText, value: AnyValue): Record {\n    const record = Item.Record.create(2);\n    record.push(this);\n    record.setAttr(key, value);\n    return record;\n  }\n\n  updatedSlot(key: AnyValue, value: AnyValue): Record {\n    const record = Item.Record.create(2);\n    record.push(this);\n    record.setSlot(key, value);\n    return record;\n  }\n\n  appended(...items: AnyItem[]): Record {\n    const record = Item.Record.create(1 + arguments.length);\n    record.push(this);\n    record.push.apply(record, arguments);\n    return record;\n  }\n\n  prepended(...items: AnyItem[]): Record {\n    const record = Item.Record.create(arguments.length + 1);\n    record.push.apply(record, arguments);\n    record.push(this);\n    return record;\n  }\n\n  abstract deleted(key: AnyValue): Item;\n\n  concat(...items: AnyItem[]): Record {\n    const record = Item.Record.create();\n    record.push(this);\n    for (let i = 0, n = arguments.length; i < n; i += 1) {\n      Item.fromAny(arguments[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  abstract conditional(thenTerm: Item, elseTerm: Item): Item;\n\n  abstract or(that: Item): Item;\n\n  abstract and(that: Item): Item;\n\n  abstract bitwiseOr(that: AnyItem): Item;\n\n  abstract bitwiseXor(that: AnyItem): Item;\n\n  abstract bitwiseAnd(that: AnyItem): Item;\n\n  lt(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return this.compareTo(that) < 0 ? Item.Bool.from(true) : Item.absent();\n  }\n\n  le(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return this.compareTo(that) <= 0 ? Item.Bool.from(true) : Item.absent();\n  }\n\n  eq(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return this.equals(that) ? Item.Bool.from(true) : Item.absent();\n  }\n\n  ne(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return !this.equals(that) ? Item.Bool.from(true) : Item.absent();\n  }\n\n  ge(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return this.compareTo(that) >= 0 ? Item.Bool.from(true) : Item.absent();\n  }\n\n  gt(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return this.compareTo(that) > 0 ? Item.Bool.from(true) : Item.absent();\n  }\n\n  abstract plus(that: AnyItem): Item;\n\n  abstract minus(that: AnyItem): Item;\n\n  abstract times(that: AnyItem): Item;\n\n  abstract divide(that: AnyItem): Item;\n\n  abstract modulo(that: AnyItem): Item;\n\n  abstract not(): Item;\n\n  abstract bitwiseNot(): Item;\n\n  abstract negative(): Item;\n\n  abstract positive(): Item;\n\n  abstract inverse(): Item;\n\n  invoke(args: Value): Item {\n    return Item.absent();\n  }\n\n  abstract lambda(template: Value): Value;\n\n  filter(predicate?: AnyItem): Selector {\n    const selector = Item.Selector.literal(this);\n    return selector.filter.apply(selector, arguments);\n  }\n\n  max(that: Item): Item {\n    return this.compareTo(that) >= 0 ? this : that;\n  }\n\n  min(that: Item): Item {\n    return this.compareTo(that) <= 0 ? this : that;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    return this;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    return this;\n  }\n\n  /**\n   * Converts this `Item` into a `string` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `string` value.\n   */\n  abstract stringValue(): string | undefined;\n\n  /**\n   * Converts this `Item` into a `string` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `string` value.\n   */\n  abstract stringValue<T>(orElse: T): string | T;\n\n  /**\n   * Converts this `Item` into a `number` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `number` value.\n   */\n  abstract numberValue(): number | undefined;\n\n  /**\n   * Converts this `Item` into a `number` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `number` value.\n   */\n  abstract numberValue<T>(orElse: T): number | T;\n\n  /**\n   * Converts this `Item` into a `boolean` value, if possible; otherwise returns\n   * `undefined` if this `Item` can't be converted into a `boolean` value.\n   */\n  abstract booleanValue(): boolean | undefined;\n\n  /**\n   * Converts this `Item` into a `boolean` value, if possible; otherwise returns\n   * `orElse` if this `Item` can't be converted into a `boolean` value.\n   */\n  abstract booleanValue<T>(orElse: T): boolean | T;\n\n  cast<T>(form: Form<T, unknown>): T | undefined;\n\n  cast<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;\n\n  cast<T, E = T>(form: Form<T, unknown>, orElse?: E): T | E | undefined {\n    let object: T | E | undefined = form.cast(this);\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  coerce<T>(form: Form<T, unknown>): T;\n\n  coerce<T, E = T>(form: Form<T, unknown>, orElse: E): T | E;\n\n  coerce<T, E = T>(form: Form<T, unknown>, orElse?: E): T | E {\n    let object: T | E | undefined = form.cast(this);\n    if (object === void 0) {\n      object = form.unit();\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object!;\n  }\n\n  abstract toAny(): AnyItem;\n\n  abstract isAliased(): boolean;\n\n  abstract isMutable(): boolean;\n\n  abstract alias(): void;\n\n  abstract branch(): Item;\n\n  abstract clone(): Item;\n\n  abstract commit(): this;\n\n  /** @hidden */\n  precedence(): number {\n    return 11;\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return callback.call(thisArg, this, 0);\n  }\n\n  iterator(): Cursor<Item> {\n    return Cursor.unary(this);\n  }\n\n  /**\n   * Returns the heterogeneous sort order of this `Item`.  Used to impose a\n   * total order on the set of all items.  When comparing two items of\n   * different types, the items order according to their `typeOrder}`.\n   */\n  abstract typeOrder(): number;\n\n  abstract compareTo(that: Item): 0 | 1 | -1;\n\n  abstract keyEquals(key: unknown): boolean;\n\n  abstract equals(that: unknown): boolean;\n\n  abstract hashCode(): number;\n\n  abstract debug(output: Output): void;\n\n  display(output: Output): void {\n    this.debug(output);\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  static empty(): Item {\n    return Item.Record.empty();\n  }\n\n  static extant(): Item {\n    return Item.Extant.extant();\n  }\n\n  static absent(): Item {\n    return Item.Absent.absent();\n  }\n\n  static fromAny(item: AnyItem): Item {\n    if (item instanceof Item) {\n      return item;\n    } else {\n      return Item.Value.fromAny(item);\n    }\n  }\n\n  private static _globalScope?: Item;\n\n  static globalScope(): Item {\n    if (!Item._globalScope) {\n      Item._globalScope = Item.Record.create(1)\n          .slot(\"math\", Item.MathModule.scope())\n          .commit();\n    }\n    return Item._globalScope;\n  }\n\n  // Forward type declarations\n  /** @hidden */\n  static Field: typeof Field; // defined by Field\n  /** @hidden */\n  static Attr: typeof Attr; // defined by Attr\n  /** @hidden */\n  static Slot: typeof Slot; // defined by Slot\n  /** @hidden */\n  static Value: typeof Value; // defined by Value\n  /** @hidden */\n  static Record: typeof Record; // defined by Record\n  /** @hidden */\n  static RecordMap: typeof RecordMap; // defined by RecordMap\n  /** @hidden */\n  static RecordMapView: typeof RecordMapView; // defined by RecordMapView\n  /** @hidden */\n  static Data: typeof Data; // defined by Data\n  /** @hidden */\n  static Text: typeof Text; // defined by Text\n  /** @hidden */\n  static Num: typeof Num; // defined by Num\n  /** @hidden */\n  static Bool: typeof Bool; // defined by Bool\n  /** @hidden */\n  static Expression: typeof Expression; // defined by Expression\n  /** @hidden */\n  static Selector: typeof Selector; // defined by Selector\n  /** @hidden */\n  static Operator: typeof Operator; // defined by Operator\n  /** @hidden */\n  static Func: typeof Func; // defined by Func\n  /** @hidden */\n  static Extant: typeof Extant; // defined by Extant\n  /** @hidden */\n  static Absent: typeof Absent; // defined by Absent\n  /** @hidden */\n  static BinaryOperator: typeof BinaryOperator; // defined by BinaryOperator\n  /** @hidden */\n  static UnaryOperator: typeof UnaryOperator; // defined by UnaryOperator\n  /** @hidden */\n  static ConditionalOperator: typeof ConditionalOperator; // defined by ConditionalOperator\n  /** @hidden */\n  static OrOperator: typeof OrOperator; // defined by OrOperator\n  /** @hidden */\n  static AndOperator: typeof AndOperator; // defined by AndOperator\n  /** @hidden */\n  static BitwiseOrOperator: typeof BitwiseOrOperator; // defined by BitwiseOrOperator\n  /** @hidden */\n  static BitwiseXorOperator: typeof BitwiseXorOperator; // defined by BitwiseXorOperator\n  /** @hidden */\n  static BitwiseAndOperator: typeof BitwiseAndOperator; // defined by BitwiseAndOperator\n  /** @hidden */\n  static LtOperator: typeof LtOperator; // defined by LtOperator\n  /** @hidden */\n  static LeOperator: typeof LeOperator; // defined by LeOperator\n  /** @hidden */\n  static EqOperator: typeof EqOperator; // defined by EqOperator\n  /** @hidden */\n  static NeOperator: typeof NeOperator; // defined by NeOperator\n  /** @hidden */\n  static GeOperator: typeof GeOperator; // defined by GeOperator\n  /** @hidden */\n  static GtOperator: typeof GtOperator; // defined by GtOperator\n  /** @hidden */\n  static PlusOperator: typeof PlusOperator; // defined by PlusOperator\n  /** @hidden */\n  static MinusOperator: typeof MinusOperator; // defined by MinusOperator\n  /** @hidden */\n  static TimesOperator: typeof TimesOperator; // defined by TimesOperator\n  /** @hidden */\n  static DivideOperator: typeof DivideOperator; // defined by DivideOperator\n  /** @hidden */\n  static ModuloOperator: typeof ModuloOperator; // defined by ModuloOperator\n  /** @hidden */\n  static NotOperator: typeof NotOperator; // defined by NotOperator\n  /** @hidden */\n  static BitwiseNotOperator: typeof BitwiseNotOperator; // defined by BitwiseNotOperator\n  /** @hidden */\n  static NegativeOperator: typeof NegativeOperator; // defined by NegativeOperator\n  /** @hidden */\n  static PositiveOperator: typeof PositiveOperator; // defined by PositiveOperator\n  /** @hidden */\n  static InvokeOperator: typeof InvokeOperator; // defined by InvokeOperator\n  /** @hidden */\n  static IdentitySelector: typeof IdentitySelector; // defined by IdentitySelector\n  /** @hidden */\n  static GetSelector: typeof GetSelector; // defined by GetSelector\n  /** @hidden */\n  static GetAttrSelector: typeof GetAttrSelector; // defined by GetAttrSelector\n  /** @hidden */\n  static GetItemSelector: typeof GetItemSelector; // defined by GetItemSelector\n  /** @hidden */\n  static KeysSelector: typeof KeysSelector; // defined by KeysSelector\n  /** @hidden */\n  static ValuesSelector: typeof ValuesSelector; // defined by ValuesSelector\n  /** @hidden */\n  static ChildrenSelector: typeof ChildrenSelector; // defined by ChildrenSelector\n  /** @hidden */\n  static DescendantsSelector: typeof DescendantsSelector; // defined by DescendantsSelector\n  /** @hidden */\n  static FilterSelector: typeof FilterSelector; // defined by FilterSelector\n  /** @hidden */\n  static LiteralSelector: typeof LiteralSelector; // defined by LiteralSelector\n  /** @hidden */\n  static LambdaFunc: typeof LambdaFunc; // defined by LambdaFunc\n  /** @hidden */\n  static BridgeFunc: typeof BridgeFunc; // defined by BridgeFunc\n  /** @hidden */\n  static MathModule: typeof MathModule; // defined by MathModule\n}\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {AnyText} from \"./Text\";\nimport {AnyNum} from \"./Num\";\n\nexport type AnyField = Field\n                     | {readonly $key: AnyValue, readonly $value: AnyValue}\n                     | {[key: string]: AnyValue};\n\nexport abstract class Field extends Item {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Always returns `true` because a `Field` can never be [[Absent]].\n   */\n  isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns `true` because a `Field` can be neither [[Extant]] nor\n   * [[Absent]].\n   */\n  isDistinct(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns the key component of this `Field`.\n   */\n  abstract get key(): Value;\n\n  /**\n   * Returns the value component of this `Field`.\n   */\n  abstract get value(): Value;\n\n  /**\n   * Sets the value of this `Field` to the new `value`, returning the old value.\n   *\n   * @throws `Error` if this `Field` is immutable.\n   */\n  abstract setValue(value: AnyValue): Value;\n\n  /**\n   * Returns a copy of this `Field` with the updated `value`.\n   */\n  abstract updatedValue(value: AnyValue): Field;\n\n  /**\n   * Returns the value component of this `Field`.\n   */\n  toValue(): Value {\n    return this.value;\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a first member `Attr` whose key string could be returned.\n   */\n  tag(): string | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns the value component of this `Field`.\n   */\n  target(): Value {\n    return this.value;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be flattened into a\n   * `Value`.\n   */\n  flattened(): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Returns a `Record` containing just this `Field`.\n   */\n  unflattened(): Record {\n    return Item.Record.of(this);\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a head `Attr` whose value could be returned if its key were\n   * equal to the `tag`.\n   */\n  header(tag: string): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a head `Attr` whose value could be returned as a `Record` if\n   * its key were equal to the `tag`.\n   */\n  headers(tag: string): Record | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a first member.\n   */\n  head(): Item {\n    return Item.absent();\n  }\n\n  /**\n   * Always returns an empty `Record` because a `Field` can't itself be a\n   * `Record`, so it can't have any non-first members.\n   */\n  tail(): Record {\n    return Item.Record.empty();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have any non-first members to flatten, and because a `Field` isn't\n   * a distinct `Value`, so it can't return `Extant`.\n   */\n  body(): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Always returns `0` because a `Field` can't be a `Record`, so it can't\n   * contain any members.\n   */\n  get length(): number {\n    return 0;\n  }\n\n  /**\n   * Always returns `false` because a `Field` can't be a `Record`, so it can't\n   * have a `Field` member whose key is equal to the given `key`.\n   */\n  has(key: AnyValue): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a `Field` member whose key is equal to the given `key`.\n   */\n  get(key: AnyValue): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have an `Attr` member whose key is equal to the given `key`.\n   */\n  getAttr(key: AnyText): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a `Slot` member whose key is equal to the given `key`.\n   */\n  getSlot(key: AnyValue): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Always returns `undefined` because a `Field` can't be a `Record`, so it\n   * can't have a `Field` member whose key is equal to the given `key`.\n   */\n  getField(key: AnyValue): Field | undefined {\n    return void 0;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Field` can't be a `Record`, so it\n   * can't have a member at the given `index`.\n   */\n  getItem(index: AnyNum): Item {\n    return Item.absent();\n  }\n\n  deleted(key: AnyValue): Field {\n    return this;\n  }\n\n  conditional(thenTerm: Field, elseTerm: Field): Field;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item {\n    thenTerm = Item.fromAny(thenTerm);\n    return thenTerm;\n  }\n\n  or(that: Field): Field;\n  or(that: AnyItem): Item;\n  or(that: AnyItem): Item {\n    return this;\n  }\n\n  and(that: Field): Field;\n  and(that: AnyItem): Item;\n  and(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return that;\n  }\n\n  lambda(template: Value): Value {\n    return Item.Value.absent();\n  }\n\n  /**\n   * Converts the value of this `Field` into a `string` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `string` value.\n   */\n  stringValue(): string | undefined;\n  /**\n   * Converts the value of this `Field` into a `string` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `string` value.\n   */\n  stringValue<T>(orElse: T): string | T;\n  stringValue<T>(orElse?: T): string | T | undefined {\n    return this.value.stringValue(orElse);\n  }\n\n  /**\n   * Converts the value of this `Field` into a `number` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `number` value.\n   */\n  numberValue(): number | undefined;\n  /**\n   * Converts the value of this `Field` into a `number` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `number` value.\n   */\n  numberValue<T>(orElse: T): number | T;\n  numberValue<T>(orElse?: T): number | T | undefined {\n    return this.value.numberValue(orElse);\n  }\n\n  /**\n   * Converts the value of this `Field` into a `boolean` value, if possible.\n   *\n   * @throws `Error` if the value of this `Field` can't be converted into a\n   *         `boolean` value.\n   */\n  booleanValue(): boolean | undefined;\n  /**\n   * Converts the value of this `Field` into a `boolean` value, if possible;\n   * otherwise returns `orElse` if the value of this `Field` can't be converted\n   * into a `boolean` value.\n   */\n  booleanValue<T>(orElse: T): boolean | T;\n  booleanValue<T>(orElse?: T): boolean | T | undefined {\n    return this.value.booleanValue(orElse);\n  }\n\n  abstract toAny(): AnyField;\n\n  abstract branch(): Field;\n\n  abstract clone(): Field;\n\n  abstract commit(): this;\n\n  /** @hidden */\n  static readonly IMMUTABLE: number = 1 << 0;\n\n  static of(key: AnyValue, value?: AnyValue): Field {\n    let name;\n    if (typeof key === \"string\") {\n      name = key;\n    } else if (key instanceof Item.Text) {\n      name = key.value;\n    }\n    if (name !== void 0 && name.charCodeAt(0) === 64/*'@'*/) {\n      arguments[0] = name.slice(1);\n      return Item.Attr.of.apply(undefined, arguments);\n    } else {\n      return Item.Slot.of.apply(undefined, arguments);\n    }\n  }\n\n  static fromAny(field: AnyField): Field {\n    if (field instanceof Field) {\n      return field;\n    } else if (field && typeof field === \"object\") {\n      if ((field as any).$key !== void 0) {\n        return Field.of((field as any).$key, (field as any).$value);\n      } else {\n        for (const key in field) {\n          return Field.of(key, (field as any)[key]);\n        }\n      }\n    }\n    throw new TypeError(\"\" + field);\n  }\n}\nItem.Field = Field;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport class InterpreterException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = InterpreterException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {HashCode, Murmur3} from \"@swim/util\";\nimport {Output, Format, Debug} from \"@swim/codec\";\n\n/**\n * Either an [[InterpreterSettings]] instance, or an [[InterpreterSettingsInit]]\n * object initializer.\n */\nexport type AnyInterpreterSettings = InterpreterSettings | InterpreterSettingsInit;\n\n/**\n * [[InterpreterSettings]] object initializer.\n */\nexport interface InterpreterSettingsInit {\n  lineSeparator?: string | null;\n  isPretty?: boolean;\n  isStyled?: boolean;\n}\n\nexport class InterpreterSettings implements Debug, HashCode {\n  /** @hidden */\n  readonly _maxScopeDepth: number;\n\n  constructor(maxScopeDepth: number) {\n    this._maxScopeDepth = maxScopeDepth;\n  }\n\n  maxScopeDepth(): number;\n\n  maxScopeDepth(maxScopeDepth: number): InterpreterSettings;\n\n  maxScopeDepth(maxScopeDepth?: number): number | InterpreterSettings {\n    if (maxScopeDepth === void 0) {\n      return this._maxScopeDepth;\n    } else {\n      return this.copy(maxScopeDepth);\n    }\n  }\n\n  protected copy(maxScopeDepth: number): InterpreterSettings {\n    return new InterpreterSettings(maxScopeDepth);\n  }\n\n  protected canEqual(that: unknown): boolean {\n    return that instanceof InterpreterSettings;\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InterpreterSettings) {\n      return that.canEqual(this) && this._maxScopeDepth === that._maxScopeDepth;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (InterpreterSettings._hashSeed === void 0) {\n      InterpreterSettings._hashSeed = Murmur3.seed(InterpreterSettings);\n    }\n    return Murmur3.mash(Murmur3.mix(InterpreterSettings._hashSeed, this._maxScopeDepth));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"new\").write(32/*' '*/).write(\"InterpreterSettings\")\n        .write(40/*'('*/).debug(this._maxScopeDepth).write(41/*')'*/);\n  }\n\n  toString(): string {\n    return Format.debug(this);\n  }\n\n  private static _hashSeed?: number;\n  private static _standard?: InterpreterSettings;\n\n  static standard(): InterpreterSettings {\n    if (!InterpreterSettings._standard) {\n      const maxScopeDepth = 1024;\n      InterpreterSettings._standard = new InterpreterSettings(maxScopeDepth);\n    }\n    return InterpreterSettings._standard;\n  }\n}\n","import {InterpreterException} from \"./InterpreterException\";\nimport {InterpreterSettings} from \"./InterpreterSettings\";\nimport {AnyItem, Item} from \"./Item\";\nimport {Selector} from \"./Selector\";\nimport {Operator} from \"./Operator\";\n\nexport type AnyInterpreter = Interpreter | AnyItem;\n\nexport class Interpreter {\n  /** @hidden */\n  _settings: InterpreterSettings;\n  /** @hidden */\n  _scopeStack: Item[] | null;\n  /** @hidden */\n  _scopeDepth: number;\n\n  constructor(settings: InterpreterSettings = InterpreterSettings.standard(),\n              scopeStack: Item[] | null = null, scopeDepth: number = 0) {\n    this._settings = settings;\n    this._scopeStack = scopeStack;\n    this._scopeDepth = scopeDepth;\n  }\n\n  settings(): InterpreterSettings;\n\n  settings(settings: InterpreterSettings): this;\n\n  settings(settings?: InterpreterSettings): InterpreterSettings | this {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = settings;\n      return this;\n    }\n  }\n\n  scopeDepth(): number {\n    return this._scopeDepth;\n  }\n\n  peekScope(): Item {\n    const scopeDepth = this._scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    return this._scopeStack![scopeDepth - 1];\n  }\n\n  getScope(index: number): Item {\n    if (index < 0 || index >= this._scopeDepth) {\n      throw new RangeError(\"\" + index);\n    }\n    return this._scopeStack![index];\n  }\n\n  pushScope(scope: Item): void {\n    const scopeDepth = this._scopeDepth;\n    if (scopeDepth >= this._settings._maxScopeDepth) {\n      throw new InterpreterException(\"scope stack overflow\");\n    }\n    const oldScopeStack = this._scopeStack;\n    let newScopeStack;\n    if (oldScopeStack === null || scopeDepth + 1 > oldScopeStack.length) {\n      newScopeStack = new Array<Item>(Interpreter.expand(scopeDepth + 1));\n      if (oldScopeStack != null) {\n        for (let i = 0; i < scopeDepth; i += 1) {\n          newScopeStack[i] = oldScopeStack[i];\n        }\n      }\n      this._scopeStack = newScopeStack;\n    } else {\n      newScopeStack = oldScopeStack;\n    }\n    newScopeStack[scopeDepth] = scope;\n    this._scopeDepth = scopeDepth + 1;\n  }\n\n  popScope(): Item {\n    const scopeDepth = this._scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    const scopeStack = this._scopeStack!;\n    const scope = scopeStack[scopeDepth - 1];\n    scopeStack[scopeDepth - 1] = void 0 as any;\n    this._scopeDepth = scopeDepth - 1;\n    return scope;\n  }\n\n  swapScope(newScope: Item): Item {\n    const scopeDepth = this._scopeDepth;\n    if (scopeDepth <= 0) {\n      throw new InterpreterException(\"scope stack empty\");\n    }\n    const scopeStack = this._scopeStack!;\n    const oldScope = scopeStack[scopeDepth - 1];\n    scopeStack[scopeDepth - 1] = newScope;\n    return oldScope;\n  }\n\n  willOperate(operator: Operator): void {\n    // stub\n  }\n\n  didOperate(operator: Operator, result: Item): void {\n    // stub\n  }\n\n  willSelect(selector: Selector): void {\n    // stub\n  }\n\n  didSelect(selector: Selector, result: unknown): void {\n    // stub\n  }\n\n  willTransform(selector: Selector): void {\n    // stub\n  }\n\n  didTransform(selector: Selector, result: Item): void {\n    // stub\n  }\n\n  static of(...objects: AnyItem[]): Interpreter {\n    const n = arguments.length;\n    const scopes = new Array(Interpreter.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      const scope = Item.fromAny(arguments[i]);\n      scopes[i] = scope;\n    }\n    return new Interpreter(InterpreterSettings.standard(), scopes, n);\n  }\n\n  static fromAny(interpreter: AnyInterpreter, globalScope: Item = Item.globalScope()): Interpreter {\n    if (!(interpreter instanceof Interpreter)) {\n      const scope = interpreter;\n      interpreter = new Interpreter();\n      if (globalScope) {\n        interpreter.pushScope(globalScope);\n      }\n      if (scope !== void 0) {\n        interpreter.pushScope(Item.fromAny(scope));\n      }\n    }\n    return interpreter;\n  }\n\n  private static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyField, Field} from \"./Field\";\nimport {AnyValue, Value} from \"./Value\";\nimport {AnyText, Text} from \"./Text\";\nimport {AnyInterpreter, Interpreter} from \"./Interpreter\";\n\nexport class Attr extends Field {\n  /** @hidden */\n  readonly _key: Text;\n  /** @hidden */\n  _value: Value;\n  /** @hidden */\n  _flags: number;\n\n  constructor(key: Text, value: Value = Item.Value.extant(), flags: number = 0) {\n    super();\n    this._key = key;\n    this._value = value;\n    this._flags = flags;\n  }\n\n  isConstant(): boolean {\n    return this._key.isConstant() && this._value.isConstant();\n  }\n\n  get name(): string {\n    return this._key.value;\n  }\n\n  get key(): Text {\n    return this._key;\n  }\n\n  get value(): Value {\n    return this._value;\n  }\n\n  setValue(newValue: Value): Value {\n    if ((this._flags & Field.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const oldValue = this._value;\n    this._value = newValue;\n    return oldValue;\n  }\n\n  updatedValue(value: Value): Attr {\n    return new Attr(this._key, value);\n  }\n\n  bitwiseOr(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseOrOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseOr(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseOr(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseXor(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseXorOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseXor(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseXor(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseAnd(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseAndOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseAnd(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseAnd(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  plus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.PlusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.plus(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.plus(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  minus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.MinusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.minus(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.minus(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  times(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.TimesOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.times(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.times(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  divide(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.DivideOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.divide(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.divide(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  modulo(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.ModuloOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Attr && this._key.equals(that._key)) {\n      newValue = this._value.modulo(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.modulo(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  not(): Item {\n    const newValue = this._value.not();\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseNot(): Item {\n    const newValue = this._value.bitwiseNot();\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  negative(): Item {\n    const newValue = this._value.negative();\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  positive(): Item {\n    const newValue = this._value.positive();\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  inverse(): Item {\n    const newValue = this._value.inverse();\n    if (newValue.isDefined()) {\n      return new Attr(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const key = this._key.evaluate(interpreter).toValue();\n    const value = this._value.evaluate(interpreter).toValue();\n    if (key === this._key && value === this._value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      if (key instanceof Item.Text) {\n        return new Attr(key, value);\n      } else {\n        return new Item.Slot(key, value);\n      }\n    }\n    return Item.absent();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const key = this._key.substitute(interpreter).toValue();\n    const value = this._value.substitute(interpreter).toValue();\n    if (key === this._key && value === this._value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      if (key instanceof Item.Text) {\n        return new Attr(key, value);\n      } else {\n        return new Item.Slot(key, value);\n      }\n    }\n    return Item.absent();\n  }\n\n  toAny(): AnyField {\n    const field = {} as {[key: string]: AnyValue};\n    field[\"@\" + this._key.value] = this._value.toAny();\n    return field;\n  }\n\n  isAliased(): boolean {\n    return false;\n  }\n\n  isMutable(): boolean {\n    return (this._flags & Field.IMMUTABLE) === 0;\n  }\n\n  alias(): void {\n    this._flags |= Field.IMMUTABLE;\n  }\n\n  branch(): Attr {\n    if ((this._flags & Field.IMMUTABLE) !== 0) {\n      return new Attr(this._key, this._value, this._flags & ~Field.IMMUTABLE);\n    } else {\n      return this;\n    }\n  }\n\n  clone(): Attr {\n    return new Attr(this._key.clone(), this._value.clone());\n  }\n\n  commit(): this {\n    if ((this._flags & Field.IMMUTABLE) === 0) {\n      this._flags |= Field.IMMUTABLE;\n      this._value.commit();\n    }\n    return this;\n  }\n\n  typeOrder(): number {\n    return 1;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Attr) {\n      let order = this._key.compareTo(that._key);\n      if (order === 0) {\n        order = this._value.compareTo(that._value);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  keyEquals(key: unknown): boolean {\n    if (typeof key === \"string\") {\n      return this._key.value === key;\n    } else if (key instanceof Field) {\n      return this._key.equals(key.key);\n    } else {\n      return this._key.equals(key);\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Attr) {\n      return this._key.equals(that._key) && this._value.equals(that._value);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (Attr._hashSeed === void 0) {\n      Attr._hashSeed = Murmur3.seed(Attr);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Attr._hashSeed,\n        this._key.hashCode()), this._value.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Attr\").write(46/*'.'*/).write(\"of\").write(40/*'('*/).display(this.key);\n    if (!(this.value instanceof Item.Extant)) {\n      output = output.write(44/*','*/).write(32/*' '*/).display(this.value);\n    }\n    output = output.write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    this.debug(output);\n  }\n\n  private static _hashSeed?: number;\n\n  static of(key: AnyText, value?: AnyValue): Attr {\n    key = Item.Text.fromAny(key);\n    value = (arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant());\n    return new Attr(key, value);\n  }\n}\nItem.Attr = Attr;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyField, Field} from \"./Field\";\nimport {AnyValue, Value} from \"./Value\";\nimport {AnyInterpreter, Interpreter} from \"./Interpreter\";\n\nexport class Slot extends Field {\n  /** @hidden */\n  readonly _key: Value;\n  /** @hidden */\n  _value: Value;\n  /** @hidden */\n  _flags: number;\n\n  constructor(key: Value, value: Value = Item.Value.extant(), flags: number = 0) {\n    super();\n    this._key = key.commit();\n    this._value = value;\n    this._flags = flags;\n  }\n\n  get key(): Value {\n    return this._key;\n  }\n\n  get value(): Value {\n    return this._value;\n  }\n\n  isConstant(): boolean {\n    return this._key.isConstant() && this._value.isConstant();\n  }\n\n  setValue(newValue: Value): Value {\n    if ((this._flags & Field.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const oldValue = this._value;\n    this._value = newValue;\n    return oldValue;\n  }\n\n  updatedValue(value: Value): Slot {\n    return new Slot(this._key, value);\n  }\n\n  bitwiseOr(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseOrOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseOr(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseOr(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseXor(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseXorOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseXor(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseXor(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseAnd(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseAndOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.bitwiseAnd(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.bitwiseAnd(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  plus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.PlusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.plus(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.plus(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  minus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.MinusOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.minus(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.minus(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  times(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.TimesOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.times(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.times(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  divide(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.DivideOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.divide(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.divide(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  modulo(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.ModuloOperator(this, that);\n    }\n    let newValue;\n    if (that instanceof Slot && this._key.equals(that._key)) {\n      newValue = this._value.modulo(that._value);\n    } else if (that instanceof Item.Value) {\n      newValue = this._value.modulo(that);\n    } else {\n      newValue = Item.Value.absent();\n    }\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  not(): Item {\n    const newValue = this._value.not();\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  bitwiseNot(): Item {\n    const newValue = this._value.bitwiseNot();\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  negative(): Item {\n    const newValue = this._value.negative();\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  positive(): Item {\n    const newValue = this._value.positive();\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  inverse(): Item {\n    const newValue = this._value.inverse();\n    if (newValue.isDefined()) {\n      return new Slot(this._key, newValue);\n    }\n    return Item.absent();\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const key = this._key.evaluate(interpreter).toValue();\n    const value = this._value.evaluate(interpreter).toValue();\n    if (key === this._key && value === this._value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      return new Slot(key, value);\n    }\n    return Item.absent();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const key = this._key.substitute(interpreter).toValue();\n    const value = this._value.substitute(interpreter).toValue();\n    if (key === this._key && value === this._value) {\n      return this;\n    } else if (key.isDefined() && value.isDefined()) {\n      return new Slot(key, value);\n    }\n    return Item.absent();\n  }\n\n  toAny(): AnyField {\n    const field = {} as {[key: string]: AnyValue};\n    if (this._key instanceof Item.Text) {\n      field[this._key.value] = this._value.toAny();\n    } else {\n      field.$key = this._key.toAny();\n      field.$value = this._value.toAny();\n    }\n    return field;\n  }\n\n  isAliased(): boolean {\n    return false;\n  }\n\n  isMutable(): boolean {\n    return (this._flags & Field.IMMUTABLE) === 0;\n  }\n\n  alias(): void {\n    this._flags |= Field.IMMUTABLE;\n  }\n\n  branch(): Slot {\n    if ((this._flags & Field.IMMUTABLE) !== 0) {\n      return new Slot(this._key, this._value, this._flags & ~Field.IMMUTABLE);\n    } else {\n      return this;\n    }\n  }\n\n  clone(): Slot {\n    return new Slot(this._key.clone(), this._value.clone());\n  }\n\n  commit(): this {\n    if ((this._flags & Field.IMMUTABLE) === 0) {\n      this._flags |= Field.IMMUTABLE;\n      this._value.commit();\n    }\n    return this;\n  }\n\n  typeOrder(): number {\n    return 2;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Slot) {\n      let order = this._key.compareTo(that._key);\n      if (order === 0) {\n        order = this._value.compareTo(that._value);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  keyEquals(key: unknown): boolean {\n    if (typeof key === \"string\" && this._key instanceof Item.Text) {\n      return this._key.value === key;\n    } else if (key instanceof Field) {\n      return this._key.equals(key.key);\n    } else {\n      return this._key.equals(key);\n    }\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Slot) {\n      return this._key.equals(that._key) && this._value.equals(that._value);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (Slot._hashSeed === void 0) {\n      Slot._hashSeed = Murmur3.seed(Slot);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Slot._hashSeed,\n        this._key.hashCode()), this._value.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Slot\").write(46/*'.'*/).write(\"of\").write(40/*'('*/).display(this.key);\n    if (!(this.value instanceof Item.Extant)) {\n      output = output.write(44/*','*/).write(32/*' '*/).display(this.value);\n    }\n    output = output.write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    this.debug(output);\n  }\n\n  private static _hashSeed?: number;\n\n  static of(key: AnyValue, value?: AnyValue): Slot {\n    key = Item.Value.fromAny(key);\n    value = arguments.length >= 2 ? Item.Value.fromAny(value) : Item.Value.extant();\n    return new Slot(key, value);\n  }\n}\nItem.Slot = Slot;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\n\n/** @hidden */\nexport class ValueBuilder implements Builder<Item, Value> {\n  _record: Record | null;\n  _value: Value | null;\n\n  constructor() {\n    this._record = null;\n    this._value = null;\n  }\n\n  push(...items: Item[]): void {\n    for (let i = 0, n = arguments.length; i < n; i += 1) {\n      const item = arguments[i] as Item;\n      if (item instanceof Field) {\n        return this.pushField(item);\n      } else if (item instanceof Value) {\n        return this.pushValue(item);\n      } else {\n        throw new TypeError(\"\" + item);\n      }\n    }\n  }\n\n  /** @hidden */\n  pushField(item: Field): void {\n    if (this._record === null) {\n      this._record = Item.Record.create();\n      if (this._value !== null) {\n        this._record.push(this._value);\n        this._value = null;\n      }\n    }\n    this._record.push(item);\n  }\n\n  /** @hidden */\n  pushValue(item: Value): void {\n    if (this._record != null) {\n      this._record.push(item);\n    } else if (this._value == null) {\n      this._value = item;\n    } else {\n      this._record = Item.Record.create();\n      this._record.push(this._value);\n      this._value = null;\n      this._record.push(item);\n    }\n  }\n\n  bind(): Value {\n    if (this._record !== null) {\n      return this._record;\n    } else if (this._value !== null) {\n      return this._value;\n    } else {\n      return Value.absent();\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {AnyItem, Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {ValueBuilder} from \"./ValueBuilder\";\nimport {Record} from \"./Record\";\nimport {AnyText} from \"./Text\";\nimport {AnyNum} from \"./Num\";\n\nexport type AnyValue = Value\n                     | {readonly [key: string]: AnyValue}\n                     | ReadonlyArray<unknown> // ReadonlyArray<AnyItem>\n                     | Uint8Array\n                     | string\n                     | number\n                     | boolean\n                     | null\n                     | undefined;\n\nexport abstract class Value extends Item {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Returns `true` if this `Value` is not [[Absent]].\n   */\n  isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns `true` if this `Value` is neither [[Extant]] nor [[Absent]].\n   */\n  isDistinct(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns [[Absent]] because a `Value` can't be a `Field`, so it\n   * can't have a key component.\n   */\n  get key(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns `this` because every `Value` is its own value component.\n   */\n  toValue(): Value {\n    return this;\n  }\n\n  /**\n   * Returns the `key` string of the first member of this `Value`, if this\n   * `Value` is a [[Record]], and its first member is an [[Attr]]; otherwise\n   * returns `undefined` if this `Value` is not a `Record`, or if this `Value`\n   * is a `Record` whose first member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure.  The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  tag(): string | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the [[Value.flattened flattened]] members of this `Value` after\n   * all attributes have been removed, if this `Value` is a [[Record]];\n   * otherwise returns `this` if this `Value` is not a `Record`.\n   *\n   * Used to concisely get the scalar value of an attributed structure.  An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  target(): Value {\n    return this;\n  }\n\n  /**\n   * Returns the sole member of this `Value`, if this `Value` is a [[Record]]\n   * with exactly one member, and its member is a `Value`; returns [[Extant]]\n   * if this `Value` is an empty `Record`; otherwise returns `this` if this\n   * `Value` is a `Record` with more than one member, or if this `Value` is a\n   * not a `Record`.\n   *\n   * Used to convert a unary `Record` into its member `Value`.  Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  flattened(): Value {\n    return this;\n  }\n\n  /**\n   * Returns `this` if this `Value` is a [[Record]]; returns a `Record`\n   * containing just this `Value`, if this `Value` is [[Value.isDistinct\n   * distinct]]; otherwise returns an empty `Record` if this `Value` is\n   * [[Extant]] or [[Absent]].  Facilitates writing code that treats a bare\n   * `Value` equivalently to a unary `Record`.\n   */\n  unflattened(): Record {\n    return Value.Record.of(this);\n  }\n\n  /**\n   * Returns the value of the first member of this `Value`, if this `Value` is\n   * a `Record`, and its first member is an [[Attr]] whose `key` string is\n   * equal to `tag`; otherwise returns [[Absent]] if this `Value` is not a\n   * `Record`, or if this `Value` is a `Record` whose first member is not an\n   * `Attr`, or if this `Value` is a `Record` whose first member is an `Attr`\n   * whose `key` does not equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`.  Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  header(tag: string): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the [[Value.unflattened unflattened]] [[Value.header header]] of\n   * this `Value`, if this `Value` is a [[Record]], and its first member is an\n   * [[Attr]] whose `key` string is equal to `tag`; otherwise returns\n   * `undefined`.\n   *\n   * The `headers` of the `tag` attribute of a structure are like the\n   * attributes of an XML element tag; through unlike an XML element, `tag`\n   * attribute headers are not limited to string keys and values.\n   */\n  headers(tag: string): Record | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the first member of this `Value`, if this `Value` is a non-empty\n   * [[Record]]; otherwise returns [[Absent]].\n   */\n  head(): Item {\n    return Item.absent();\n  }\n\n  /**\n   * Returns a view of all but the first member of this `Value`, if this\n   * `Value` is a non-empty [[Record]]; otherwise returns an empty `Record`\n   * if this `Value` is not a `Record`, of if this `Value` is itself an\n   * empty `Record`.\n   */\n  tail(): Record {\n    return Value.Record.empty();\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Value.tail tail]] of this\n   * `Value`.  Used to recursively deconstruct a structure, terminating with\n   * its last `Value`, rather than a unary `Record` containing its last value,\n   * if the structure ends with a `Value` member.\n   */\n  body(): Value {\n    return Value.extant();\n  }\n\n  /**\n   * Returns the number of members contained in this `Value`, if this `Value`\n   * is a [[Record]]; otherwise returns `0` if this `Value` is not a `Record`.\n   */\n  get length(): number {\n    return 0;\n  }\n\n  /**\n   * Returns `true` if this `Value` is a [[Record]] that has a [[Field]] member\n   * with a key that is equal to the given `key`; otherwise returns `false` if\n   * this `Value` is not a `Record`, or if this `Value` is a `Record`, but has\n   * no `Field` member with a key equal to the given `key`.\n   */\n  has(key: AnyValue): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Field` member\n   * with a key equal to the given `key`.\n   */\n  get(key: AnyValue): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Attr` member\n   * with a key equal to the given `key`.\n   */\n  getAttr(key: AnyText): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Value` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Value` is not a\n   * [[Record]], or if this `Value` is a `Record`, but has no `Slot` member\n   * with a key equal to the given `key`.\n   */\n  getSlot(key: AnyValue): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Returns the last [[Field]] member of this `Value` whose key is equal to\n   * the given `key`; returns `undefined` if this `Value` is not a [[Record]],\n   * or if this `Value` is a `Record`, but has no `Field` member with a `key`\n   * equal to the given `key`.\n   */\n  getField(key: AnyValue): Field | undefined {\n    return void 0;\n  }\n\n  /**\n   * Returns the member of this `Value` at the given `index`, if this `Value`\n   * is a [[Record]], and the `index` is greater than or equal to zero, and\n   * less than the [[Record.length length]] of the `Record`; otherwise returns\n   * [[Absent]] if this `Value` is not a `Record`, or if this `Value` is a\n   * `Record`, but the `index` is out of bounds.\n   */\n  getItem(index: AnyNum): Item {\n    return Item.absent();\n  }\n\n  deleted(key: AnyValue): Value {\n    return this;\n  }\n\n  conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item {\n    thenTerm = Item.fromAny(thenTerm);\n    return thenTerm;\n  }\n\n  or(that: AnyValue): Value;\n  or(that: AnyItem): Item;\n  or(that: AnyItem): Item {\n    return this;\n  }\n\n  and(that: AnyValue): Value;\n  and(that: AnyItem): Item;\n  and(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    return that;\n  }\n\n  bitwiseOr(that: AnyValue): Value;\n  bitwiseOr(that: AnyItem): Item;\n  bitwiseOr(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseOrOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.bitwiseOr(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.bitwiseOr(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  bitwiseXor(that: AnyValue): Value;\n  bitwiseXor(that: AnyItem): Item;\n  bitwiseXor(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseXorOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.bitwiseXor(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.bitwiseXor(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  bitwiseAnd(that: AnyValue): Value;\n  bitwiseAnd(that: AnyItem): Item;\n  bitwiseAnd(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.BitwiseAndOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.bitwiseAnd(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.bitwiseAnd(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  lt(that: AnyValue): Value;\n  lt(that: AnyItem): Item;\n  lt(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.LtOperator(this, that);\n    }\n    return super.lt(that);\n  }\n\n  le(that: AnyValue): Value;\n  le(that: AnyItem): Item;\n  le(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.LeOperator(this, that);\n    }\n    return super.le(that);\n  }\n\n  eq(that: AnyValue): Value;\n  eq(that: AnyItem): Item;\n  eq(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.EqOperator(this, that);\n    }\n    return super.eq(that);\n  }\n\n  ne(that: AnyValue): Value;\n  ne(that: AnyItem): Item;\n  ne(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.NeOperator(this, that);\n    }\n    return super.ne(that);\n  }\n\n  ge(that: AnyValue): Value;\n  ge(that: AnyItem): Item;\n  ge(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.GeOperator(this, that);\n    }\n    return super.ge(that);\n  }\n\n  gt(that: AnyValue): Value;\n  gt(that: AnyItem): Item;\n  gt(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.GtOperator(this, that);\n    }\n    return super.gt(that);\n  }\n\n  plus(that: AnyValue): Value;\n  plus(that: AnyItem): Item;\n  plus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.PlusOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.plus(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.plus(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  minus(that: AnyValue): Value;\n  minus(that: AnyItem): Item;\n  minus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.MinusOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.minus(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.minus(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  times(that: AnyValue): Value;\n  times(that: AnyItem): Item;\n  times(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.TimesOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.times(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.times(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  divide(that: AnyValue): Value;\n  divide(that: AnyItem): Item;\n  divide(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.DivideOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.divide(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.divide(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  modulo(that: AnyValue): Value;\n  modulo(that: AnyItem): Item;\n  modulo(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Item.Expression) {\n      return new Item.ModuloOperator(this, that);\n    } else if (that instanceof Item.Attr) {\n      const newValue = this.modulo(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Attr(that.key, newValue);\n      }\n    } else if (that instanceof Item.Slot) {\n      const newValue = this.modulo(that.value);\n      if (newValue.isDefined()) {\n        return new Item.Slot(that.key, newValue);\n      }\n    }\n    return Item.absent();\n  }\n\n  not(): Value {\n    return Value.absent();\n  }\n\n  bitwiseNot(): Value {\n    return Value.absent();\n  }\n\n  negative(): Value {\n    return Value.absent();\n  }\n\n  positive(): Value {\n    return Value.absent();\n  }\n\n  inverse(): Value {\n    return Value.absent();\n  }\n\n  lambda(template: Value): Value {\n    return new Item.LambdaFunc(this, template);\n  }\n\n  /**\n   * Converts this `Value` into a `string` value, if possible; otherwise returns\n   * `undefined` if this `Value` can't be converted into a `string` value.\n   */\n  stringValue(): string | undefined;\n  /**\n   * Converts this `Value` into a `string` value, if possible; otherwise returns\n   * `orElse` if this `Value` can't be converted into a `string` value.\n   */\n  stringValue<T>(orElse: T): string | T;\n  stringValue<T>(orElse?: T): string | T | undefined {\n    return orElse;\n  }\n\n  /**\n   * Converts this `Value` into a `number` value, if possible; otherwise returns\n   * `undefined` if this `Value` can't be converted into a `number` value.\n   */\n  numberValue(): number | undefined;\n  /**\n   * Converts this `Value` into a `number` value, if possible; otherwise returns\n   * `orElse` if this `Value` can't be converted into a `number` value.\n   */\n  numberValue<T>(orElse: T): number | T;\n  numberValue<T>(orElse?: T): number | T | undefined {\n    return orElse;\n  }\n\n  /**\n   * Converts this `Value` into a `boolean` value, if possible; otherwise\n   * returns `undefined` if this `Value` can't be converted into a `boolean`\n   * value.\n   */\n  booleanValue(): boolean | undefined;\n  /**\n   * Converts this `Value` into a `boolean` value, if possible; otherwise\n   * returns `orElse` if this `Value` can't be converted into a `boolean` value.\n   */\n  booleanValue<T>(orElse: T): boolean | T;\n  booleanValue<T>(orElse?: T): boolean | T | undefined {\n    return orElse;\n  }\n\n  abstract toAny(): AnyValue;\n\n  isAliased(): boolean {\n    return false;\n  }\n\n  isMutable(): boolean {\n    return false;\n  }\n\n  alias(): void {\n    // nop\n  }\n\n  branch(): Value {\n    return this;\n  }\n\n  clone(): Value {\n    return this;\n  }\n\n  commit(): this {\n    return this;\n  }\n\n  keyEquals(key: unknown): boolean {\n    return false;\n  }\n\n  static builder(): Builder<Item, Value> {\n    return new ValueBuilder();\n  }\n\n  static empty(): Value {\n    return Value.Record.empty();\n  }\n\n  static extant(): Value {\n    return Value.Extant.extant();\n  }\n\n  static absent(): Value {\n    return Value.Absent.absent();\n  }\n\n  static fromAny(value: AnyValue): Value {\n    if (value instanceof Value) {\n      return value;\n    } else if (value === void 0) {\n      return Value.Absent.absent();\n    } else if (value === null) {\n      return Value.Extant.extant();\n    } else if (typeof value === \"boolean\") {\n      return Value.Bool.from(value);\n    } else if (typeof value === \"number\") {\n      return Value.Num.from(value);\n    } else if (typeof value === \"string\") {\n      return Value.Text.from(value);\n    } else if (value instanceof Uint8Array) {\n      return Value.Data.wrap(value);\n    } else if (Array.isArray(value)) {\n      return Value.Record.fromArray(value);\n    } else if (typeof value === \"object\") {\n      return Value.Record.fromObject(value as {[key: string]: AnyValue});\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n}\nItem.Value = Value;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Item} from \"./Item\";\nimport {Record} from \"./Record\";\n\n/** @hidden */\nexport class RecordCursor extends Cursor<Item> {\n  /** @hidden */\n  readonly _record: Record;\n  /** @hidden */\n  readonly _lower: number;\n  /** @hidden */\n  readonly _upper: number;\n  /** @hidden */\n  _index: number;\n  /** @hidden */\n  _direction: number;\n\n  constructor(record: Record, lower: number = 0, upper: number = record.length, index: number = lower) {\n    super();\n    this._record = record;\n    this._lower = lower;\n    this._upper = upper;\n    this._index = index;\n    this._direction = 0;\n  }\n\n  isEmpty(): boolean {\n    return this._index >= this._upper;\n  }\n\n  head(): Item {\n    this._direction = 0;\n    if (this._index < this._upper) {\n      return this._record.getItem(this._index);\n    } else {\n      throw new Error(\"empty\");\n    }\n  }\n\n  step(): void {\n    this._direction = 0;\n    if (this._index < this._upper) {\n      this._index += 1;\n    } else {\n      throw new Error(\"empty\");\n    }\n  }\n\n  skip(count: number): void {\n    this._index = Math.min(Math.max(this._lower, this._index + count, this._upper));\n  }\n\n  hasNext(): boolean {\n    return this._index < this._upper;\n  }\n\n  nextIndex(): number {\n    return this._index - this._lower;\n  }\n\n  next(): {value?: Item, done: boolean} {\n    this._direction = 1;\n    const index = this._index;\n    if (index < this._upper) {\n      this._index = index + 1;\n      return {value: this._record.getItem(index), done: this._index === this._upper};\n    } else {\n      this._index = this._upper;\n      return {done: true};\n    }\n  }\n\n  hasPrevious(): boolean {\n    return this._index > this._lower;\n  }\n\n  previousIndex(): number {\n    return this._index - this._lower - 1;\n  }\n\n  previous(): {value?: Item, done: boolean} {\n    this._direction = -1;\n    const index = this._index - 1;\n    if (index >= this._lower) {\n      this._index = index;\n      return {value: this._record.getItem(index), done: index === this._lower};\n    } else {\n      this._index = 0;\n      return {done: true};\n    }\n  }\n\n  set(newItem: Item): void {\n    if (this._direction > 0) {\n      this._record.setItem(this._index - 1, newItem);\n    } else {\n      this._record.setItem(this._index, newItem);\n    }\n  }\n\n  delete(): void {\n    if (this._direction > 0) {\n      this._index -= 1;\n    }\n    this._record.splice(this._index, 1);\n    this._direction = 0;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects, Cursor, Builder} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {AnyValue, Value} from \"./Value\";\nimport {RecordCursor} from \"./RecordCursor\";\nimport {AnyText} from \"./Text\";\nimport {AnyNum} from \"./Num\";\nimport {AnyInterpreter, Interpreter} from \"./Interpreter\";\n\nexport type AnyRecord = Record\n                      | {readonly [key: string]: AnyValue}\n                      | ReadonlyArray<unknown>; // ReadonlyArray<AnyItem>\n\nexport abstract class Record extends Value implements Builder<Item, Record> {\n  /** @hidden */\n  _hashCode?: number;\n\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  /**\n   * Returns `true` if this `Record` has no members.\n   */\n  abstract isEmpty(): boolean;\n\n  /**\n   * Returns `true` if this `Record` has only [[Value]] members–no `Field`\n   * members.\n   */\n  isArray(): boolean {\n    return this.fieldCount() === 0;\n  }\n\n  /**\n   * Returns `true` if this `Record` has only [[Field]] members–no `Value`\n   * members.\n   */\n  isObject(): boolean {\n    return this.valueCount() === 0;\n  }\n\n  /**\n   * Returns the number of members contained in this `Record`.\n   */\n  abstract get length(): number;\n\n  /**\n   * Returns the number of [[Field]] members contained in this `Record`.\n   */\n  fieldCount(): number {\n    let count = 0;\n    this.forEach(function (member: Item): void {\n      if (member instanceof Item.Field) {\n        count += 1;\n      }\n    }, this);\n    return count;\n  }\n\n  /**\n   * Returns the number of [[Value]] members contained in this `Record`.\n   */\n  valueCount(): number {\n    let count = 0;\n    this.forEach(function (member: Item): void {\n      if (member instanceof Value) {\n        count += 1;\n      }\n    }, this);\n    return count;\n  }\n\n  isConstant(): boolean {\n    return this.forEach(function (member: Item): boolean | undefined {\n      return member.isConstant() ? void 0 : false;\n    }, this) === void 0;\n  }\n\n  /**\n   * Returns the `key` string of the first member of this `Record`, if the\n   * first member is an [[Attr]]; otherwise returns `undefined` if the first\n   * member is not an `Attr`.\n   *\n   * Used to concisely get the name of the discriminating attribute of a\n   * structure.  The `tag` can be used to discern the nominal type of a\n   * polymorphic structure, similar to an XML element tag.\n   */\n  tag(): string | undefined {\n    const item = this.head();\n    if (item instanceof Item.Attr) {\n      return item.key.value;\n    }\n    return void 0;\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] members of this `Record` after\n   * all attributes have been removed.\n   *\n   * Used to concisely get the scalar value of an attributed structure.  An\n   * attributed structure is a `Record` with one or more attributes that modify\n   * one or more other members.\n   */\n  target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    this.forEach(function (item: Item): void {\n      if (item instanceof Item.Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }, this);\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Returns the sole member of this `Record`, if this `Record` has exactly one\n   * member, and its member is a `Value`; returns [[Extant]] if this `Record`\n   * is empty; otherwise returns `this` if this `Record` has more than one\n   * member.\n   *\n   * Used to convert a unary `Record` into its member `Value`.  Facilitates\n   * writing code that treats a unary `Record` equivalently to a bare `Value`.\n   */\n  flattened(): Value {\n    if (this.isEmpty()) {\n      return Value.extant();\n    } else {\n      const items = this.iterator();\n      const head = items.head();\n      items.step();\n      if (items.isEmpty() && head instanceof Value) {\n        return head;\n      } else {\n        return this.branch();\n      }\n    }\n  }\n\n  /**\n   * Returns `this` `Record.\n   */\n  unflattened(): Record {\n    return this;\n  }\n\n  /**\n   * Returns the value of the first member of this `Record`, if the first\n   * member is an [[Attr]] whose `key` string is equal to `tag`; otherwise\n   * returns [[Absent]] if the first member of this `Record` is not an `Attr`,\n   * or if the first member of this `Record` is an `Attr` whose `key` does not\n   * equal the `tag`.\n   *\n   * Used to conditionally get the value of the head `Attr` of a structure, if\n   * and only if the key string of the head `Attr` is equal to the `tag`.  Can\n   * be used to check if a structure might conform to a nominal type named\n   * `tag`, while simultaneously getting the value of the `tag` attribute.\n   */\n  header(tag: string): Value {\n    const head = this.head();\n    if (head instanceof Item.Attr && head.key.value === tag) {\n      return head.value;\n    } else {\n      return Value.absent();\n    }\n  }\n\n  /**\n   * Returns the [[Record.unflattened unflattened]] [[Record.header header]] of\n   * this `Record`.  The `headers` of the `tag` attribute of a structure are\n   * like the attributes of an XML element tag; through unlike an XML element,\n   * `tag` attribute headers are not limited to string keys and values.\n   */\n  headers(tag: string): Record | undefined {\n    const head = this.head();\n    if (head instanceof Item.Attr && head.key.value === tag) {\n      const header = head.value;\n      if (header instanceof Record) {\n        return header;\n      } else {\n        return Record.of(header);\n      }\n    }\n    return void 0;\n  }\n\n  /**\n   * Returns the first member of this `Record`, if this `Record` is non-empty;\n   * otherwise returns [[Absent]].\n   */\n  head(): Item {\n    return this.forEach(function (item: Item): Item {\n      return item;\n    }, this) || Item.absent();\n  }\n\n  /**\n   * Returns a view of all but the first member of this `Record`, if this\n   * `Record` is non-empty; otherwise returns an empty `Record`, if this\n   * `Record` is itself empty.\n   */\n  tail(): Record {\n    const tail = Record.create();\n    this.forEach(function (item: Item, index: number): void {\n      if (index > 0) {\n        tail.push(item);\n      }\n    }, this);\n    return tail;\n  }\n\n  /**\n   * Returns the [[Record.flattened flattened]] [[Record.tail tail]] of this\n   * `Record`.  Used to recursively deconstruct a structure, terminating\n   * with its last `Value`, rather than a unary `Record` containing its last\n   * value, if the structure ends with a `Value` member.\n   */\n  body(): Value {\n    const tail = this.tail();\n    if (!tail.isEmpty()) {\n      return tail.flattened();\n    } else {\n      return Value.absent();\n    }\n  }\n\n  /**\n   * Returns `true` if this `Record` has a [[Field]] member with a key that is\n   * equal to the given `key`; otherwise returns `false` if this `Record` has\n   * no `Field` member with a key equal to the given `key`.\n   */\n  has(key: AnyValue): boolean {\n    key = Value.fromAny(key);\n    return this.forEach(function (item: Item): boolean | undefined {\n      return item instanceof Item.Field && item.key.equals(key) ? true : void 0;\n    }, this) || false;\n  }\n\n  indexOf(item: AnyItem, index: number = 0): number {\n    item = Item.fromAny(item);\n    if (index < 0) {\n      index = Math.max(0, this.length + index);\n    }\n    const i = this.forEach(function (member: Item, i: number): number | undefined {\n      return i >= index && (item as Item).equals(member) ? i : void 0;\n    }, this);\n    return i !== void 0 ? i : -1;\n  }\n\n  lastIndexOf(item: AnyItem, index?: number): number {\n    item = Item.fromAny(item);\n    const n = this.length;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = Math.min(index, n - 1);\n    while (index >= 0) {\n      if (item.equals(this.getItem(index))) {\n        return index;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  /**\n   * Returns the value of the last [[Field]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Field` member with a key equal to the given `key`.\n   */\n  get(key: AnyValue): Value {\n    key = Value.fromAny(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Item.Field && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Attr]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Attr` member with a key equal to the given `key`.\n   */\n  getAttr(key: AnyText): Value {\n    key = Value.Text.fromAny(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Item.Attr && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the value of the last [[Slot]] member of this `Record` whose key\n   * is equal to the given `key`; returns [[Absent]] if this `Record` has no\n   * `Slot` member with a key equal to the given `key`.\n   */\n  getSlot(key: AnyValue): Value {\n    key = Value.fromAny(key);\n    return this.forEach(function (item: Item): Value | undefined {\n      return item instanceof Item.Slot && item.key.equals(key) ? item.value : void 0;\n    }, this) || Value.absent();\n  }\n\n  /**\n   * Returns the last [[Field]] member of this `Record` whose key is equal to\n   * the given `key`; returns `undefined` if this `Record` has no `Field` member\n   * with a `key` equal to the given `key`.\n   */\n  getField(key: AnyValue): Field | undefined {\n    key = Value.fromAny(key);\n    return this.forEach(function (item: Item): Field | undefined {\n      return item instanceof Item.Field && item.key.equals(key) ? item : void 0;\n    }, this);\n  }\n\n  /**\n   * Returns the member of this `Record` at the given `index`, if the `index`\n   * is greater than or equal to zero, and less than the [[Record.length\n   * length]] of this `Record`; otherwise returns [[Absent]] if the `index` is\n   * out of bounds.\n   */\n  abstract getItem(index: AnyNum): Item;\n\n  set(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        if (item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(item.updatedValue(newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Item.Slot(key, newValue));\n    return this;\n  }\n\n  setAttr(key: AnyText, newValue: AnyValue): this {\n    key = Value.Text.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        if (item instanceof Item.Attr && item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(new Item.Attr(key, newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Item.Attr(key, newValue));\n    return this;\n  }\n\n  setSlot(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const items = this.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        if (item instanceof Item.Slot && item.isMutable()) {\n          item.setValue(newValue);\n        } else {\n          items.set(new Item.Slot(key, newValue));\n        }\n        return this;\n      }\n      items.step();\n    }\n    this.push(new Item.Slot(key, newValue));\n    return this;\n  }\n\n  /**\n   * Replaces the member of this `Record` at the given `index` with a new\n   * `item`, returning {@code this} {@code Record}, if the {@code index} is\n   * greater than or equal to zero, and less than the [[Record.length length]]\n   * of this {@code Record}.\n   *\n   * @throws `Error` if this is an immutable `Record`.\n   * @throws `RangeError` if the `index` is out of bounds.\n   */\n  abstract setItem(index: number, item: AnyItem): this;\n\n  updated(key: AnyValue, value: AnyValue): Record {\n    key = Value.fromAny(key);\n    value = Value.fromAny(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Item.Field && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Item.Slot(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Item.Slot(key, value));\n    return record;\n  }\n\n  updatedAttr(key: AnyText, value: AnyValue): Record {\n    key = Value.Text.fromAny(key);\n    value = Value.fromAny(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Item.Attr && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Item.Attr(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Item.Attr(key, value));\n    return record;\n  }\n\n  updatedSlot(key: AnyValue, value: AnyValue): Record {\n    key = Value.fromAny(key);\n    value = Value.fromAny(value);\n    const record = this.isMutable() ? this : this.branch();\n    const items = record.iterator();\n    while (!items.isEmpty()) {\n      const item = items.head();\n      if (item.key.equals(key)) {\n        if (item instanceof Item.Slot && item.isMutable()) {\n          item.setValue(value);\n        } else {\n          items.set(new Item.Slot(key, value));\n        }\n        return record;\n      }\n      items.step();\n    }\n    record.push(new Item.Slot(key, value));\n    return record;\n  }\n\n  abstract push(...items: AnyItem[]): number;\n\n  abstract splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];\n\n  abstract delete(key: AnyValue): Item;\n\n  abstract clear(): void;\n\n  appended(...items: AnyItem[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.push.apply(record, arguments);\n    return record;\n  }\n\n  prepended(...items: AnyItem[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.splice.apply(record, Array.prototype.concat.apply([0, 0], arguments));\n    return record;\n  }\n\n  deleted(key: AnyValue): Record {\n    const record = this.isMutable() ? this : this.branch();\n    record.delete(key);\n    return record;\n  }\n\n  concat(...items: AnyItem[]): Record {\n    const record = this.isMutable() ? this : this.branch();\n    for (let i = 0, n = arguments.length; i < n; i += 1) {\n      Item.fromAny(arguments[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  slice(lower?: number, upper?: number): Record {\n    return this.subRecord.apply(this, arguments).branch();\n  }\n\n  attr(key: AnyText, value?: AnyValue): this {\n    this.push(Item.Attr.of.apply(void 0, arguments));\n    return this;\n  }\n\n  slot(key: AnyValue, value?: AnyValue): this {\n    this.push(Item.Slot.of.apply(void 0, arguments));\n    return this;\n  }\n\n  item(item: AnyItem): this {\n    this.push(item);\n    return this;\n  }\n\n  items(...items: AnyItem[]): this {\n    this.push.apply(this, arguments);\n    return this;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Record {\n    interpreter = Interpreter.fromAny(interpreter);\n    const scope = Record.create();\n    interpreter.pushScope(scope);\n    let changed = false;\n    this.forEach(function (oldItem: Item): void {\n      const newItem = oldItem.evaluate(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }, this);\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  substitute(interpreter: AnyInterpreter): Record {\n    interpreter = Interpreter.fromAny(interpreter);\n    const scope = Record.create();\n    interpreter.pushScope(scope);\n    let changed = false;\n    this.forEach(function (oldItem: Item) {\n      const newItem = oldItem.substitute(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }, this);\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  stringValue(): string | undefined;\n  stringValue<T>(orElse: T): string | T;\n  stringValue<T>(orElse?: T): string | T | undefined {\n    let recordString = \"\";\n    const defined = this.forEach(function (item: Item): null | void {\n      if (item instanceof Value) {\n        const itemString = item.stringValue();\n        if (itemString !== void 0) {\n          recordString += itemString;\n          return;\n        }\n      }\n      return null; // break\n    }, this) === void 0;\n    return defined ? recordString : void 0;\n  }\n\n  toAny(): AnyValue {\n    if (!this.isEmpty() && this.isArray()) {\n      return this.toArray();\n    } else {\n      return this.toObject();\n    }\n  }\n\n  toArray(): AnyItem[] {\n    const array = new Array<AnyItem>(this.length);\n    this.forEach(function (item: Item, index: number): void {\n      if (item instanceof Value) {\n        array[index] = item.toAny();\n      } else if (item instanceof Item.Field) {\n        array[index] = {\n          $key: item.key.toAny(),\n          $value: item.value.toAny(),\n        };\n      }\n    }, this);\n    return array;\n  }\n\n  toObject(): {[key: string]: AnyValue} {\n    const object = {} as {[key: string]: AnyValue};\n    this.forEach(function (item: Item, index: number): void {\n      if (item instanceof Item.Attr) {\n        object[\"@\" + item.key.value] = item.value.toAny();\n      } else if (item instanceof Item.Slot) {\n        if (item.key instanceof Value.Text) {\n          object[item.key.value] = item.value.toAny();\n        } else {\n          object[\"$\" + index] = {\n            $key: item.key.toAny(),\n            $value: item.value.toAny(),\n          };\n        }\n      } else if (item instanceof Value) {\n        object[\"$\" + index] = item.toAny();\n      }\n    }, this);\n    return object;\n  }\n\n  isAliased(): boolean {\n    return false;\n  }\n\n  isMutable(): boolean {\n    return true;\n  }\n\n  alias(): void {\n    // nop\n  }\n\n  branch(): Record {\n    const branch = Record.create();\n    this.forEach(function (item: Item): void {\n      branch.push(item);\n    }, this);\n    return branch;\n  }\n\n  clone(): Record {\n    const clone = Record.create();\n    this.forEach(function (item: Item): void {\n      clone.push(item.clone());\n    }, this);\n    return clone;\n  }\n\n  commit(): this {\n    return this;\n  }\n\n  bind(): Record {\n    return this;\n  }\n\n  subRecord(lower?: number, upper?: number): Record {\n    const n = this.length;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    lower = Math.min(Math.max(0, lower), n);\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    const record = Value.Record.create();\n    this.forEach(function (item: Item, index: number): null | void {\n      if (index < lower!) {\n        return;\n      } else if (index < upper!) {\n        record.push(item);\n        return;\n      } else {\n        return null;\n      }\n    }, this);\n    return record;\n  }\n\n  abstract forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                                   thisArg?: S): T | undefined;\n\n  iterator(): Cursor<Item> {\n    return new RecordCursor(this);\n  }\n\n  typeOrder(): number {\n    return 3;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Record) {\n      const xs = this.iterator();\n      const ys = that.iterator();\n      let order = 0 as 0 | 1 | -1;\n      do {\n        if (!xs.isEmpty() && !ys.isEmpty()) {\n          order = xs.head().compareTo(ys.head());\n          xs.step();\n          ys.step();\n        } else {\n          break;\n        }\n      } while (order === 0);\n      if (order !== 0) {\n        return order;\n      } else if (xs.isEmpty() && !ys.isEmpty()) {\n        return -1;\n      } else if (!xs.isEmpty() && ys.isEmpty()) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Record) {\n      const xs = this.iterator();\n      const ys = that.iterator();\n      while (!xs.isEmpty() && !ys.isEmpty()) {\n        if (!xs.head().equals(ys.head())) {\n          return false;\n        }\n        xs.step();\n        ys.step();\n      }\n      return xs.isEmpty() && ys.isEmpty();\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      if (Record._hashSeed === void 0) {\n        Record._hashSeed = Murmur3.seed(Record);\n      }\n      let code = Record._hashSeed;\n      this.forEach(function (item: Item): void {\n        code = Murmur3.mix(code, item.hashCode());\n      }, this);\n      this._hashCode = Murmur3.mash(code);\n    }\n    return this._hashCode;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Record\").write(46/*'.'*/);\n    if (this.isEmpty()) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"of\").write(40/*'('*/);\n      this.forEach(function (item: Item, index: number): void {\n        if (index !== 0) {\n          output = output.write(44/*','*/).write(32/*' '*/);\n        }\n        output.display(item);\n      }, this);\n      output = output.write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    this.debug(output);\n  }\n\n  /** @hidden */\n  static readonly ALIASED: number = 1;\n  /** @hidden */\n  static readonly IMMUTABLE: number = 2;\n\n  private static _hashSeed?: number;\n\n  static empty(): Record {\n    return Record.RecordMap.empty();\n  }\n\n  static create(initialCapacity?: number): Record {\n    return Record.RecordMap.create(initialCapacity);\n  }\n\n  static of(...items: AnyItem[]): Record {\n    return Record.RecordMap.of.apply(void 0, arguments);\n  }\n\n  static fromAny(value: AnyRecord): Record {\n    if (value instanceof Record) {\n      return value;\n    } else if (Array.isArray(value)) {\n      return Record.fromArray(value);\n    } else if (value && typeof value === \"object\") {\n      return Record.fromObject(value as {[key: string]: AnyValue});\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  static fromArray(array: {[index: number]: AnyItem, length?: number}): Record {\n    const n = array.length || 0;\n    const record = Record.create(n);\n    for (let i = 0; i < n; i += 1) {\n      record.push(Item.fromAny(array[i]));\n    }\n    return record;\n  }\n\n  static fromObject(object: {[key: string]: AnyValue}): Record {\n    const record = Record.create();\n    for (const key in object) {\n      const value = object[key];\n      if (key.charCodeAt(0) === 36/*'$'*/) {\n        if (!value || typeof value !== \"object\" || !value.hasOwnProperty(\"$key\")) {\n          record.push(Value.fromAny(value));\n        } else {\n          record.push(Item.Field.of((value as any).$key, (value as any).$value));\n        }\n      } else {\n        record.push(Item.Field.of(key, value));\n      }\n    }\n    return record;\n  }\n\n  /** @hidden */\n  static expand(n: number): number {\n    n = Math.max(8, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\nItem.Record = Record;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"./Item\";\nimport {Field} from \"./Field\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {AnyText, Text} from \"./Text\";\nimport {AnyNum} from \"./Num\";\nimport {AnyInterpreter, Interpreter} from \"./Interpreter\";\n\n/** @hidden */\nexport class RecordMap extends Record {\n  /** @hidden */\n  _array: Array<Item> | null;\n  /** @hidden */\n  _table: Array<Field> | null;\n  /** @hidden */\n  _itemCount: number;\n  /** @hidden */\n  _fieldCount: number;\n  /** @hidden */\n  _flags: number;\n\n  constructor(array: Array<Item> | null, table: Array<Field> | null,\n              itemCount: number, fieldCount: number, flags: number) {\n    super();\n    this._array = array;\n    this._table = table;\n    this._itemCount = itemCount;\n    this._fieldCount = fieldCount;\n    this._flags = flags;\n  }\n\n  isEmpty(): boolean {\n    return this._itemCount === 0;\n  }\n\n  get length(): number {\n    return this._itemCount;\n  }\n\n  fieldCount(): number {\n    return this._fieldCount;\n  }\n\n  valueCount(): number {\n    return this._itemCount - this._fieldCount;\n  }\n\n  isConstant(): boolean {\n    const array = this._array;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      if (!array![i]!.isConstant()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  tag(): string | undefined {\n    if (this._fieldCount > 0) {\n      const head = this._array![0];\n      if (head instanceof Item.Attr) {\n        return head.key.value;\n      }\n    }\n    return void 0;\n  }\n\n  target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    const array = this._array!;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    } else {\n      return this;\n    }\n  }\n\n  head(): Item {\n    if (this._itemCount > 0) {\n      return this._array![0];\n    }\n    return Item.absent();\n  }\n\n  tail(): Record {\n    const n = this._itemCount;\n    if (n > 0) {\n      return new Record.RecordMapView(this, 1, n);\n    } else {\n      return Record.empty();\n    }\n  }\n\n  body(): Value {\n    const n = this._itemCount;\n    if (n > 2) {\n      return new Record.RecordMapView(this, 1, n).branch();\n    } else if (n === 2) {\n      const item = this._array![1];\n      if (item instanceof Value) {\n        return item;\n      } else {\n        return Record.of(item);\n      }\n    }\n    return Value.absent();\n  }\n\n  has(key: AnyValue): boolean {\n    if (this._fieldCount !== 0) {\n      key = Value.fromAny(key);\n      const table = this.hashTable()!;\n      const n = table.length;\n      //assert(n > 0);\n      const x = Math.abs(key.hashCode() % n);\n      let i = x;\n      do {\n        const field = table[i];\n        if (field !== void 0) {\n          if (field.key.equals(key)) {\n            return true;\n          }\n        } else {\n          break;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n    }\n    return false;\n  }\n\n  indexOf(item: AnyItem, index: number = 0): number {\n    item = Item.fromAny(item);\n    const array = this._array!;\n    const n = this._itemCount;\n    if (index < 0) {\n      index = Math.max(0, n + index);\n    }\n    while (index < n) {\n      if (item.equals(array[index])) {\n        return index;\n      }\n      index += 1;\n    }\n    return -1;\n  }\n\n  lastIndexOf(item: AnyItem, index?: number): number {\n    item = Item.fromAny(item);\n    const array = this._array!;\n    const n = this._itemCount;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = Math.min(index, n - 1);\n    while (index >= 0) {\n      if (item.equals(array[index])) {\n        return index;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  get(key: AnyValue): Value {\n    if (this._fieldCount > 0) {\n      key = Value.fromAny(key);\n      const table = this.hashTable()!;\n      const n = table.length;\n      //assert(n > 0);\n      const x = Math.abs(key.hashCode() % n);\n      let i = x;\n      do {\n        const field = table[i];\n        if (field !== void 0) {\n          if (field.key.equals(key)) {\n            return field.value;\n          }\n        } else {\n          break;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n    }\n    return Value.absent();\n  }\n\n  getAttr(key: AnyText): Value {\n    if (this._fieldCount > 0) {\n      key = Value.Text.fromAny(key);\n      const table = this.hashTable()!;\n      const n = table.length;\n      //assert(n > 0);\n      const x = Math.abs(key.hashCode() % n);\n      let i = x;\n      do {\n        const field = table[i];\n        if (field !== void 0) {\n          if (field instanceof Item.Attr && field.key.equals(key)) {\n            return field.value;\n          }\n        } else {\n          break;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n    }\n    return Value.absent();\n  }\n\n  getSlot(key: AnyValue): Value {\n    if (this._fieldCount > 0) {\n      key = Value.fromAny(key);\n      const table = this.hashTable()!;\n      const n = table.length;\n      //assert(n > 0);\n      const x = Math.abs(key.hashCode() % n);\n      let i = x;\n      do {\n        const field = table[i];\n        if (field !== void 0) {\n          if (field instanceof Item.Slot && field.key.equals(key)) {\n            return field.value;\n          }\n        } else {\n          break;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n    }\n    return Value.absent();\n  }\n\n  getField(key: AnyValue): Field | undefined {\n    if (this._fieldCount > 0) {\n      key = Value.fromAny(key);\n      const table = this.hashTable()!;\n      const n = table.length;\n      //assert(n > 0);\n      const x = Math.abs(key.hashCode() % n);\n      let i = x;\n      do {\n        const field = table[i];\n        if (field !== void 0) {\n          if (field.key.equals(key)) {\n            return field;\n          }\n        } else {\n          break;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n    }\n    return void 0;\n  }\n\n  getItem(index: AnyNum): Item {\n    if (index instanceof Item.Num) {\n      index = index.value;\n    }\n    const n = this._itemCount;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index >= 0 && index < n) {\n      return this._array![index];\n    } else {\n      return Item.absent();\n    }\n  }\n\n  set(key: AnyValue, newValue: Value): this {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    if ((this._flags & Record.ALIASED) !== 0) {\n      if (this._fieldCount > 0) {\n        this.setAliased(key, newValue);\n      } else {\n        this.pushAliased(new Item.Slot(key, newValue));\n      }\n    } else {\n      if (this._fieldCount > 0) {\n        if (this._table !== null) {\n          this.setMutable(key, newValue);\n        } else {\n          this.updateMutable(key, newValue);\n        }\n      } else {\n        this.pushMutable(new Item.Slot(key, newValue));\n      }\n    }\n    return this;\n  }\n\n  private setAliased(key: Value, newValue: Value): void {\n    const n = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        newArray[i] = item.updatedValue(newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        this._array = newArray;\n        this._table = null;\n        this._flags &= ~Record.ALIASED;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Item.Slot(key, newValue);\n    this._array = newArray;\n    this._table = null;\n    this._itemCount = n + 1;\n    this._fieldCount += 1;\n    this._flags &= ~Record.ALIASED;\n  }\n\n  private setMutable(key: Value, newValue: Value): void {\n    const table = this._table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field !== void 0) {\n        if (field.key.equals(key)) {\n          if (field.isMutable()) {\n            field.setValue(newValue);\n            return;\n          } else {\n            this.updateMutable(key, newValue);\n            return;\n          }\n        }\n      } else {\n        break;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Item.Slot(key, newValue);\n    this.pushMutable(field);\n    RecordMap.put(table, field);\n  }\n\n  private updateMutable(key: Value, newValue: Value): void {\n    const array = this._array!;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        array[i] = item.updatedValue(newValue);\n        this._table = null;\n        return;\n      }\n    }\n    const field = new Item.Slot(key, newValue);\n    this.pushMutable(field);\n    RecordMap.put(this._table, field);\n  }\n\n  setAttr(key: AnyText, newValue: Value): this {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.Text.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    if ((this._flags & Record.ALIASED) !== 0) {\n      if (this._fieldCount > 0) {\n        this.setAttrAliased(key, newValue);\n      } else {\n        this.pushAliased(new Item.Attr(key, newValue));\n      }\n    } else {\n      if (this._fieldCount > 0) {\n        if (this._table !== null) {\n          this.setAttrMutable(key, newValue);\n        } else {\n          this.updateAttrMutable(key, newValue);\n        }\n      } else {\n        this.pushMutable(new Item.Attr(key, newValue));\n      }\n    }\n    return this;\n  }\n\n  private setAttrAliased(key: Text, newValue: Value): void {\n    const n = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        newArray[i] = new Item.Attr(key, newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        this._array = newArray;\n        this._table = null;\n        this._flags &= ~Record.ALIASED;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Item.Attr(key, newValue);\n    this._array = newArray;\n    this._table = null;\n    this._itemCount = n + 1;\n    this._fieldCount += 1;\n    this._flags &= ~Record.ALIASED;\n  }\n\n  private setAttrMutable(key: Text, newValue: Value): void {\n    const table = this._table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field !== void 0) {\n        if (field.key.equals(key)) {\n          if (field instanceof Item.Attr && field.isMutable()) {\n            field.setValue(newValue);\n          } else {\n            this.updateAttrMutable(key, newValue);\n          }\n          return;\n        }\n      } else {\n        break;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Item.Attr(key, newValue);\n    this.push(field);\n    RecordMap.put(table, field);\n  }\n\n  private updateAttrMutable(key: Text, newValue: Value): void {\n    const array = this._array!;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        array[i] = new Item.Attr(key, newValue);\n        this._table = null;\n        return;\n      }\n    }\n    const field = new Item.Attr(key, newValue);\n    this.push(field);\n    RecordMap.put(this._table, field);\n  }\n\n  setSlot(key: AnyValue, newValue: Value): this {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    if ((this._flags & Record.ALIASED) !== 0) {\n      if (this._fieldCount > 0) {\n        this.setSlotAliased(key, newValue);\n      } else {\n        this.pushAliased(new Item.Slot(key, newValue));\n      }\n    } else {\n      if (this._fieldCount > 0) {\n        if (this._table !== null) {\n          this.setSlotMutable(key, newValue);\n        } else {\n          this.updateSlotMutable(key, newValue);\n        }\n      } else {\n        this.pushMutable(new Item.Slot(key, newValue));\n      }\n    }\n    return this;\n  }\n\n  private setSlotAliased(key: Value, newValue: Value): void {\n    const n = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(n + 1));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        newArray[i] = new Item.Slot(key, newValue);\n        i += 1;\n        while (i < n) {\n          newArray[i] = oldArray[i];\n          i += 1;\n        }\n        this._array = newArray;\n        this._table = null;\n        this._flags &= ~Record.ALIASED;\n        return;\n      }\n      newArray[i] = item;\n    }\n    newArray[n] = new Item.Slot(key, newValue);\n    this._array = newArray;\n    this._table = null;\n    this._itemCount = n + 1;\n    this._fieldCount += 1;\n    this._flags &= ~Record.ALIASED;\n  }\n\n  private setSlotMutable(key: Value, newValue: Value): void {\n    const table = this._table!;\n    const n = table.length;\n    //assert(n > 0);\n    const x = Math.abs(key.hashCode() % n);\n    let i = x;\n    do {\n      const field = table[i];\n      if (field !== void 0) {\n        if (field.key.equals(key)) {\n          if (field instanceof Item.Slot && field.isMutable()) {\n            field.setValue(newValue);\n          } else {\n            this.updateSlotMutable(key, newValue);\n          }\n          return;\n        }\n      } else {\n        break;\n      }\n      i = (i + 1) % n;\n    } while (i !== x);\n    const field = new Item.Slot(key, newValue);\n    this.push(field);\n    RecordMap.put(table, field);\n  }\n\n  private updateSlotMutable(key: Value, newValue: Value): void {\n    const array = this._array!;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        array[i] = new Item.Slot(key, newValue);\n        this._table = null;\n        return;\n      }\n    }\n    const field = new Item.Slot(key, newValue);\n    this.push(field);\n    RecordMap.put(this._table, field);\n  }\n\n  setItem(index: number, newItem: AnyItem): this {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    newItem = Item.fromAny(newItem);\n    const n = this._itemCount;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index > n) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((this._flags & Record.ALIASED) !== 0) {\n      this.setItemAliased(index, newItem);\n    } else {\n      this.setItemMutable(index, newItem);\n    }\n    return this;\n  }\n\n  private setItemAliased(index: number, newItem: Item): void {\n    const n = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      newArray[i] = oldArray[i];\n    }\n    const oldItem = oldArray[index];\n    newArray[index] = newItem;\n    this._array = newArray;\n    this._table = null;\n    if (newItem instanceof Item.Field) {\n      if (!(oldItem instanceof Item.Field)) {\n        this._fieldCount += 1;\n      }\n    } else if (oldItem instanceof Item.Field) {\n      this._fieldCount -= 1;\n    }\n    this._flags &= ~Record.ALIASED;\n  }\n\n  private setItemMutable(index: number, newItem: Item): void {\n    const array = this._array!;\n    const oldItem = array[index];\n    array[index] = newItem;\n    if (newItem instanceof Item.Field) {\n      this._table = null;\n      if (!(oldItem instanceof Item.Field)) {\n        this._fieldCount += 1;\n      }\n    } else if (oldItem instanceof Item.Field) {\n      this._table = null;\n      this._fieldCount -= 1;\n    }\n  }\n\n  updated(key: AnyValue, newValue: AnyValue): Record {\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();\n    if ((record._flags & Record.ALIASED) !== 0) {\n      if (record._fieldCount > 0) {\n        record.setAliased(key, newValue);\n      } else {\n        record.pushAliased(new Item.Slot(key, newValue));\n      }\n    } else {\n      if (record._fieldCount > 0) {\n        if (record._table !== null) {\n          record.setMutable(key, newValue);\n        } else {\n          record.updateMutable(key, newValue);\n        }\n      } else {\n        record.pushMutable(new Item.Slot(key, newValue));\n      }\n    }\n    return record;\n  }\n\n  updatedAttr(key: AnyText, newValue: AnyValue): Record {\n    key = Value.Text.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();\n    if ((record._flags & Record.ALIASED) !== 0) {\n      if (record._fieldCount > 0) {\n        record.setAttrAliased(key, newValue);\n      } else {\n        record.pushAliased(new Item.Attr(key, newValue));\n      }\n    } else {\n      if (record._fieldCount > 0) {\n        if (record._table !== null) {\n          record.setAttrMutable(key, newValue);\n        } else {\n          record.updateAttrMutable(key, newValue);\n        }\n      } else {\n        record.pushMutable(new Item.Attr(key, newValue));\n      }\n    }\n    return record;\n  }\n\n  updatedSlot(key: AnyValue, newValue: AnyValue): Record {\n    key = Value.fromAny(key);\n    newValue = Value.fromAny(newValue);\n    const record = (this._flags & Record.IMMUTABLE) === 0 ? this : this.branch();\n    if ((record._flags & Record.ALIASED) !== 0) {\n      if (record._fieldCount > 0) {\n        record.setSlotAliased(key, newValue);\n      } else {\n        record.pushAliased(new Item.Slot(key, newValue));\n      }\n    } else {\n      if (record._fieldCount > 0) {\n        if (record._table !== null) {\n          record.setSlotMutable(key, newValue);\n        } else {\n          record.updateSlotMutable(key, newValue);\n        }\n      } else {\n        record.pushMutable(new Item.Slot(key, newValue));\n      }\n    }\n    return record;\n  }\n\n  push(...newItems: AnyItem[]): number {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this._flags & Record.ALIASED) !== 0) {\n      this.pushAliased.apply(this, arguments);\n    } else {\n      this.pushMutable.apply(this, arguments);\n    }\n    return this._itemCount;\n  }\n\n  private pushAliased(...newItems: AnyItem[]): void {\n    const k = arguments.length;\n    let m = this._itemCount;\n    let n = this._fieldCount;\n    const oldArray = this._array;\n    const newArray = new Array(Record.expand(m + k));\n    if (oldArray !== null) {\n      for (let i = 0; i < m; i += 1) {\n        newArray[i] = oldArray[i];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(arguments[i]);\n      newArray[m] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n      }\n    }\n    this._array = newArray;\n    this._table = null;\n    this._itemCount = m;\n    this._fieldCount = n;\n    this._flags &= ~Record.ALIASED;\n  }\n\n  private pushMutable(...newItems: AnyItem[]): void {\n    const k = arguments.length;\n    let m = this._itemCount;\n    let n = this._fieldCount;\n    const oldArray = this._array;\n    let newArray;\n    if (oldArray === null || m + k > oldArray.length) {\n      newArray = new Array(Record.expand(m + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < m; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(arguments[i]);\n      newArray[m] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n        this._table = null;\n      }\n    }\n    this._array = newArray;\n    this._itemCount = m;\n    this._fieldCount = n;\n  }\n\n  splice(start: number, deleteCount: number = 0, ...newItems: AnyItem[]): Item[] {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const n = this._itemCount;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.min(Math.max(0, start), n);\n    deleteCount = Math.min(Math.max(0, deleteCount), n - start);\n    if ((this._flags & Record.ALIASED) !== 0) {\n      return this.spliceAliased.apply(this, arguments);\n    } else {\n      return this.spliceMutable.apply(this, arguments);\n    }\n  }\n\n  /** @hidden */\n  spliceAliased(start: number, deleteCount: number, ...newItems: AnyItem[]): Item[] {\n    const k = newItems.length;\n    let m = this._itemCount;\n    let n = this._fieldCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(m - deleteCount + k));\n    for (let i = 0; i < start; i += 1) {\n      newArray[i] = oldArray[i];\n    }\n    const oldItems = [];\n    for (let i = start; i < start + deleteCount; i += 1) {\n      const oldItem = oldArray[i];\n      oldItems.push(oldItem);\n      m -= 1;\n      if (oldItem instanceof Item.Field) {\n        n -= 1;\n      }\n    }\n    for (let i = start; i < m; i += 1) {\n      newArray[i + k] = oldArray[i + deleteCount];\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(newItems[i]);\n      newArray[i + start] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n      }\n    }\n    this._array = newArray;\n    this._table = null;\n    this._itemCount = m;\n    this._fieldCount = n;\n    this._flags &= ~Record.ALIASED;\n    return oldItems;\n  }\n\n  /** @hidden */\n  spliceMutable(start: number, deleteCount: number, ...newItems: AnyItem[]): Item[] {\n    const k = newItems.length;\n    let m = this._itemCount;\n    let n = this._fieldCount;\n    const oldArray = this._array!;\n    let newArray;\n    if (oldArray === null || m - deleteCount + k > oldArray.length) {\n      newArray = new Array(Record.expand(m - deleteCount + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < start; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    const oldItems = [];\n    for (let i = start; i < start + deleteCount; i += 1) {\n      const oldItem = oldArray[i];\n      oldItems.push(oldItem);\n      m -= 1;\n      if (oldItem instanceof Item.Field) {\n        n -= 1;\n      }\n    }\n    if (k > deleteCount) {\n      for (let i = m - 1; i >= start; i -= 1) {\n        newArray[i + k] = oldArray[i + deleteCount];\n      }\n    } else {\n      for (let i = start; i < m; i += 1) {\n        newArray[i + k] = oldArray[i + deleteCount];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(newItems[i]);\n      newArray[i + start] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n      }\n    }\n    this._array = newArray;\n    this._itemCount = m;\n    this._fieldCount = n;\n    return oldItems;\n  }\n\n  delete(key: AnyValue): Item {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromAny(key);\n    if ((this._flags & Record.ALIASED) !== 0) {\n      return this.deleteAliased(key);\n    } else {\n      return this.deleteMutable(key);\n    }\n  }\n\n  private deleteAliased(key: Value): Item {\n    const n = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          newArray[i] = oldArray[j];\n        }\n        this._array = newArray;\n        this._table = null;\n        this._itemCount = n - 1;\n        this._fieldCount -= 1;\n        this._flags &= ~Record.ALIASED;\n        return item;\n      }\n      newArray[i] = item;\n    }\n    return Item.absent();\n  }\n\n  private deleteMutable(key: Value): Item {\n    const n = this._itemCount;\n    const array = this._array!;\n    for (let i = 0; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          array[i] = array[j];\n        }\n        array[n - 1] = void 0 as any;\n        this._table = null;\n        this._itemCount = n - 1;\n        this._fieldCount -= 1;\n        return item;\n      }\n    }\n    return Item.absent();\n  }\n\n  clear(): void {\n    if ((this._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    this._array = null;\n    this._table = null;\n    this._itemCount = 0;\n    this._fieldCount = 0;\n    this._flags = 0;\n  }\n\n  isAliased(): boolean {\n    return (this._flags & Record.ALIASED) !== 0;\n  }\n\n  isMutable(): boolean {\n    return (this._flags & Record.IMMUTABLE) === 0;\n  }\n\n  alias(): void {\n    this._flags |= Record.ALIASED;\n  }\n\n  branch(): RecordMap {\n    if ((this._flags & (Record.ALIASED | Record.IMMUTABLE)) === 0) {\n      const array = this._array!;\n      for (let i = 0, n = this._itemCount; i < n; i += 1) {\n        array[i].alias();\n      }\n    }\n    this._flags |= Record.ALIASED;\n    return new RecordMap(this._array, this._table, this._itemCount, this._fieldCount, Record.ALIASED);\n  }\n\n  clone(): RecordMap {\n    const itemCount = this._itemCount;\n    const oldArray = this._array!;\n    const newArray = new Array(itemCount);\n    for (let i = 0; i < itemCount; i += 1) {\n      newArray[i] = oldArray[i].clone();\n    }\n    return new RecordMap(newArray, null, itemCount, this._fieldCount, 0);\n  }\n\n  commit(): this {\n    if ((this._flags & Record.IMMUTABLE) === 0) {\n      this._flags |= Record.IMMUTABLE;\n      const array = this._array!;\n      for (let i = 0, n = this._itemCount; i < n; i += 1) {\n        array[i].commit();\n      }\n    }\n    return this;\n  }\n\n  hashTable(): Array<Field> | null {\n    const n = this._fieldCount;\n    let table = this._table;\n    if (n !== 0 && this._table === null) {\n      table = new Array(Record.expand(Math.max(n, n * 10 / 7)));\n      const array = this._array!;\n      for (let i = 0, m = this._itemCount; i < m; i += 1) {\n        const item = array[i];\n        if (item instanceof Item.Field) {\n          RecordMap.put(table, item);\n        }\n      }\n      this._table = table;\n    }\n    return table;\n  }\n\n  /** @hidden */\n  static put(table: Field[] | null, field: Field): void {\n    if (table !== null) {\n      const n = table.length;\n      const x = Math.abs(field.key.hashCode() % n);\n      let i = x;\n      do {\n        const item = table[i];\n        if (item !== void 0) {\n          if (field.key.equals(item.key)) {\n            table[i] = field;\n            return;\n          }\n        } else {\n          table[i] = field;\n          return;\n        }\n        i = (i + 1) % n;\n      } while (i !== x);\n      throw new Error();\n    }\n  }\n\n  evaluate(interpreter: AnyInterpreter): Record {\n    interpreter = Interpreter.fromAny(interpreter);\n    const array = this._array!;\n    const n = this._itemCount;\n    const scope = Record.create(n);\n    interpreter.pushScope(scope);\n    let changed = false;\n    for (let i = 0; i < n; i += 1) {\n      const oldItem = array[i];\n      const newItem = oldItem.evaluate(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  substitute(interpreter: AnyInterpreter): Record {\n    interpreter = Interpreter.fromAny(interpreter);\n    const array = this._array!;\n    const n = this._itemCount;\n    const scope = Record.create(n);\n    interpreter.pushScope(scope);\n    let changed = false;\n    for (let i = 0; i < n; i += 1) {\n      const oldItem = array[i];\n      const newItem = oldItem.substitute(interpreter);\n      if (newItem.isDefined()) {\n        scope.push(newItem);\n      }\n      if (oldItem !== newItem) {\n        changed = true;\n      }\n    }\n    interpreter.popScope();\n    return changed ? scope : this;\n  }\n\n  subRecord(lower?: number, upper?: number): Record {\n    const n = this._itemCount;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    if (lower < 0 || upper > n || lower > upper) {\n      throw new RangeError(lower + \", \" + upper);\n    }\n    return new Record.RecordMapView(this, lower, upper);\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    const array = this._array!;\n    for (let i = 0, n = this._itemCount; i < n; i += 1) {\n      const result = callback.call(thisArg, array[i], i);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return;\n  }\n\n  private static _empty?: RecordMap;\n\n  static empty(): RecordMap {\n    if (!RecordMap._empty) {\n      RecordMap._empty = new RecordMap(null, null, 0, 0, Record.ALIASED | Record.IMMUTABLE);\n    }\n    return RecordMap._empty;\n  }\n\n  static create(initialCapacity?: number): RecordMap {\n    if (initialCapacity === void 0) {\n      return new RecordMap(null, null, 0, 0, Record.ALIASED);\n    } else {\n      return new RecordMap(new Array(initialCapacity), null, 0, 0, 0);\n    }\n  }\n\n  static of(...items: AnyItem[]): RecordMap {\n    const n = arguments.length;\n    if (n === 0) {\n      return new RecordMap(null, null, 0, 0, Record.ALIASED);\n    } else {\n      const array = new Array(n);\n      let itemCount = 0;\n      let fieldCount = 0;\n      for (let i = 0; i < n; i += 1) {\n        const item = Item.fromAny(arguments[i]);\n        array[i] = item;\n        itemCount += 1;\n        if (item instanceof Item.Field) {\n          fieldCount += 1;\n        }\n      }\n      return new RecordMap(array, null, itemCount, fieldCount, 0);\n    }\n  }\n}\nItem.RecordMap = RecordMap;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {RecordMap} from \"./RecordMap\";\nimport {AnyNum} from \"./Num\";\n\n/** @hidden */\nexport class RecordMapView extends Record {\n  /** @hidden */\n  readonly _record: RecordMap;\n  /** @hidden */\n  _lower: number;\n  /** @hidden */\n  _upper: number;\n\n  constructor(record: RecordMap, lower: number, upper: number) {\n    super();\n    this._record = record;\n    this._lower = lower;\n    this._upper = upper;\n  }\n\n  isEmpty(): boolean {\n    return this._lower === this._upper;\n  }\n\n  isArray(): boolean {\n    const array = this._record._array!;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      if (array[i] instanceof Item.Field) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isObject(): boolean {\n    const array = this._record._array!;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      if (array[i] instanceof Value) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  get length(): number {\n    return this._upper - this._lower;\n  }\n\n  fieldCount(): number {\n    const array = this._record._array!;\n    let k = 0;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      if (array[i] instanceof Item.Field) {\n        k += 1;\n      }\n    }\n    return k;\n  }\n\n  valueCount(): number {\n    let k = 0;\n    const array = this._record._array!;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      if (array[i] instanceof Value) {\n        k += 1;\n      }\n    }\n    return k;\n  }\n\n  isConstant(): boolean {\n    const array = this._record._array;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      if (!array![i].isConstant()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  tag(): string | undefined {\n    if (this.length > 0) {\n      const item = this._record._array![this._lower];\n      if (item instanceof Item.Attr) {\n        return item.key.value;\n      }\n    }\n    return void 0;\n  }\n\n  target(): Value {\n    let value: Value | undefined;\n    let record: Record | undefined;\n    let modified = false;\n    const array = this._record._array!;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Attr) {\n        modified = true;\n      } else if (value === void 0 && item instanceof Value) {\n        value = item;\n      } else {\n        if (record === void 0) {\n          record = Record.create();\n          if (value !== void 0) {\n            record.push(value);\n          }\n        }\n        record.push(item);\n      }\n    }\n    if (value === void 0) {\n      return Value.extant();\n    } else if (record === void 0) {\n      return value;\n    } else if (modified) {\n      return record;\n    } else {\n      return this;\n    }\n  }\n\n  head(): Item {\n    if (this.length > 0) {\n      return this._record._array![this._lower];\n    } else {\n      return Item.absent();\n    }\n  }\n\n  tail(): Record {\n    if (this.length > 0) {\n      return new RecordMapView(this._record, this._lower + 1, this._upper);\n    } else {\n      return Record.empty();\n    }\n  }\n\n  body(): Value {\n    const n = this.length;\n    if (n > 2) {\n      return new RecordMapView(this._record, this._lower + 1, this._upper).branch();\n    } else if (n === 2) {\n      const item = this._record._array![this._lower + 1];\n      if (item instanceof Value) {\n        return item;\n      } else {\n        return Record.of(item);\n      }\n    } else {\n      return Value.absent();\n    }\n  }\n\n  indexOf(item: AnyItem, index: number = 0): number {\n    item = Item.fromAny(item);\n    const array = this._record._array!;\n    const n = this.length;\n    if (index < 0) {\n      index = Math.max(0, n + index);\n    }\n    index = this._lower + index;\n    while (index < this._upper) {\n      if (item.equals(array[index])) {\n        return index - this._lower;\n      }\n      index += 1;\n    }\n    return -1;\n  }\n\n  lastIndexOf(item: AnyItem, index?: number): number {\n    item = Item.fromAny(item);\n    const array = this._record._array!;\n    const n = this.length;\n    if (index === void 0) {\n      index = n - 1;\n    } else if (index < 0) {\n      index = n + index;\n    }\n    index = this._lower + Math.min(index, n - 1);\n    while (index >= this._lower) {\n      if (item.equals(array[index])) {\n        return index - this._lower;\n      }\n      index -= 1;\n    }\n    return -1;\n  }\n\n  getItem(index: AnyNum): Item {\n    if (index instanceof Item.Num) {\n      index = index.value;\n    }\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index >= 0 && index < n) {\n      return this._record._array![this._lower + index];\n    } else {\n      return Item.absent();\n    }\n  }\n\n  setItem(index: number, newItem: AnyItem): this {\n    if ((this._record._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    newItem = Item.fromAny(newItem);\n    const n = this.length;\n    if (index < 0) {\n      index = n + index;\n    }\n    if (index < 0 || index > n) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((this._record._flags & Record.ALIASED) !== 0) {\n      this.setItemAliased(index, newItem);\n    } else {\n      this.setItemMutable(index, newItem);\n    }\n    return this;\n  }\n\n  private setItemAliased(index: number, newItem: Item): void {\n    const n = this._record._itemCount;\n    const oldArray = this._record._array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = 0; i < n; i += 1) {\n      newArray[i] = oldArray[i];\n    }\n    const oldItem = oldArray[this._lower + index];\n    newArray[this._lower + index] = newItem;\n    this._record._array = newArray;\n    this._record._table = null;\n    if (newItem instanceof Item.Field) {\n      if (!(oldItem instanceof Item.Field)) {\n        this._record._fieldCount += 1;\n      }\n    } else if (oldItem instanceof Item.Field) {\n      this._record._fieldCount -= 1;\n    }\n    this._record._flags &= ~Record.ALIASED;\n  }\n\n  private setItemMutable(index: number, newItem: Item): void {\n    const array = this._record._array!;\n    const oldItem = array[this._lower + index];\n    array[this._lower + index] = newItem;\n    if (newItem instanceof Item.Field) {\n      this._record._table = null;\n      if (!(oldItem instanceof Item.Field)) {\n        this._record._fieldCount += 1;\n      }\n    } else if (oldItem instanceof Item.Field) {\n      this._record._table = null;\n      this._record._fieldCount -= 1;\n    }\n  }\n\n  push(...newItems: AnyItem[]): number {\n    if ((this._record._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this._record._flags & Record.ALIASED) !== 0) {\n      this.pushAliased.apply(this, arguments);\n    } else {\n      this.pushMutable.apply(this, arguments);\n    }\n    return this.length;\n  }\n\n  private pushAliased(...newItems: AnyItem[]): void {\n    const k = newItems.length;\n    let m = this._record._itemCount;\n    let n = this._record._fieldCount;\n    const oldArray = this._record._array;\n    const newArray = new Array(Record.expand(m + k));\n    if (oldArray !== null) {\n      for (let i = 0; i < this._upper; i += 1) {\n        newArray[i] = oldArray[i];\n      }\n      for (let i = this._upper; i < m; i += 1) {\n        newArray[i + k] = oldArray[i];\n      }\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(newItems[i]);\n      newArray[i + this._upper] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n      }\n    }\n    this._record._array = newArray;\n    this._record._table = null;\n    this._record._itemCount = m;\n    this._record._fieldCount = n;\n    this._record._flags &= ~Record.ALIASED;\n    this._upper += k;\n  }\n\n  private pushMutable(...newItems: AnyItem[]): void {\n    const k = newItems.length;\n    let m = this._record._itemCount;\n    let n = this._record._fieldCount;\n    const oldArray = this._record._array!;\n    let newArray;\n    if (oldArray === null || m + k > oldArray.length) {\n      newArray = new Array(Record.expand(m + k));\n      if (oldArray !== null) {\n        for (let i = 0; i < this._upper; i += 1) {\n          newArray[i] = oldArray[i];\n        }\n      }\n    } else {\n      newArray = oldArray;\n    }\n    for (let i = m - 1; i >= this._upper; i -= 1) {\n      newArray[i + k] = oldArray[i];\n    }\n    for (let i = 0; i < k; i += 1) {\n      const newItem = Item.fromAny(newItems[i]);\n      newArray[i + this._upper] = newItem;\n      m += 1;\n      if (newItem instanceof Item.Field) {\n        n += 1;\n        this._record._table = null;\n      }\n    }\n    this._record._array = newArray;\n    this._record._itemCount = m;\n    this._record._fieldCount = n;\n    this._upper += k;\n  }\n\n  splice(start: number, deleteCount: number = 0, ...newItems: AnyItem[]): Item[] {\n    if ((this._record._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    const n = this.length;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.min(Math.max(0, start), n);\n    deleteCount = Math.min(Math.max(0, deleteCount), n - start);\n    let deleted;\n    if ((this._record._flags & Record.ALIASED) !== 0) {\n      deleted = this._record.spliceAliased(this._lower + start, deleteCount, ...newItems);\n    } else {\n      deleted = this._record.spliceMutable(this._lower + start, deleteCount, ...newItems);\n    }\n    this._upper += newItems.length - deleted.length;\n    return deleted;\n  }\n\n  delete(key: AnyValue): Item {\n    if ((this._record._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    key = Value.fromAny(key);\n    if ((this._record._flags & Record.ALIASED) !== 0) {\n      return this.deleteAliased(key);\n    } else {\n      return this.deleteMutable(key);\n    }\n  }\n\n  /** @hidden */\n  deleteAliased(key: Value): Item {\n    const n = this._record._itemCount;\n    const oldArray = this._record._array!;\n    const newArray = new Array(Record.expand(n));\n    for (let i = this._lower; i < this._upper; i += 1) {\n      const item = oldArray[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          newArray[i] = oldArray[j];\n        }\n        this._record._array = newArray;\n        this._record._table = null;\n        this._record._itemCount = n - 1;\n        this._record._fieldCount -= 1;\n        this._record._flags &= ~Record.ALIASED;\n        this._upper -= 1;\n        return item;\n      }\n      newArray[i] = item;\n    }\n    return Item.absent();\n  }\n\n  /** @hidden */\n  deleteMutable(key: Value): Item {\n    const n = this._record._itemCount;\n    const array = this._record._array!;\n    for (let i = this._lower; i < this._upper; i += 1) {\n      const item = array[i];\n      if (item instanceof Item.Field && item.key.equals(key)) {\n        for (let j = i + 1; j < n; j += 1, i += 1) {\n          array[i] = array[j];\n        }\n        array[n - 1] = void 0 as any;\n        this._record._table = null;\n        this._record._itemCount -= 1;\n        this._record._fieldCount -= 1;\n        this._upper -= 1;\n        return item;\n      }\n    }\n    return Item.absent();\n  }\n\n  clear(): void {\n    if ((this._record._flags & Record.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((this._record._flags & Record.ALIASED) !== 0) {\n      this.clearAliased();\n    } else {\n      this.clearMutable();\n    }\n  }\n\n  private clearAliased(): void {\n    const m = this._record._itemCount;\n    let n = this._record._fieldCount;\n    const l = m - this.length;\n    const oldArray = this._record._array!;\n    const newArray = new Array(Record.expand(l));\n    let i = 0;\n    while (i < this._lower) {\n      newArray[i] = oldArray[i];\n      i += 1;\n    }\n    while (i < this._upper) {\n      if (oldArray[i] instanceof Item.Field) {\n        n -= 1;\n      }\n      i += 1;\n    }\n    i = this._lower;\n    let j = this._upper;\n    while (j < m) {\n      newArray[i] = oldArray[j];\n      i += 1;\n      j += 1;\n    }\n    this._record._array = newArray;\n    this._record._table = null;\n    this._record._itemCount = l;\n    this._record._fieldCount = n;\n    this._record._flags &= ~Record.ALIASED;\n    this._upper = this._lower;\n  }\n\n  private clearMutable(): void {\n    const m = this._record._itemCount;\n    let n = this._record._fieldCount;\n    const array = this._record._array!;\n    let i = this._lower;\n    while (i < this._upper) {\n      if (array[i] instanceof Item.Field) {\n        n -= 1;\n      }\n      i += 1;\n    }\n    i = this._lower;\n    let j = this._upper;\n    while (j < m) {\n      const item = array[j];\n      if (item instanceof Item.Field) {\n        this._record._table = null;\n      }\n      array[i] = item;\n      i += 1;\n      j += 1;\n    }\n    this._record._itemCount = i;\n    this._record._fieldCount = n;\n    while (i < m) {\n      array[i] = void 0 as any;\n      i += 1;\n    }\n    this._upper = this._lower;\n  }\n\n  isAliased(): boolean {\n    return (this._record._flags & Record.ALIASED) !== 0;\n  }\n\n  isMutable(): boolean {\n    return (this._record._flags & Record.IMMUTABLE) === 0;\n  }\n\n  alias(): void {\n    this._record._flags |= Record.ALIASED;\n  }\n\n  branch(): RecordMap {\n    const m = this.length;\n    let n = 0;\n    const oldArray = this._record._array!;\n    const newArray = new Array(Record.expand(m));\n    let i = this._lower;\n    let j = 0;\n    while (j < m) {\n      const item = oldArray[i];\n      newArray[j] = item;\n      if (item instanceof Item.Field) {\n        n += 1;\n      }\n      i += 1;\n      j += 1;\n    }\n    return new RecordMap(newArray, null, m, n, 0);\n  }\n\n  clone(): RecordMap {\n    const m = this.length;\n    let n = 0;\n    const oldArray = this._record._array!;\n    const newArray = new Array(Record.expand(m));\n    let i = this._lower;\n    let j = 0;\n    while (j < m) {\n      const item = oldArray[i];\n      newArray[j] = item.clone();\n      if (item instanceof Item.Field) {\n        n += 1;\n      }\n      i += 1;\n      j += 1;\n    }\n    return new RecordMap(newArray, null, m, n, 0);\n  }\n\n  commit(): this {\n    this._record.commit();\n    return this;\n  }\n\n  subRecord(lower?: number, upper?: number): Record {\n    const n = this.length;\n    if (lower === void 0) {\n      lower = 0;\n    } else if (lower < 0) {\n      lower = n + lower;\n    }\n    if (upper === void 0) {\n      upper = n;\n    } else if (upper < 0) {\n      upper = n + upper;\n    }\n    if (lower < 0 || upper > n || lower > upper) {\n      throw new RangeError(lower + \", \" + upper);\n    }\n    return new RecordMapView(this._record, this._lower + lower, this._upper + upper);\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    const array = this._record._array!;\n    for (let i = this._lower, n = this._upper; i < n; i += 1) {\n      const result = callback.call(thisArg, array[i], i);\n      if (result !== void 0) {\n        return result;\n      }\n    }\n    return;\n  }\n}\nItem.RecordMapView = RecordMapView;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings, Output} from \"@swim/codec\";\nimport {Data} from \"./Data\";\n\n/** @hidden */\nexport class DataOutput extends Output<Data> {\n  /** @hidden */\n  readonly _data: Data;\n  /** @hidden */\n  _settings: OutputSettings;\n\n  constructor(data: Data, settings: OutputSettings) {\n    super();\n    this._data = data;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return true;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<Data>;\n  isPart(isPart?: boolean): boolean | Output<Data> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  write(b: number | string): Output<Data> {\n    if (typeof b === \"number\") {\n      this._data.addByte(b);\n      return this;\n    } else {\n      throw new TypeError(\"\" + b);\n    }\n  }\n\n  writeln(string?: string): Output<Data> {\n    throw new TypeError(\"\" + string);\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<Data>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<Data> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = OutputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  bind(): Data {\n    return this._data;\n  }\n\n  clone(): Output<Data> {\n    return new DataOutput(this._data.branch(), this._settings);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects, Random} from \"@swim/util\";\nimport {Input, OutputSettings, Output, Writer, Unicode, Base16, Base64} from \"@swim/codec\";\nimport {Item} from \"./Item\";\nimport {Value} from \"./Value\";\nimport {DataOutput} from \"./DataOutput\";\n\nexport type AnyData = Data | Uint8Array;\n\nexport class Data extends Value {\n  /** @hidden */\n  _array: Uint8Array | null;\n  /** @hidden */\n  _size: number;\n  /** @hidden */\n  _flags: number;\n\n  constructor(array: Uint8Array | null, size: number, flags: number) {\n    super();\n    this._array = array;\n    this._size = size;\n    this._flags = flags;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  get size(): number {\n    return this._size;\n  }\n\n  getByte(index: number): number {\n    if (index < 0 || index >= this.size) {\n      throw new RangeError(\"\" + index);\n    }\n    return this._array![index];\n  }\n\n  setByte(index: number, value: number): Data {\n    const flags = this._flags;\n    if ((flags & Data.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    } else if (index < 0 || index >= this._size) {\n      throw new RangeError(\"\" + index);\n    }\n    if ((flags & Data.ALIASED) !== 0) {\n      return this.setByteAliased(index, value);\n    } else {\n      return this.setByteMutable(index, value);\n    }\n  }\n\n  private setByteAliased(index: number, value: number): Data {\n    const n = this.size;\n    const oldArray = this._array!;\n    const newArray = new Uint8Array(Data.expand(n));\n    newArray.set(oldArray, 0);\n    newArray[index] = value;\n    this._array = newArray;\n    this._flags &= ~Data.ALIASED;\n    return this;\n  }\n\n  private setByteMutable(index: number, value: number): Data {\n    this._array![index] = value;\n    return this;\n  }\n\n  public addByte(value: number): Data {\n    const flags = this._flags;\n    if ((flags & Data.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((flags & Data.ALIASED) !== 0) {\n      return this.addByteAliased(value);\n    } else {\n      return this.addByteMutable(value);\n    }\n  }\n\n  private addByteAliased(value: number): Data {\n    const n = this.size;\n    const oldArray = this._array;\n    const newArray = new Uint8Array(Data.expand(n + 1));\n    if (oldArray != null) {\n      newArray.set(oldArray, 0);\n    }\n    newArray[n] = value;\n    this._array = newArray;\n    this._size = n + 1;\n    this._flags &= ~Data.ALIASED;\n    return this;\n  }\n\n  private addByteMutable(value: number): Data {\n    const n = this.size;\n    const oldArray = this._array;\n    let newArray;\n    if (oldArray === null || n + 1 > oldArray.length) {\n      newArray = new Uint8Array(Data.expand(n + 1));\n      if (oldArray !== null) {\n        newArray.set(oldArray, 0);\n      }\n      this._array = newArray;\n    } else {\n      newArray = oldArray;\n    }\n    newArray[n] = value;\n    this._size = n + 1;\n    return this;\n  }\n\n  addData(data: Data): Data {\n    let array = data._array;\n    if (array !== null) {\n      const size = data._size;\n      if (array.length > size) {\n        array = array.slice(0, size);\n      }\n      return this.addUint8Array(array);\n    } else {\n      return this;\n    }\n  }\n\n  addUint8Array(array: Uint8Array): Data {\n    const flags = this._flags;\n    if ((flags & Data.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    if ((flags & Data.ALIASED) !== 0) {\n      return this.addUint8ArrayAliased(array);\n    } else {\n      return this.addUint8ArrayMutable(array);\n    }\n  }\n\n  private addUint8ArrayAliased(array: Uint8Array): Data {\n    const size = array.length;\n    if (size === 0) {\n      return this;\n    }\n    const n = this.size;\n    const oldArray = this._array;\n    const newArray = new Uint8Array(Data.expand(n + size));\n    if (oldArray !== null) {\n      newArray.set(oldArray, 0);\n    }\n    newArray.set(array, n);\n    this._array = newArray;\n    this._size = n + size;\n    this._flags &= ~Data.ALIASED;\n    return this;\n  }\n\n  private addUint8ArrayMutable(array: Uint8Array): Data {\n    const size = array.length;\n    if (size === 0) {\n      return this;\n    }\n    const n = this.size;\n    const oldArray = this._array;\n    let newArray;\n    if (oldArray === null || n + size > oldArray.length) {\n      newArray = new Uint8Array(Data.expand(n + size));\n      if (oldArray !== null) {\n        newArray.set(oldArray, 0);\n      }\n      this._array = newArray;\n    } else {\n      newArray = oldArray;\n    }\n    newArray.set(array, n);\n    this._size = n + size;\n    return this;\n  }\n\n  clear(): void {\n    if ((this._flags & Data.IMMUTABLE) !== 0) {\n      throw new Error(\"immutable\");\n    }\n    this._array = null;\n    this._size = 0;\n    this._flags = Data.ALIASED;\n  }\n\n  toUint8Array(): Uint8Array {\n    const oldArray = this._array;\n    const flags = this._flags;\n    if ((flags & Data.IMMUTABLE) !== 0) {\n      return oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);\n    } else if ((flags & Data.ALIASED) !== 0 || this._size !== oldArray!.length) {\n      const newArray = oldArray !== null ? oldArray.slice(0) : new Uint8Array(0);\n      this._array = newArray;\n      this._flags &= ~Data.ALIASED;\n      return newArray;\n    } else {\n      return oldArray!;\n    }\n  }\n\n  asUint8Array(): Uint8Array | undefined {\n    let array: Uint8Array | undefined;\n    if (this._array && this._size > 0) {\n      array = this._array;\n      if (array.length !== this._size) {\n        array = new Uint8Array(array.buffer, array.byteOffset, this._size);\n      }\n    } else {\n      array = void 0;\n    }\n    return array;\n  }\n\n  toAny(): AnyData {\n    return this.toUint8Array();\n  }\n\n  isAliased(): boolean {\n    return (this._flags & Data.ALIASED) !== 0;\n  }\n\n  isMutable(): boolean {\n    return (this._flags & Data.IMMUTABLE) === 0;\n  }\n\n  branch(): Data {\n    this._flags |= Data.ALIASED;\n    return new Data(this._array, this._size, Data.ALIASED);\n  }\n\n  clone(): Data {\n    return this.branch();\n  }\n\n  commit(): this {\n    this._flags |= Data.IMMUTABLE;\n    return this;\n  }\n\n  writeBase16(output: Output, base16: Base16 = Base16.uppercase()): Writer<unknown, unknown> {\n    let array = this._array;\n    const size = this._size;\n    if (array !== null && size !== 0) {\n      if (array.length !== size) {\n        array = array.slice(0, size);\n      }\n      return base16.writeUint8Array(array, output);\n    } else {\n      return Writer.done();\n    }\n  }\n\n  toBase16(base16: Base16 = Base16.uppercase()): string {\n    const output = Unicode.stringOutput();\n    this.writeBase16(output, base16);\n    return output.bind();\n  }\n\n  writeBase64(output: Output, base64: Base64 = Base64.standard()): Writer<unknown, unknown> {\n    let array = this._array;\n    const size = this._size;\n    if (array !== null && size !== 0) {\n      if (array.length !== size) {\n        array = array.slice(0, size);\n      }\n      return base64.writeUint8Array(array, output);\n    } else {\n      return Writer.done();\n    }\n  }\n\n  toBase64(base64: Base64 = Base64.standard()): string {\n    const output = Unicode.stringOutput();\n    this.writeBase64(output, base64);\n    return output.bind();\n  }\n\n  typeOrder(): number {\n    return 4;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Data) {\n      const xs = this._array!;\n      const ys = that._array!;\n      const xn = this._size;\n      const yn = that._size;\n      let order = 0;\n      let i = 0;\n      do {\n        if (i < xn && i < yn) {\n          order = xs[i] - ys[i];\n          i += 1;\n        } else {\n          break;\n        }\n      } while (order === 0);\n      if (order > 0) {\n        return 1;\n      } else if (order < 0) {\n        return -1;\n      } else if (xn > yn) {\n        return 1;\n      } else if (xn < yn) {\n        return -1;\n      } else {\n        return 0;\n      }\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Data) {\n      const xs = this._array!;\n      const ys = that._array!;\n      const xn = this._size;\n      if (xn !== that._size) {\n        return false;\n      }\n      for (let i = 0; i < xn; i += 1) {\n        if (xs[i] !== ys[i]) {\n          return false;\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (Data._hashSeed === void 0) {\n      Data._hashSeed = Murmur3.seed(Data);\n    }\n    return Murmur3.mash(Murmur3.mix(Data._hashSeed, this._array || new Uint8Array(0)));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Data\").write(46/*'.'*/);\n    if (this._size === 0) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"base16\").write(40/*'('*/).write(34/*'\"'*/);\n      this.writeBase16(output);\n      output = output.write(34/*'\"'*/).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    this.debug(output);\n  }\n\n  /** @hidden */\n  static readonly ALIASED: number = 1 << 0;\n  /** @hidden */\n  static readonly IMMUTABLE: number = 1 << 1;\n\n  private static _hashSeed?: number;\n\n  private static _empty?: Data;\n\n  static output(): Output<Data>;\n  static output(initialCapacity: number): Output<Data>;\n  static output(data: Data): Output<Data>;\n  static output(data?: number | Data): Output<Data> {\n    if (!(data instanceof Data)) {\n      data = Data.create(data);\n    }\n    return new DataOutput(data, OutputSettings.standard());\n  }\n\n  static empty(): Data {\n    if (Data._empty == null) {\n      Data._empty = new Data(null, 0, Data.ALIASED | Data.IMMUTABLE);\n    }\n    return Data._empty;\n  }\n\n  static create(initialCapacity?: number): Data {\n    if (initialCapacity === void 0) {\n      return new Data(null, 0, Data.ALIASED);\n    } else {\n      return new Data(new Uint8Array(initialCapacity), 0, 0);\n    }\n  }\n\n  static wrap(value: Uint8Array): Data {\n    return new Data(value, value.length, Data.ALIASED);\n  }\n\n  static fromBase16(input: Input | string): Data {\n    if (typeof input === \"string\") {\n      input = Unicode.stringInput(input);\n    }\n    return Base16.parse(input, Data.output()).bind();\n  }\n\n  static fromBase64(input: Input | string, base64: Base64 = Base64.standard()): Data {\n    if (typeof input === \"string\") {\n      input = Unicode.stringInput(input);\n    }\n    return base64.parse(input, Data.output()).bind();\n  }\n\n  static fromAny(value: AnyData): Data {\n    if (value instanceof Data) {\n      return value;\n    } else if (value instanceof Uint8Array) {\n      return Data.wrap(value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  static random(size: number): Data {\n    const array = new Uint8Array(size);\n    Random.fillBytes(array);\n    return Data.wrap(array);\n  }\n\n  /** @hidden */\n  static expand(n: number): number {\n    n = Math.max(32, n) - 1;\n    n |= n >> 1; n |= n >> 2; n |= n >> 4; n |= n >> 8; n |= n >> 16;\n    return n + 1;\n  }\n}\nItem.Data = Data;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyOutputSettings, OutputSettings, Output} from \"@swim/codec\";\nimport {Text} from \"./Text\";\n\n/** @hidden */\nexport class TextOutput extends Output<Text> {\n  /** @hidden */\n  _string: string;\n  /** @hidden */\n  _settings: OutputSettings;\n\n  constructor(string: string, settings: OutputSettings) {\n    super();\n    this._string = string;\n    this._settings = settings;\n  }\n\n  isCont(): boolean {\n    return true;\n  }\n\n  isFull(): boolean {\n    return false;\n  }\n\n  isDone(): boolean {\n    return false;\n  }\n\n  isError(): boolean {\n    return false;\n  }\n\n  isPart(): boolean;\n  isPart(isPart: boolean): Output<Text>;\n  isPart(isPart?: boolean): boolean | Output<Text> {\n    if (isPart === void 0) {\n      return false;\n    } else {\n      return this;\n    }\n  }\n\n  write(token: number | string): Output<Text> {\n    if (typeof token === \"number\") {\n      if ((token >= 0x0000 && token <= 0xd7ff)\n          || (token >= 0xe000 && token <= 0xffff)) { // U+0000..U+D7FF | U+E000..U+FFFF\n        token = String.fromCharCode(token);\n      } else if (token >= 0x10000 && token <= 0x10ffff) { // U+10000..U+10FFFF\n        const u = token - 0x10000;\n        token = String.fromCharCode(0xd800 | (u >>> 10), 0xdc00 | (u & 0x3ff));\n      } else { // invalid code point\n        token = \"\\ufffd\";\n      }\n    }\n    this._string += token;\n    return this;\n  }\n\n  settings(): OutputSettings;\n  settings(settings: AnyOutputSettings): Output<Text>;\n  settings(settings?: AnyOutputSettings): OutputSettings | Output<Text> {\n    if (settings === void 0) {\n      return this._settings;\n    } else {\n      this._settings = OutputSettings.fromAny(settings);\n      return this;\n    }\n  }\n\n  bind(): Text {\n    return Text.from(this._string);\n  }\n\n  clone(): Output<Text> {\n    return new TextOutput(this._string, this._settings);\n  }\n\n  toString(): string {\n    return this._string;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects, HashGenCacheSet} from \"@swim/util\";\nimport {OutputSettings, Output, Format} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {TextOutput} from \"./TextOutput\";\n\nexport type AnyText = Text | string;\n\nexport class Text extends Value {\n  /** @hidden */\n  readonly _value: string;\n  /** @hidden */\n  _hashCode?: number;\n\n  private constructor(value: string) {\n    super();\n    this._value = value;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  get value(): string {\n    return this._value;\n  }\n\n  get size(): number {\n    return this._value.length;\n  }\n\n  stringValue(): string;\n  stringValue<T>(orElse: T): string;\n  stringValue<T>(orElse?: T): string {\n    return this._value;\n  }\n\n  numberValue(): number | undefined;\n  numberValue<T>(orElse: T): number | T;\n  numberValue<T>(orElse?: T): number | T | undefined {\n    try {\n      return Item.Num.from(this._value).numberValue();\n    } catch (error) {\n      return orElse;\n    }\n  }\n\n  booleanValue(): boolean | undefined;\n  booleanValue<T>(orElse: T): boolean | T;\n  booleanValue<T>(orElse?: T): boolean | T | undefined {\n    if (this._value === \"true\") {\n      return true;\n    } else if (this._value === \"false\") {\n      return false;\n    } else {\n      return orElse;\n    }\n  }\n\n  toAny(): AnyText {\n    return this._value;\n  }\n\n  valueOf(): string {\n    return this._value;\n  }\n\n  plus(that: AnyValue): Value;\n  plus(that: AnyItem): Item;\n  plus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Text) {\n      return Text.from(this._value + that._value);\n    }\n    return super.plus(that);\n  }\n\n  branch(): Text {\n    return this;\n  }\n\n  clone(): Text {\n    return this;\n  }\n\n  commit(): this {\n    return this;\n  }\n\n  typeOrder(): number {\n    return 5;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Text) {\n      const order = this._value.localeCompare(that._value);\n      return order < 0 ? -1 : order > 0 ? 1 : 0;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Text) {\n      return this._value === that._value;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this._value);\n    }\n    return this._hashCode;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Text\").write(46/*'.'*/);\n    if (this._value.length === 0) {\n      output = output.write(\"empty\").write(40/*'('*/).write(41/*')'*/);\n    } else {\n      output = output.write(\"from\").write(40/*'('*/).debug(this._value).write(41/*')'*/);\n    }\n  }\n\n  display(output: Output): void {\n    Format.debug(this._value, output);\n  }\n\n  toString(): string {\n    return this._value;\n  }\n\n  private static _empty?: Text;\n\n  private static _cache?: HashGenCacheSet<Text>;\n\n  static output(settings: OutputSettings = OutputSettings.standard()): Output<Text> {\n    return new TextOutput(\"\", settings);\n  }\n\n  static empty(): Text {\n    if (!Text._empty) {\n      Text._empty = new Text(\"\");\n    }\n    return Text._empty;\n  }\n\n  static from(value: string): Text {\n    const n = value.length;\n    if (n === 0) {\n      return Text.empty();\n    } else {\n      let text = new Text(value);\n      if (n <= 64) {\n        text = Text.cache().put(text);\n      }\n      return text;\n    }\n  }\n\n  static fromAny(value: AnyText): Text {\n    if (value instanceof Text) {\n      return value;\n    } else if (typeof value === \"string\") {\n      return Text.from(value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheSet<Text> {\n    if (Text._cache == null) {\n      const cacheSize = 128;\n      Text._cache = new HashGenCacheSet<Text>(cacheSize);\n    }\n    return Text._cache;\n  }\n}\nItem.Text = Text;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects, HashGenCacheSet} from \"@swim/util\";\nimport {Output, Format} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\n\nexport type AnyNum = Num | number;\n\nexport class Num extends Value {\n  /** @hidden */\n  readonly _value: number;\n  /** @hidden */\n  readonly _flags: number;\n\n  private constructor(value: number, flags: number = 0) {\n    super();\n    this._value = value;\n    this._flags = flags;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  get value(): number {\n    return this._value;\n  }\n\n  isNaN(): boolean {\n    return isNaN(this._value);\n  }\n\n  isInfinite(): boolean {\n    return !isNaN(this._value) && !isFinite(this._value);\n  }\n\n  isUint32(): boolean {\n    return (this._flags & Num.UINT32) !== 0;\n  }\n\n  isUint64(): boolean {\n    return (this._flags & Num.UINT64) !== 0;\n  }\n\n  stringValue(): string;\n  stringValue<T>(orElse: T): string;\n  stringValue<T>(orElse?: T): string {\n    return \"\" + this._value;\n  }\n\n  numberValue(): number;\n  numberValue<T>(orElse: T): number;\n  numberValue<T>(orElse?: T): number {\n    return this._value;\n  }\n\n  booleanValue(): boolean;\n  booleanValue<T>(orElse: T): boolean;\n  booleanValue<T>(orElse?: T): boolean {\n    return !!this._value;\n  }\n\n  toAny(): AnyNum {\n    return this._value;\n  }\n\n  valueOf(): number {\n    return this._value;\n  }\n\n  bitwiseOr(that: AnyValue): Value;\n  bitwiseOr(that: AnyItem): Item;\n  bitwiseOr(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from((this._value | that._value) >>> 0);\n    }\n    return super.bitwiseOr(that);\n  }\n\n  bitwiseXor(that: AnyValue): Value;\n  bitwiseXor(that: AnyItem): Item;\n  bitwiseXor(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from((this._value ^ that._value) >>> 0);\n    }\n    return super.bitwiseXor(that);\n  }\n\n  bitwiseAnd(that: AnyValue): Value;\n  bitwiseAnd(that: AnyItem): Item;\n  bitwiseAnd(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from((this._value & that._value) >>> 0);\n    }\n    return super.bitwiseAnd(that);\n  }\n\n  plus(that: AnyValue): Value;\n  plus(that: AnyItem): Item;\n  plus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from(this._value + that._value);\n    }\n    return super.plus(that);\n  }\n\n  minus(that: AnyValue): Value;\n  minus(that: AnyItem): Item;\n  minus(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from(this._value - that._value);\n    }\n    return super.minus(that);\n  }\n\n  times(that: AnyValue): Value;\n  times(that: AnyItem): Item;\n  times(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from(this._value * that._value);\n    }\n    return super.times(that);\n  }\n\n  divide(that: AnyValue): Value;\n  divide(that: AnyItem): Item;\n  divide(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from(this._value / that._value);\n    }\n    return super.divide(that);\n  }\n\n  modulo(that: AnyValue): Value;\n  modulo(that: AnyItem): Item;\n  modulo(that: AnyItem): Item {\n    that = Item.fromAny(that);\n    if (that instanceof Num) {\n      return Num.from(this._value % that._value);\n    }\n    return super.modulo(that);\n  }\n\n  bitwiseNot(): Value {\n    return Num.from(~this._value >>> 0);\n  }\n\n  negative(): Value {\n    return Num.from(-this._value);\n  }\n\n  positive(): Value {\n    return this;\n  }\n\n  inverse(): Value {\n    return Num.from(1 / this._value);\n  }\n\n  abs(): Num {\n    return Num.from(Math.abs(this._value));\n  }\n\n  ceil(): Num {\n    return Num.from(Math.ceil(this._value));\n  }\n\n  floor(): Num {\n    return Num.from(Math.floor(this._value));\n  }\n\n  round(): Num {\n    return Num.from(Math.round(this._value));\n  }\n\n  sqrt(): Num {\n    return Num.from(Math.sqrt(this._value));\n  }\n\n  pow(that: AnyNum): Num {\n    that = Num.fromAny(that);\n    return Num.from(Math.pow(this._value, that._value));\n  }\n\n  max(that: Num): Num;\n  max(that: Item): Item;\n  max(that: Item): Item {\n    return this.compareTo(that) >= 0 ? this : that;\n  }\n\n  min(that: Num): Num;\n  min(that: Item): Item;\n  min(that: Item): Item {\n    return this.compareTo(that) <= 0 ? this : that;\n  }\n\n  typeOrder(): number {\n    return 6;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Num) {\n      const x = this._value;\n      const y = that._value;\n      return x < y ? -1 : x > y ? 1 : isNaN(y) ? (isNaN(x) ? 0 : -1) : isNaN(x) ? 1 : 0;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Num) {\n      const x = this._value;\n      const y = that._value;\n      return x === y || isNaN(x) && isNaN(y);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    return Murmur3.hash(this._value);\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Num\").write(46/*'.'*/).write(\"from\")\n        .write(40/*'('*/).display(this).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    Format.displayNumber(this._value, output);\n  }\n\n  /** @hidden */\n  static readonly TYPE_MASK = 0x3;\n  /** @hidden */\n  static readonly UINT32: number = 1;\n  /** @hidden */\n  static readonly UINT64: number = 2;\n\n  private static _positiveZero?: Num;\n  private static _negativeZero?: Num;\n  private static _positiveOne?: Num;\n  private static _negativeOne?: Num;\n  private static _nan?: Num;\n\n  private static _cache?: HashGenCacheSet<Num>;\n\n  static positiveZero(): Num {\n    if (Num._positiveZero === void 0) {\n      Num._positiveZero = new Num(0);\n    }\n    return Num._positiveZero;\n  }\n\n  static negativeZero(): Num {\n    if (Num._negativeZero === void 0) {\n      Num._negativeZero = new Num(-0);\n    }\n    return Num._negativeZero;\n  }\n\n  static positiveOne(): Num {\n    if (Num._positiveOne === void 0) {\n      Num._positiveOne = new Num(1);\n    }\n    return Num._positiveOne;\n  }\n\n  static negativeOne(): Num {\n    if (Num._negativeOne === void 0) {\n      Num._negativeOne = new Num(-1);\n    }\n    return Num._negativeOne;\n  }\n\n  static nan(): Num {\n    if (Num._nan === void 0) {\n      Num._nan = new Num(NaN);\n    }\n    return Num._nan;\n  }\n\n  static uint32(value: number): Num {\n    return new Num(value, Num.UINT32);\n  }\n\n  static uint64(value: number): Num {\n    return new Num(value, Num.UINT64);\n  }\n\n  static from(value: number | string): Num {\n    if (typeof value === \"number\") {\n      if (value === 0) {\n        if (1 / value === -Infinity) {\n          return Num.negativeZero();\n        } else {\n          return Num.positiveZero();\n        }\n      } else if (value === 1) {\n        return Num.positiveOne();\n      } else if (value === -1) {\n        return Num.negativeOne();\n      } else if (isNaN(value)) {\n        return Num.nan();\n      } else {\n        return Num.cache().put(new Num(value));\n      }\n    } else if (typeof value === \"string\") {\n      if (value === \"NaN\") {\n        return Num.nan();\n      } else {\n        const num = +value;\n        if (isFinite(num)) {\n          return Num.from(num);\n        }\n      }\n      throw new Error(value);\n    }\n    throw new TypeError(\"\" + value);\n  }\n\n  static fromAny(value: AnyNum): Num {\n    if (value instanceof Num) {\n      return value;\n    } else if (typeof value === \"number\") {\n      return Num.from(value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  /** @hidden */\n  static cache(): HashGenCacheSet<Num> {\n    if (Num._cache == null) {\n      const cacheSize = 16;\n      Num._cache = new HashGenCacheSet<Num>(cacheSize);\n    }\n    return Num._cache;\n  }\n}\nItem.Num = Num;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\n\nexport type AnyBool = Bool | boolean;\n\nexport class Bool extends Value {\n  /** @hidden */\n  readonly _value: boolean;\n  /** @hidden */\n  _hashCode?: number;\n\n  private constructor(value: boolean) {\n    super();\n    this._value = value;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  get value(): boolean {\n    return this._value;\n  }\n\n  stringValue(): string;\n  stringValue<T>(orElse: T): string;\n  stringValue<T>(orElse?: T): string {\n    return this._value ? \"true\" : \"false\";\n  }\n\n  booleanValue(): boolean;\n  booleanValue<T>(orElse: T): boolean;\n  booleanValue<T>(orElse?: T): boolean {\n    return this._value;\n  }\n\n  toAny(): AnyBool {\n    return this._value;\n  }\n\n  valueOf(): boolean {\n    return this._value;\n  }\n\n  conditional(thenTerm: AnyValue, elseTerm: AnyValue): Value;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item {\n    return this._value ? Item.fromAny(thenTerm) : Item.fromAny(elseTerm);\n  }\n\n  or(that: AnyValue): Value;\n  or(that: AnyItem): Item;\n  or(that: AnyItem): Item {\n    return this._value ? this : Item.fromAny(that);\n  }\n\n  and(that: AnyValue): Value;\n  and(that: AnyItem): Item;\n  and(that: AnyItem): Item {\n    return this._value ? Item.fromAny(that) : this;\n  }\n\n  not(): Value {\n    return Bool.from(!this._value);\n  }\n\n  typeOrder(): number {\n    return 7;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof Bool) {\n      if (this._value && !that._value) {\n        return -1;\n      } else if (!this._value && that._value) {\n        return 1;\n      } else {\n        return 0;\n      }\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof Bool) {\n      return this._value === that._value;\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (this._hashCode === void 0) {\n      this._hashCode = Murmur3.hash(this._value ? \"true\" : \"false\");\n    }\n    return this._hashCode;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Bool\").write(46/*'.'*/).write(\"from\")\n        .write(40/*'('*/).write(this._value ? \"true\" : \"false\").write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    output = output.write(this._value ? \"true\" : \"false\");\n  }\n\n  private static readonly True: Bool = new Bool(true);\n\n  private static readonly False: Bool = new Bool(false);\n\n  static from(value: boolean): Bool {\n    return value ? Bool.True : Bool.False;\n  }\n\n  static fromAny(value: AnyBool): Bool {\n    if (value instanceof Bool) {\n      return value;\n    } else if (typeof value === \"boolean\") {\n      return Bool.from(value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n}\nItem.Bool = Bool;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Operator} from \"./Operator\";\n\nexport abstract class Expression extends Value {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  conditional(thenTerm: Value, elseTerm: Value): Value;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item;\n  conditional(thenTerm: AnyItem, elseTerm: AnyItem): Item {\n    thenTerm = Item.fromAny(thenTerm);\n    elseTerm = Item.fromAny(elseTerm);\n    return new Item.ConditionalOperator(this, thenTerm, elseTerm);\n  }\n\n  or(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.OrOperator(this, that);\n  }\n\n  and(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.AndOperator(this, that);\n  }\n\n  bitwiseOr(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.BitwiseOrOperator(this, that);\n  }\n\n  bitwiseXor(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.BitwiseXorOperator(this, that);\n  }\n\n  bitwiseAnd(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.BitwiseAndOperator(this, that);\n  }\n\n  lt(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.LtOperator(this, that);\n  }\n\n  le(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.LeOperator(this, that);\n  }\n\n  eq(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.EqOperator(this, that);\n  }\n\n  ne(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.NeOperator(this, that);\n  }\n\n  ge(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.GeOperator(this, that);\n  }\n\n  gt(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.GtOperator(this, that);\n  }\n\n  plus(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.PlusOperator(this, that);\n  }\n\n  minus(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.MinusOperator(this, that);\n  }\n\n  times(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.TimesOperator(this, that);\n  }\n\n  divide(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.DivideOperator(this, that);\n  }\n\n  modulo(that: AnyItem): Operator {\n    that = Item.fromAny(that);\n    return new Item.ModuloOperator(this, that);\n  }\n\n  not(): Operator {\n    return new Item.NotOperator(this);\n  }\n\n  bitwiseNot(): Operator {\n    return new Item.BitwiseNotOperator(this);\n  }\n\n  negative(): Operator {\n    return new Item.NegativeOperator(this);\n  }\n\n  positive(): Operator {\n    return new Item.PositiveOperator(this);\n  }\n\n  inverse(): Operator {\n    return new Item.DivideOperator(Item.Num.positiveOne(), this);\n  }\n\n  toAny(): AnyValue {\n    return this;\n  }\n}\nItem.Expression = Expression;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"./Item\";\nimport {Expression} from \"./Expression\";\n\nexport abstract class Operator extends Expression {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n}\nItem.Operator = Operator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output} from \"@swim/codec\";\nimport {AnyInterpreter, Interpreter} from \"./Interpreter\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {AnyText} from \"./Text\";\nimport {AnyNum} from \"./Num\";\nimport {Expression} from \"./Expression\";\nimport {IdentitySelector} from \"./selector/IdentitySelector\";\nimport {KeysSelector} from \"./selector/KeysSelector\";\nimport {ValuesSelector} from \"./selector/ValuesSelector\";\nimport {ChildrenSelector} from \"./selector/ChildrenSelector\";\nimport {DescendantsSelector} from \"./selector/DescendantsSelector\";\nimport {Operator} from \"./Operator\";\n\nexport abstract class Selector extends Expression {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  isConstant(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the `Selector` that this `Selector` uses to match sub-selections.\n   */\n  abstract then(): Selector;\n\n  abstract forSelected<T, S = unknown>(interpreter: Interpreter,\n                                       callback: (this: S, interpreter: Interpreter) => T | undefined,\n                                       thisArg?: S): T | undefined;\n\n  abstract mapSelected<S = unknown>(interpreter: Interpreter,\n                                    transform: (this: S, interpreter: Interpreter) => Item,\n                                    thisArg?: S): Item;\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const selected = Item.Record.create();\n    this.forSelected(interpreter, function (interpreter: Interpreter): void {\n      const scope = interpreter.peekScope();\n      if (scope) {\n        selected.push(scope);\n      }\n    }, this);\n    return selected.isEmpty() ? Item.absent() : selected.flattened();\n  }\n\n  abstract substitute(interpreter: AnyInterpreter): Item;\n\n  abstract andThen(then: Selector): Selector;\n\n  get(key: AnyValue): Selector {\n    key = Value.fromAny(key);\n    return this.andThen(new Item.GetSelector(key, Selector.identity()));\n  }\n\n  getAttr(key: AnyText): Selector {\n    key = Item.Text.fromAny(key);\n    return this.andThen(new Item.GetAttrSelector(key, Selector.identity()));\n  }\n\n  getItem(index: AnyNum): Selector {\n    index = Item.Num.fromAny(index);\n    return this.andThen(new Item.GetItemSelector(index, Selector.identity()));\n  }\n\n  keys(): Selector {\n    return this.andThen(Selector.keys());\n  }\n\n  values(): Selector {\n    return this.andThen(Selector.values());\n  }\n\n  children(): Selector {\n    return this.andThen(Selector.children());\n  }\n\n  descendants(): Selector {\n    return this.andThen(Selector.descendants());\n  }\n\n  filter(predicate?: AnyItem): Selector {\n    if (arguments.length === 0) {\n      return new Item.FilterSelector(this, Selector.identity());\n    } else {\n      predicate = Item.fromAny(predicate);\n      return this.andThen(predicate.filter());\n    }\n  }\n\n  invoke(args: Value): Operator {\n    return new Item.InvokeOperator(this, args);\n  }\n\n  precedence(): number {\n    return 11;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Selector\").write(46/*'.'*/).write(\"identity\").write(40/*'('*/).write(41/*')'*/);\n    this.debugThen(output);\n  }\n\n  abstract debugThen(output: Output): void;\n\n  abstract clone(): Selector;\n\n  /** @hidden */\n  static _identity: IdentitySelector; // defined by IdentitySelector\n  private static _keys?: KeysSelector;\n  private static _values?: ValuesSelector;\n  private static _children?: ChildrenSelector;\n  private static _descendants?: DescendantsSelector;\n\n  static identity(): Selector {\n    return Selector._identity;\n  }\n\n  static get(key: AnyValue): Selector {\n    key = Value.fromAny(key);\n    return new Item.GetSelector(key, Selector.identity());\n  }\n\n  static getAttr(key: AnyText): Selector {\n    key = Item.Text.fromAny(key);\n    return new Item.GetAttrSelector(key, Selector.identity());\n  }\n\n  static getItem(index: AnyNum): Selector {\n    index = Item.Num.fromAny(index);\n    return new Item.GetItemSelector(index, Selector.identity());\n  }\n\n  static keys(): Selector {\n    if (!Selector._keys) {\n      Selector._keys = new Item.KeysSelector(Selector.identity());\n    }\n    return Selector._keys;\n  }\n\n  static values(): Selector {\n    if (!Selector._values) {\n      Selector._values = new Item.ValuesSelector(Selector.identity());\n    }\n    return Selector._values;\n  }\n\n  static children(): Selector {\n    if (!Selector._children) {\n      Selector._children = new Item.ChildrenSelector(Selector.identity());\n    }\n    return Selector._children;\n  }\n\n  static descendants(): Selector {\n    if (!Selector._descendants) {\n      Selector._descendants = new Item.DescendantsSelector(Selector.identity());\n    }\n    return Selector._descendants;\n  }\n\n  static literal(item: AnyItem): Selector {\n    item = Item.fromAny(item);\n    if (!(item instanceof Selector)) {\n      item = new Item.LiteralSelector(item, Selector.identity());\n    }\n    return item as Selector;\n  }\n}\nItem.Selector = Selector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"./Item\";\nimport {Value} from \"./Value\";\nimport {Expression} from \"./Expression\";\nimport {InvokeOperator} from \"./operator/InvokeOperator\";\nimport {Interpreter} from \"./Interpreter\";\n\nexport abstract class Func extends Expression {\n  /** @hidden */\n  constructor() {\n    super();\n  }\n\n  abstract invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item;\n\n  expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n    return void 0;\n  }\n\n  isConstant(): boolean {\n    return false;\n  }\n}\nItem.Func = Func;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"./Item\";\nimport {Value} from \"./Value\";\nimport {Record} from \"./Record\";\n\nexport type AnyExtant = Extant | null;\n\nexport class Extant extends Value {\n  /** @hidden */\n  private constructor() {\n    super();\n  }\n\n  /**\n   * Always returns `true` because `Extant` is a defined value.\n   */\n  isDefined(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns `false` because `Extant` is not a distinct\n   * value.\n   */\n  isDistinct(): boolean {\n    return false;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns an empty `Record` because `Extant` is not a distinct value.\n   */\n  unflattened(): Record {\n    return Value.Record.empty();\n  }\n\n  not(): Value {\n    return Value.absent();\n  }\n\n  /**\n   * Always returns the empty `string` because `Extant` behaves like an empty\n   * `Record`, which converts to a `string` by concatenating the string values\n   * of all its members, if all its members convert to string values.\n   */\n  stringValue(): string;\n  /**\n   * Always returns the empty `string` because `Extant` behaves like an empty\n   * `Record`, which converts to a `string` by concatenating the string values\n   * of all its members, if all its members convert to string values.\n   */\n  stringValue<T>(orElse: T): string;\n  stringValue<T>(orElse?: T): string {\n    return \"\";\n  }\n\n  /**\n   * Always returns `true` because `Extant` behaves like a truthy value.\n   */\n  booleanValue(): boolean;\n  /**\n   * Always returns `true` because `Extant` behaves like a truthy value.\n   */\n  booleanValue<T>(orElse: T): boolean;\n  booleanValue<T>(orElse?: T): boolean {\n    return true;\n  }\n\n  toAny(): AnyExtant {\n    return null;\n  }\n\n  typeOrder(): number {\n    return 98;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  hashCode(): number {\n    if (Extant._hashSeed === void 0) {\n      Extant._hashSeed = Murmur3.seed(Extant);\n    }\n    return Extant._hashSeed;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Value\").write(46/*'.'*/).write(\"extant\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    output = output.write(\"null\");\n  }\n\n  private static readonly _extant: Extant = new Extant();\n\n  private static _hashSeed?: number;\n\n  static extant(): Extant {\n    return Extant._extant;\n  }\n\n  static fromAny(value: AnyExtant): Extant {\n    if (value instanceof Extant) {\n      return value;\n    } else if (value === null) {\n      return Extant.extant();\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n}\nItem.Extant = Extant;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects, Cursor} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {Record} from \"./Record\";\nimport {AnyText} from \"./Text\";\n\nexport type AnyAbsent = Absent | undefined;\n\nexport class Absent extends Value {\n  /** @hidden */\n  private constructor() {\n    super();\n  }\n\n  /**\n   * Always returns `false` because `Absent` represents an undefined value.\n   */\n  isDefined(): boolean {\n    return false;\n  }\n\n  /**\n   * Always returns `false` because `Absent` is not a distinct value.\n   */\n  isDistinct(): boolean {\n    return false;\n  }\n\n  isConstant(): boolean {\n    return true;\n  }\n\n  /**\n   * Always returns an empty `Record` because `Absent` is not a distinct value.\n   */\n  unflattened(): Record {\n    return Value.Record.empty();\n  }\n\n  updated(key: AnyValue, value: AnyValue): Record {\n    return Value.Record.of(Item.Slot.of(key, value));\n  }\n\n  updatedAttr(key: AnyText, value: AnyValue): Record {\n    return Value.Record.of(Item.Attr.of(key, value));\n  }\n\n  updatedSlot(key: AnyValue, value: AnyValue): Record {\n    return Value.Record.of(Item.Slot.of(key, value));\n  }\n\n  appended(...items: AnyItem[]): Record {\n    return Value.Record.of(items);\n  }\n\n  prepended(...items: AnyItem[]): Record {\n    return Value.Record.of(items);\n  }\n\n  concat(...items: AnyItem[]): Record {\n    const record = Value.Record.create();\n    for (let i = 0, n = arguments.length; i < n; i += 1) {\n      Item.fromAny(arguments[i]).forEach(function (item: Item): void {\n        record.push(item);\n      });\n    }\n    return record;\n  }\n\n  cond(thenTerm: AnyValue, elseTerm: AnyValue): Value;\n  cond(thenTerm: AnyItem, elseTerm: AnyItem): Item;\n  cond(thenTerm: AnyItem, elseTerm: AnyItem): Item {\n    return Item.fromAny(elseTerm);\n  }\n\n  or(that: AnyValue): Value;\n  or(that: AnyItem): Item;\n  or(that: AnyItem): Item {\n    return Item.fromAny(that);\n  }\n\n  and(that: AnyValue): Value;\n  and(that: AnyItem): Item;\n  and(that: AnyItem): Item {\n    return this;\n  }\n\n  not(): Value {\n    return Value.extant();\n  }\n\n  /**\n   * Always returns `false` because `Absent` behaves like a falsey value.\n   */\n  booleanValue(): boolean;\n  /**\n   * Always returns `false` because `Absent` behaves like a falsey value.\n   */\n  booleanValue<T>(orElse: T): boolean;\n  booleanValue<T>(orElse?: T): boolean {\n    return false;\n  }\n\n  toAny(): AnyAbsent {\n    return void 0;\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return void 0;\n  }\n\n  iterator(): Cursor<Item> {\n    return Cursor.empty();\n  }\n\n  typeOrder(): number {\n    return 99;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  hashCode(): number {\n    if (Absent._hashSeed === void 0) {\n      Absent._hashSeed = Murmur3.seed(Absent);\n    }\n    return Absent._hashSeed;\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Value\").write(46/*'.'*/).write(\"absent\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  display(output: Output): void {\n    output = output.write(\"undefined\");\n  }\n\n  private static readonly _absent: Absent = new Absent();\n\n  private static _hashSeed?: number;\n\n  static absent(): Absent {\n    return Absent._absent;\n  }\n\n  static fromAny(value: AnyAbsent): Absent {\n    if (value instanceof Absent) {\n      return value;\n    } else if (value === void 0) {\n      return Absent.absent();\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n}\nItem.Absent = Absent;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nexport class FormException extends Error {\n  constructor(message?: string) {\n    super(message);\n    (this as any).__proto__ = FormException.prototype;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"./Item\";\nimport {AnyValue, Value} from \"./Value\";\nimport {TagForm} from \"./form/TagForm\";\nimport {UnitForm} from \"./form/UnitForm\";\nimport {StringForm} from \"./form/StringForm\";\nimport {NumberForm} from \"./form/NumberForm\";\nimport {BooleanForm} from \"./form/BooleanForm\";\nimport {AnyForm} from \"./form/AnyForm\";\nimport {ItemForm} from \"./form/ItemForm\";\nimport {ValueForm} from \"./form/ValueForm\";\n\n/**\n * Transformation between a structurally typed [Item] and a nominally typed\n * JavaScript object.\n */\nexport abstract class Form<T extends U, U = T> {\n  /**\n   * Returns the key of the tag attribute that distinguishes structures of this\n   * `Form`; returns `undefined` if this `Form` has no distinguishing tag\n   * attribute.  Used to accelerate distrcrimination of polymorphic structural\n   * types with nominal type hints.\n   */\n  tag(): string | undefined;\n\n  /**\n   * Returns a version of this `Form` that requires a head [Attr] with the\n   * given `tag` name.\n   */\n  tag(tag: string | undefined): Form<T, U>;\n\n  tag(tag?: string | undefined): string | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return void 0;\n    } else if (tag !== void 0) {\n      return new Form.TagForm<T, U>(tag, this);\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Returns a default–possibly `undefined`–value of type `T`.  Used as the\n   * fallback return value when [Item.coerce coercing] an invalid structural\n   * value.\n   */\n  unit(): T | undefined;\n\n  /**\n   * Returns a version of this `Form` with the given `unit` value.\n   */\n  unit(unit: T | undefined): Form<T, U>;\n\n  unit(unit?: T | undefined): T | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return void 0;\n    } else if (unit !== void 0) {\n      return new Form.UnitForm<T, U>(unit, this);\n    } else {\n      return this;\n    }\n  }\n\n  /**\n   * Converts a nominally typed JavaScript `object` into its structurally typed\n   * equivalent, optionally based on the provided prototype `item`.\n   */\n  abstract mold(object: U, item?: Item): Item;\n\n  /**\n   * Converts a structurally typed `item` into a nominally typed JavaScript\n   * object, optionally based on the provided prototype `object`.\n   */\n  abstract cast(item: Item, object?: T): T | undefined;\n\n  // Forward type declarations\n  /** @hidden */\n  static TagForm: typeof TagForm; // defined by TagForm\n  /** @hidden */\n  static UnitForm: typeof UnitForm; // defined by UnitForm\n  /** @hidden */\n  static StringForm: typeof StringForm; // defined by StringForm\n  /** @hidden */\n  static NumberForm: typeof NumberForm; // defined by NumberForm\n  /** @hidden */\n  static BooleanForm: typeof BooleanForm; // defined by BooleanForm\n  /** @hidden */\n  static AnyForm: typeof AnyForm; // defined by AnyForm\n  /** @hidden */\n  static ItemForm: typeof ItemForm; // defined by ItemForm\n  /** @hidden */\n  static ValueForm: typeof ValueForm; // defined by ValueForm\n\n  private static _stringForm?: Form<string>;\n  private static _numberForm?: Form<number>;\n  private static _booleanForm?: Form<boolean>;\n  private static _anyForm?: Form<AnyItem>;\n  private static _itemForm?: Form<Item, AnyItem>;\n  private static _valueForm?: Form<Value, AnyValue>;\n\n  static forString(): Form<string> {\n    if (!Form._stringForm) {\n      Form._stringForm = new Form.StringForm(\"\");\n    }\n    return Form._stringForm;\n  }\n\n  static forNumber(): Form<number> {\n    if (!Form._numberForm) {\n      Form._numberForm = new Form.NumberForm(0);\n    }\n    return Form._numberForm;\n  }\n\n  static forBoolean(): Form<boolean> {\n    if (!Form._booleanForm) {\n      Form._booleanForm = new Form.BooleanForm(false);\n    }\n    return Form._booleanForm;\n  }\n\n  static forAny(): Form<AnyItem> {\n    if (!Form._anyForm) {\n      Form._anyForm = new Form.AnyForm(void 0);\n    }\n    return Form._anyForm;\n  }\n\n  static forItem(): Form<Item, AnyItem> {\n    if (!Form._itemForm) {\n      Form._itemForm = new Form.ItemForm(Item.absent());\n    }\n    return Form._itemForm;\n  }\n\n  static forValue(): Form<Value, AnyValue> {\n    if (!Form._valueForm) {\n      Form._valueForm = new Form.ValueForm(Value.absent());\n    }\n    return Form._valueForm;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Operator} from \"../Operator\";\n\nexport abstract class BinaryOperator extends Operator {\n  /** @hidden */\n  readonly _operand1: Item;\n  /** @hidden */\n  readonly _operand2: Item;\n\n  constructor(operand1: Item, operand2: Item) {\n    super();\n    this._operand1 = operand1;\n    this._operand2 = operand2;\n  }\n\n  operand1(): Item {\n    return this._operand1;\n  }\n\n  abstract operator(): string;\n\n  operand2(): Item {\n    return this._operand2;\n  }\n\n  isConstant(): boolean {\n    return this._operand1.isConstant() && this._operand2.isConstant();\n  }\n}\nItem.BinaryOperator = BinaryOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Operator} from \"../Operator\";\n\nexport abstract class UnaryOperator extends Operator {\n  /** @hidden */\n  readonly _operand: Item;\n\n  constructor(operand: Item) {\n    super();\n    this._operand = operand;\n  }\n\n  operand(): Item {\n    return this._operand;\n  }\n\n  abstract operator(): string;\n\n  isConstant(): boolean {\n    return this._operand.isConstant();\n  }\n}\nItem.UnaryOperator = UnaryOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Operator} from \"../Operator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class ConditionalOperator extends Operator {\n  /** @hidden */\n  readonly _ifTerm: Item;\n  /** @hidden */\n  readonly _thenTerm: Item;\n  /** @hidden */\n  readonly _elseTerm: Item;\n\n  constructor(ifTerm: Item, thenTerm: Item, elseTerm: Item) {\n    super();\n    this._ifTerm = ifTerm.commit();\n    this._thenTerm = thenTerm.commit();\n    this._elseTerm = elseTerm.commit();\n  }\n\n  ifTerm(): Item {\n    return this._ifTerm;\n  }\n\n  thenTerm(): Item {\n    return this._thenTerm;\n  }\n\n  elseTerm(): Item {\n    return this._elseTerm;\n  }\n\n  isConstant(): boolean {\n    return this._ifTerm.isConstant() && this._thenTerm.isConstant()\n        && this._elseTerm.isConstant();\n  }\n\n  precedence(): number {\n    return 2;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    let result;\n    const ifTerm = this._ifTerm.evaluate(interpreter);\n    if (ifTerm.booleanValue(false)) {\n      const theTerm = this._thenTerm.evaluate(interpreter);\n      result = theTerm;\n    } else {\n      const elseTerm = this._elseTerm.evaluate(interpreter);\n      result = elseTerm;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const ifTerm = this._ifTerm.substitute(interpreter);\n    const thenTerm = this._thenTerm.substitute(interpreter);\n    const elseTerm = this._elseTerm.substitute(interpreter);\n    return new ConditionalOperator(ifTerm, thenTerm, elseTerm);\n  }\n\n  typeOrder() {\n    return 20;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof ConditionalOperator) {\n      let order = this._ifTerm.compareTo(that._ifTerm);\n      if (order === 0) {\n        order = this._thenTerm.compareTo(that._thenTerm);\n        if (order === 0) {\n          order = this._elseTerm.compareTo(that._elseTerm);\n        }\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ConditionalOperator) {\n      return this._ifTerm.equals(that._ifTerm) && this._thenTerm.equals(that._thenTerm)\n          && this._elseTerm.equals(that._elseTerm);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (ConditionalOperator._hashSeed === void 0) {\n      ConditionalOperator._hashSeed = Murmur3.seed(ConditionalOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(Murmur3.mix(ConditionalOperator._hashSeed,\n        this._ifTerm.hashCode()), this._thenTerm.hashCode()), this._elseTerm.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._ifTerm).write(46/*'.'*/).write(\"conditional\").write(40/*'('*/)\n        .debug(this._thenTerm).write(44/*','*/).write(32/*' '*/)\n        .debug(this._elseTerm).write(41/*')'*/);\n  }\n\n  clone(): ConditionalOperator {\n    return new ConditionalOperator(this._ifTerm.clone(), this._thenTerm.clone(), this._elseTerm.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.ConditionalOperator = ConditionalOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class OrOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"||\";\n  }\n\n  precedence(): number {\n    return 3;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    let result: Item;\n    const argument1 = this._operand1.evaluate(interpreter);\n    if (argument1.booleanValue(false)) {\n      result = argument1;\n    } else {\n      const argument2 = this._operand2.evaluate(interpreter);\n      result = argument2;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.or(argument2);\n  }\n\n  typeOrder(): number {\n    return 21;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof OrOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof OrOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (OrOperator._hashSeed === void 0) {\n      OrOperator._hashSeed = Murmur3.seed(OrOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(OrOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"or\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): OrOperator {\n    return new OrOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.OrOperator = OrOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class AndOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"&&\";\n  }\n\n  precedence(): number {\n    return 4;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    let result: Item;\n    const argument1 = this._operand1.evaluate(interpreter);\n    if (argument1.booleanValue(false)) {\n      const argument2 = this._operand2.evaluate(interpreter);\n      result = argument2;\n    } else {\n      result = argument1;\n    }\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.and(argument2);\n  }\n\n  typeOrder(): number {\n    return 22;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof AndOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof AndOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (AndOperator._hashSeed === void 0) {\n      AndOperator._hashSeed = Murmur3.seed(AndOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(AndOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"and\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): AndOperator {\n    return new AndOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.AndOperator = AndOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class BitwiseOrOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"|\";\n  }\n\n  precedence(): number {\n    return 5;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.bitwiseOr(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.bitwiseOr(argument2);\n  }\n\n  typeOrder(): number {\n    return 23;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof BitwiseOrOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseOrOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (BitwiseOrOperator._hashSeed === void 0) {\n      BitwiseOrOperator._hashSeed = Murmur3.seed(BitwiseOrOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseOrOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"bitwiseOr\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): BitwiseOrOperator {\n    return new BitwiseOrOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.BitwiseOrOperator = BitwiseOrOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class BitwiseXorOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"^\";\n  }\n\n  precedence(): number {\n    return 6;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.bitwiseXor(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.bitwiseXor(argument2);\n  }\n\n  typeOrder(): number {\n    return 24;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof BitwiseXorOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseXorOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (BitwiseXorOperator._hashSeed === void 0) {\n      BitwiseXorOperator._hashSeed = Murmur3.seed(BitwiseXorOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseXorOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"bitwiseXor\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): BitwiseXorOperator {\n    return new BitwiseXorOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.BitwiseXorOperator = BitwiseXorOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class BitwiseAndOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"&\";\n  }\n\n  precedence(): number {\n    return 7;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.bitwiseAnd(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.bitwiseAnd(argument2);\n  }\n\n  typeOrder(): number {\n    return 25;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof BitwiseAndOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseAndOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (BitwiseAndOperator._hashSeed === void 0) {\n      BitwiseAndOperator._hashSeed = Murmur3.seed(BitwiseAndOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(BitwiseAndOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"bitwiseAnd\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): BitwiseAndOperator {\n    return new BitwiseAndOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.BitwiseAndOperator = BitwiseAndOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class LtOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"<\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.lt(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.lt(argument2);\n  }\n\n  typeOrder(): number {\n    return 26;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof LtOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LtOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (LtOperator._hashSeed === void 0) {\n      LtOperator._hashSeed = Murmur3.seed(LtOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(LtOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"lt\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): LtOperator {\n    return new LtOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.LtOperator = LtOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class LeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"<=\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.le(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.le(argument2);\n  }\n\n  typeOrder(): number {\n    return 27;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof LeOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LeOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (LeOperator._hashSeed === void 0) {\n      LeOperator._hashSeed = Murmur3.seed(LeOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(LeOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"le\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): LeOperator {\n    return new LeOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.LeOperator = LeOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class EqOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"==\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.eq(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.eq(argument2);\n  }\n\n  typeOrder(): number {\n    return 28;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof EqOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof EqOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (EqOperator._hashSeed === void 0) {\n      EqOperator._hashSeed = Murmur3.seed(EqOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(EqOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"eq\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): EqOperator {\n    return new EqOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.EqOperator = EqOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class NeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"!=\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.ne(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.ne(argument2);\n  }\n\n  typeOrder(): number {\n    return 29;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof NeOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NeOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (NeOperator._hashSeed === void 0) {\n      NeOperator._hashSeed = Murmur3.seed(NeOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(NeOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"ne\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): NeOperator {\n    return new NeOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.NeOperator = NeOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class GeOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \">=\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.ge(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.ge(argument2);\n  }\n\n  typeOrder(): number {\n    return 30;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof GeOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GeOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (GeOperator._hashSeed === void 0) {\n      GeOperator._hashSeed = Murmur3.seed(GeOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(GeOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"ge\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): GeOperator {\n    return new GeOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.GeOperator = GeOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class GtOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \">\";\n  }\n\n  precedence(): number {\n    return 0;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.gt(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.gt(argument2);\n  }\n\n  typeOrder(): number {\n    return 31;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof GtOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GtOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (GtOperator._hashSeed === void 0) {\n      GtOperator._hashSeed = Murmur3.seed(GtOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(GtOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"gt\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): GtOperator {\n    return new GtOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.GtOperator = GtOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class PlusOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"+\";\n  }\n\n  precedence(): number {\n    return 8;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.plus(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.plus(argument2);\n  }\n\n  typeOrder(): number {\n    return 32;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof PlusOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PlusOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (PlusOperator._hashSeed === void 0) {\n      PlusOperator._hashSeed = Murmur3.seed(PlusOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(PlusOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"plus\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): PlusOperator {\n    return new PlusOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.PlusOperator = PlusOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class MinusOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"-\";\n  }\n\n  precedence(): number {\n    return 8;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.minus(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.minus(argument2);\n  }\n\n  typeOrder(): number {\n    return 33;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof MinusOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof MinusOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (MinusOperator._hashSeed === void 0) {\n      MinusOperator._hashSeed = Murmur3.seed(MinusOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(MinusOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"minus\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): MinusOperator {\n    return new MinusOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.MinusOperator = MinusOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class TimesOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"*\";\n  }\n\n  precedence(): number {\n    return 9;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.times(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.times(argument2);\n  }\n\n  typeOrder(): number {\n    return 34;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof TimesOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof TimesOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (TimesOperator._hashSeed === void 0) {\n      TimesOperator._hashSeed = Murmur3.seed(TimesOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(TimesOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"times\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): TimesOperator {\n    return new TimesOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.TimesOperator = TimesOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class DivideOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"/\";\n  }\n\n  precedence(): number {\n    return 9;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.divide(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.divide(argument2);\n  }\n\n  typeOrder(): number {\n    return 35;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof DivideOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DivideOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (DivideOperator._hashSeed === void 0) {\n      DivideOperator._hashSeed = Murmur3.seed(DivideOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(DivideOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"divide\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): DivideOperator {\n    return new DivideOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.DivideOperator = DivideOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {BinaryOperator} from \"./BinaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class ModuloOperator extends BinaryOperator {\n  constructor(operand1: Item, operand2: Item) {\n    super(operand1, operand2);\n  }\n\n  operator(): string {\n    return \"%\";\n  }\n\n  precedence(): number {\n    return 9;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    interpreter.willOperate(this);\n    const argument1 = this._operand1.evaluate(interpreter);\n    const argument2 = this._operand2.evaluate(interpreter);\n    const result = argument1.modulo(argument2);\n    interpreter.didOperate(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument1 = this._operand1.substitute(interpreter);\n    const argument2 = this._operand2.substitute(interpreter);\n    return argument1.modulo(argument2);\n  }\n\n  typeOrder(): number {\n    return 36;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof ModuloOperator) {\n      let order = this._operand1.compareTo(that._operand1);\n      if (order === 0) {\n        order = this._operand2.compareTo(that._operand2);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ModuloOperator) {\n      return this._operand1.equals(that._operand1) && this._operand2.equals(that._operand2);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (ModuloOperator._hashSeed === void 0) {\n      ModuloOperator._hashSeed = Murmur3.seed(ModuloOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(ModuloOperator._hashSeed,\n        this._operand1.hashCode()), this._operand2.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand1).write(46/*'.'*/).write(\"modulo\").write(40/*'('*/)\n        .debug(this._operand2).write(41/*')'*/);\n  }\n\n  clone(): ModuloOperator {\n    return new ModuloOperator(this._operand1.clone(), this._operand2.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.ModuloOperator = ModuloOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class NotOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  operator(): string {\n    return \"!\";\n  }\n\n  precedence(): number {\n    return 10;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.evaluate(interpreter);\n    return argument.not();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.substitute(interpreter);\n    return argument.not();\n  }\n\n  typeOrder(): number {\n    return 37;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof NotOperator) {\n      return this._operand.compareTo(that._operand);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NotOperator) {\n      return this._operand.equals(that._operand);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (NotOperator._hashSeed === void 0) {\n      NotOperator._hashSeed = Murmur3.seed(NotOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(NotOperator._hashSeed, this._operand.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand).write(46/*'.'*/).write(\"not\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  clone(): NotOperator {\n    return new NotOperator(this._operand.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.NotOperator = NotOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class BitwiseNotOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  operator(): string {\n    return \"~\";\n  }\n\n  precedence(): number {\n    return 10;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.evaluate(interpreter);\n    return argument.bitwiseNot();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.substitute(interpreter);\n    return argument.bitwiseNot();\n  }\n\n  typeOrder(): number {\n    return 38;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof BitwiseNotOperator) {\n      return this._operand.compareTo(that._operand);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof BitwiseNotOperator) {\n      return this._operand.equals(that._operand);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (BitwiseNotOperator._hashSeed === void 0) {\n      BitwiseNotOperator._hashSeed = Murmur3.seed(BitwiseNotOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(BitwiseNotOperator._hashSeed, this._operand.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand).write(46/*'.'*/).write(\"bitwiseNot\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  clone(): BitwiseNotOperator {\n    return new BitwiseNotOperator(this._operand.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.BitwiseNotOperator = BitwiseNotOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class NegativeOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  operator(): string {\n    return \"-\";\n  }\n\n  precedence(): number {\n    return 10;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.evaluate(interpreter);\n    return argument.negative();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.substitute(interpreter);\n    return argument.negative();\n  }\n\n  typeOrder(): number {\n    return 39;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof NegativeOperator) {\n      return this._operand.compareTo(that._operand);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof NegativeOperator) {\n      return this._operand.equals(that._operand);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (NegativeOperator._hashSeed === void 0) {\n      NegativeOperator._hashSeed = Murmur3.seed(NegativeOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(NegativeOperator._hashSeed, this._operand.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand).write(46/*'.'*/).write(\"negative\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  clone(): NegativeOperator {\n    return new NegativeOperator(this._operand.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.NegativeOperator = NegativeOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {UnaryOperator} from \"./UnaryOperator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class PositiveOperator extends UnaryOperator {\n  constructor(operand: Item) {\n    super(operand);\n  }\n\n  operator(): string {\n    return \"+\";\n  }\n\n  precedence(): number {\n    return 10;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.evaluate(interpreter);\n    return argument.positive();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const argument = this._operand.substitute(interpreter);\n    return argument.positive();\n  }\n\n  typeOrder(): number {\n    return 40;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof PositiveOperator) {\n      return this._operand.compareTo(that._operand);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof PositiveOperator) {\n      return this._operand.equals(that._operand);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (PositiveOperator._hashSeed === void 0) {\n      PositiveOperator._hashSeed = Murmur3.seed(PositiveOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(PositiveOperator._hashSeed, this._operand.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._operand).write(46/*'.'*/).write(\"positive\").write(40/*'('*/).write(41/*')'*/);\n  }\n\n  clone(): PositiveOperator {\n    return new PositiveOperator(this._operand.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.PositiveOperator = PositiveOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Value} from \"../Value\";\nimport {Operator} from \"../Operator\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class InvokeOperator extends Operator {\n  /** @hidden */\n  readonly _func: Value;\n  /** @hidden */\n  readonly _args: Value;\n  /** @hidden */\n  _state?: unknown;\n\n  constructor(func: Value, args: Value) {\n    super();\n    this._func = func;\n    this._args = args.commit();\n  }\n\n  func(): Value {\n    return this._func;\n  }\n\n  args(): Value {\n    return this._args;\n  }\n\n  state(): unknown {\n    return this._state;\n  }\n\n  setState(state: unknown) {\n    this._state = state;\n  }\n\n  isConstant(): boolean {\n    return this._func.isConstant() && this._args.isConstant();\n  }\n\n  precedence(): number {\n    return 11;\n  }\n\n  evaluate(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const func = this._func.evaluate(interpreter);\n    if (func instanceof Item.Func) {\n      return func.invoke(this._args, interpreter, this);\n    }\n    return Item.absent();\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const func = this._func.evaluate(interpreter);\n    if (func instanceof Item.Func) {\n      const result = func.expand(this._args, interpreter, this);\n      if (result) {\n        return result;\n      }\n    }\n    const args = this._args.substitute(interpreter).toValue();\n    return new InvokeOperator(this._func, args);\n  }\n\n  typeOrder(): number {\n    return 41;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof InvokeOperator) {\n      let order = this._func.compareTo(that._func);\n      if (order === 0) {\n        order = this._args.compareTo(that._args);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof InvokeOperator) {\n      return this._func.equals(that._func) && this._args.equals(that._args);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (InvokeOperator._hashSeed === void 0) {\n      InvokeOperator._hashSeed = Murmur3.seed(InvokeOperator);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(InvokeOperator._hashSeed,\n        this._func.hashCode()), this._args.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this._func).write(46/*'.'*/).write(\"invoke\").write(40/*'('*/)\n        .debug(this._args).write(41/*')'*/);\n  }\n\n  clone(): InvokeOperator {\n    return new InvokeOperator(this._func.clone(), this._args.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.InvokeOperator = InvokeOperator;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"../Item\";\nimport {AnyValue, Value} from \"../Value\";\nimport {AnyText} from \"../Text\";\nimport {AnyNum} from \"../Num\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class IdentitySelector extends Selector {\n  then(): Selector {\n    return this;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const oldScope = interpreter.popScope();\n      // Evaluate the current selection.\n      const newScope = oldScope.evaluate(interpreter);\n      // Push the evaluated selection onto the scope stack.\n      interpreter.pushScope(newScope);\n      // Visit the evaluated selection.\n      selected = callback.call(thisArg, interpreter);\n      // Restore the original selection to the top of the scope stack.\n      interpreter.swapScope(oldScope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    return transform.call(thisArg, interpreter);\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    return interpreter.peekScope().substitute(interpreter);\n  }\n\n  get(key: AnyValue): Selector {\n    key = Value.fromAny(key);\n    return new Item.GetSelector(key, this);\n  }\n\n  getAttr(key: AnyText): Selector {\n    key = Item.Text.fromAny(key);\n    return new Item.GetAttrSelector(key, this);\n  }\n\n  getItem(index: AnyNum): Selector {\n    index = Item.Num.fromAny(index);\n    return new Item.GetItemSelector(index, this);\n  }\n\n  andThen(then: Selector): Selector {\n    return then;\n  }\n\n  keys(): Selector {\n    return Selector.keys();\n  }\n\n  values(): Selector {\n    return Selector.values();\n  }\n\n  children(): Selector {\n    return Selector.children();\n  }\n\n  descendants(): Selector {\n    return Selector.descendants();\n  }\n\n  filter(predicate?: AnyItem): Selector {\n    if (arguments.length === 0) {\n      return new Item.FilterSelector(this, this);\n    } else {\n      predicate = Item.fromAny(predicate);\n      return predicate.filter();\n    }\n  }\n\n  typeOrder(): number {\n    return 10;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  hashCode(): number {\n    if (IdentitySelector._hashSeed === void 0) {\n      IdentitySelector._hashSeed = Murmur3.seed(IdentitySelector);\n    }\n    return IdentitySelector._hashSeed;\n  }\n\n  debugThen(output: Output): void {\n    // nop\n  }\n\n  clone(): Selector {\n    return this;\n  }\n\n  private static _hashSeed?: number;\n}\nItem.IdentitySelector = IdentitySelector;\nSelector._identity = new IdentitySelector();\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport {Value} from \"../Value\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class GetSelector extends Selector {\n  /** @hidden */\n  readonly _key: Value;\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(key: Value, then: Selector) {\n    super();\n    this._key = key.commit();\n    this._then = then;\n  }\n\n  accessor(): Value {\n    return this._key;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    interpreter.willSelect(this);\n    // Evaluate the key, in case it's dynamic.\n    const key = this._key.evaluate(interpreter).toValue();\n    const selected = GetSelector.forSelected(key, this._then, interpreter, callback, thisArg);\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  private static forSelected<T, S>(key: Value, then: Selector, interpreter: Interpreter,\n                                   callback: (this: S, interpreter: Interpreter) => T,\n                                   thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        field = scope.getField(key);\n        if (field) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(field.toValue());\n          // Subselect the field value.\n          selected = then.forSelected(interpreter, callback, thisArg);\n          // Pop the field value off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        GetSelector.forSelected(key, then, interpreter, callback, thisArg);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    // Evaluate the key, if it's dynamic.\n    const key = this._key.evaluate(interpreter).toValue();\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        const oldField = scope.getField(key);\n        if (oldField) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(oldField.toValue());\n          // Transform the field value.\n          const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n          // Pop the field value off the scope stack.\n          interpreter.popScope();\n          if (newItem instanceof Item.Field) {\n            // Replace the original field with the transformed field.\n            if (key.equals(newItem.key)) {\n              scope.set(key, newItem.toValue());\n            } else {\n              scope.delete(key);\n              scope.push(newItem);\n            }\n          } else if (newItem.isDefined()) {\n            // Update the field with the transformed value.\n            scope.set(key, newItem.toValue());\n          } else {\n            // Remove the field.\n            scope.delete(key);\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    // Evaluate the key, in case it's dynamic.\n    const key = this._key.evaluate(interpreter).toValue();\n    const value = GetSelector.substitute(key, this._then, interpreter);\n    if (value) {\n      return value;\n    }\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new GetSelector(this._key, then as Selector);\n  }\n\n  private static substitute(key: Value, then: Selector, interpreter: Interpreter): Item | undefined {\n    let selected: Item | undefined;\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        field = scope.getField(key);\n        if (field) {\n          // Substitute the field value.\n          selected = field.toValue().substitute(interpreter);\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        GetSelector.substitute(key, then, interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  andThen(then: Selector): Selector {\n    return new GetSelector(this._key, this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 12;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof GetSelector) {\n      let order = this._key.compareTo(that._key);\n      if (order === 0) {\n        order = this._then.compareTo(that._then);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetSelector) {\n      return this._key.equals(that._key) && this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (GetSelector._hashSeed === void 0) {\n      GetSelector._hashSeed = Murmur3.seed(GetSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetSelector._hashSeed,\n        this._key.hashCode()), this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"get\").write(40/*'('*/).debug(this._key).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new GetSelector(this._key.clone(), this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.GetSelector = GetSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Field} from \"../Field\";\nimport {Attr} from \"../Attr\";\nimport {Text} from \"../Text\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class GetAttrSelector extends Selector {\n  /** @hidden */\n  readonly _key: Text;\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(key: Text, then: Selector) {\n    super();\n    this._key = key;\n    this._then = then;\n  }\n\n  accessor(): Text {\n    return this._key;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    interpreter.willSelect(this);\n    const key = this._key;\n    const selected = GetAttrSelector.forSelected(key, this._then, interpreter, callback);\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  private static forSelected<T, S>(key: Text, then: Selector, interpreter: Interpreter,\n                                   callback: (this: S, interpreter: Interpreter) => T | undefined,\n                                   thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        field = scope.getField(key);\n        if (field instanceof Attr) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(field.toValue());\n          // Subselect the field value.\n          selected = then.forSelected(interpreter, callback, thisArg);\n          // Pop the field value off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        GetAttrSelector.forSelected(key, then, interpreter, callback, thisArg);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    const key = this._key;\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        const oldField = scope.getField(key);\n        if (oldField instanceof Item.Attr) {\n          // Push the field value onto the scope stack.\n          interpreter.pushScope(oldField.toValue());\n          // Transform the field value.\n          const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n          // Pop the field value off the scope stack.\n          interpreter.popScope();\n          if (newItem instanceof Item.Field) {\n            // Replace the original field with the transformed field.\n            if (key.equals(newItem.key)) {\n              scope.setAttr(key, newItem.toValue());\n            } else {\n              scope.delete(key);\n              scope.push(newItem);\n            }\n          } else if (newItem.isDefined()) {\n            // Update the field with the transformed value.\n            scope.setAttr(key, newItem.toValue());\n          } else {\n            // Remove the field.\n            scope.delete(key);\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const key = this._key;\n    const value = GetAttrSelector.substitute(key, this._then, interpreter);\n    if (value) {\n      return value;\n    }\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new GetAttrSelector(this._key, then as Selector);\n  }\n\n  private static substitute(key: Text, then: Selector, interpreter: Interpreter): Item | undefined {\n    let selected: Item | undefined;\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the next selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let field: Field | undefined;\n      // Only records can have members.\n      if (scope instanceof Item.Record) {\n        field = scope.getField(key);\n        if (field instanceof Item.Attr) {\n          // Substitute the field value.\n          selected = field.toValue().substitute(interpreter);\n        }\n      }\n      if (field === void 0 && selected === void 0) {\n        GetAttrSelector.substitute(key, then, interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    return selected;\n  }\n\n  andThen(then: Selector): Selector {\n    return new GetAttrSelector(this._key, this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 13;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof GetAttrSelector) {\n      let order = this._key.compareTo(that._key);\n      if (order === 0) {\n        order = this._then.compareTo(that._then);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetAttrSelector) {\n      return this._key.equals(that._key) && this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (GetAttrSelector._hashSeed === void 0) {\n      GetAttrSelector._hashSeed = Murmur3.seed(GetAttrSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetAttrSelector._hashSeed,\n        this._key.hashCode()), this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"getAttr\").write(40/*'('*/).debug(this._key).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new GetAttrSelector(this._key.clone(), this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.GetAttrSelector = GetAttrSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Num} from \"../Num\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class GetItemSelector extends Selector {\n  /** @hidden */\n  readonly _index: Num;\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(index: Num, then: Selector) {\n    super();\n    this._index = index;\n    this._then = then;\n  }\n\n  accessor(): Num {\n    return this._index;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    const index = this._index.numberValue();\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      if (scope instanceof Item.Record && index < scope.length) {\n        const item = scope.getItem(index);\n        // Push the item onto the scope stack.\n        interpreter.pushScope(item);\n        // Subselect the item.\n        selected = this._then.forSelected(interpreter, callback, thisArg);\n        // Pop the item off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      const index = this._index.numberValue();\n      if (scope instanceof Item.Record && index < scope.length) {\n        const oldItem = scope.getItem(index);\n        // Push the item onto the scope stack.\n        interpreter.pushScope(oldItem);\n        // Transform the item.\n        const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n        // Pop the item off the scope stack.\n        interpreter.popScope();\n        if (newItem.isDefined()) {\n          scope.setItem(index, newItem);\n        } else {\n          scope.splice(index, 1);\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const index = this._index.numberValue();\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      let selected: Item | undefined;\n      if (scope instanceof Item.Record && index < scope.length) {\n        const item = scope.getItem(index);\n        // Substitute the item.\n        selected = item.substitute(interpreter);\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n      if (selected) {\n        return selected;\n      }\n    }\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new GetItemSelector(this._index, then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new GetItemSelector(this._index, this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 14;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof GetItemSelector) {\n      let order = this._index.compareTo(that._index);\n      if (order === 0) {\n        order = this._then.compareTo(that._then);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof GetItemSelector) {\n      return this._index.equals(that._index) && this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (GetItemSelector._hashSeed === void 0) {\n      GetItemSelector._hashSeed = Murmur3.seed(GetItemSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(GetItemSelector._hashSeed,\n        this._index.hashCode()), this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"getItem\").write(40/*'('*/).debug(this._index).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new GetItemSelector(this._index, this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.GetItemSelector = GetItemSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class KeysSelector extends Selector {\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(then: Selector) {\n    super();\n    this._then = then;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope();\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Only fields can have keys.\n          if (child instanceof Item.Field) {\n            // Push the child key onto the scope stack.\n            interpreter.pushScope(child.key);\n            // Subselect the child key.\n            selected = this._then.forSelected(interpreter, callback, thisArg);\n            // Pop the child key off of the scope stack.\n            interpreter.popScope();\n          }\n        }\n      } else if (scope instanceof Item.Field) {\n        // Push the key onto the scope stack.\n        interpreter.pushScope(scope.key);\n        // Subselect the key.\n        selected = this._then.forSelected(interpreter, callback, thisArg);\n        // Pop the key off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      let scope = interpreter.popScope();\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        while (children.hasNext()) {\n          const child = children.next().value!;\n          if (child instanceof Item.Field) {\n            const oldKey = child.key;\n            // Push the key onto the scope stack.\n            interpreter.pushScope(oldKey);\n            // Subselect the key.\n            const newKey = this._then.mapSelected(interpreter, transform, thisArg).toValue();\n            // Pop the key off of the scope stack.\n            interpreter.popScope();\n            if (newKey.isDefined()) {\n              if (oldKey !== newKey) {\n                if (scope instanceof Item.Attr && newKey instanceof Item.Text) {\n                  children.set(Item.Attr.of(newKey, scope.toValue()));\n                } else {\n                  children.set(Item.Slot.of(newKey, scope.toValue()));\n                }\n              }\n            } else {\n              children.delete();\n            }\n          }\n        }\n      } else if (scope instanceof Item.Field) {\n        const oldKey = scope.key;\n        // Push the key onto the scope stack.\n        interpreter.pushScope(oldKey);\n        // Subselect the key.\n        const newKey = this._then.mapSelected(interpreter, transform, thisArg).toValue();\n        // Pop the key off of the scope stack.\n        interpreter.popScope();\n        if (newKey.isDefined()) {\n          if (oldKey !== newKey) {\n            if (scope instanceof Item.Attr && newKey instanceof Item.Text) {\n              scope = Item.Attr.of(newKey, scope.toValue());\n            } else {\n              scope = Item.Slot.of(newKey, scope.toValue());\n            }\n          }\n        } else {\n          scope = Item.absent();\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new KeysSelector(then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new KeysSelector(this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 15;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof KeysSelector) {\n      return this._then.compareTo(that._then);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof KeysSelector) {\n      return this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (KeysSelector._hashSeed === void 0) {\n      KeysSelector._hashSeed = Murmur3.seed(KeysSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(KeysSelector._hashSeed, this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"keys\").write(40/*'('*/).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new KeysSelector(this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.KeysSelector = KeysSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class ValuesSelector extends Selector {\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(then: Selector) {\n    super();\n    this._then = then;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope();\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child value onto the scope stack.\n          interpreter.pushScope(child.toValue());\n          // Subselect the child value.\n          selected = this._then.forSelected(interpreter, callback, thisArg);\n          // Pop the child value off of the scope stack.\n          interpreter.popScope();\n        }\n      } else {\n        // Push the value onto the scope stack.\n        interpreter.pushScope(scope.toValue());\n        // Subselect the value.\n        selected = this._then.forSelected(interpreter, callback, thisArg);\n        // Pop the value off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      let scope = interpreter.popScope();\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        while (children.hasNext()) {\n          const child = children.next().value!;\n          if (child instanceof Item.Field) {\n            const oldValue = child.toValue();\n            // Push the child value onto the scope stack.\n            interpreter.pushScope(oldValue);\n            // Transform the child value.\n            const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n            // Pop the child value off of the scope stack.\n            interpreter.popScope();\n            if (newItem.isDefined()) {\n              if (newItem instanceof Item.Field) {\n                children.set(newItem);\n              } else if (newItem !== oldValue) {\n                children.set(child.updatedValue(newItem.toValue()));\n              }\n            } else {\n              children.delete();\n            }\n          } else {\n            // Push the child onto the scope stack.\n            interpreter.pushScope(child.toValue());\n            // Transform the child.\n            const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n            // Pop the child off of the scope stack.\n            interpreter.popScope();\n            if (newItem.isDefined()) {\n              if (child !== newItem) {\n                children.set(newItem);\n              }\n            } else {\n              children.delete();\n            }\n          }\n        }\n      } else if (scope instanceof Item.Field) {\n        const oldValue = scope.toValue();\n        // Push the field value onto the scope stack.\n        interpreter.pushScope(oldValue);\n        // Transform the field value.\n        const newItem = this._then.mapSelected(interpreter, transform, thisArg);\n        // Pop the field value off of the scope stack.\n        interpreter.popScope();\n        if (newItem.isDefined()) {\n          if (newItem instanceof Item.Field) {\n            scope = newItem;\n          } else if (newItem !== oldValue) {\n            scope = scope.updatedValue(newItem.toValue());\n          }\n        } else {\n          scope = Item.absent();\n        }\n      } else {\n        // Push the value onto the scope stack.\n        interpreter.pushScope(scope);\n        // Transform the value.\n        scope = this._then.mapSelected(interpreter, transform, thisArg);\n        // Pop the value off of the scope stack.\n        interpreter.popScope();\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new ValuesSelector(then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new ValuesSelector(this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 16;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof ValuesSelector) {\n      return this._then.compareTo(that._then);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ValuesSelector) {\n      return this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (ValuesSelector._hashSeed === void 0) {\n      ValuesSelector._hashSeed = Murmur3.seed(ValuesSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(ValuesSelector._hashSeed, this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"values\").write(40/*'('*/).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new ValuesSelector(this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.ValuesSelector = ValuesSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class ChildrenSelector extends Selector {\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(then: Selector) {\n    super();\n    this._then = then;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have children.\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child, while none have been selected:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(child);\n          // Subselect the child.\n          selected = this._then.forSelected(interpreter, callback, thisArg);\n          // Pop the child off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have children.\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child:\n        while (children.hasNext()) {\n          const oldChild = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(oldChild);\n          // Transform the child.\n          const newChild = this._then.mapSelected(interpreter, transform);\n          // Pop the child off the scope stack.\n          interpreter.popScope();\n          if (newChild.isDefined()) {\n            // Update the child, if its identity changed.\n            if (newChild !== oldChild) {\n              children.set(newChild);\n            }\n          } else {\n            // Remove the child, if it transformed to Absent.\n            children.delete();\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new ChildrenSelector(then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new ChildrenSelector(this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 17;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof ChildrenSelector) {\n      return this._then.compareTo(that._then);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof ChildrenSelector) {\n      return this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (ChildrenSelector._hashSeed === void 0) {\n      ChildrenSelector._hashSeed = Murmur3.seed(ChildrenSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(ChildrenSelector._hashSeed, this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"children\").write(40/*'('*/).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new ChildrenSelector(this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.ChildrenSelector = ChildrenSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class DescendantsSelector extends Selector {\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(then: Selector) {\n    super();\n    this._then = then;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have descendants.\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child, while none have selected a result:\n        while (selected === void 0 && children.hasNext()) {\n          const child = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(child);\n          // Subselect the child.\n          selected = this._then.forSelected(interpreter, callback, thisArg);\n          // If the child was not selected:\n          if (selected === void 0) {\n            // Recursively select the child's children.\n            this.forSelected(interpreter, callback, thisArg);\n          }\n          // Pop the child off of the scope stack.\n          interpreter.popScope();\n        }\n      }\n      // Push the current selection back onto the stack.\n      interpreter.pushScope(scope);\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // Pop the current selection off of the stack to take it out of scope.\n      const scope = interpreter.popScope().toValue();\n      // Only records can have descendants.\n      if (scope instanceof Item.Record) {\n        const children = scope.iterator();\n        // For each child:\n        while (children.hasNext()) {\n          const oldChild = children.next().value!;\n          // Push the child onto the scope stack.\n          interpreter.pushScope(oldChild);\n          // Transform the child.\n          let newChild = this._then.mapSelected(interpreter, transform, thisArg);\n          // If the child was not removed:\n          if (newChild.isDefined()) {\n            // Recursively transform the child's children.\n            newChild = this.mapSelected(interpreter, transform, thisArg);\n          }\n          // Pop the child off the scope stack.\n          interpreter.popScope();\n          if (newChild.isDefined()) {\n            // Update the child, if its identity changed.\n            if (newChild !== oldChild) {\n              children.set(newChild);\n            }\n          } else {\n            // Remove the child, if it transformed to Absent.\n            children.delete();\n          }\n        }\n      }\n      // Push the transformed selection back onto the stack.\n      interpreter.pushScope(scope);\n      result = scope;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new DescendantsSelector(then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new DescendantsSelector(this._then.andThen(then));\n  }\n\n  typeOrder(): number {\n    return 18;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof DescendantsSelector) {\n      return this._then.compareTo(that._then);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof DescendantsSelector) {\n      return this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (DescendantsSelector._hashSeed === void 0) {\n      DescendantsSelector._hashSeed = Murmur3.seed(DescendantsSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(DescendantsSelector._hashSeed, this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"descendants\").write(40/*'('*/).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new DescendantsSelector(this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.DescendantsSelector = DescendantsSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {AnyItem, Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class FilterSelector extends Selector {\n  /** @hidden */\n  readonly _predicate: Selector;\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(predicate: Selector, then: Selector) {\n    super();\n    this._predicate = predicate;\n    this._then = then;\n  }\n\n  predicate(): Selector {\n    return this._predicate;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // If the filter matches the selection scope:\n      if (this.filterSelected(interpreter)) {\n        // Then subselect the selection scope.\n        selected = this._then.forSelected(interpreter, callback, thisArg);\n      }\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      // If the filter matches the selection scope:\n      if (this.filterSelected(interpreter)) {\n        // Then transform the selection scope.\n        result = this._then.mapSelected(interpreter, transform, thisArg);\n      } else {\n        result = interpreter.peekScope().toValue();\n      }\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let predicate = this._predicate.substitute(interpreter);\n    if (!(predicate instanceof Selector)) {\n      predicate = this._predicate;\n    }\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new FilterSelector(predicate as Selector, then as Selector);\n  }\n\n  protected filterSelected(interpreter: Interpreter): boolean {\n    return this._predicate.forSelected(interpreter, this.selected, this) !== void 0;\n  }\n\n  protected selected(interpreter: Interpreter): null {\n    return null;\n  }\n\n  andThen(then: Selector): Selector {\n    return new FilterSelector(this._predicate, this._then.andThen(then));\n  }\n\n  filter(predicate?: AnyItem): Selector {\n    if (arguments.length === 0) {\n      return this;\n    } else {\n      predicate = Item.fromAny(predicate);\n      return this.andThen(predicate.filter());\n    }\n  }\n\n  typeOrder(): number {\n    return 19;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof FilterSelector) {\n      let order = this._predicate.compareTo(that._predicate);\n      if (order === 0) {\n        order = this._then.compareTo(that._then);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof FilterSelector) {\n      return this._predicate.equals(that._predicate) && this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (FilterSelector._hashSeed === void 0) {\n      FilterSelector._hashSeed = Murmur3.seed(FilterSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(FilterSelector._hashSeed,\n        this._predicate.hashCode()), this._then.hashCode()));\n  }\n\n  debugThen(output: Output): void {\n    output = output.write(46/*'.'*/).write(\"filter\").write(40/*'('*/).debug(this._predicate).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  clone(): Selector {\n    return new FilterSelector(this._predicate.clone(), this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.FilterSelector = FilterSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Selector} from \"../Selector\";\nimport {AnyInterpreter, Interpreter} from \"../Interpreter\";\n\nexport class LiteralSelector extends Selector {\n  /** @hidden */\n  readonly _item: Item;\n  /** @hidden */\n  readonly _then: Selector;\n\n  constructor(item: Item, then: Selector) {\n    super();\n    this._item = item.commit();\n    this._then = then;\n  }\n\n  item(): Item {\n    return this._item;\n  }\n\n  then(): Selector {\n    return this._then;\n  }\n\n  forSelected<T, S = unknown>(interpreter: Interpreter,\n                              callback: (this: S, interpreter: Interpreter) => T | undefined,\n                              thisArg?: S): T | undefined {\n    let selected: T | undefined;\n    interpreter.willSelect(this);\n    if (interpreter.scopeDepth() !== 0) {\n      const literal = this._item.evaluate(interpreter);\n      if (literal.isDefined()) {\n        // Push the literal onto the scope stack.\n        interpreter.pushScope(literal);\n        // Subselect the literal.\n        selected = this._then.forSelected(interpreter, callback, thisArg);\n        // Pop the literal off of the scope stack.\n        interpreter.popScope();\n      }\n    }\n    interpreter.didSelect(this, selected);\n    return selected;\n  }\n\n  mapSelected<S = unknown>(interpreter: Interpreter,\n                           transform: (this: S, interpreter: Interpreter) => Item,\n                           thisArg?: S): Item {\n    let result: Item;\n    interpreter.willTransform(this);\n    if (interpreter.scopeDepth() !== 0) {\n      let literal = this._item.evaluate(interpreter);\n      if (literal.isDefined()) {\n        // Push the literal onto the scope stack.\n        interpreter.pushScope(literal);\n        // Transform the literal.\n        literal = this._then.mapSelected(interpreter, transform, thisArg);\n        // Pop the literal off of the scope stack.\n        interpreter.popScope();\n      }\n      result = literal;\n    } else {\n      result = Item.absent();\n    }\n    interpreter.didTransform(this, result);\n    return result;\n  }\n\n  substitute(interpreter: AnyInterpreter): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const item = this._item.substitute(interpreter);\n    let then = this._then.substitute(interpreter);\n    if (!(then instanceof Selector)) {\n      then = this._then;\n    }\n    return new LiteralSelector(item, then as Selector);\n  }\n\n  andThen(then: Selector): Selector {\n    return new LiteralSelector(this._item, this._then.andThen(then));\n  }\n\n  precedence(): number {\n    return this._item.precedence();\n  }\n\n  typeOrder(): number {\n    return 11;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof LiteralSelector) {\n      let order = this._item.compareTo(that._item);\n      if (order === 0) {\n        order = this._then.compareTo(that._then);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LiteralSelector) {\n      return this._item.equals(that._item) && this._then.equals(that._then);\n    }\n    return false;\n  }\n\n  hashCode(): number {\n    if (LiteralSelector._hashSeed === void 0) {\n      LiteralSelector._hashSeed = Murmur3.seed(LiteralSelector);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(LiteralSelector._hashSeed,\n        this._item.hashCode()), this._then.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output = output.write(\"Selector\").write(46/*'.'*/).write(\"literal\").write(40/*'('*/)\n        .debug(this._item).write(41/*')'*/);\n    this._then.debugThen(output);\n  }\n\n  debugThen(output: Output): void {\n    // nop\n  }\n\n  clone(): Selector {\n    return new LiteralSelector(this._item.clone(), this._then.clone());\n  }\n\n  private static _hashSeed?: number;\n}\nItem.LiteralSelector = LiteralSelector;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Value} from \"../Value\";\nimport {Func} from \"../Func\";\nimport {Interpreter} from \"../Interpreter\";\nimport {InvokeOperator} from \"../operator/InvokeOperator\";\n\nexport class LambdaFunc extends Func {\n  readonly _bindings: Value;\n  readonly _template: Value;\n\n  constructor(bindings: Value, template: Value) {\n    super();\n    this._bindings = bindings;\n    this._template = template;\n  }\n\n  bindings(): Value {\n    return this._bindings;\n  }\n\n  template(): Value {\n    return this._template;\n  }\n\n  precedence(): number {\n    return 1;\n  }\n\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const bindings = this._bindings;\n    const arity = Math.max(1, bindings.length);\n    const params = Item.Record.create(arity);\n    let i = 0;\n    let j = 0;\n    while (i < arity) {\n      const binding = bindings instanceof Item.Record ? bindings.getItem(i) : i === 0 ? bindings : Item.absent();\n      const arg = args instanceof Item.Record ? args.getItem(j).toValue() : j === 0 ? args : Item.Value.absent();\n      if (binding instanceof Item.Text && arg.isDistinct()) {\n        params.push(Item.Slot.of(binding, arg));\n        j += 1;\n      } else if (binding instanceof Item.Slot) {\n        if (arg.isDistinct()) {\n          params.push(binding.updatedValue(arg));\n        } else {\n          params.push(binding);\n        }\n        j += 1;\n      }\n      i += 1;\n    }\n    interpreter.pushScope(params);\n    const result = this._template.evaluate(interpreter);\n    interpreter.popScope();\n    return result;\n  }\n\n  typeOrder(): number {\n    return 50;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof LambdaFunc) {\n      let order = this._bindings.compareTo(that._bindings);\n      if (order === 0) {\n        order = this._template.compareTo(that._template);\n      }\n      return order;\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    if (this === that) {\n      return true;\n    } else if (that instanceof LambdaFunc) {\n      return this._bindings.equals(that._bindings) && this._template.equals(that._template);\n    }\n    return false;\n  }\n\n  hashCode() {\n    if (LambdaFunc._hashSeed === void 0) {\n      LambdaFunc._hashSeed = Murmur3.seed(LambdaFunc);\n    }\n    return Murmur3.mash(Murmur3.mix(Murmur3.mix(LambdaFunc._hashSeed,\n        this._bindings.hashCode()), this._template.hashCode()));\n  }\n\n  debug(output: Output): void {\n    output.debug(this.bindings).write(46/*'.'*/).write(\"lambda\").write(40/*'('*/)\n        .debug(this.template).write(41/*')'*/);\n  }\n\n  private static _hashSeed?: number;\n}\nItem.LambdaFunc = LambdaFunc;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Murmur3, Objects} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {Item} from \"../Item\";\nimport {Func} from \"../Func\";\n\nexport abstract class BridgeFunc extends Func {\n  typeOrder(): number {\n    return 51;\n  }\n\n  compareTo(that: Item): 0 | 1 | -1 {\n    if (that instanceof BridgeFunc) {\n      return Objects.compare((this as any).__proto__.constructor.name,\n                             (that as any).__proto__.constructor.name);\n    }\n    return Objects.compare(this.typeOrder(), that.typeOrder());\n  }\n\n  equals(that: unknown): boolean {\n    return this === that;\n  }\n\n  hashCode(): number {\n    return Murmur3.seed((this as any).__proto__.constructor);\n  }\n\n  debug(output: Output) {\n    output = output.write((this as any).__proto__.constructor.name);\n  }\n}\nItem.BridgeFunc = BridgeFunc;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Value} from \"../Value\";\nimport {Record} from \"../Record\";\nimport {Func} from \"../Func\";\nimport {Interpreter} from \"../Interpreter\";\nimport {InvokeOperator} from \"../operator/InvokeOperator\";\nimport {BridgeFunc} from \"./BridgeFunc\";\n\nexport class MathModule {\n  private constructor() {\n    // stub\n  }\n\n  private static _max?: Func;\n  private static _min?: Func;\n  private static _abs?: Func;\n  private static _ceil?: Func;\n  private static _floor?: Func;\n  private static _round?: Func;\n  private static _sqrt?: Func;\n  private static _pow?: Func;\n  private static _rate?: Func;\n  private static _random?: Func;\n\n  private static _scope?: Record;\n\n  static max(): Func {\n    if (!MathModule._max) {\n      MathModule._max = new MaxFunc();\n    }\n    return MathModule._max;\n  }\n\n  static min(): Func {\n    if (!MathModule._min) {\n      MathModule._min = new MinFunc();\n    }\n    return MathModule._min;\n  }\n\n  static abs(): Func {\n    if (!MathModule._abs) {\n      MathModule._abs = new AbsFunc();\n    }\n    return MathModule._abs;\n  }\n\n  static ceil(): Func {\n    if (!MathModule._ceil) {\n      MathModule._ceil = new CeilFunc();\n    }\n    return MathModule._ceil;\n  }\n\n  static floor(): Func {\n    if (!MathModule._floor) {\n      MathModule._floor = new FloorFunc();\n    }\n    return MathModule._floor;\n  }\n\n  static round(): Func {\n    if (!MathModule._round) {\n      MathModule._round = new RoundFunc();\n    }\n    return MathModule._round;\n  }\n\n  static sqrt(): Func {\n    if (!MathModule._sqrt) {\n      MathModule._sqrt = new SqrtFunc();\n    }\n    return MathModule._sqrt;\n  }\n\n  static pow(): Func {\n    if (!MathModule._pow) {\n      MathModule._pow = new PowFunc();\n    }\n    return MathModule._pow;\n  }\n\n  static rate(): Func {\n    if (!MathModule._rate) {\n      MathModule._rate = new RateFunc();\n    }\n    return MathModule._rate;\n  }\n\n  static random(): Func {\n    if (!MathModule._random) {\n      MathModule._random = new RandomFunc();\n    }\n    return MathModule._random;\n  }\n\n  static scope(): Record {\n    if (!MathModule._scope) {\n      MathModule._scope = Item.Record.create(10)\n          .slot(\"max\", MathModule.max())\n          .slot(\"min\", MathModule.min())\n          .slot(\"abs\", MathModule.abs())\n          .slot(\"ceil\", MathModule.ceil())\n          .slot(\"floor\", MathModule.floor())\n          .slot(\"round\", MathModule.round())\n          .slot(\"pow\", MathModule.pow())\n          .slot(\"sqrt\", MathModule.sqrt())\n          .slot(\"rate\", MathModule.rate())\n          .slot(\"random\", MathModule.random())\n          .commit();\n    }\n    return MathModule._scope;\n  }\n}\nItem.MathModule = MathModule;\n\n/** @hidden */\nclass MaxFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let x: Item;\n    let y: Item | undefined;\n    if (args.length >= 2) {\n      x = args.getItem(0).evaluate(interpreter);\n      y = args.getItem(1).evaluate(interpreter);\n    } else {\n      x = args.evaluate(interpreter);\n    }\n    if (y !== void 0) {\n      return x.max(y);\n    } else if (operator) {\n      y = operator.state() as Item;\n      const max = y !== void 0 ? x.max(y) : x;\n      operator.setState(max);\n      return max;\n    }\n    return Item.absent();\n  }\n\n  expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n    if (args.length === 1) {\n      args = args.evaluate(interpreter).toValue();\n      return this.invoke(args, interpreter, operator);\n    }\n    return void 0;\n  }\n}\n\n/** @hidden */\nclass MinFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let x: Item;\n    let y: Item | undefined;\n    if (args.length >= 2) {\n      x = args.getItem(0).evaluate(interpreter);\n      y = args.getItem(1).evaluate(interpreter);\n    } else {\n      x = args.evaluate(interpreter);\n    }\n    if (y !== void 0) {\n      return x.min(y);\n    } else if (operator) {\n      y = operator.state() as Item;\n      const min = y !== void 0 ? x.min(y) : x;\n      operator.setState(min);\n      return min;\n    }\n    return Item.absent();\n  }\n\n  expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n    if (args.length === 1) {\n      args = args.evaluate(interpreter).toValue();\n      return this.invoke(args, interpreter, operator);\n    }\n    return void 0;\n  }\n}\n\n/** @hidden */\nclass AbsFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    if (args instanceof Item.Num) {\n      return args.abs();\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass CeilFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    if (args instanceof Item.Num) {\n      return args.ceil();\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass FloorFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    if (args instanceof Item.Num) {\n      return args.floor();\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass RoundFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    if (args instanceof Item.Num) {\n      return args.round();\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass SqrtFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    if (args instanceof Item.Num) {\n      return args.sqrt();\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass PowFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    const x = args.getItem(0).evaluate(interpreter);\n    const y = args.getItem(1).evaluate(interpreter);\n    if (x instanceof Item.Num && y instanceof Item.Num) {\n      return x.pow(y);\n    }\n    return Item.absent();\n  }\n}\n\n/** @hidden */\nclass RateFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    interpreter = Interpreter.fromAny(interpreter);\n    let value: number;\n    let period: number;\n    if (args.length >= 2) {\n      value = args.getItem(0).evaluate(interpreter).numberValue(NaN);\n      period = args.getItem(1).evaluate(interpreter).numberValue(1000);\n    } else {\n      value = args.evaluate(interpreter).numberValue(NaN);\n      period = 1000;\n    }\n    if (isFinite(value) && operator) {\n      let state = operator.state() as {v0: number, t0: number, dv: number, dt: number} | undefined;\n      if (state === void 0) {\n        state = {v0: value, t0: Date.now(), dv: 0, dt: 0};\n        operator.setState(state);\n      } else {\n        const t1 = Date.now();\n        const dt = t1 - state.t0;\n        if (dt > period && t1 > state.t0 || dt > 2 * period) {\n          const dv = value - state.v0;\n          state.v0 = value;\n          state.t0 = t1;\n          state.dv = dv;\n          state.dt = dt;\n        }\n        operator.setState(state);\n        if (state.dt !== 0) {\n          const rate = period * state.dv / state.dt;\n          return Item.Num.from(rate);\n        }\n      }\n    }\n    return Item.absent();\n  }\n\n  expand(args: Value, interpreter: Interpreter, operator: InvokeOperator): Item | undefined {\n    args = args.evaluate(interpreter).toValue();\n    return this.invoke(args, interpreter, operator);\n  }\n}\n\n/** @hidden */\nclass RandomFunc extends BridgeFunc {\n  invoke(args: Value, interpreter?: Interpreter, operator?: InvokeOperator): Item {\n    args = args.evaluate(interpreter).toValue();\n    const lower = args.length >= 1 ? args.getItem(0).numberValue(0.0) : 0.0;\n    const upper = args.length >= 2 ? args.getItem(1).numberValue(lower + 1.0) : lower + 1.0;\n    const value = lower + Math.random() * (upper - lower);\n    return Item.Num.from(value);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Attr} from \"../Attr\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class TagForm<T extends U, U = T> extends Form<T, U> {\n  /** @hidden */\n  readonly _tag: string;\n  /** @hidden */\n  readonly _form: Form<T, U>;\n\n  constructor(tag: string, form: Form<T, U>) {\n    super();\n    this._tag = tag;\n    this._form = form;\n  }\n\n  tag(): string | undefined;\n  tag(tag: string | undefined): Form<T, U>;\n  tag(tag?: string | undefined): string | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return this._tag;\n    } else if (tag !== void 0) {\n      return new TagForm<T, U>(tag, this._form);\n    } else {\n      return this._form;\n    }\n  }\n\n  unit(): T | undefined;\n  unit(unit: T | undefined): Form<T, U>;\n  unit(unit?: T | undefined): T | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return this._form.unit();\n    } else {\n      return new TagForm<T, U>(this._tag, this._form.unit(unit));\n    }\n  }\n\n  mold(object: U, item?: Item): Item {\n    item = this._form.mold(object, item);\n    if (!item.header(this._tag).isDefined()) {\n      item = item.prepended(Attr.of(this._tag));\n    }\n    return item;\n  }\n\n  cast(item: Item, object?: T): T | undefined {\n    if (item.header(this._tag).isDefined()) {\n      return this._form.cast(item, object);\n    } else if (item.keyEquals(this._tag)) {\n      return this._form.cast(item.toValue(), object);\n    }\n    return void 0;\n  }\n}\nForm.TagForm = TagForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class UnitForm<T extends U, U = T> extends Form<T, U> {\n  /** @hidden */\n  readonly _unit: T;\n  /** @hidden */\n  readonly _form: Form<T, U>;\n\n  constructor(unit: T, form: Form<T, U>) {\n    super();\n    this._unit = unit;\n    this._form = form;\n  }\n\n  tag(): string | undefined;\n  tag(tag: string | undefined): Form<T, U>;\n  tag(tag?: string | undefined): string | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return this._form.tag();\n    } else {\n      return new UnitForm<T, U>(this._unit, this._form.tag(tag));\n    }\n  }\n\n  unit(): T | undefined;\n  unit(unit: T | undefined): Form<T, U>;\n  unit(unit?: T | undefined): T | undefined | Form<T, U> {\n    if (arguments.length === 0) {\n      return this._form.unit();\n    } else if (unit !== void 0) {\n      return new UnitForm<T, U>(unit, this._form);\n    } else {\n      return this._form;\n    }\n  }\n\n  mold(object: U, item?: Item): Item {\n    return this._form.mold.apply(this._form, arguments);\n  }\n\n  cast(item: Item, object?: T): T | undefined {\n    return this._form.cast.apply(this._form, arguments);\n  }\n}\nForm.UnitForm = UnitForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Text} from \"../Text\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class StringForm extends Form<string> {\n  /** @hidden */\n  readonly _unit: string | undefined;\n\n  constructor(unit?: string) {\n    super();\n    this._unit = unit;\n  }\n\n  unit(): string | undefined;\n  unit(unit: string | undefined): Form<string>;\n  unit(unit?: string | undefined): string | undefined | Form<string> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new StringForm(unit);\n    }\n  }\n\n  mold(object: string, item?: Item): Item {\n    if (item === void 0) {\n      return Text.from(object);\n    } else {\n      return item.concat(Text.from(object));\n    }\n  }\n\n  cast(item: Item, object?: string): string | undefined {\n    const value = item.target();\n    try {\n      return value.stringValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\nForm.StringForm = StringForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Num} from \"../Num\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class NumberForm extends Form<number> {\n  /** @hidden */\n  readonly _unit: number | undefined;\n\n  constructor(unit?: number) {\n    super();\n    this._unit = unit;\n  }\n\n  unit(): number | undefined;\n  unit(unit: number | undefined): Form<number>;\n  unit(unit?: number | undefined): number | undefined | Form<number> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new NumberForm(unit);\n    }\n  }\n\n  mold(object: number, item?: Item): Item {\n    if (item === void 0) {\n      return Num.from(object);\n    } else {\n      return item.concat(Num.from(object));\n    }\n  }\n\n  cast(item: Item, object?: number): number | undefined {\n    const value = item.target();\n    try {\n      return value.numberValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\nForm.NumberForm = NumberForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {Bool} from \"../Bool\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class BooleanForm extends Form<boolean> {\n  /** @hidden */\n  readonly _unit: boolean | undefined;\n\n  constructor(unit?: boolean) {\n    super();\n    this._unit = unit;\n  }\n\n  unit(): boolean | undefined;\n  unit(unit: boolean | undefined): Form<boolean>;\n  unit(unit?: boolean | undefined): boolean | undefined | Form<boolean> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new BooleanForm(unit);\n    }\n  }\n\n  mold(object: boolean, item?: Item): Item {\n    if (item === void 0) {\n      return Bool.from(object);\n    } else {\n      return item.concat(Bool.from(object));\n    }\n  }\n\n  cast(item: Item, object?: boolean): boolean | undefined {\n    const value = item.target();\n    try {\n      return value.booleanValue();\n    } catch (error) {\n      return void 0;\n    }\n  }\n}\nForm.BooleanForm = BooleanForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"../Item\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class AnyForm extends Form<AnyItem> {\n  /** @hidden */\n  readonly _unit: AnyItem | undefined;\n\n  constructor(unit?: AnyItem) {\n    super();\n    this._unit = unit;\n  }\n\n  unit(): AnyItem | undefined;\n  unit(unit: AnyItem | undefined): Form<AnyItem>;\n  unit(unit?: AnyItem | undefined): AnyItem | undefined | Form<AnyItem> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new AnyForm(unit);\n    }\n  }\n\n  mold(object: AnyItem, item?: Item): Item {\n    object = Item.fromAny(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  cast(item: Item, object?: AnyItem): AnyItem | undefined {\n    return item.toAny();\n  }\n}\nForm.AnyForm = AnyForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item} from \"../Item\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class ItemForm extends Form<Item, AnyItem> {\n  /** @hidden */\n  readonly _unit: Item | undefined;\n\n  constructor(unit?: Item) {\n    super();\n    this._unit = unit ? unit.commit() : unit;\n  }\n\n  unit(): Item | undefined;\n  unit(unit: Item | undefined): Form<Item, AnyItem>;\n  unit(unit?: Item | undefined): Item | undefined | Form<Item, AnyItem> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new ItemForm(unit);\n    }\n  }\n\n  mold(object: AnyItem, item?: Item): Item {\n    object = Item.fromAny(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  cast(item: Item, object?: Item): Item | undefined {\n    return item;\n  }\n}\nForm.ItemForm = ItemForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item} from \"../Item\";\nimport {AnyValue, Value} from \"../Value\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class ValueForm extends Form<Value, AnyValue> {\n  /** @hidden */\n  readonly _unit: Value | undefined;\n\n  constructor(unit?: Value) {\n    super();\n    this._unit = unit ? unit.commit() : unit;\n  }\n\n  unit(): Value | undefined;\n  unit(unit: Value | undefined): Form<Value, AnyValue>;\n  unit(unit?: Value | undefined): Value | undefined | Form<Value, AnyValue> {\n    if (arguments.length === 0) {\n      return this._unit;\n    } else {\n      return new ValueForm(unit);\n    }\n  }\n\n  mold(object: AnyValue, item?: Item): Item {\n    object = Value.fromAny(object);\n    if (item !== void 0) {\n      object = item.concat(object);\n    }\n    return object;\n  }\n\n  cast(item: Item, object?: Value): Value | undefined {\n    return item.toValue();\n  }\n}\nForm.ValueForm = ValueForm;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Value} from \"../Value\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class ValueCursor<V> extends Cursor<V> {\n  private readonly _cursor: Cursor<Value>;\n  private readonly _form: Form<V, unknown>;\n\n  constructor(cursor: Cursor<Value>, form: Form<V, unknown>) {\n    super();\n    this._cursor = cursor;\n    this._form = form;\n  }\n\n  isEmpty(): boolean {\n    return this._cursor.isEmpty();\n  }\n\n  head(): V {\n    const value = this._cursor.head();\n    return value.coerce(this._form);\n  }\n\n  step(): void {\n    this._cursor.step();\n  }\n\n  skip(count: number): void {\n    this._cursor.skip(count);\n  }\n\n  hasNext(): boolean {\n    return this._cursor.hasNext();\n  }\n\n  nextIndex(): number {\n    return this._cursor.nextIndex();\n  }\n\n  next(): {value?: V, done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && value.coerce(this._form), done};\n  }\n\n  hasPrevious(): boolean {\n    return this._cursor.hasPrevious();\n  }\n\n  previousIndex(): number {\n    return this._cursor.previousIndex();\n  }\n\n  previous(): {value?: V, done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && value.coerce(this._form), done};\n  }\n\n  delete(): void {\n    this._cursor.delete();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Value} from \"../Value\";\nimport {Form} from \"../Form\";\n\n/** @hidden */\nexport class ValueEntryCursor<K, V> extends Cursor<[K, V]> {\n  private readonly _cursor: Cursor<[Value, Value]>;\n  private readonly _keyForm: Form<K, unknown>;\n  private readonly _valueForm: Form<V, unknown>;\n\n  constructor(cursor: Cursor<[Value, Value]>, keyForm: Form<K, unknown>, valueForm: Form<V, unknown>) {\n    super();\n    this._cursor = cursor;\n    this._keyForm = keyForm;\n    this._valueForm = valueForm;\n  }\n\n  isEmpty(): boolean {\n    return this._cursor.isEmpty();\n  }\n\n  head(): [K, V] {\n    const pair = this._cursor.head();\n    return [pair[0].coerce(this._keyForm), pair[1].coerce(this._valueForm)];\n  }\n\n  step(): void {\n    this._cursor.step();\n  }\n\n  skip(count: number): void {\n    this._cursor.skip(count);\n  }\n\n  hasNext(): boolean {\n    return this._cursor.hasNext();\n  }\n\n  nextIndex(): number {\n    return this._cursor.nextIndex();\n  }\n\n  next(): {value?: [K, V], done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && [value[0].coerce(this._keyForm), value[1].coerce(this._valueForm)], done};\n  }\n\n  hasPrevious(): boolean {\n    return this._cursor.hasPrevious();\n  }\n\n  previousIndex(): number {\n    return this._cursor.previousIndex();\n  }\n\n  previous(): {value?: [K, V], done: boolean} {\n    const {value, done} = this._cursor.next();\n    return {value: value && [value[0].coerce(this._keyForm), value[1].coerce(this._valueForm)], done};\n  }\n\n  delete(): void {\n    this._cursor.delete();\n  }\n}\n"]}