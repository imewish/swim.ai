{"version":3,"sources":["../../main/RecordOutlet.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/AbstractRecordOutlet.ts","../../main/RecordStreamlet.ts","../../main/AbstractRecordStreamlet.ts","../../main/RecordFieldUpdater.ts","../../main/Transmuter.ts","../../main/RecordModel.ts","../../main/RecordScope.ts","../../main/selector/GetOutlet.ts","../../main/operator/BinaryOutlet.ts","../../main/operator/UnaryOutlet.ts","../../main/operator/ConditionalOutlet.ts","../../main/operator/OrOutlet.ts","../../main/operator/AndOutlet.ts","../../main/operator/BitwiseOrOutlet.ts","../../main/operator/BitwiseXorOutlet.ts","../../main/operator/BitwiseAndOutlet.ts","../../main/operator/LtOutlet.ts","../../main/operator/LeOutlet.ts","../../main/operator/EqOutlet.ts","../../main/operator/NeOutlet.ts","../../main/operator/GeOutlet.ts","../../main/operator/GtOutlet.ts","../../main/operator/PlusOutlet.ts","../../main/operator/MinusOutlet.ts","../../main/operator/TimesOutlet.ts","../../main/operator/DivideOutlet.ts","../../main/operator/ModuloOutlet.ts","../../main/operator/NotOutlet.ts","../../main/operator/BitwiseNotOutlet.ts","../../main/operator/NegativeOutlet.ts","../../main/operator/PositiveOutlet.ts","../../main/operator/InvokeOutlet.ts","../../main/Dataflow.ts"],"names":["RecordOutlet","is","object","outlet","MapOutlet","StreamletScope","Streamlet","Model","Scope","Dataflow","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","AbstractRecordOutlet","_this","_super","call","_effects","BTree","_outlets","_outputs","_version","streamletScope","streamletContext","scope","hasOwn","key","has","get","Text","from","KeyOutlet","updated","invalidateInputKey","outputIterator","Cursor","array","empty","bindOutput","output","oldOutputs","n","length","newOutputs","i","unbindOutput","j","unbindOutputs","outlets","isEmpty","forEach","keyOutlet","unbindInput","disconnectOutputs","outputs","member","Field","toValue","disconnectInputs","effect","oldEffects","willInvalidateInputKey","onInvalidateInputKey","MapInlet","invalidateOutputKey","invalidateOutput","invalidateInput","didInvalidateInputKey","willInvalidateInput","onInvalidateInput","didInvalidateInput","reconcileInputKey","version","willReconcileInputKey","removed","onReconcileInputKey","reconcileOutputKey","reconcileInput","didReconcileInputKey","willReconcileInput","onReconcileInput","reconcileOutput","reconcile","didReconcileInput","memoize","combinator","MemoizeMapCombinator","bindInput","filter","func","FilterFieldsCombinator","map","MapValueCombinator","MapFieldValuesCombinator","reduce","identity","accumulator","combiner","ReduceFieldsCombinator","watch","WatchValueCombinator","WatchFieldsCombinator","Record","RecordStreamlet","isConstant","streamletClass","compile","AbstractStreamlet","reflectEachInlet","inlet","name","input","compileInlet","AbstractRecordStreamlet","context","setStreamletScope","setStreamletContext","defineProperty","reflectOutletCount","value","Value","absent","getAttr","getSlot","getField","isDefined","Slot","of","getItem","index","Num","entry","reflectOutletIndex","name_1","extant","Item","set","newValue","Error","setAttr","setSlot","setItem","item","push","items","_i","arguments","splice","start","deleteCount","newItems","delete","clear","callback","thisArg","reflectEachOutlet","result","StreamletInlet","reflectInletKey","StreamletOutlet","reflectOutletKey","inoutlet","StreamletInoutlet","invalidate","willInvalidate","onInvalidate","onInvalidateOutlets","didInvalidate","willReconcile","onReconcileInlets","onReconcile","onReconcileOutlets","didReconcile","getInput","orElse","castInput","form","cast","coerceInput","unit","getOutput","willInvalidateInlet","didInvalidateInlet","willReconcileInlet","didReconcileInlet","willInvalidateOutlet","didInvalidateOutlet","willReconcileOutlet","didReconcileOutlet","invalidateOutlets","reconcileInlets","reconcileOutlets","RecordFieldUpdater","record","_record","_key","onInvalidateOutput","onReconcileOutput","_input","AbstractInlet","Transmuter","system","RecordModel","state","_state","_fieldUpdaters","isArray","isObject","fieldCount","valueCount","indexOf","lastIndexOf","fromAny","field","bindValue","expr","fieldUpdater","valueInput","newItem","oldItem","equals","apply","Math","max","deleted","oldState","branch","keyIterator","fieldUpdaters","materialize","materializeItem","materializeField","materializeValue","child","updatedValue","compileItem","compileField","compileValue","setValue","transmute","transmuter","transmuteItem","transmuteField","transmuteValue","oldValue","transmuteModel","model","globalScope","MathModule","RecordScope","GetOutlet","_keyInlet","OutletInlet","_mapInlet","OutletMapInlet","keyInlet","mapInlet","keyInput","mapInput","AbstractOutlet","BinaryOutlet","_operand1Inlet","_operand2Inlet","operand1Inlet","operand2Inlet","operand1Input","operand2Input","argument1","argument2","evaluate","UnaryOutlet","_operandInlet","operandInlet","operandInput","argument","ConditionalOutlet","_ifInlet","_thenInlet","_elseInlet","ifInlet","thenInlet","elseInlet","ifInput","ifTerm","booleanValue","thenInput","thenTerm","elseInput","elseTerm","OrOutlet","AndOutlet","BitwiseOrOutlet","bitwiseOr","BitwiseXorOutlet","bitwiseXor","BitwiseAndOutlet","bitwiseAnd","LtOutlet","lt","LeOutlet","le","EqOutlet","eq","NeOutlet","ne","GeOutlet","ge","GtOutlet","gt","PlusOutlet","plus","MinusOutlet","minus","TimesOutlet","times","DivideOutlet","divide","ModuloOutlet","modulo","NotOutlet","not","BitwiseNotOutlet","bitwiseNot","NegativeOutlet","negative","PositiveOutlet","positive","InvokeOutlet","_scope","_funcInlet","_argsInlet","funcInlet","argsInlet","funcInput","argsInput","Func","args","interpreter","Interpreter","pushScope","invoke","Outlet","ValueInput","Selector","compileSelector","Operator","compileOperator","TypeError","selector","IdentitySelector","compileIdentitySelector","GetSelector","compileGetSelector","GetAttrSelector","compileGetAttrSelector","GetItemSelector","compileGetItemSelector","KeysSelector","compileKeysSelector","ValuesSelector","compileValuesSelector","ChildrenSelector","compileChildrenSelector","DescendantsSelector","compileDescendantsSelector","FilterSelector","compileFilterSelector","accessor","getOutlet","then","stringValue","operator","ConditionalOperator","compileConditionalOperator","BinaryOperator","compileBinaryOperator","UnaryOperator","compileUnaryOperator","InvokeOperator","compileInvokeOperator","ifOutlet","thenOutlet","elseOutlet","OrOperator","compileOrOperator","AndOperator","compileAndOperator","BitwiseOrOperator","compileBitwiseOrOperator","BitwiseXorOperator","compileBitwiseXorOperator","BitwiseAndOperator","compileBitwiseAndOperator","LtOperator","compileLtOperator","LeOperator","compileLeOperator","EqOperator","compileEqOperator","NeOperator","compileNeOperator","GeOperator","compileGeOperator","GtOperator","compileGtOperator","PlusOperator","compilePlusOperator","MinusOperator","compileMinusOperator","TimesOperator","compileTimesOperator","DivideOperator","compileDivideOperator","ModuloOperator","compileModuloOperator","compileBinaryOutlet","operand1","operand2","operand1Outlet","operand2Outlet","NotOperator","compileNotOperator","BitwiseNotOperator","compileBitwiseNotOperator","NegativeOperator","compileNegativeOperator","PositiveOperator","compilePositiveOperator","compileUnaryOutlet","operand","operandOutlet","invokeOutlet","funcOutlet","argsOutlet"],"mappings":"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","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/dataflow/dist/main/swim-dataflow.min.js","sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Map} from \"@swim/util\";\nimport {Value, Record} from \"@swim/structure\";\nimport {Outlet, MapOutlet, StreamletScope} from \"@swim/streamlet\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"@swim/streamlet\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"@swim/streamlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\nimport {RecordModel} from \"./RecordModel\";\nimport {RecordScope} from \"./RecordScope\";\nimport {Dataflow} from \"./Dataflow\";\n\nexport interface RecordOutlet extends Outlet<Record>, MapOutlet<Value, Value, Record>, StreamletScope<Value> {\n  outlet(key: Value | string): Outlet<Value>;\n\n  get(): Record;\n  get(key: Value): Value;\n\n  memoize(): MapOutlet<Value, Value, Record>;\n\n  map<O2>(func: MapValueFunction<Record, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map<Value, V2>>;\n\n  watch(func: WatchValueFunction<Record>): this;\n  watch(func: WatchFieldsFunction<Value, Value>): this;\n}\n\n/** @hidden */\nexport const RecordOutlet = {\n  is(object: unknown): object is RecordOutlet {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as RecordOutlet;\n      return MapOutlet.is(outlet) && StreamletScope.is(outlet);\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  Streamlet: void 0 as unknown as typeof RecordStreamlet, // defined by RecordStreamlet\n  /** @hidden */\n  Model: void 0 as unknown as typeof RecordModel, // defined by RecordModel\n  /** @hidden */\n  Scope: void 0 as unknown as typeof RecordScope, // defined by RecordScope\n  /** @hidden */\n  Dataflow: void 0 as unknown as typeof Dataflow, // defined by Dataflow\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AnyItem, Item, Field, AnyValue, Value, Record, Text, Selector} from \"@swim/structure\";\nimport {Inlet, Outlet, KeyEffect, MapInlet, MapOutlet, KeyOutlet, StreamletContext, StreamletScope} from \"@swim/streamlet\";\nimport {MemoizeMapCombinator} from \"@swim/streamlet\";\nimport {FilterFieldsFunction, FilterFieldsCombinator} from \"@swim/streamlet\";\nimport {MapValueFunction, MapValueCombinator} from \"@swim/streamlet\";\nimport {MapFieldValuesFunction, MapFieldValuesCombinator} from \"@swim/streamlet\";\nimport {ReduceFieldsCombinator} from \"@swim/streamlet\";\nimport {WatchValueFunction, WatchValueCombinator} from \"@swim/streamlet\";\nimport {WatchFieldsFunction, WatchFieldsCombinator} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport abstract class AbstractRecordOutlet extends Record implements RecordOutlet {\n  /** @hidden */\n  protected _effects: BTree<Value, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<Value, KeyOutlet<Value, Value>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<Record>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    super();\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  streamletScope(): StreamletScope<Value> | null {\n    return null;\n  }\n\n  streamletContext(): StreamletContext | null {\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  hasOwn(key: AnyValue): boolean {\n    return this.has(key);\n  }\n\n  get(): Record;\n  get(key: AnyValue): Value;\n  get(key?: AnyValue): Record | Value {\n    if (key === void 0) {\n      return this;\n    } else {\n      return super.get(key);\n    }\n  }\n\n  abstract keyIterator(): Cursor<Value>;\n\n  outlet(key: Value | string): Outlet<Value> {\n    if (typeof key === \"string\") {\n      key = Text.from(key);\n    }\n    if (!this.hasOwn(key)) {\n      const scope = this.streamletScope();\n      if (RecordOutlet.is(scope) && scope.has(key)) {\n        // TODO: Support dynamic shadowing?\n        return scope.outlet(key);\n      }\n    }\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<Value, Value>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n      this.invalidateInputKey(key, KeyEffect.Update);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Cursor<Inlet<Record>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<Record>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<Record>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<Record>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<Record>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: Value, keyOutlet: KeyOutlet<Value, Value>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const oldOutputs = this._outputs;\n    if (oldOutputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {\n        oldOutputs[i].unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: Value, keyOutlet: KeyOutlet<Value, Value>) {\n        keyOutlet.disconnectOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n    this.forEach(function (member: Item): void {\n      if (member instanceof Field) {\n        member = member.toValue();\n      }\n      if (member instanceof AbstractRecordOutlet) {\n        member.disconnectOutputs();\n      } else if (member instanceof RecordOutlet.Streamlet) {\n        member.disconnectOutputs();\n      } else if (RecordOutlet.is(member)) {\n        member.disconnectOutputs();\n      }\n    }, this);\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInputKey(key: Value, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: Value, outlet: KeyOutlet<Value, Value>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInputKey(key: Value, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileInputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        this.onReconcileInputKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._effects.forEach(function (key: Value): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.forEach(function (member: Item): void {\n        if (member instanceof Field) {\n          member = member.toValue();\n        }\n        if (member instanceof AbstractRecordOutlet) {\n          member.reconcileInput(version);\n        } else if (member instanceof RecordOutlet.Streamlet) {\n          member.reconcile(version);\n        } else if (RecordOutlet.is(member)) {\n          member.reconcileInput(version);\n        }\n      }, this);\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<Value, Value, Record> {\n    const combinator = new MemoizeMapCombinator<Value, Value, Record>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(predicate?: AnyItem): Selector;\n  filter(func: FilterFieldsFunction<Value, Value>): MapOutlet<Value, Value, Map<Value, Value>>;\n  filter(func: AnyItem | FilterFieldsFunction<Value, Value>): Selector | MapOutlet<Value, Value, Map<Value, Value>> {\n    if (typeof func !== \"function\") {\n      return super.filter(func as AnyItem);\n    } else {\n      const combinator = new FilterFieldsCombinator<Value, Value, Record>(func);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  map<O2>(func: MapValueFunction<Record, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map<Value, V2>>;\n  map<V2>(func: MapValueFunction<Record, V2> | MapFieldValuesFunction<Value, Value, V2>): Outlet<V2> | MapOutlet<Value, V2, Map<Value, V2>> {\n    if (func.length === 1) {\n      const combinator = new MapValueCombinator<Record, V2>(func as MapValueFunction<Record, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapFieldValuesCombinator<Value, Value, V2, Record>(func as MapFieldValuesFunction<Value, Value, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: Value) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new ReduceFieldsCombinator<Value, Value, Record, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<Record>): this;\n  watch(func: WatchFieldsFunction<Value, Value>): this;\n  watch(func: WatchValueFunction<Record> | WatchFieldsFunction<Value, Value>): this {\n    if (func.length === 1) {\n      const combinator = new WatchValueCombinator<Record>(func as WatchValueFunction<Record>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new WatchFieldsCombinator<Value, Value, Record>(func as WatchFieldsFunction<Value, Value>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record} from \"@swim/structure\";\nimport {Inlet, Outlet, StreamletContext, StreamletScope, StreamletClass, Streamlet, AbstractStreamlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport abstract class RecordStreamlet<I extends Value = Value, O extends Value = I> extends Record implements Streamlet<I, O> {\n  isConstant(): boolean {\n    return false;\n  }\n\n  protected streamletClass(): StreamletClass {\n    return (this as any).__proto__ as StreamletClass;\n  }\n\n  abstract streamletScope(): StreamletScope<O> | null;\n\n  abstract setStreamletScope(parent: StreamletScope<O> | null): void;\n\n  abstract streamletContext(): StreamletContext | null;\n\n  abstract setStreamletContext(context: StreamletContext | null): void;\n\n  abstract inlet(key: string): Inlet<I> | null;\n\n  abstract bindInput(key: string, input: Outlet<I>): void;\n\n  abstract unbindInput(key: string): void;\n\n  abstract outlet(key: string): Outlet<O> | null;\n\n  abstract disconnectInputs(): void;\n\n  abstract disconnectOutputs(): void;\n\n  abstract invalidate(): void;\n\n  abstract reconcile(version: number): void;\n\n  compile(): void {\n    AbstractStreamlet.reflectEachInlet<I, O, void, this>(this, this.streamletClass(), function (inlet: Inlet<I>, name: string): void {\n      if (inlet.input() === null) {\n        this.compileInlet(inlet, name);\n      }\n    }, this);\n  }\n\n  compileInlet(inlet: Inlet<I>, name: string): void {\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      const input = scope.outlet(name);\n      if (input !== null) {\n        // Assume Outlet<O> conforms to Outlet<I>.\n        inlet.bindInput(input as Outlet<unknown> as Outlet<I>);\n      }\n    }\n  }\n}\nRecordOutlet.Streamlet = RecordStreamlet;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item, Field, Slot, AnyValue, Value, AnyText, Text, AnyNum, Num, Form} from \"@swim/structure\";\nimport {\n  Inlet,\n  Outlet,\n  Inoutlet,\n  StreamletContext,\n  GenericStreamlet,\n  AbstractStreamlet,\n  StreamletScope,\n  StreamletInlet,\n  StreamletOutlet,\n  StreamletInoutlet,\n} from \"@swim/streamlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\n\nexport abstract class AbstractRecordStreamlet<I extends Value = Value, O extends Value = I> extends RecordStreamlet<I, O> implements GenericStreamlet<I, O> {\n  protected scope: StreamletScope<O> | null;\n  protected context: StreamletContext | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor(scope: StreamletScope<O> | null = null) {\n    super();\n    this.scope = scope;\n    this.context = null;\n    this._version = -1;\n  }\n\n  streamletScope(): StreamletScope<O> | null {\n    return this.scope;\n  }\n\n  setStreamletScope(scope: StreamletScope<O> | null): void {\n    this.scope = scope;\n  }\n\n  streamletContext(): StreamletContext | null {\n    if (this.context) {\n      return this.context;\n    }\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  setStreamletContext(context: StreamletContext | null): void {\n    this.context = context;\n  }\n\n  isEmpty(): boolean {\n    return this.length !== 0;\n  }\n\n  get length(): number {\n    return AbstractStreamlet.reflectOutletCount(this.streamletClass());\n  }\n\n  has(key: AnyValue): boolean {\n    if (key instanceof Text) {\n      key = key.value;\n    } else if (typeof key !== \"string\") {\n      return false;\n    }\n    const outlet = this.outlet(key);\n    return outlet !== null;\n  }\n\n  get(key: AnyValue): Value {\n    if (key instanceof Text) {\n      key = key.value;\n    } else if (typeof key !== \"string\") {\n      return Value.absent();\n    }\n    const outlet = this.outlet(key);\n    if (outlet !== null) {\n      const output = outlet.get();\n      if (output !== void 0) {\n        return output;\n      }\n    }\n    return Value.absent();\n  }\n\n  getAttr(key: AnyText): Value {\n    return Value.absent();\n  }\n\n  getSlot(key: AnyValue): Value {\n    return this.get(key);\n  }\n\n  getField(key: AnyValue): Field | undefined {\n    if (typeof key === \"string\") {\n      key = Text.from(key);\n    } else if (!(key instanceof Text)) {\n      return void 0;\n    }\n    const value = this.get(key);\n    if (value.isDefined()) {\n      return Slot.of(key, value);\n    }\n    return void 0;\n  }\n\n  getItem(index: AnyNum): Item {\n    if (index instanceof Num) {\n      index = index.value;\n    }\n    const entry = AbstractStreamlet.reflectOutletIndex<I, O>(index, this, this.streamletClass());\n    if (entry !== null) {\n      const name = entry[0];\n      let output = entry[1].get() as Value | undefined;\n      if (output === void 0) {\n        output = Value.extant();\n      }\n      return Slot.of(name, output);\n    }\n    return Item.absent();\n  }\n\n  set(key: AnyValue, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setAttr(key: AnyText, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setSlot(key: AnyValue, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setItem(index: number, item: AnyItem): this {\n    throw new Error(\"unsupported\");\n  }\n\n  push(...items: AnyItem[]): number {\n    throw new Error(\"unsupported\");\n  }\n\n  splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[] {\n    throw new Error(\"unsupported\");\n  }\n\n  delete(key: AnyValue): Item {\n    throw new Error(\"unsupported\");\n  }\n\n  clear(): void {\n    throw new Error(\"unsupported\");\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return AbstractStreamlet.reflectEachOutlet(this, this.streamletClass(), function (outlet: Outlet<O>, name: string, index: number): T | void {\n      const output = outlet.get();\n      if (output !== void 0) {\n        const result = callback.call(thisArg, output, index);\n        if (result !== void 0) {\n          return result;\n        }\n      }\n    }, this);\n  }\n\n  inlet(key: string): Inlet<I> | null;\n  inlet<I2 extends I>(): Inlet<I2>;\n  inlet(key?: string): Inlet<I> | null {\n    if (key === void 0) {\n      return new StreamletInlet<I>(this);\n    } else {\n      return AbstractStreamlet.reflectInletKey<I, O>(key, this, this.streamletClass());\n    }\n  }\n\n  bindInput(key: string, input: Outlet<I>): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.bindInput(input);\n  }\n\n  unbindInput(key: string): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.unbindInput();\n  }\n\n  outlet(key: string | Outlet<O>): Outlet<O> | null;\n  outlet<O2 extends Value>(): Outlet<O2>;\n  outlet(key?: string | Outlet<O>): Outlet<O> | null {\n    if (key === void 0) {\n      return new StreamletOutlet<O>(this);\n    } else if (typeof key === \"string\") {\n      return AbstractStreamlet.reflectOutletKey<I, O>(key, this, this.streamletClass());\n    } else {\n      return key;\n    }\n  }\n\n  inoutlet<I2 extends I, O2 extends Value>(): Inoutlet<I2, O2> {\n    return new StreamletInoutlet<I2, O2>(this as RecordStreamlet<I2, O2>);\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      this.onInvalidateOutlets();\n      this.didInvalidate();\n    }\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      this.onReconcileInlets(version);\n      this.onReconcile(version);\n      this.onReconcileOutlets(version);\n      this.didReconcile(version);\n    }\n  }\n\n  getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse?: E): I2 | E | undefined {\n    if (typeof inlet === \"string\") {\n      inlet = this.inlet(inlet) as Inlet<I2>;\n    }\n    let object: I2 | E | undefined;\n    if (inlet !== null) {\n      const input = inlet.input();\n      if (input !== null) {\n        object = input.get();\n      }\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  castInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T | undefined;\n  castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;\n  castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse?: E): T | E | undefined {\n    const input = this.getInput(inlet);\n    let object: T | E | undefined;\n    if (input !== void 0) {\n      object = form.cast(input);\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  coerceInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T;\n  coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;\n  coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse?: E): T | E {\n    const input = this.getInput(inlet);\n    let object: T | E | undefined;\n    if (input !== void 0) {\n      object = form.cast(input);\n    }\n    if (object === void 0) {\n      object = form.unit();\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object!;\n  }\n\n  getOutput(outlet: Outlet<O> | string): O | undefined {\n    return void 0;\n  }\n\n  disconnectInputs(): void {\n    AbstractStreamlet.disconnectInputs(this, this.streamletClass());\n  }\n\n  disconnectOutputs(): void {\n    AbstractStreamlet.disconnectOutputs(this, this.streamletClass());\n  }\n\n  willInvalidateInlet(inlet: Inlet<I>): void {\n    // stub\n  }\n\n  didInvalidateInlet(inlet: Inlet<I>): void {\n    this.invalidate();\n  }\n\n  willReconcileInlet(inlet: Inlet<I>, version: number): void {\n    // stub\n  }\n\n  didReconcileInlet(inlet: Inlet<I>, version: number): void {\n    this.reconcile(version);\n  }\n\n  willInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  didInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  willReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  didReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidateOutlets(): void {\n    AbstractStreamlet.invalidateOutlets(this, this.streamletClass());\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInlets(version: number): void {\n    AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutlets(version: number): void {\n    AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record} from \"@swim/structure\";\nimport {KeyEffect, AbstractInlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport class RecordFieldUpdater extends AbstractInlet<Value> {\n  /** @hidden */\n  protected readonly _record: Record;\n  /** @hidden */\n  protected readonly _key: Value;\n\n  constructor(record: Record, key: Value) {\n    super();\n    this._record = record;\n    this._key = key;\n  }\n\n  protected onInvalidateOutput(): void {\n    if (RecordOutlet.is(this._record)) {\n      this._record.invalidateInputKey(this._key, KeyEffect.Update);\n    }\n  }\n\n  protected onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      const value = this._input.get();\n      if (value !== void 0) {\n        this._record.set(this._key, value);\n      } else {\n        this._record.delete(this._key);\n      }\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Record} from \"@swim/structure\";\nimport {RecordModel} from \"./RecordModel\";\n\nexport abstract class Transmuter {\n  abstract transmute(model: RecordModel): Record;\n\n  static system(): Transmuter {\n    return null as unknown as Transmuter;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AnyItem, Item, Field, Slot, AnyValue, Value, Record, AnyText, Text, AnyNum, MathModule} from \"@swim/structure\";\nimport {KeyEffect, MapOutlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\nimport {AbstractRecordOutlet} from \"./AbstractRecordOutlet\";\nimport {RecordFieldUpdater} from \"./RecordFieldUpdater\";\nimport {Transmuter} from \"./Transmuter\";\n\nexport class RecordModel extends AbstractRecordOutlet {\n  /** @hidden */\n  protected _state: Record;\n  /** @hidden */\n  protected _fieldUpdaters: BTree<Value, RecordFieldUpdater>;\n\n  constructor(state: Record = Record.create()) {\n    super();\n    this._state = state;\n    this._fieldUpdaters = new BTree();\n  }\n\n  isEmpty(): boolean {\n    return this._state.isEmpty();\n  }\n\n  isArray(): boolean {\n    return this._state.isArray();\n  }\n\n  isObject(): boolean {\n    return this._state.isObject();\n  }\n\n  get length(): number {\n    return this._state.length;\n  }\n\n  fieldCount(): number {\n    return this._state.fieldCount();\n  }\n\n  valueCount(): number {\n    return this._state.valueCount();\n  }\n\n  has(key: AnyValue): boolean {\n    if (this._state.has(key)) {\n      return true;\n    } else {\n      const scope = this.streamletScope();\n      return scope instanceof Record ? scope.has(key) : false;\n    }\n  }\n\n  hasOwn(key: AnyValue): boolean {\n    return this._state.has(key);\n  }\n\n  indexOf(item: AnyItem, index?: number): number {\n    return this._state.indexOf(item, index);\n  }\n\n  lastIndexOf(item: AnyItem, index: number = 0): number {\n    return this._state.lastIndexOf(item, index);\n  }\n\n  get(): Record;\n  get(key: AnyValue): Value;\n  get(key?: AnyValue): Record | Value {\n    if (key === void 0) {\n      return this;\n    } else {\n      key = Value.fromAny(key);\n      let value = this._state.get(key);\n      if (!value.isDefined()) {\n        const scope = this.streamletScope();\n        if (scope instanceof Record) {\n          value = scope.get(key);\n        }\n      }\n      return value;\n    }\n  }\n\n  getAttr(key: AnyText): Value {\n    key = Text.fromAny(key);\n    let value = this._state.getAttr(key);\n    if (!value.isDefined()) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        value = scope.getAttr(key);\n      }\n    }\n    return value;\n  }\n\n  getSlot(key: AnyValue): Value {\n    key = Value.fromAny(key);\n    let value = this._state.getSlot(key);\n    if (!value.isDefined()) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        value = scope.getSlot(key);\n      }\n    }\n    return value;\n  }\n\n  getField(key: AnyValue): Field | undefined {\n    key = Value.fromAny(key);\n    let field = this._state.getField(key);\n    if (field === void 0) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n      }\n    }\n    return field;\n  }\n\n  getItem(index: AnyNum): Item {\n    return this._state.getItem(index);\n  }\n\n  bindValue(key: Value, expr: Value): void {\n    const fieldUpdater = new RecordFieldUpdater(this, key);\n    const valueInput = RecordOutlet.Dataflow.compile(expr, this);\n    fieldUpdater.bindInput(valueInput);\n    // TODO: clean up existing field updater\n    this._fieldUpdaters = this._fieldUpdaters.updated(key, fieldUpdater);\n  }\n\n  set(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.set(key, newValue);\n      } else {\n        this._state.set(key, newValue);\n      }\n    } else {\n      this._state.set(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setAttr(key: AnyText, newValue: AnyValue): this {\n    key = Text.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.setAttr(key, newValue);\n      } else {\n        this._state.setAttr(key, newValue);\n      }\n    } else {\n      this._state.setAttr(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setSlot(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.setSlot(key, newValue);\n      } else {\n        this._state.setSlot(key, newValue);\n      }\n    } else {\n      this._state.setSlot(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setItem(index: number, newItem: AnyItem): this {\n    const oldItem = this._state.getItem(index);\n    newItem = Item.fromAny(newItem);\n    this._state.setItem(index, newItem);\n    if (oldItem instanceof Field && newItem instanceof Field) {\n      if (oldItem.key.equals(newItem.key)) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Update);\n      } else {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n    } else if (oldItem instanceof Field) {\n      this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n    } else if (newItem instanceof Field) {\n      this.invalidateInputKey(newItem.key, KeyEffect.Update);\n    } else {\n      this.invalidateInput();\n    }\n    return this;\n  }\n\n  push(...newItems: AnyItem[]): number {\n    let i = this._state.length;\n    const n = this._state.push.apply(this._state, arguments);\n    while (i < n) {\n      const newItem = this._state.get(i);\n      if (newItem instanceof Field) {\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n      i += 1;\n    }\n    return n;\n  }\n\n  splice(start: number, deleteCount: number = 0, ...newItems: AnyItem[]): Item[] {\n    const n = this._state.length;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.max(0, start);\n    deleteCount = Math.max(0, deleteCount);\n    const deleted = this._state.splice.apply(this._state, arguments);\n    for (let i = 0; i < deleted.length; i += 1) {\n      const oldItem = deleted[i];\n      if (oldItem instanceof Field) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n      }\n    }\n    for (let i = start; i < start + newItems.length; i += 1) {\n      const newItem = this._state.get(i);\n      if (newItem instanceof Field) {\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n    }\n    return deleted;\n  }\n\n  delete(key: AnyValue): Item {\n    const oldItem = this._state.delete(key);\n    if (oldItem instanceof Field) {\n      this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n    }\n    return oldItem;\n  }\n\n  clear(): void {\n    const oldState = this._state.branch();\n    this._state.clear();\n    oldState.forEach(function (oldItem: Item): void {\n      if (oldItem instanceof Field) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n      }\n    }, this);\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return this._state.forEach(callback, thisArg);\n  }\n\n  keyIterator(): Cursor<Value> {\n    throw new Error(); // TODO\n  }\n\n  disconnectInputs(): void {\n    const fieldUpdaters = this._fieldUpdaters;\n    if (!fieldUpdaters.isEmpty()) {\n      this._fieldUpdaters = new BTree();\n      fieldUpdaters.forEach(function (key: Value, inlet: RecordFieldUpdater): void {\n        inlet.disconnectInputs();\n      }, this);\n    }\n  }\n\n  memoize(): MapOutlet<Value, Value, Record> {\n    return this;\n  }\n\n  materialize(record: Record): void {\n    record.forEach(function (item: Item): void {\n      this.materializeItem(item);\n    }, this);\n  }\n\n  materializeItem(item: Item): void {\n    if (item instanceof Field) {\n      this.materializeField(item);\n    } else {\n      this.materializeValue(item);\n    }\n  }\n\n  materializeField(field: Field): void {\n    const value = field.value;\n    if (value instanceof RecordStreamlet) {\n      value.setStreamletScope(this);\n      this._state.push(field);\n    } else if (value instanceof Record) {\n      // Add recursively materialized nested scope.\n      const child = new RecordOutlet.Scope(this);\n      child.materialize(value);\n      this._state.push(field.updatedValue(child));\n    } else {\n      this._state.push(field);\n    }\n  }\n\n  materializeValue(value: Value): void {\n    if (value instanceof RecordStreamlet) {\n      value.setStreamletScope(this);\n      this._state.push(value);\n    } else if (value instanceof Record) {\n      // Add recursively materialized nested scope.\n      const child = new RecordOutlet.Scope(this);\n      child.materialize(value);\n      this._state.push(child);\n    } else {\n      this._state.push(value);\n    }\n  }\n\n  compile(record: Record): void {\n    record.forEach(function (item: Item, index: number): void {\n      this.compileItem(item, index);\n    }, this);\n  }\n\n  compileItem(item: Item, index: number): void {\n    if (item instanceof Field) {\n      this.compileField(item, index);\n    } else {\n      this.compileValue(item, index);\n    }\n  }\n\n  compileField(field: Field, index: number): void {\n    const key = field.key;\n    const value = field.value;\n    if (!key.isConstant()) {\n      // TODO: Add dynamic key updater.\n    } else if (!value.isConstant()) {\n      if (value instanceof RecordStreamlet) {\n        // Lexically bind nested streamlet.\n        value.compile();\n        // Invalidate nested scope key.\n        this.invalidateInputKey(key, KeyEffect.Update);\n      } else if (value instanceof Record) {\n        // Recursively compile nested scope.\n        (this._state.getItem(index).toValue() as RecordModel).compile(value);\n        // Invalidate nested scope key.\n        this.invalidateInputKey(key, KeyEffect.Update);\n      } else {\n        // Set placeholder value.\n        field.setValue(Value.extant());\n        // Bind dynamic value updater.\n        this.bindValue(key, value);\n      }\n    } else {\n      // Invalidate constant key.\n      this.invalidateInputKey(key, KeyEffect.Update);\n    }\n  }\n\n  compileValue(value: Value, index: number): void {\n    if (value instanceof RecordStreamlet) {\n      value.compile();\n    } else if (value instanceof Record) {\n      // Recursively compile nested scope.\n      (this._state.getItem(index) as RecordModel).compile(value);\n    } else if (!value.isConstant()) {\n      // TODO: Bind dynamic item updater.\n    } else {\n      // TODO: Fold constant expressions.\n    }\n  }\n\n  transmute(transmuter: Transmuter | null = Transmuter.system()): void {\n    this.forEach(function (oldItem: Item, index: number): void {\n      const newItem = this.transmuteItem(oldItem, transmuter);\n      if (oldItem !== newItem) {\n        this.setItem(index, newItem);\n      }\n    }, this);\n  }\n\n  transmuteItem(item: Item, transmuter: Transmuter | null): Item {\n    if (item instanceof Field) {\n      return this.transmuteField(item, transmuter);\n    } else {\n      return this.transmuteValue(item, transmuter);\n    }\n  }\n\n  transmuteField(field: Field, transmuter: Transmuter | null): Field {\n    const oldValue = field.value;\n    const newValue = this.transmuteValue(oldValue, transmuter);\n    if (oldValue !== newValue) {\n      return field.updatedValue(newValue);\n    } else {\n      return field;\n    }\n  }\n\n  transmuteValue(oldValue: Value, transmuter: Transmuter | null): Value {\n    if (oldValue instanceof RecordModel) {\n      let newValue = this.transmuteModel(oldValue);\n      if (oldValue === newValue && transmuter) {\n        newValue = transmuter.transmute(oldValue);\n      }\n      return newValue;\n    } else {\n      return oldValue;\n    }\n  }\n\n  transmuteModel(model: RecordModel): Record {\n    const scope = this.streamletScope();\n    if (scope instanceof RecordModel) {\n      return scope.transmuteModel(model);\n    } else {\n      return model;\n    }\n  }\n\n  static from(record: Record): RecordModel {\n    const model = new RecordModel();\n    model.materialize(record);\n    model.compile(record);\n    return model;\n  }\n\n  static of(...items: AnyItem[]): RecordModel {\n    return RecordModel.from(Record.of.apply(void 0, arguments));\n  }\n\n  static globalScope(): RecordModel {\n    const model = new RecordModel();\n    model.materializeField(Slot.of(\"math\", MathModule.scope().branch()));\n    return model;\n  }\n}\nRecordOutlet.Model = RecordModel;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Value, Record} from \"@swim/structure\";\nimport {StreamletScope} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {RecordModel} from \"./RecordModel\";\n\nexport class RecordScope extends RecordModel {\n  /** @hidden */\n  protected scope: StreamletScope<Value> | null;\n\n  constructor(scope: StreamletScope<Value> | null, state?: Record) {\n    super(state);\n    this.scope = scope;\n  }\n\n  streamletScope(): StreamletScope<Value> | null {\n    return this.scope;\n  }\n\n  static from(record: Record): RecordScope {\n    const scope = new RecordScope(RecordScope.globalScope());\n    scope.materialize(record);\n    scope.compile(record);\n    return scope;\n  }\n\n  static of(...items: AnyItem[]): RecordScope {\n    return RecordScope.from(Record.of.apply(void 0, arguments));\n  }\n}\nRecordOutlet.Scope = RecordScope;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, MapInlet, AbstractOutlet, OutletInlet, OutletMapInlet} from \"@swim/streamlet\";\n\n/** @hidden */\nexport class GetOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _keyInlet: OutletInlet<Value>;\n  /** @hidden */\n  readonly _mapInlet: OutletMapInlet<Value, Value, unknown>;\n\n  constructor() {\n    super();\n    this._keyInlet = new OutletInlet<Value>(this);\n    this._mapInlet = new OutletMapInlet<Value, Value, unknown>(this);\n  }\n\n  keyInlet(): Inlet<Value> {\n    return this._keyInlet;\n  }\n\n  mapInlet(): MapInlet<Value, Value, unknown> {\n    return this._mapInlet;\n  }\n\n  get(): Value {\n    const keyInput = this._keyInlet.input();\n    if (keyInput !== null) {\n      const key = keyInput.get();\n      if (key !== void 0) {\n        const mapInput = this._mapInlet.input();\n        if (mapInput !== null) {\n          const value = mapInput.get(key);\n          if (value !== void 0) {\n            return value;\n          }\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport abstract class BinaryOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const operand2Input = this._operand2Inlet.input();\n    if (operand1Input !== null && operand2Input !== null) {\n      const argument1 = operand1Input.get();\n      const argument2 = operand2Input.get();\n      if (argument1 !== void 0 && argument2 !== void 0) {\n        const result = this.evaluate(argument1, argument2);\n        return result.toValue();\n      }\n    }\n    return Value.absent();\n  }\n\n  protected abstract evaluate(argument1: Value, argument2: Value): Item;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport abstract class UnaryOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operandInlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operandInlet = new OutletInlet<Value>(this);\n  }\n\n  operandInlet(): Inlet<Value> {\n    return this._operandInlet;\n  }\n\n  get(): Value {\n    const operandInput = this._operandInlet.input();\n    if (operandInput !== null) {\n      const argument = operandInput.get();\n      if (argument !== void 0) {\n        const result = this.evaluate(argument);\n        return result.toValue();\n      }\n    }\n    return Value.absent();\n  }\n\n  protected abstract evaluate(argument: Value): Item;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class ConditionalOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _ifInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _thenInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _elseInlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._ifInlet = new OutletInlet<Value>(this);\n    this._thenInlet = new OutletInlet<Value>(this);\n    this._elseInlet = new OutletInlet<Value>(this);\n  }\n\n  ifInlet(): Inlet<Value> {\n    return this._ifInlet;\n  }\n\n  thenInlet(): Inlet<Value> {\n    return this._thenInlet;\n  }\n\n  elseInlet(): Inlet<Value> {\n    return this._elseInlet;\n  }\n\n  get(): Value {\n    const ifInput = this._ifInlet.input();\n    if (ifInput !== null) {\n      const ifTerm = ifInput.get();\n      if (ifTerm !== void 0) {\n        if (ifTerm.booleanValue(false)) {\n          const thenInput = this._thenInlet.input();\n          if (thenInput !== null) {\n            const thenTerm = thenInput.get();\n            if (thenTerm !== void 0) {\n              return thenTerm;\n            }\n          }\n        } else {\n          const elseInput = this._elseInlet.input();\n          if (elseInput !== null) {\n            const elseTerm = elseInput.get();\n            if (elseTerm !== void 0) {\n              return elseTerm;\n            }\n          }\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class OrOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const argument1 = operand1Input !== null ? operand1Input.get() : void 0;\n    if (argument1 !== void 0 && argument1.booleanValue(false)) {\n      return argument1;\n    }\n    const operand2Input = this._operand2Inlet.input();\n    const argument2 = operand2Input !== null ? operand2Input.get() : void 0;\n    if (argument2 !== void 0) {\n      return argument2;\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class AndOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const argument1 = operand1Input !== null ? operand1Input.get() : void 0;\n    if (argument1 !== void 0) {\n      if (argument1.booleanValue(false)) {\n        const operand2Input = this._operand2Inlet.input();\n        const argument2 = operand2Input !== null ? operand2Input.get() : void 0;\n        if (argument2 !== void 0) {\n          return argument2;\n        }\n      }\n      return argument1;\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseOrOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseOr(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseXorOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseXor(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseAndOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseAnd(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class LtOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.lt(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class LeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.le(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class EqOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.eq(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class NeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.ne(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class GeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.ge(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class GtOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.gt(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class PlusOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.plus(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class MinusOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.minus(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class TimesOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.times(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class DivideOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.divide(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class ModuloOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.modulo(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class NotOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.not();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class BitwiseNotOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.bitwiseNot();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class NegativeOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.negative();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class PositiveOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.positive();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record, Func, Interpreter} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class InvokeOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _scope: Record;\n  /** @hidden */\n  readonly _funcInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _argsInlet: Inlet<Value>;\n\n  constructor(scope: Record) {\n    super();\n    this._scope = scope;\n    this._funcInlet = new OutletInlet<Value>(this);\n    this._argsInlet = new OutletInlet<Value>(this);\n  }\n\n  funcInlet(): Inlet<Value> {\n    return this._funcInlet;\n  }\n\n  argsInlet(): Inlet<Value> {\n    return this._argsInlet;\n  }\n\n  get(): Value {\n    const funcInput = this._funcInlet.input();\n    const argsInput = this._argsInlet.input();\n    if (funcInput !== null && argsInput !== null) {\n      const func = funcInput.get();\n      if (func instanceof Func) {\n        const args = argsInput.get();\n        if (args !== void 0) {\n          const interpreter = new Interpreter();\n          interpreter.pushScope(this._scope);\n          const result = func.invoke(args, interpreter, void 0 /* TODO: generalize InvokeOperator to InvokeContext */);\n          return result.toValue();\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  Value,\n  Record,\n  Selector,\n  IdentitySelector,\n  GetSelector,\n  GetAttrSelector,\n  GetItemSelector,\n  KeysSelector,\n  ValuesSelector,\n  ChildrenSelector,\n  DescendantsSelector,\n  FilterSelector,\n  Operator,\n  BinaryOperator,\n  UnaryOperator,\n  ConditionalOperator,\n  OrOperator,\n  AndOperator,\n  BitwiseOrOperator,\n  BitwiseXorOperator,\n  BitwiseAndOperator,\n  LtOperator,\n  LeOperator,\n  EqOperator,\n  NeOperator,\n  GeOperator,\n  GtOperator,\n  PlusOperator,\n  MinusOperator,\n  TimesOperator,\n  DivideOperator,\n  ModuloOperator,\n  NotOperator,\n  BitwiseNotOperator,\n  NegativeOperator,\n  PositiveOperator,\n  InvokeOperator,\n} from \"@swim/structure\";\nimport {Outlet, KeyOutlet, StreamletScope, ValueInput} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {GetOutlet} from \"./selector/GetOutlet\";\nimport {BinaryOutlet} from \"./operator/BinaryOutlet\";\nimport {UnaryOutlet} from \"./operator/UnaryOutlet\";\nimport {ConditionalOutlet} from \"./operator/ConditionalOutlet\";\nimport {OrOutlet} from \"./operator/OrOutlet\";\nimport {AndOutlet} from \"./operator/AndOutlet\";\nimport {BitwiseOrOutlet} from \"./operator/BitwiseOrOutlet\";\nimport {BitwiseXorOutlet} from \"./operator/BitwiseXorOutlet\";\nimport {BitwiseAndOutlet} from \"./operator/BitwiseAndOutlet\";\nimport {LtOutlet} from \"./operator/LtOutlet\";\nimport {LeOutlet} from \"./operator/LeOutlet\";\nimport {EqOutlet} from \"./operator/EqOutlet\";\nimport {NeOutlet} from \"./operator/NeOutlet\";\nimport {GeOutlet} from \"./operator/GeOutlet\";\nimport {GtOutlet} from \"./operator/GtOutlet\";\nimport {PlusOutlet} from \"./operator/PlusOutlet\";\nimport {MinusOutlet} from \"./operator/MinusOutlet\";\nimport {TimesOutlet} from \"./operator/TimesOutlet\";\nimport {DivideOutlet} from \"./operator/DivideOutlet\";\nimport {ModuloOutlet} from \"./operator/ModuloOutlet\";\nimport {NotOutlet} from \"./operator/NotOutlet\";\nimport {BitwiseNotOutlet} from \"./operator/BitwiseNotOutlet\";\nimport {NegativeOutlet} from \"./operator/NegativeOutlet\";\nimport {PositiveOutlet} from \"./operator/PositiveOutlet\";\nimport {InvokeOutlet} from \"./operator/InvokeOutlet\";\n\nexport class Dataflow {\n  /** @hidden */\n  private constructor() {\n    // nop\n  }\n\n  /**\n   * Returns an `Outlet` that evaluates the given `expr` in the context of the\n   * given `scope`, and updates whenever any dependent expression updates.\n   */\n  static compile(expr: Value, scope: Outlet<Value>): Outlet<Value> {\n    if (scope instanceof KeyOutlet) {\n      const value = scope.get();\n      if (Outlet.is<Value>(value)) {\n        scope = value;\n      }\n    }\n    if (expr.isConstant()) {\n      return new ValueInput<Value>(expr);\n    } else if (expr instanceof Selector) {\n      return Dataflow.compileSelector(expr, scope);\n    } else if (expr instanceof Operator) {\n      return Dataflow.compileOperator(expr, scope);\n    }\n    throw new TypeError(\"\" + expr);\n  }\n\n  private static compileSelector(selector: Selector, scope: Outlet<Value>): Outlet<Value> {\n    if (selector instanceof IdentitySelector) {\n      return Dataflow.compileIdentitySelector(scope);\n    } else if (selector instanceof GetSelector) {\n      return Dataflow.compileGetSelector(selector, scope);\n    } else if (selector instanceof GetAttrSelector) {\n      return Dataflow.compileGetAttrSelector(selector, scope);\n    } else if (selector instanceof GetItemSelector) {\n      return Dataflow.compileGetItemSelector(selector, scope);\n    } else if (selector instanceof KeysSelector) {\n      return Dataflow.compileKeysSelector(scope);\n    } else if (selector instanceof ValuesSelector) {\n      return Dataflow.compileValuesSelector(scope);\n    } else if (selector instanceof ChildrenSelector) {\n      return Dataflow.compileChildrenSelector(scope);\n    } else if (selector instanceof DescendantsSelector) {\n      return Dataflow.compileDescendantsSelector(scope);\n    } else if (selector instanceof FilterSelector) {\n      return Dataflow.compileFilterSelector(selector, scope);\n    }\n    throw new TypeError(\"\" + selector);\n  }\n\n  private static compileIdentitySelector(scope: Outlet<Value>): Outlet<Value> {\n    return scope;\n  }\n\n  private static compileGetSelector(selector: GetSelector, scope: Outlet<Value>): Outlet<Value> {\n    const key = selector.accessor();\n    if (key.isConstant()) {\n      if (RecordOutlet.is(scope)) {\n        const outlet = scope.outlet(key);\n        if (outlet !== null) {\n          return Dataflow.compile(selector.then(), outlet);\n        }\n      } else if (StreamletScope.is<Value>(scope)) {\n        const name = key.stringValue(void 0);\n        if (name !== void 0) {\n          const outlet = scope.outlet(name);\n          if (outlet !== null) {\n            return Dataflow.compile(selector.then(), outlet);\n          }\n        }\n      }\n    } else {\n      const getOutlet = new GetOutlet();\n      const outlet = Dataflow.compile(key, scope);\n      getOutlet.keyInlet().bindInput(outlet);\n      getOutlet.mapInlet().bindInput(scope);\n      return getOutlet;\n    }\n    return null as unknown as Outlet<Value>;\n  }\n\n  private static compileGetAttrSelector(selector: GetAttrSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileGetItemSelector(selector: GetItemSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileKeysSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileValuesSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileChildrenSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileDescendantsSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileFilterSelector(selector: FilterSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileOperator(operator: Operator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof ConditionalOperator) {\n      return Dataflow.compileConditionalOperator(operator, scope);\n    } else if (operator instanceof BinaryOperator) {\n      return Dataflow.compileBinaryOperator(operator, scope);\n    } else if (operator instanceof UnaryOperator) {\n      return Dataflow.compileUnaryOperator(operator, scope);\n    } else if (operator instanceof InvokeOperator) {\n      return Dataflow.compileInvokeOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileConditionalOperator(operator: ConditionalOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new ConditionalOutlet();\n    const ifTerm = operator.ifTerm().toValue();\n    const thenTerm = operator.thenTerm().toValue();\n    const elseTerm = operator.elseTerm().toValue();\n    const ifOutlet = Dataflow.compile(ifTerm, scope);\n    const thenOutlet = Dataflow.compile(thenTerm, scope);\n    const elseOutlet = Dataflow.compile(elseTerm, scope);\n    outlet.ifInlet().bindInput(ifOutlet);\n    outlet.thenInlet().bindInput(thenOutlet);\n    outlet.elseInlet().bindInput(elseOutlet);\n    return outlet;\n  }\n\n  private static compileBinaryOperator(operator: BinaryOperator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof OrOperator) {\n      return Dataflow.compileOrOperator(operator, scope);\n    } else if (operator instanceof AndOperator) {\n      return Dataflow.compileAndOperator(operator, scope);\n    } else if (operator instanceof BitwiseOrOperator) {\n      return Dataflow.compileBitwiseOrOperator(operator, scope);\n    } else if (operator instanceof BitwiseXorOperator) {\n      return Dataflow.compileBitwiseXorOperator(operator, scope);\n    } else if (operator instanceof BitwiseAndOperator) {\n      return Dataflow.compileBitwiseAndOperator(operator, scope);\n    } else if (operator instanceof LtOperator) {\n      return Dataflow.compileLtOperator(operator, scope);\n    } else if (operator instanceof LeOperator) {\n      return Dataflow.compileLeOperator(operator, scope);\n    } else if (operator instanceof EqOperator) {\n      return Dataflow.compileEqOperator(operator, scope);\n    } else if (operator instanceof NeOperator) {\n      return Dataflow.compileNeOperator(operator, scope);\n    } else if (operator instanceof GeOperator) {\n      return Dataflow.compileGeOperator(operator, scope);\n    } else if (operator instanceof GtOperator) {\n      return Dataflow.compileGtOperator(operator, scope);\n    } else if (operator instanceof PlusOperator) {\n      return Dataflow.compilePlusOperator(operator, scope);\n    } else if (operator instanceof MinusOperator) {\n      return Dataflow.compileMinusOperator(operator, scope);\n    } else if (operator instanceof TimesOperator) {\n      return Dataflow.compileTimesOperator(operator, scope);\n    } else if (operator instanceof DivideOperator) {\n      return Dataflow.compileDivideOperator(operator, scope);\n    } else if (operator instanceof ModuloOperator) {\n      return Dataflow.compileModuloOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileBinaryOutlet(operator: BinaryOperator, outlet: BinaryOutlet, scope: Outlet<Value>): Outlet<Value> {\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileOrOperator(operator: OrOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new OrOutlet();\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileAndOperator(operator: AndOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new AndOutlet();\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileBitwiseOrOperator(operator: BitwiseOrOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseOrOutlet(), scope);\n  }\n\n  private static compileBitwiseXorOperator(operator: BitwiseXorOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseXorOutlet(), scope);\n  }\n\n  private static compileBitwiseAndOperator(operator: BitwiseAndOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseAndOutlet(), scope);\n  }\n\n  private static compileLtOperator(operator: LtOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new LtOutlet(), scope);\n  }\n\n  private static compileLeOperator(operator: LeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new LeOutlet(), scope);\n  }\n\n  private static compileEqOperator(operator: EqOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new EqOutlet(), scope);\n  }\n\n  private static compileNeOperator(operator: NeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new NeOutlet(), scope);\n  }\n\n  private static compileGeOperator(operator: GeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new GeOutlet(), scope);\n  }\n\n  private static compileGtOperator(operator: GtOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new GtOutlet(), scope);\n  }\n\n  private static compilePlusOperator(operator: PlusOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new PlusOutlet(), scope);\n  }\n\n  private static compileMinusOperator(operator: MinusOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new MinusOutlet(), scope);\n  }\n\n  private static compileTimesOperator(operator: TimesOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new TimesOutlet(), scope);\n  }\n\n  private static compileDivideOperator(operator: DivideOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new DivideOutlet(), scope);\n  }\n\n  private static compileModuloOperator(operator: ModuloOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new ModuloOutlet(), scope);\n  }\n\n  private static compileUnaryOperator(operator: UnaryOperator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof NotOperator) {\n      return Dataflow.compileNotOperator(operator, scope);\n    } else if (operator instanceof BitwiseNotOperator) {\n      return Dataflow.compileBitwiseNotOperator(operator, scope);\n    } else if (operator instanceof NegativeOperator) {\n      return Dataflow.compileNegativeOperator(operator, scope);\n    } else if (operator instanceof PositiveOperator) {\n      return Dataflow.compilePositiveOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileUnaryOutlet(operator: UnaryOperator, outlet: UnaryOutlet, scope: Outlet<Value>): Outlet<Value> {\n    const operand = operator.operand().toValue();\n    const operandOutlet = Dataflow.compile(operand, scope);\n    outlet.operandInlet().bindInput(operandOutlet);\n    return outlet;\n  }\n\n  private static compileNotOperator(operator: NotOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new NotOutlet(), scope);\n  }\n\n  private static compileBitwiseNotOperator(operator: BitwiseNotOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new BitwiseNotOutlet(), scope);\n  }\n\n  private static compileNegativeOperator(operator: NegativeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new NegativeOutlet(), scope);\n  }\n\n  private static compilePositiveOperator(operator: PositiveOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new PositiveOutlet(), scope);\n  }\n\n  private static compileInvokeOperator(operator: InvokeOperator, scope: Outlet<Value>): Outlet<Value> {\n    const func = operator.func();\n    const args = operator.args();\n    const invokeOutlet = new InvokeOutlet(scope as unknown as Record);\n    const funcOutlet = Dataflow.compile(func, scope);\n    const argsOutlet = Dataflow.compile(args, scope);\n    invokeOutlet.funcInlet().bindInput(funcOutlet);\n    invokeOutlet.argsInlet().bindInput(argsOutlet);\n    return invokeOutlet;\n  }\n}\nRecordOutlet.Dataflow = Dataflow;\n"]}