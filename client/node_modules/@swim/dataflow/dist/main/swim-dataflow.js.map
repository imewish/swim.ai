{"version":3,"file":"swim-dataflow.js","sources":["../../main/RecordOutlet.ts","../../../../../node_modules/tslib/tslib.es6.js","../../main/AbstractRecordOutlet.ts","../../main/RecordStreamlet.ts","../../main/AbstractRecordStreamlet.ts","../../main/RecordFieldUpdater.ts","../../main/Transmuter.ts","../../main/RecordModel.ts","../../main/RecordScope.ts","../../main/selector/GetOutlet.ts","../../main/operator/BinaryOutlet.ts","../../main/operator/UnaryOutlet.ts","../../main/operator/ConditionalOutlet.ts","../../main/operator/OrOutlet.ts","../../main/operator/AndOutlet.ts","../../main/operator/BitwiseOrOutlet.ts","../../main/operator/BitwiseXorOutlet.ts","../../main/operator/BitwiseAndOutlet.ts","../../main/operator/LtOutlet.ts","../../main/operator/LeOutlet.ts","../../main/operator/EqOutlet.ts","../../main/operator/NeOutlet.ts","../../main/operator/GeOutlet.ts","../../main/operator/GtOutlet.ts","../../main/operator/PlusOutlet.ts","../../main/operator/MinusOutlet.ts","../../main/operator/TimesOutlet.ts","../../main/operator/DivideOutlet.ts","../../main/operator/ModuloOutlet.ts","../../main/operator/NotOutlet.ts","../../main/operator/BitwiseNotOutlet.ts","../../main/operator/NegativeOutlet.ts","../../main/operator/PositiveOutlet.ts","../../main/operator/InvokeOutlet.ts","../../main/Dataflow.ts"],"sourcesContent":["// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Map} from \"@swim/util\";\nimport {Value, Record} from \"@swim/structure\";\nimport {Outlet, MapOutlet, StreamletScope} from \"@swim/streamlet\";\nimport {MapValueFunction, MapFieldValuesFunction} from \"@swim/streamlet\";\nimport {WatchValueFunction, WatchFieldsFunction} from \"@swim/streamlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\nimport {RecordModel} from \"./RecordModel\";\nimport {RecordScope} from \"./RecordScope\";\nimport {Dataflow} from \"./Dataflow\";\n\nexport interface RecordOutlet extends Outlet<Record>, MapOutlet<Value, Value, Record>, StreamletScope<Value> {\n  outlet(key: Value | string): Outlet<Value>;\n\n  get(): Record;\n  get(key: Value): Value;\n\n  memoize(): MapOutlet<Value, Value, Record>;\n\n  map<O2>(func: MapValueFunction<Record, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map<Value, V2>>;\n\n  watch(func: WatchValueFunction<Record>): this;\n  watch(func: WatchFieldsFunction<Value, Value>): this;\n}\n\n/** @hidden */\nexport const RecordOutlet = {\n  is(object: unknown): object is RecordOutlet {\n    if (typeof object === \"object\" && object) {\n      const outlet = object as RecordOutlet;\n      return MapOutlet.is(outlet) && StreamletScope.is(outlet);\n    }\n    return false;\n  },\n\n  // Forward type declarations\n  /** @hidden */\n  Streamlet: void 0 as unknown as typeof RecordStreamlet, // defined by RecordStreamlet\n  /** @hidden */\n  Model: void 0 as unknown as typeof RecordModel, // defined by RecordModel\n  /** @hidden */\n  Scope: void 0 as unknown as typeof RecordScope, // defined by RecordScope\n  /** @hidden */\n  Dataflow: void 0 as unknown as typeof Dataflow, // defined by Dataflow\n};\n","/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor, Map} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AnyItem, Item, Field, AnyValue, Value, Record, Text, Selector} from \"@swim/structure\";\nimport {Inlet, Outlet, KeyEffect, MapInlet, MapOutlet, KeyOutlet, StreamletContext, StreamletScope} from \"@swim/streamlet\";\nimport {MemoizeMapCombinator} from \"@swim/streamlet\";\nimport {FilterFieldsFunction, FilterFieldsCombinator} from \"@swim/streamlet\";\nimport {MapValueFunction, MapValueCombinator} from \"@swim/streamlet\";\nimport {MapFieldValuesFunction, MapFieldValuesCombinator} from \"@swim/streamlet\";\nimport {ReduceFieldsCombinator} from \"@swim/streamlet\";\nimport {WatchValueFunction, WatchValueCombinator} from \"@swim/streamlet\";\nimport {WatchFieldsFunction, WatchFieldsCombinator} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport abstract class AbstractRecordOutlet extends Record implements RecordOutlet {\n  /** @hidden */\n  protected _effects: BTree<Value, KeyEffect>;\n  /** @hidden */\n  protected _outlets: BTree<Value, KeyOutlet<Value, Value>>;\n  /** @hidden */\n  protected _outputs: ReadonlyArray<Inlet<Record>> | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor() {\n    super();\n    this._effects = new BTree();\n    this._outlets = new BTree();\n    this._outputs = null;\n    this._version = -1;\n  }\n\n  streamletScope(): StreamletScope<Value> | null {\n    return null;\n  }\n\n  streamletContext(): StreamletContext | null {\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  hasOwn(key: AnyValue): boolean {\n    return this.has(key);\n  }\n\n  get(): Record;\n  get(key: AnyValue): Value;\n  get(key?: AnyValue): Record | Value {\n    if (key === void 0) {\n      return this;\n    } else {\n      return super.get(key);\n    }\n  }\n\n  abstract keyIterator(): Cursor<Value>;\n\n  outlet(key: Value | string): Outlet<Value> {\n    if (typeof key === \"string\") {\n      key = Text.from(key);\n    }\n    if (!this.hasOwn(key)) {\n      const scope = this.streamletScope();\n      if (RecordOutlet.is(scope) && scope.has(key)) {\n        // TODO: Support dynamic shadowing?\n        return scope.outlet(key);\n      }\n    }\n    let outlet = this._outlets.get(key);\n    if (outlet === void 0) {\n      outlet = new KeyOutlet<Value, Value>(this, key);\n      this._outlets = this._outlets.updated(key, outlet);\n      this.invalidateInputKey(key, KeyEffect.Update);\n    }\n    return outlet;\n  }\n\n  outputIterator(): Cursor<Inlet<Record>> {\n    return this._outputs !== null ? Cursor.array(this._outputs) : Cursor.empty();\n  }\n\n  bindOutput(output: Inlet<Record>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    const newOutputs = new Array<Inlet<Record>>(n + 1);\n    for (let i = 0; i < n; i += 1) {\n      newOutputs[i] = oldOutputs![i];\n    }\n    newOutputs[n] = output;\n    this._outputs = newOutputs;\n  }\n\n  unbindOutput(output: Inlet<Record>): void {\n    const oldOutputs = this._outputs;\n    const n = oldOutputs !== null ? oldOutputs.length : 0;\n    for (let i = 0; i < n; i += 1) {\n      if (oldOutputs![i] === output) {\n        if (n > 1) {\n          const newOutputs = new Array<Inlet<Record>>(n - 1);\n          for (let j = 0; j < i; j += 1) {\n            newOutputs[j] = oldOutputs![j];\n          }\n          for (let j = i; j < n - 1; j += 1) {\n            newOutputs[j] = oldOutputs![j + 1];\n          }\n          this._outputs = newOutputs;\n        } else {\n          this._outputs = null;\n        }\n        break;\n      }\n    }\n  }\n\n  unbindOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: Value, keyOutlet: KeyOutlet<Value, Value>) {\n        keyOutlet.unbindOutputs();\n      }, this);\n    }\n    const oldOutputs = this._outputs;\n    if (oldOutputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = oldOutputs.length; i < n; i += 1) {\n        oldOutputs[i].unbindInput();\n      }\n    }\n  }\n\n  disconnectOutputs(): void {\n    const outlets = this._outlets;\n    if (outlets.isEmpty()) {\n      this._outlets = new BTree();\n      outlets.forEach(function (key: Value, keyOutlet: KeyOutlet<Value, Value>) {\n        keyOutlet.disconnectOutputs();\n      }, this);\n    }\n    const outputs = this._outputs;\n    if (outputs !== null) {\n      this._outputs = null;\n      for (let i = 0, n = outputs.length; i < n; i += 1) {\n        const output = outputs[i];\n        output.unbindInput();\n        output.disconnectOutputs();\n      }\n    }\n    this.forEach(function (member: Item): void {\n      if (member instanceof Field) {\n        member = member.toValue();\n      }\n      if (member instanceof AbstractRecordOutlet) {\n        member.disconnectOutputs();\n      } else if (member instanceof RecordOutlet.Streamlet) {\n        member.disconnectOutputs();\n      } else if (RecordOutlet.is(member)) {\n        member.disconnectOutputs();\n      }\n    }, this);\n  }\n\n  disconnectInputs(): void {\n    // nop\n  }\n\n  invalidateInputKey(key: Value, effect: KeyEffect): void {\n    const oldEffects = this._effects;\n    if (oldEffects.get(key) !== effect) {\n      this.willInvalidateInputKey(key, effect);\n      this._effects = oldEffects.updated(key, effect);\n      this._version = -1;\n      this.onInvalidateInputKey(key, effect);\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        const output = this._outputs![i];\n        if (MapInlet.is(output)) {\n          output.invalidateOutputKey(key, effect);\n        } else {\n          output.invalidateOutput();\n        }\n      }\n      const outlet = this._outlets.get(key);\n      if (outlet !== void 0) {\n        outlet.invalidateInput();\n      }\n      this.didInvalidateInputKey(key, effect);\n    }\n  }\n\n  invalidateInput(): void {\n    if (this._version >= 0) {\n      this.willInvalidateInput();\n      this._version = -1;\n      this.onInvalidateInput();\n      const n = this._outputs !== null ? this._outputs.length : 0;\n      for (let i = 0; i < n; i += 1) {\n        this._outputs![i].invalidateOutput();\n      }\n      this._outlets.forEach(function (key: Value, outlet: KeyOutlet<Value, Value>): void {\n        outlet.invalidateInput();\n      }, this);\n      this.didInvalidateInput();\n    }\n  }\n\n  reconcileInputKey(key: Value, version: number): void {\n    if (this._version < 0) {\n      const oldEffects = this._effects;\n      const effect = oldEffects.get(key);\n      if (effect !== void 0) {\n        this.willReconcileInputKey(key, effect, version);\n        this._effects = oldEffects.removed(key);\n        this.onReconcileInputKey(key, effect, version);\n        for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n          const output = this._outputs![i];\n          if (MapInlet.is(output)) {\n            output.reconcileOutputKey(key, version);\n          }\n        }\n        const outlet = this._outlets.get(key);\n        if (outlet !== void 0) {\n          outlet.reconcileInput(version);\n        }\n        this.didReconcileInputKey(key, effect, version);\n      }\n    }\n  }\n\n  reconcileInput(version: number): void {\n    if (this._version < 0) {\n      this.willReconcileInput(version);\n      this._effects.forEach(function (key: Value): void {\n        this.reconcileInputKey(key, version);\n      }, this);\n      this._version = version;\n      this.onReconcileInput(version);\n      for (let i = 0, n = this._outputs !== null ? this._outputs.length : 0; i < n; i += 1) {\n        this._outputs![i].reconcileOutput(version);\n      }\n      this.forEach(function (member: Item): void {\n        if (member instanceof Field) {\n          member = member.toValue();\n        }\n        if (member instanceof AbstractRecordOutlet) {\n          member.reconcileInput(version);\n        } else if (member instanceof RecordOutlet.Streamlet) {\n          member.reconcile(version);\n        } else if (RecordOutlet.is(member)) {\n          member.reconcileInput(version);\n        }\n      }, this);\n      this.didReconcileInput(version);\n    }\n  }\n\n  protected willInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected onInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected didInvalidateInputKey(key: Value, effect: KeyEffect): void {\n    // stub\n  }\n\n  protected willInvalidateInput(): void {\n    // stub\n  }\n\n  protected onInvalidateInput(): void {\n    // stub\n  }\n\n  protected didInvalidateInput(): void {\n    // stub\n  }\n\n  protected willReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected onReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected didReconcileInputKey(key: Value, effect: KeyEffect, version: number): void {\n    // stub\n  }\n\n  protected willReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInput(version: number): void {\n    // stub\n  }\n\n  protected didReconcileInput(version: number): void {\n    // stub\n  }\n\n  memoize(): MapOutlet<Value, Value, Record> {\n    const combinator = new MemoizeMapCombinator<Value, Value, Record>();\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  filter(predicate?: AnyItem): Selector;\n  filter(func: FilterFieldsFunction<Value, Value>): MapOutlet<Value, Value, Map<Value, Value>>;\n  filter(func: AnyItem | FilterFieldsFunction<Value, Value>): Selector | MapOutlet<Value, Value, Map<Value, Value>> {\n    if (typeof func !== \"function\") {\n      return super.filter(func as AnyItem);\n    } else {\n      const combinator = new FilterFieldsCombinator<Value, Value, Record>(func);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  map<O2>(func: MapValueFunction<Record, O2>): Outlet<O2>;\n  map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map<Value, V2>>;\n  map<V2>(func: MapValueFunction<Record, V2> | MapFieldValuesFunction<Value, Value, V2>): Outlet<V2> | MapOutlet<Value, V2, Map<Value, V2>> {\n    if (func.length === 1) {\n      const combinator = new MapValueCombinator<Record, V2>(func as MapValueFunction<Record, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    } else {\n      const combinator = new MapFieldValuesCombinator<Value, Value, V2, Record>(func as MapFieldValuesFunction<Value, Value, V2>);\n      combinator.bindInput(this);\n      return combinator;\n    }\n  }\n\n  reduce<U>(identity: U, accumulator: (result: U, element: Value) => U, combiner: (result: U, result2: U) => U): Outlet<U> {\n    const combinator = new ReduceFieldsCombinator<Value, Value, Record, U>(identity, accumulator, combiner);\n    combinator.bindInput(this);\n    return combinator;\n  }\n\n  watch(func: WatchValueFunction<Record>): this;\n  watch(func: WatchFieldsFunction<Value, Value>): this;\n  watch(func: WatchValueFunction<Record> | WatchFieldsFunction<Value, Value>): this {\n    if (func.length === 1) {\n      const combinator = new WatchValueCombinator<Record>(func as WatchValueFunction<Record>);\n      combinator.bindInput(this);\n      return this;\n    } else {\n      const combinator = new WatchFieldsCombinator<Value, Value, Record>(func as WatchFieldsFunction<Value, Value>);\n      combinator.bindInput(this);\n      return this;\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record} from \"@swim/structure\";\nimport {Inlet, Outlet, StreamletContext, StreamletScope, StreamletClass, Streamlet, AbstractStreamlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport abstract class RecordStreamlet<I extends Value = Value, O extends Value = I> extends Record implements Streamlet<I, O> {\n  isConstant(): boolean {\n    return false;\n  }\n\n  protected streamletClass(): StreamletClass {\n    return (this as any).__proto__ as StreamletClass;\n  }\n\n  abstract streamletScope(): StreamletScope<O> | null;\n\n  abstract setStreamletScope(parent: StreamletScope<O> | null): void;\n\n  abstract streamletContext(): StreamletContext | null;\n\n  abstract setStreamletContext(context: StreamletContext | null): void;\n\n  abstract inlet(key: string): Inlet<I> | null;\n\n  abstract bindInput(key: string, input: Outlet<I>): void;\n\n  abstract unbindInput(key: string): void;\n\n  abstract outlet(key: string): Outlet<O> | null;\n\n  abstract disconnectInputs(): void;\n\n  abstract disconnectOutputs(): void;\n\n  abstract invalidate(): void;\n\n  abstract reconcile(version: number): void;\n\n  compile(): void {\n    AbstractStreamlet.reflectEachInlet<I, O, void, this>(this, this.streamletClass(), function (inlet: Inlet<I>, name: string): void {\n      if (inlet.input() === null) {\n        this.compileInlet(inlet, name);\n      }\n    }, this);\n  }\n\n  compileInlet(inlet: Inlet<I>, name: string): void {\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      const input = scope.outlet(name);\n      if (input !== null) {\n        // Assume Outlet<O> conforms to Outlet<I>.\n        inlet.bindInput(input as Outlet<unknown> as Outlet<I>);\n      }\n    }\n  }\n}\nRecordOutlet.Streamlet = RecordStreamlet;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Item, Field, Slot, AnyValue, Value, AnyText, Text, AnyNum, Num, Form} from \"@swim/structure\";\nimport {\n  Inlet,\n  Outlet,\n  Inoutlet,\n  StreamletContext,\n  GenericStreamlet,\n  AbstractStreamlet,\n  StreamletScope,\n  StreamletInlet,\n  StreamletOutlet,\n  StreamletInoutlet,\n} from \"@swim/streamlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\n\nexport abstract class AbstractRecordStreamlet<I extends Value = Value, O extends Value = I> extends RecordStreamlet<I, O> implements GenericStreamlet<I, O> {\n  protected scope: StreamletScope<O> | null;\n  protected context: StreamletContext | null;\n  /** @hidden */\n  protected _version: number;\n\n  constructor(scope: StreamletScope<O> | null = null) {\n    super();\n    this.scope = scope;\n    this.context = null;\n    this._version = -1;\n  }\n\n  streamletScope(): StreamletScope<O> | null {\n    return this.scope;\n  }\n\n  setStreamletScope(scope: StreamletScope<O> | null): void {\n    this.scope = scope;\n  }\n\n  streamletContext(): StreamletContext | null {\n    if (this.context) {\n      return this.context;\n    }\n    const scope = this.streamletScope();\n    if (scope !== null) {\n      return scope.streamletContext();\n    }\n    return null;\n  }\n\n  setStreamletContext(context: StreamletContext | null): void {\n    this.context = context;\n  }\n\n  isEmpty(): boolean {\n    return this.length !== 0;\n  }\n\n  get length(): number {\n    return AbstractStreamlet.reflectOutletCount(this.streamletClass());\n  }\n\n  has(key: AnyValue): boolean {\n    if (key instanceof Text) {\n      key = key.value;\n    } else if (typeof key !== \"string\") {\n      return false;\n    }\n    const outlet = this.outlet(key);\n    return outlet !== null;\n  }\n\n  get(key: AnyValue): Value {\n    if (key instanceof Text) {\n      key = key.value;\n    } else if (typeof key !== \"string\") {\n      return Value.absent();\n    }\n    const outlet = this.outlet(key);\n    if (outlet !== null) {\n      const output = outlet.get();\n      if (output !== void 0) {\n        return output;\n      }\n    }\n    return Value.absent();\n  }\n\n  getAttr(key: AnyText): Value {\n    return Value.absent();\n  }\n\n  getSlot(key: AnyValue): Value {\n    return this.get(key);\n  }\n\n  getField(key: AnyValue): Field | undefined {\n    if (typeof key === \"string\") {\n      key = Text.from(key);\n    } else if (!(key instanceof Text)) {\n      return void 0;\n    }\n    const value = this.get(key);\n    if (value.isDefined()) {\n      return Slot.of(key, value);\n    }\n    return void 0;\n  }\n\n  getItem(index: AnyNum): Item {\n    if (index instanceof Num) {\n      index = index.value;\n    }\n    const entry = AbstractStreamlet.reflectOutletIndex<I, O>(index, this, this.streamletClass());\n    if (entry !== null) {\n      const name = entry[0];\n      let output = entry[1].get() as Value | undefined;\n      if (output === void 0) {\n        output = Value.extant();\n      }\n      return Slot.of(name, output);\n    }\n    return Item.absent();\n  }\n\n  set(key: AnyValue, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setAttr(key: AnyText, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setSlot(key: AnyValue, newValue: AnyValue): this {\n    throw new Error(\"unsupported\");\n  }\n\n  setItem(index: number, item: AnyItem): this {\n    throw new Error(\"unsupported\");\n  }\n\n  push(...items: AnyItem[]): number {\n    throw new Error(\"unsupported\");\n  }\n\n  splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[] {\n    throw new Error(\"unsupported\");\n  }\n\n  delete(key: AnyValue): Item {\n    throw new Error(\"unsupported\");\n  }\n\n  clear(): void {\n    throw new Error(\"unsupported\");\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return AbstractStreamlet.reflectEachOutlet(this, this.streamletClass(), function (outlet: Outlet<O>, name: string, index: number): T | void {\n      const output = outlet.get();\n      if (output !== void 0) {\n        const result = callback.call(thisArg, output, index);\n        if (result !== void 0) {\n          return result;\n        }\n      }\n    }, this);\n  }\n\n  inlet(key: string): Inlet<I> | null;\n  inlet<I2 extends I>(): Inlet<I2>;\n  inlet(key?: string): Inlet<I> | null {\n    if (key === void 0) {\n      return new StreamletInlet<I>(this);\n    } else {\n      return AbstractStreamlet.reflectInletKey<I, O>(key, this, this.streamletClass());\n    }\n  }\n\n  bindInput(key: string, input: Outlet<I>): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.bindInput(input);\n  }\n\n  unbindInput(key: string): void {\n    const inlet = this.inlet(key);\n    if (inlet === null) {\n      throw new Error(\"\" + key);\n    }\n    inlet.unbindInput();\n  }\n\n  outlet(key: string | Outlet<O>): Outlet<O> | null;\n  outlet<O2 extends Value>(): Outlet<O2>;\n  outlet(key?: string | Outlet<O>): Outlet<O> | null {\n    if (key === void 0) {\n      return new StreamletOutlet<O>(this);\n    } else if (typeof key === \"string\") {\n      return AbstractStreamlet.reflectOutletKey<I, O>(key, this, this.streamletClass());\n    } else {\n      return key;\n    }\n  }\n\n  inoutlet<I2 extends I, O2 extends Value>(): Inoutlet<I2, O2> {\n    return new StreamletInoutlet<I2, O2>(this as RecordStreamlet<I2, O2>);\n  }\n\n  invalidate(): void {\n    if (this._version >= 0) {\n      this.willInvalidate();\n      this._version = -1;\n      this.onInvalidate();\n      this.onInvalidateOutlets();\n      this.didInvalidate();\n    }\n  }\n\n  reconcile(version: number): void {\n    if (this._version < 0) {\n      this.willReconcile(version);\n      this._version = version;\n      this.onReconcileInlets(version);\n      this.onReconcile(version);\n      this.onReconcileOutlets(version);\n      this.didReconcile(version);\n    }\n  }\n\n  getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;\n  getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse?: E): I2 | E | undefined {\n    if (typeof inlet === \"string\") {\n      inlet = this.inlet(inlet) as Inlet<I2>;\n    }\n    let object: I2 | E | undefined;\n    if (inlet !== null) {\n      const input = inlet.input();\n      if (input !== null) {\n        object = input.get();\n      }\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  castInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T | undefined;\n  castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;\n  castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse?: E): T | E | undefined {\n    const input = this.getInput(inlet);\n    let object: T | E | undefined;\n    if (input !== void 0) {\n      object = form.cast(input);\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object;\n  }\n\n  coerceInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T;\n  coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;\n  coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse?: E): T | E {\n    const input = this.getInput(inlet);\n    let object: T | E | undefined;\n    if (input !== void 0) {\n      object = form.cast(input);\n    }\n    if (object === void 0) {\n      object = form.unit();\n    }\n    if (object === void 0) {\n      object = orElse;\n    }\n    return object!;\n  }\n\n  getOutput(outlet: Outlet<O> | string): O | undefined {\n    return void 0;\n  }\n\n  disconnectInputs(): void {\n    AbstractStreamlet.disconnectInputs(this, this.streamletClass());\n  }\n\n  disconnectOutputs(): void {\n    AbstractStreamlet.disconnectOutputs(this, this.streamletClass());\n  }\n\n  willInvalidateInlet(inlet: Inlet<I>): void {\n    // stub\n  }\n\n  didInvalidateInlet(inlet: Inlet<I>): void {\n    this.invalidate();\n  }\n\n  willReconcileInlet(inlet: Inlet<I>, version: number): void {\n    // stub\n  }\n\n  didReconcileInlet(inlet: Inlet<I>, version: number): void {\n    this.reconcile(version);\n  }\n\n  willInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  didInvalidateOutlet(outlet: Outlet<O>): void {\n    // stub\n  }\n\n  willReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  didReconcileOutlet(outlet: Outlet<O>, version: number): void {\n    // stub\n  }\n\n  protected willInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidate(): void {\n    // stub\n  }\n\n  protected didInvalidate(): void {\n    // stub\n  }\n\n  protected onInvalidateOutlets(): void {\n    AbstractStreamlet.invalidateOutlets(this, this.streamletClass());\n  }\n\n  protected willReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileInlets(version: number): void {\n    AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());\n  }\n\n  protected onReconcile(version: number): void {\n    // stub\n  }\n\n  protected onReconcileOutlets(version: number): void {\n    AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());\n  }\n\n  protected didReconcile(version: number): void {\n    // stub\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record} from \"@swim/structure\";\nimport {KeyEffect, AbstractInlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\n\nexport class RecordFieldUpdater extends AbstractInlet<Value> {\n  /** @hidden */\n  protected readonly _record: Record;\n  /** @hidden */\n  protected readonly _key: Value;\n\n  constructor(record: Record, key: Value) {\n    super();\n    this._record = record;\n    this._key = key;\n  }\n\n  protected onInvalidateOutput(): void {\n    if (RecordOutlet.is(this._record)) {\n      this._record.invalidateInputKey(this._key, KeyEffect.Update);\n    }\n  }\n\n  protected onReconcileOutput(version: number): void {\n    if (this._input !== null) {\n      const value = this._input.get();\n      if (value !== void 0) {\n        this._record.set(this._key, value);\n      } else {\n        this._record.delete(this._key);\n      }\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Record} from \"@swim/structure\";\nimport {RecordModel} from \"./RecordModel\";\n\nexport abstract class Transmuter {\n  abstract transmute(model: RecordModel): Record;\n\n  static system(): Transmuter {\n    return null as unknown as Transmuter;\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {BTree} from \"@swim/collections\";\nimport {AnyItem, Item, Field, Slot, AnyValue, Value, Record, AnyText, Text, AnyNum, MathModule} from \"@swim/structure\";\nimport {KeyEffect, MapOutlet} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {RecordStreamlet} from \"./RecordStreamlet\";\nimport {AbstractRecordOutlet} from \"./AbstractRecordOutlet\";\nimport {RecordFieldUpdater} from \"./RecordFieldUpdater\";\nimport {Transmuter} from \"./Transmuter\";\n\nexport class RecordModel extends AbstractRecordOutlet {\n  /** @hidden */\n  protected _state: Record;\n  /** @hidden */\n  protected _fieldUpdaters: BTree<Value, RecordFieldUpdater>;\n\n  constructor(state: Record = Record.create()) {\n    super();\n    this._state = state;\n    this._fieldUpdaters = new BTree();\n  }\n\n  isEmpty(): boolean {\n    return this._state.isEmpty();\n  }\n\n  isArray(): boolean {\n    return this._state.isArray();\n  }\n\n  isObject(): boolean {\n    return this._state.isObject();\n  }\n\n  get length(): number {\n    return this._state.length;\n  }\n\n  fieldCount(): number {\n    return this._state.fieldCount();\n  }\n\n  valueCount(): number {\n    return this._state.valueCount();\n  }\n\n  has(key: AnyValue): boolean {\n    if (this._state.has(key)) {\n      return true;\n    } else {\n      const scope = this.streamletScope();\n      return scope instanceof Record ? scope.has(key) : false;\n    }\n  }\n\n  hasOwn(key: AnyValue): boolean {\n    return this._state.has(key);\n  }\n\n  indexOf(item: AnyItem, index?: number): number {\n    return this._state.indexOf(item, index);\n  }\n\n  lastIndexOf(item: AnyItem, index: number = 0): number {\n    return this._state.lastIndexOf(item, index);\n  }\n\n  get(): Record;\n  get(key: AnyValue): Value;\n  get(key?: AnyValue): Record | Value {\n    if (key === void 0) {\n      return this;\n    } else {\n      key = Value.fromAny(key);\n      let value = this._state.get(key);\n      if (!value.isDefined()) {\n        const scope = this.streamletScope();\n        if (scope instanceof Record) {\n          value = scope.get(key);\n        }\n      }\n      return value;\n    }\n  }\n\n  getAttr(key: AnyText): Value {\n    key = Text.fromAny(key);\n    let value = this._state.getAttr(key);\n    if (!value.isDefined()) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        value = scope.getAttr(key);\n      }\n    }\n    return value;\n  }\n\n  getSlot(key: AnyValue): Value {\n    key = Value.fromAny(key);\n    let value = this._state.getSlot(key);\n    if (!value.isDefined()) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        value = scope.getSlot(key);\n      }\n    }\n    return value;\n  }\n\n  getField(key: AnyValue): Field | undefined {\n    key = Value.fromAny(key);\n    let field = this._state.getField(key);\n    if (field === void 0) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record) {\n        field = scope.getField(key);\n      }\n    }\n    return field;\n  }\n\n  getItem(index: AnyNum): Item {\n    return this._state.getItem(index);\n  }\n\n  bindValue(key: Value, expr: Value): void {\n    const fieldUpdater = new RecordFieldUpdater(this, key);\n    const valueInput = RecordOutlet.Dataflow.compile(expr, this);\n    fieldUpdater.bindInput(valueInput);\n    // TODO: clean up existing field updater\n    this._fieldUpdaters = this._fieldUpdaters.updated(key, fieldUpdater);\n  }\n\n  set(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.set(key, newValue);\n      } else {\n        this._state.set(key, newValue);\n      }\n    } else {\n      this._state.set(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setAttr(key: AnyText, newValue: AnyValue): this {\n    key = Text.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.setAttr(key, newValue);\n      } else {\n        this._state.setAttr(key, newValue);\n      }\n    } else {\n      this._state.setAttr(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setSlot(key: AnyValue, newValue: AnyValue): this {\n    key = Value.fromAny(key);\n    if (!this._state.has(key)) {\n      const scope = this.streamletScope();\n      if (scope instanceof Record && scope.has(key)) {\n        scope.setSlot(key, newValue);\n      } else {\n        this._state.setSlot(key, newValue);\n      }\n    } else {\n      this._state.setSlot(key, newValue);\n    }\n    this.invalidateInputKey(key, KeyEffect.Update);\n    return this;\n  }\n\n  setItem(index: number, newItem: AnyItem): this {\n    const oldItem = this._state.getItem(index);\n    newItem = Item.fromAny(newItem);\n    this._state.setItem(index, newItem);\n    if (oldItem instanceof Field && newItem instanceof Field) {\n      if (oldItem.key.equals(newItem.key)) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Update);\n      } else {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n    } else if (oldItem instanceof Field) {\n      this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n    } else if (newItem instanceof Field) {\n      this.invalidateInputKey(newItem.key, KeyEffect.Update);\n    } else {\n      this.invalidateInput();\n    }\n    return this;\n  }\n\n  push(...newItems: AnyItem[]): number {\n    let i = this._state.length;\n    const n = this._state.push.apply(this._state, arguments);\n    while (i < n) {\n      const newItem = this._state.get(i);\n      if (newItem instanceof Field) {\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n      i += 1;\n    }\n    return n;\n  }\n\n  splice(start: number, deleteCount: number = 0, ...newItems: AnyItem[]): Item[] {\n    const n = this._state.length;\n    if (start < 0) {\n      start = n + start;\n    }\n    start = Math.max(0, start);\n    deleteCount = Math.max(0, deleteCount);\n    const deleted = this._state.splice.apply(this._state, arguments);\n    for (let i = 0; i < deleted.length; i += 1) {\n      const oldItem = deleted[i];\n      if (oldItem instanceof Field) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n      }\n    }\n    for (let i = start; i < start + newItems.length; i += 1) {\n      const newItem = this._state.get(i);\n      if (newItem instanceof Field) {\n        this.invalidateInputKey(newItem.key, KeyEffect.Update);\n      }\n    }\n    return deleted;\n  }\n\n  delete(key: AnyValue): Item {\n    const oldItem = this._state.delete(key);\n    if (oldItem instanceof Field) {\n      this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n    }\n    return oldItem;\n  }\n\n  clear(): void {\n    const oldState = this._state.branch();\n    this._state.clear();\n    oldState.forEach(function (oldItem: Item): void {\n      if (oldItem instanceof Field) {\n        this.invalidateInputKey(oldItem.key, KeyEffect.Remove);\n      }\n    }, this);\n  }\n\n  forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void,\n                          thisArg?: S): T | undefined {\n    return this._state.forEach(callback, thisArg);\n  }\n\n  keyIterator(): Cursor<Value> {\n    throw new Error(); // TODO\n  }\n\n  disconnectInputs(): void {\n    const fieldUpdaters = this._fieldUpdaters;\n    if (!fieldUpdaters.isEmpty()) {\n      this._fieldUpdaters = new BTree();\n      fieldUpdaters.forEach(function (key: Value, inlet: RecordFieldUpdater): void {\n        inlet.disconnectInputs();\n      }, this);\n    }\n  }\n\n  memoize(): MapOutlet<Value, Value, Record> {\n    return this;\n  }\n\n  materialize(record: Record): void {\n    record.forEach(function (item: Item): void {\n      this.materializeItem(item);\n    }, this);\n  }\n\n  materializeItem(item: Item): void {\n    if (item instanceof Field) {\n      this.materializeField(item);\n    } else {\n      this.materializeValue(item);\n    }\n  }\n\n  materializeField(field: Field): void {\n    const value = field.value;\n    if (value instanceof RecordStreamlet) {\n      value.setStreamletScope(this);\n      this._state.push(field);\n    } else if (value instanceof Record) {\n      // Add recursively materialized nested scope.\n      const child = new RecordOutlet.Scope(this);\n      child.materialize(value);\n      this._state.push(field.updatedValue(child));\n    } else {\n      this._state.push(field);\n    }\n  }\n\n  materializeValue(value: Value): void {\n    if (value instanceof RecordStreamlet) {\n      value.setStreamletScope(this);\n      this._state.push(value);\n    } else if (value instanceof Record) {\n      // Add recursively materialized nested scope.\n      const child = new RecordOutlet.Scope(this);\n      child.materialize(value);\n      this._state.push(child);\n    } else {\n      this._state.push(value);\n    }\n  }\n\n  compile(record: Record): void {\n    record.forEach(function (item: Item, index: number): void {\n      this.compileItem(item, index);\n    }, this);\n  }\n\n  compileItem(item: Item, index: number): void {\n    if (item instanceof Field) {\n      this.compileField(item, index);\n    } else {\n      this.compileValue(item, index);\n    }\n  }\n\n  compileField(field: Field, index: number): void {\n    const key = field.key;\n    const value = field.value;\n    if (!key.isConstant()) {\n      // TODO: Add dynamic key updater.\n    } else if (!value.isConstant()) {\n      if (value instanceof RecordStreamlet) {\n        // Lexically bind nested streamlet.\n        value.compile();\n        // Invalidate nested scope key.\n        this.invalidateInputKey(key, KeyEffect.Update);\n      } else if (value instanceof Record) {\n        // Recursively compile nested scope.\n        (this._state.getItem(index).toValue() as RecordModel).compile(value);\n        // Invalidate nested scope key.\n        this.invalidateInputKey(key, KeyEffect.Update);\n      } else {\n        // Set placeholder value.\n        field.setValue(Value.extant());\n        // Bind dynamic value updater.\n        this.bindValue(key, value);\n      }\n    } else {\n      // Invalidate constant key.\n      this.invalidateInputKey(key, KeyEffect.Update);\n    }\n  }\n\n  compileValue(value: Value, index: number): void {\n    if (value instanceof RecordStreamlet) {\n      value.compile();\n    } else if (value instanceof Record) {\n      // Recursively compile nested scope.\n      (this._state.getItem(index) as RecordModel).compile(value);\n    } else if (!value.isConstant()) {\n      // TODO: Bind dynamic item updater.\n    } else {\n      // TODO: Fold constant expressions.\n    }\n  }\n\n  transmute(transmuter: Transmuter | null = Transmuter.system()): void {\n    this.forEach(function (oldItem: Item, index: number): void {\n      const newItem = this.transmuteItem(oldItem, transmuter);\n      if (oldItem !== newItem) {\n        this.setItem(index, newItem);\n      }\n    }, this);\n  }\n\n  transmuteItem(item: Item, transmuter: Transmuter | null): Item {\n    if (item instanceof Field) {\n      return this.transmuteField(item, transmuter);\n    } else {\n      return this.transmuteValue(item, transmuter);\n    }\n  }\n\n  transmuteField(field: Field, transmuter: Transmuter | null): Field {\n    const oldValue = field.value;\n    const newValue = this.transmuteValue(oldValue, transmuter);\n    if (oldValue !== newValue) {\n      return field.updatedValue(newValue);\n    } else {\n      return field;\n    }\n  }\n\n  transmuteValue(oldValue: Value, transmuter: Transmuter | null): Value {\n    if (oldValue instanceof RecordModel) {\n      let newValue = this.transmuteModel(oldValue);\n      if (oldValue === newValue && transmuter) {\n        newValue = transmuter.transmute(oldValue);\n      }\n      return newValue;\n    } else {\n      return oldValue;\n    }\n  }\n\n  transmuteModel(model: RecordModel): Record {\n    const scope = this.streamletScope();\n    if (scope instanceof RecordModel) {\n      return scope.transmuteModel(model);\n    } else {\n      return model;\n    }\n  }\n\n  static from(record: Record): RecordModel {\n    const model = new RecordModel();\n    model.materialize(record);\n    model.compile(record);\n    return model;\n  }\n\n  static of(...items: AnyItem[]): RecordModel {\n    return RecordModel.from(Record.of.apply(void 0, arguments));\n  }\n\n  static globalScope(): RecordModel {\n    const model = new RecordModel();\n    model.materializeField(Slot.of(\"math\", MathModule.scope().branch()));\n    return model;\n  }\n}\nRecordOutlet.Model = RecordModel;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {AnyItem, Value, Record} from \"@swim/structure\";\nimport {StreamletScope} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {RecordModel} from \"./RecordModel\";\n\nexport class RecordScope extends RecordModel {\n  /** @hidden */\n  protected scope: StreamletScope<Value> | null;\n\n  constructor(scope: StreamletScope<Value> | null, state?: Record) {\n    super(state);\n    this.scope = scope;\n  }\n\n  streamletScope(): StreamletScope<Value> | null {\n    return this.scope;\n  }\n\n  static from(record: Record): RecordScope {\n    const scope = new RecordScope(RecordScope.globalScope());\n    scope.materialize(record);\n    scope.compile(record);\n    return scope;\n  }\n\n  static of(...items: AnyItem[]): RecordScope {\n    return RecordScope.from(Record.of.apply(void 0, arguments));\n  }\n}\nRecordOutlet.Scope = RecordScope;\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, MapInlet, AbstractOutlet, OutletInlet, OutletMapInlet} from \"@swim/streamlet\";\n\n/** @hidden */\nexport class GetOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _keyInlet: OutletInlet<Value>;\n  /** @hidden */\n  readonly _mapInlet: OutletMapInlet<Value, Value, unknown>;\n\n  constructor() {\n    super();\n    this._keyInlet = new OutletInlet<Value>(this);\n    this._mapInlet = new OutletMapInlet<Value, Value, unknown>(this);\n  }\n\n  keyInlet(): Inlet<Value> {\n    return this._keyInlet;\n  }\n\n  mapInlet(): MapInlet<Value, Value, unknown> {\n    return this._mapInlet;\n  }\n\n  get(): Value {\n    const keyInput = this._keyInlet.input();\n    if (keyInput !== null) {\n      const key = keyInput.get();\n      if (key !== void 0) {\n        const mapInput = this._mapInlet.input();\n        if (mapInput !== null) {\n          const value = mapInput.get(key);\n          if (value !== void 0) {\n            return value;\n          }\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport abstract class BinaryOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const operand2Input = this._operand2Inlet.input();\n    if (operand1Input !== null && operand2Input !== null) {\n      const argument1 = operand1Input.get();\n      const argument2 = operand2Input.get();\n      if (argument1 !== void 0 && argument2 !== void 0) {\n        const result = this.evaluate(argument1, argument2);\n        return result.toValue();\n      }\n    }\n    return Value.absent();\n  }\n\n  protected abstract evaluate(argument1: Value, argument2: Value): Item;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport abstract class UnaryOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operandInlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operandInlet = new OutletInlet<Value>(this);\n  }\n\n  operandInlet(): Inlet<Value> {\n    return this._operandInlet;\n  }\n\n  get(): Value {\n    const operandInput = this._operandInlet.input();\n    if (operandInput !== null) {\n      const argument = operandInput.get();\n      if (argument !== void 0) {\n        const result = this.evaluate(argument);\n        return result.toValue();\n      }\n    }\n    return Value.absent();\n  }\n\n  protected abstract evaluate(argument: Value): Item;\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class ConditionalOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _ifInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _thenInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _elseInlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._ifInlet = new OutletInlet<Value>(this);\n    this._thenInlet = new OutletInlet<Value>(this);\n    this._elseInlet = new OutletInlet<Value>(this);\n  }\n\n  ifInlet(): Inlet<Value> {\n    return this._ifInlet;\n  }\n\n  thenInlet(): Inlet<Value> {\n    return this._thenInlet;\n  }\n\n  elseInlet(): Inlet<Value> {\n    return this._elseInlet;\n  }\n\n  get(): Value {\n    const ifInput = this._ifInlet.input();\n    if (ifInput !== null) {\n      const ifTerm = ifInput.get();\n      if (ifTerm !== void 0) {\n        if (ifTerm.booleanValue(false)) {\n          const thenInput = this._thenInlet.input();\n          if (thenInput !== null) {\n            const thenTerm = thenInput.get();\n            if (thenTerm !== void 0) {\n              return thenTerm;\n            }\n          }\n        } else {\n          const elseInput = this._elseInlet.input();\n          if (elseInput !== null) {\n            const elseTerm = elseInput.get();\n            if (elseTerm !== void 0) {\n              return elseTerm;\n            }\n          }\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class OrOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const argument1 = operand1Input !== null ? operand1Input.get() : void 0;\n    if (argument1 !== void 0 && argument1.booleanValue(false)) {\n      return argument1;\n    }\n    const operand2Input = this._operand2Inlet.input();\n    const argument2 = operand2Input !== null ? operand2Input.get() : void 0;\n    if (argument2 !== void 0) {\n      return argument2;\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class AndOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _operand1Inlet: Inlet<Value>;\n  /** @hidden */\n  readonly _operand2Inlet: Inlet<Value>;\n\n  constructor() {\n    super();\n    this._operand1Inlet = new OutletInlet<Value>(this);\n    this._operand2Inlet = new OutletInlet<Value>(this);\n  }\n\n  operand1Inlet(): Inlet<Value> {\n    return this._operand1Inlet;\n  }\n\n  operand2Inlet(): Inlet<Value> {\n    return this._operand2Inlet;\n  }\n\n  get(): Value {\n    const operand1Input = this._operand1Inlet.input();\n    const argument1 = operand1Input !== null ? operand1Input.get() : void 0;\n    if (argument1 !== void 0) {\n      if (argument1.booleanValue(false)) {\n        const operand2Input = this._operand2Inlet.input();\n        const argument2 = operand2Input !== null ? operand2Input.get() : void 0;\n        if (argument2 !== void 0) {\n          return argument2;\n        }\n      }\n      return argument1;\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseOrOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseOr(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseXorOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseXor(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class BitwiseAndOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.bitwiseAnd(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class LtOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.lt(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class LeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.le(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class EqOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.eq(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class NeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.ne(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class GeOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.ge(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class GtOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.gt(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class PlusOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.plus(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class MinusOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.minus(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class TimesOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.times(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class DivideOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.divide(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {BinaryOutlet} from \"./BinaryOutlet\";\n\nexport class ModuloOutlet extends BinaryOutlet {\n  protected evaluate(argument1: Value, argument2: Value): Item {\n    return argument1.modulo(argument2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class NotOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.not();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class BitwiseNotOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.bitwiseNot();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class NegativeOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.negative();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Item, Value} from \"@swim/structure\";\nimport {UnaryOutlet} from \"./UnaryOutlet\";\n\nexport class PositiveOutlet extends UnaryOutlet {\n  protected evaluate(argument: Value): Item {\n    return argument.positive();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Value, Record, Func, Interpreter} from \"@swim/structure\";\nimport {Inlet, AbstractOutlet, OutletInlet} from \"@swim/streamlet\";\n\nexport class InvokeOutlet extends AbstractOutlet<Value> {\n  /** @hidden */\n  readonly _scope: Record;\n  /** @hidden */\n  readonly _funcInlet: Inlet<Value>;\n  /** @hidden */\n  readonly _argsInlet: Inlet<Value>;\n\n  constructor(scope: Record) {\n    super();\n    this._scope = scope;\n    this._funcInlet = new OutletInlet<Value>(this);\n    this._argsInlet = new OutletInlet<Value>(this);\n  }\n\n  funcInlet(): Inlet<Value> {\n    return this._funcInlet;\n  }\n\n  argsInlet(): Inlet<Value> {\n    return this._argsInlet;\n  }\n\n  get(): Value {\n    const funcInput = this._funcInlet.input();\n    const argsInput = this._argsInlet.input();\n    if (funcInput !== null && argsInput !== null) {\n      const func = funcInput.get();\n      if (func instanceof Func) {\n        const args = argsInput.get();\n        if (args !== void 0) {\n          const interpreter = new Interpreter();\n          interpreter.pushScope(this._scope);\n          const result = func.invoke(args, interpreter, void 0 /* TODO: generalize InvokeOperator to InvokeContext */);\n          return result.toValue();\n        }\n      }\n    }\n    return Value.absent();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {\n  Value,\n  Record,\n  Selector,\n  IdentitySelector,\n  GetSelector,\n  GetAttrSelector,\n  GetItemSelector,\n  KeysSelector,\n  ValuesSelector,\n  ChildrenSelector,\n  DescendantsSelector,\n  FilterSelector,\n  Operator,\n  BinaryOperator,\n  UnaryOperator,\n  ConditionalOperator,\n  OrOperator,\n  AndOperator,\n  BitwiseOrOperator,\n  BitwiseXorOperator,\n  BitwiseAndOperator,\n  LtOperator,\n  LeOperator,\n  EqOperator,\n  NeOperator,\n  GeOperator,\n  GtOperator,\n  PlusOperator,\n  MinusOperator,\n  TimesOperator,\n  DivideOperator,\n  ModuloOperator,\n  NotOperator,\n  BitwiseNotOperator,\n  NegativeOperator,\n  PositiveOperator,\n  InvokeOperator,\n} from \"@swim/structure\";\nimport {Outlet, KeyOutlet, StreamletScope, ValueInput} from \"@swim/streamlet\";\nimport {RecordOutlet} from \"./RecordOutlet\";\nimport {GetOutlet} from \"./selector/GetOutlet\";\nimport {BinaryOutlet} from \"./operator/BinaryOutlet\";\nimport {UnaryOutlet} from \"./operator/UnaryOutlet\";\nimport {ConditionalOutlet} from \"./operator/ConditionalOutlet\";\nimport {OrOutlet} from \"./operator/OrOutlet\";\nimport {AndOutlet} from \"./operator/AndOutlet\";\nimport {BitwiseOrOutlet} from \"./operator/BitwiseOrOutlet\";\nimport {BitwiseXorOutlet} from \"./operator/BitwiseXorOutlet\";\nimport {BitwiseAndOutlet} from \"./operator/BitwiseAndOutlet\";\nimport {LtOutlet} from \"./operator/LtOutlet\";\nimport {LeOutlet} from \"./operator/LeOutlet\";\nimport {EqOutlet} from \"./operator/EqOutlet\";\nimport {NeOutlet} from \"./operator/NeOutlet\";\nimport {GeOutlet} from \"./operator/GeOutlet\";\nimport {GtOutlet} from \"./operator/GtOutlet\";\nimport {PlusOutlet} from \"./operator/PlusOutlet\";\nimport {MinusOutlet} from \"./operator/MinusOutlet\";\nimport {TimesOutlet} from \"./operator/TimesOutlet\";\nimport {DivideOutlet} from \"./operator/DivideOutlet\";\nimport {ModuloOutlet} from \"./operator/ModuloOutlet\";\nimport {NotOutlet} from \"./operator/NotOutlet\";\nimport {BitwiseNotOutlet} from \"./operator/BitwiseNotOutlet\";\nimport {NegativeOutlet} from \"./operator/NegativeOutlet\";\nimport {PositiveOutlet} from \"./operator/PositiveOutlet\";\nimport {InvokeOutlet} from \"./operator/InvokeOutlet\";\n\nexport class Dataflow {\n  /** @hidden */\n  private constructor() {\n    // nop\n  }\n\n  /**\n   * Returns an `Outlet` that evaluates the given `expr` in the context of the\n   * given `scope`, and updates whenever any dependent expression updates.\n   */\n  static compile(expr: Value, scope: Outlet<Value>): Outlet<Value> {\n    if (scope instanceof KeyOutlet) {\n      const value = scope.get();\n      if (Outlet.is<Value>(value)) {\n        scope = value;\n      }\n    }\n    if (expr.isConstant()) {\n      return new ValueInput<Value>(expr);\n    } else if (expr instanceof Selector) {\n      return Dataflow.compileSelector(expr, scope);\n    } else if (expr instanceof Operator) {\n      return Dataflow.compileOperator(expr, scope);\n    }\n    throw new TypeError(\"\" + expr);\n  }\n\n  private static compileSelector(selector: Selector, scope: Outlet<Value>): Outlet<Value> {\n    if (selector instanceof IdentitySelector) {\n      return Dataflow.compileIdentitySelector(scope);\n    } else if (selector instanceof GetSelector) {\n      return Dataflow.compileGetSelector(selector, scope);\n    } else if (selector instanceof GetAttrSelector) {\n      return Dataflow.compileGetAttrSelector(selector, scope);\n    } else if (selector instanceof GetItemSelector) {\n      return Dataflow.compileGetItemSelector(selector, scope);\n    } else if (selector instanceof KeysSelector) {\n      return Dataflow.compileKeysSelector(scope);\n    } else if (selector instanceof ValuesSelector) {\n      return Dataflow.compileValuesSelector(scope);\n    } else if (selector instanceof ChildrenSelector) {\n      return Dataflow.compileChildrenSelector(scope);\n    } else if (selector instanceof DescendantsSelector) {\n      return Dataflow.compileDescendantsSelector(scope);\n    } else if (selector instanceof FilterSelector) {\n      return Dataflow.compileFilterSelector(selector, scope);\n    }\n    throw new TypeError(\"\" + selector);\n  }\n\n  private static compileIdentitySelector(scope: Outlet<Value>): Outlet<Value> {\n    return scope;\n  }\n\n  private static compileGetSelector(selector: GetSelector, scope: Outlet<Value>): Outlet<Value> {\n    const key = selector.accessor();\n    if (key.isConstant()) {\n      if (RecordOutlet.is(scope)) {\n        const outlet = scope.outlet(key);\n        if (outlet !== null) {\n          return Dataflow.compile(selector.then(), outlet);\n        }\n      } else if (StreamletScope.is<Value>(scope)) {\n        const name = key.stringValue(void 0);\n        if (name !== void 0) {\n          const outlet = scope.outlet(name);\n          if (outlet !== null) {\n            return Dataflow.compile(selector.then(), outlet);\n          }\n        }\n      }\n    } else {\n      const getOutlet = new GetOutlet();\n      const outlet = Dataflow.compile(key, scope);\n      getOutlet.keyInlet().bindInput(outlet);\n      getOutlet.mapInlet().bindInput(scope);\n      return getOutlet;\n    }\n    return null as unknown as Outlet<Value>;\n  }\n\n  private static compileGetAttrSelector(selector: GetAttrSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileGetItemSelector(selector: GetItemSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileKeysSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileValuesSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileChildrenSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileDescendantsSelector(scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileFilterSelector(selector: FilterSelector, scope: Outlet<Value>): Outlet<Value> {\n    throw new Error(); // TODO\n  }\n\n  private static compileOperator(operator: Operator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof ConditionalOperator) {\n      return Dataflow.compileConditionalOperator(operator, scope);\n    } else if (operator instanceof BinaryOperator) {\n      return Dataflow.compileBinaryOperator(operator, scope);\n    } else if (operator instanceof UnaryOperator) {\n      return Dataflow.compileUnaryOperator(operator, scope);\n    } else if (operator instanceof InvokeOperator) {\n      return Dataflow.compileInvokeOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileConditionalOperator(operator: ConditionalOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new ConditionalOutlet();\n    const ifTerm = operator.ifTerm().toValue();\n    const thenTerm = operator.thenTerm().toValue();\n    const elseTerm = operator.elseTerm().toValue();\n    const ifOutlet = Dataflow.compile(ifTerm, scope);\n    const thenOutlet = Dataflow.compile(thenTerm, scope);\n    const elseOutlet = Dataflow.compile(elseTerm, scope);\n    outlet.ifInlet().bindInput(ifOutlet);\n    outlet.thenInlet().bindInput(thenOutlet);\n    outlet.elseInlet().bindInput(elseOutlet);\n    return outlet;\n  }\n\n  private static compileBinaryOperator(operator: BinaryOperator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof OrOperator) {\n      return Dataflow.compileOrOperator(operator, scope);\n    } else if (operator instanceof AndOperator) {\n      return Dataflow.compileAndOperator(operator, scope);\n    } else if (operator instanceof BitwiseOrOperator) {\n      return Dataflow.compileBitwiseOrOperator(operator, scope);\n    } else if (operator instanceof BitwiseXorOperator) {\n      return Dataflow.compileBitwiseXorOperator(operator, scope);\n    } else if (operator instanceof BitwiseAndOperator) {\n      return Dataflow.compileBitwiseAndOperator(operator, scope);\n    } else if (operator instanceof LtOperator) {\n      return Dataflow.compileLtOperator(operator, scope);\n    } else if (operator instanceof LeOperator) {\n      return Dataflow.compileLeOperator(operator, scope);\n    } else if (operator instanceof EqOperator) {\n      return Dataflow.compileEqOperator(operator, scope);\n    } else if (operator instanceof NeOperator) {\n      return Dataflow.compileNeOperator(operator, scope);\n    } else if (operator instanceof GeOperator) {\n      return Dataflow.compileGeOperator(operator, scope);\n    } else if (operator instanceof GtOperator) {\n      return Dataflow.compileGtOperator(operator, scope);\n    } else if (operator instanceof PlusOperator) {\n      return Dataflow.compilePlusOperator(operator, scope);\n    } else if (operator instanceof MinusOperator) {\n      return Dataflow.compileMinusOperator(operator, scope);\n    } else if (operator instanceof TimesOperator) {\n      return Dataflow.compileTimesOperator(operator, scope);\n    } else if (operator instanceof DivideOperator) {\n      return Dataflow.compileDivideOperator(operator, scope);\n    } else if (operator instanceof ModuloOperator) {\n      return Dataflow.compileModuloOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileBinaryOutlet(operator: BinaryOperator, outlet: BinaryOutlet, scope: Outlet<Value>): Outlet<Value> {\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileOrOperator(operator: OrOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new OrOutlet();\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileAndOperator(operator: AndOperator, scope: Outlet<Value>): Outlet<Value> {\n    const outlet = new AndOutlet();\n    const operand1 = operator.operand1().toValue();\n    const operand2 = operator.operand2().toValue();\n    const operand1Outlet = Dataflow.compile(operand1, scope);\n    const operand2Outlet = Dataflow.compile(operand2, scope);\n    outlet.operand1Inlet().bindInput(operand1Outlet);\n    outlet.operand2Inlet().bindInput(operand2Outlet);\n    return outlet;\n  }\n\n  private static compileBitwiseOrOperator(operator: BitwiseOrOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseOrOutlet(), scope);\n  }\n\n  private static compileBitwiseXorOperator(operator: BitwiseXorOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseXorOutlet(), scope);\n  }\n\n  private static compileBitwiseAndOperator(operator: BitwiseAndOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new BitwiseAndOutlet(), scope);\n  }\n\n  private static compileLtOperator(operator: LtOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new LtOutlet(), scope);\n  }\n\n  private static compileLeOperator(operator: LeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new LeOutlet(), scope);\n  }\n\n  private static compileEqOperator(operator: EqOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new EqOutlet(), scope);\n  }\n\n  private static compileNeOperator(operator: NeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new NeOutlet(), scope);\n  }\n\n  private static compileGeOperator(operator: GeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new GeOutlet(), scope);\n  }\n\n  private static compileGtOperator(operator: GtOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new GtOutlet(), scope);\n  }\n\n  private static compilePlusOperator(operator: PlusOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new PlusOutlet(), scope);\n  }\n\n  private static compileMinusOperator(operator: MinusOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new MinusOutlet(), scope);\n  }\n\n  private static compileTimesOperator(operator: TimesOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new TimesOutlet(), scope);\n  }\n\n  private static compileDivideOperator(operator: DivideOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new DivideOutlet(), scope);\n  }\n\n  private static compileModuloOperator(operator: ModuloOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileBinaryOutlet(operator, new ModuloOutlet(), scope);\n  }\n\n  private static compileUnaryOperator(operator: UnaryOperator, scope: Outlet<Value>): Outlet<Value> {\n    if (operator instanceof NotOperator) {\n      return Dataflow.compileNotOperator(operator, scope);\n    } else if (operator instanceof BitwiseNotOperator) {\n      return Dataflow.compileBitwiseNotOperator(operator, scope);\n    } else if (operator instanceof NegativeOperator) {\n      return Dataflow.compileNegativeOperator(operator, scope);\n    } else if (operator instanceof PositiveOperator) {\n      return Dataflow.compilePositiveOperator(operator, scope);\n    }\n    throw new TypeError(\"\" + operator);\n  }\n\n  private static compileUnaryOutlet(operator: UnaryOperator, outlet: UnaryOutlet, scope: Outlet<Value>): Outlet<Value> {\n    const operand = operator.operand().toValue();\n    const operandOutlet = Dataflow.compile(operand, scope);\n    outlet.operandInlet().bindInput(operandOutlet);\n    return outlet;\n  }\n\n  private static compileNotOperator(operator: NotOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new NotOutlet(), scope);\n  }\n\n  private static compileBitwiseNotOperator(operator: BitwiseNotOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new BitwiseNotOutlet(), scope);\n  }\n\n  private static compileNegativeOperator(operator: NegativeOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new NegativeOutlet(), scope);\n  }\n\n  private static compilePositiveOperator(operator: PositiveOperator, scope: Outlet<Value>): Outlet<Value> {\n    return Dataflow.compileUnaryOutlet(operator, new PositiveOutlet(), scope);\n  }\n\n  private static compileInvokeOperator(operator: InvokeOperator, scope: Outlet<Value>): Outlet<Value> {\n    const func = operator.func();\n    const args = operator.args();\n    const invokeOutlet = new InvokeOutlet(scope as unknown as Record);\n    const funcOutlet = Dataflow.compile(func, scope);\n    const argsOutlet = Dataflow.compile(args, scope);\n    invokeOutlet.funcInlet().bindInput(funcOutlet);\n    invokeOutlet.argsInlet().bindInput(argsOutlet);\n    return invokeOutlet;\n  }\n}\nRecordOutlet.Dataflow = Dataflow;\n"],"names":["MapOutlet","StreamletScope","BTree","Text","KeyOutlet","Cursor","Field","MapInlet","MemoizeMapCombinator","FilterFieldsCombinator","MapValueCombinator","MapFieldValuesCombinator","ReduceFieldsCombinator","WatchValueCombinator","WatchFieldsCombinator","Record","AbstractStreamlet","Value","Slot","Num","Item","StreamletInlet","StreamletOutlet","StreamletInoutlet","AbstractInlet","MathModule","OutletInlet","OutletMapInlet","AbstractOutlet","Func","Interpreter","Outlet","ValueInput","Selector","Operator","IdentitySelector","GetSelector","GetAttrSelector","GetItemSelector","KeysSelector","ValuesSelector","ChildrenSelector","DescendantsSelector","FilterSelector","ConditionalOperator","BinaryOperator","UnaryOperator","InvokeOperator","OrOperator","AndOperator","BitwiseOrOperator","BitwiseXorOperator","BitwiseAndOperator","LtOperator","LeOperator","EqOperator","NeOperator","GeOperator","GtOperator","PlusOperator","MinusOperator","TimesOperator","DivideOperator","ModuloOperator","NotOperator","BitwiseNotOperator","NegativeOperator","PositiveOperator"],"mappings":"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"}