import { Cursor, Map } from "@swim/util";
import { BTree } from "@swim/collections";
import { AnyItem, AnyValue, Value, Record, Selector } from "@swim/structure";
import { Inlet, Outlet, KeyEffect, MapOutlet, KeyOutlet, StreamletContext, StreamletScope } from "@swim/streamlet";
import { FilterFieldsFunction } from "@swim/streamlet";
import { MapValueFunction } from "@swim/streamlet";
import { MapFieldValuesFunction } from "@swim/streamlet";
import { WatchValueFunction } from "@swim/streamlet";
import { WatchFieldsFunction } from "@swim/streamlet";
import { RecordOutlet } from "./RecordOutlet";
export declare abstract class AbstractRecordOutlet extends Record implements RecordOutlet {
    protected _effects: BTree<Value, KeyEffect>;
    protected _outlets: BTree<Value, KeyOutlet<Value, Value>>;
    protected _outputs: ReadonlyArray<Inlet<Record>> | null;
    protected _version: number;
    constructor();
    streamletScope(): StreamletScope<Value> | null;
    streamletContext(): StreamletContext | null;
    hasOwn(key: AnyValue): boolean;
    get(): Record;
    get(key: AnyValue): Value;
    abstract keyIterator(): Cursor<Value>;
    outlet(key: Value | string): Outlet<Value>;
    outputIterator(): Cursor<Inlet<Record>>;
    bindOutput(output: Inlet<Record>): void;
    unbindOutput(output: Inlet<Record>): void;
    unbindOutputs(): void;
    disconnectOutputs(): void;
    disconnectInputs(): void;
    invalidateInputKey(key: Value, effect: KeyEffect): void;
    invalidateInput(): void;
    reconcileInputKey(key: Value, version: number): void;
    reconcileInput(version: number): void;
    protected willInvalidateInputKey(key: Value, effect: KeyEffect): void;
    protected onInvalidateInputKey(key: Value, effect: KeyEffect): void;
    protected didInvalidateInputKey(key: Value, effect: KeyEffect): void;
    protected willInvalidateInput(): void;
    protected onInvalidateInput(): void;
    protected didInvalidateInput(): void;
    protected willReconcileInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected onReconcileInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected didReconcileInputKey(key: Value, effect: KeyEffect, version: number): void;
    protected willReconcileInput(version: number): void;
    protected onReconcileInput(version: number): void;
    protected didReconcileInput(version: number): void;
    memoize(): MapOutlet<Value, Value, Record>;
    filter(predicate?: AnyItem): Selector;
    filter(func: FilterFieldsFunction<Value, Value>): MapOutlet<Value, Value, Map<Value, Value>>;
    map<O2>(func: MapValueFunction<Record, O2>): Outlet<O2>;
    map<V2>(func: MapFieldValuesFunction<Value, Value, V2>): MapOutlet<Value, V2, Map<Value, V2>>;
    reduce<U>(identity: U, accumulator: (result: U, element: Value) => U, combiner: (result: U, result2: U) => U): Outlet<U>;
    watch(func: WatchValueFunction<Record>): this;
    watch(func: WatchFieldsFunction<Value, Value>): this;
}
//# sourceMappingURL=AbstractRecordOutlet.d.ts.map