import { AnyItem, Item, Field, AnyValue, Value, AnyText, AnyNum, Form } from "@swim/structure";
import { Inlet, Outlet, Inoutlet, StreamletContext, GenericStreamlet, StreamletScope } from "@swim/streamlet";
import { RecordStreamlet } from "./RecordStreamlet";
export declare abstract class AbstractRecordStreamlet<I extends Value = Value, O extends Value = I> extends RecordStreamlet<I, O> implements GenericStreamlet<I, O> {
    protected scope: StreamletScope<O> | null;
    protected context: StreamletContext | null;
    protected _version: number;
    constructor(scope?: StreamletScope<O> | null);
    streamletScope(): StreamletScope<O> | null;
    setStreamletScope(scope: StreamletScope<O> | null): void;
    streamletContext(): StreamletContext | null;
    setStreamletContext(context: StreamletContext | null): void;
    isEmpty(): boolean;
    get length(): number;
    has(key: AnyValue): boolean;
    get(key: AnyValue): Value;
    getAttr(key: AnyText): Value;
    getSlot(key: AnyValue): Value;
    getField(key: AnyValue): Field | undefined;
    getItem(index: AnyNum): Item;
    set(key: AnyValue, newValue: AnyValue): this;
    setAttr(key: AnyText, newValue: AnyValue): this;
    setSlot(key: AnyValue, newValue: AnyValue): this;
    setItem(index: number, item: AnyItem): this;
    push(...items: AnyItem[]): number;
    splice(start: number, deleteCount?: number, ...newItems: AnyItem[]): Item[];
    delete(key: AnyValue): Item;
    clear(): void;
    forEach<T, S = unknown>(callback: (this: S, item: Item, index: number) => T | void, thisArg?: S): T | undefined;
    inlet(key: string): Inlet<I> | null;
    inlet<I2 extends I>(): Inlet<I2>;
    bindInput(key: string, input: Outlet<I>): void;
    unbindInput(key: string): void;
    outlet(key: string | Outlet<O>): Outlet<O> | null;
    outlet<O2 extends Value>(): Outlet<O2>;
    inoutlet<I2 extends I, O2 extends Value>(): Inoutlet<I2, O2>;
    invalidate(): void;
    reconcile(version: number): void;
    getInput<I2 extends I>(inlet: Inlet<I2> | string): I2 | undefined;
    getInput<I2 extends I, E = I2>(inlet: Inlet<I2> | string, orElse: E): I2 | E;
    castInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T | undefined;
    castInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;
    coerceInput<T>(inlet: Inlet<I> | string, form: Form<T, unknown>): T;
    coerceInput<T, E = T>(inlet: Inlet<I> | string, form: Form<T, unknown>, orElse: E): T | E;
    getOutput(outlet: Outlet<O> | string): O | undefined;
    disconnectInputs(): void;
    disconnectOutputs(): void;
    willInvalidateInlet(inlet: Inlet<I>): void;
    didInvalidateInlet(inlet: Inlet<I>): void;
    willReconcileInlet(inlet: Inlet<I>, version: number): void;
    didReconcileInlet(inlet: Inlet<I>, version: number): void;
    willInvalidateOutlet(outlet: Outlet<O>): void;
    didInvalidateOutlet(outlet: Outlet<O>): void;
    willReconcileOutlet(outlet: Outlet<O>, version: number): void;
    didReconcileOutlet(outlet: Outlet<O>, version: number): void;
    protected willInvalidate(): void;
    protected onInvalidate(): void;
    protected didInvalidate(): void;
    protected onInvalidateOutlets(): void;
    protected willReconcile(version: number): void;
    protected onReconcileInlets(version: number): void;
    protected onReconcile(version: number): void;
    protected onReconcileOutlets(version: number): void;
    protected didReconcile(version: number): void;
}
//# sourceMappingURL=AbstractRecordStreamlet.d.ts.map