import { Selector, IdentitySelector, GetSelector, GetAttrSelector, GetItemSelector, KeysSelector, ValuesSelector, ChildrenSelector, DescendantsSelector, FilterSelector, Operator, BinaryOperator, UnaryOperator, ConditionalOperator, OrOperator, AndOperator, BitwiseOrOperator, BitwiseXorOperator, BitwiseAndOperator, LtOperator, LeOperator, EqOperator, NeOperator, GeOperator, GtOperator, PlusOperator, MinusOperator, TimesOperator, DivideOperator, ModuloOperator, NotOperator, BitwiseNotOperator, NegativeOperator, PositiveOperator, InvokeOperator, } from "@swim/structure";
import { Outlet, KeyOutlet, StreamletScope, ValueInput } from "@swim/streamlet";
import { RecordOutlet } from "./RecordOutlet";
import { GetOutlet } from "./selector/GetOutlet";
import { ConditionalOutlet } from "./operator/ConditionalOutlet";
import { OrOutlet } from "./operator/OrOutlet";
import { AndOutlet } from "./operator/AndOutlet";
import { BitwiseOrOutlet } from "./operator/BitwiseOrOutlet";
import { BitwiseXorOutlet } from "./operator/BitwiseXorOutlet";
import { BitwiseAndOutlet } from "./operator/BitwiseAndOutlet";
import { LtOutlet } from "./operator/LtOutlet";
import { LeOutlet } from "./operator/LeOutlet";
import { EqOutlet } from "./operator/EqOutlet";
import { NeOutlet } from "./operator/NeOutlet";
import { GeOutlet } from "./operator/GeOutlet";
import { GtOutlet } from "./operator/GtOutlet";
import { PlusOutlet } from "./operator/PlusOutlet";
import { MinusOutlet } from "./operator/MinusOutlet";
import { TimesOutlet } from "./operator/TimesOutlet";
import { DivideOutlet } from "./operator/DivideOutlet";
import { ModuloOutlet } from "./operator/ModuloOutlet";
import { NotOutlet } from "./operator/NotOutlet";
import { BitwiseNotOutlet } from "./operator/BitwiseNotOutlet";
import { NegativeOutlet } from "./operator/NegativeOutlet";
import { PositiveOutlet } from "./operator/PositiveOutlet";
import { InvokeOutlet } from "./operator/InvokeOutlet";
var Dataflow = (function () {
    function Dataflow() {
    }
    Dataflow.compile = function (expr, scope) {
        if (scope instanceof KeyOutlet) {
            var value = scope.get();
            if (Outlet.is(value)) {
                scope = value;
            }
        }
        if (expr.isConstant()) {
            return new ValueInput(expr);
        }
        else if (expr instanceof Selector) {
            return Dataflow.compileSelector(expr, scope);
        }
        else if (expr instanceof Operator) {
            return Dataflow.compileOperator(expr, scope);
        }
        throw new TypeError("" + expr);
    };
    Dataflow.compileSelector = function (selector, scope) {
        if (selector instanceof IdentitySelector) {
            return Dataflow.compileIdentitySelector(scope);
        }
        else if (selector instanceof GetSelector) {
            return Dataflow.compileGetSelector(selector, scope);
        }
        else if (selector instanceof GetAttrSelector) {
            return Dataflow.compileGetAttrSelector(selector, scope);
        }
        else if (selector instanceof GetItemSelector) {
            return Dataflow.compileGetItemSelector(selector, scope);
        }
        else if (selector instanceof KeysSelector) {
            return Dataflow.compileKeysSelector(scope);
        }
        else if (selector instanceof ValuesSelector) {
            return Dataflow.compileValuesSelector(scope);
        }
        else if (selector instanceof ChildrenSelector) {
            return Dataflow.compileChildrenSelector(scope);
        }
        else if (selector instanceof DescendantsSelector) {
            return Dataflow.compileDescendantsSelector(scope);
        }
        else if (selector instanceof FilterSelector) {
            return Dataflow.compileFilterSelector(selector, scope);
        }
        throw new TypeError("" + selector);
    };
    Dataflow.compileIdentitySelector = function (scope) {
        return scope;
    };
    Dataflow.compileGetSelector = function (selector, scope) {
        var key = selector.accessor();
        if (key.isConstant()) {
            if (RecordOutlet.is(scope)) {
                var outlet = scope.outlet(key);
                if (outlet !== null) {
                    return Dataflow.compile(selector.then(), outlet);
                }
            }
            else if (StreamletScope.is(scope)) {
                var name_1 = key.stringValue(void 0);
                if (name_1 !== void 0) {
                    var outlet = scope.outlet(name_1);
                    if (outlet !== null) {
                        return Dataflow.compile(selector.then(), outlet);
                    }
                }
            }
        }
        else {
            var getOutlet = new GetOutlet();
            var outlet = Dataflow.compile(key, scope);
            getOutlet.keyInlet().bindInput(outlet);
            getOutlet.mapInlet().bindInput(scope);
            return getOutlet;
        }
        return null;
    };
    Dataflow.compileGetAttrSelector = function (selector, scope) {
        throw new Error();
    };
    Dataflow.compileGetItemSelector = function (selector, scope) {
        throw new Error();
    };
    Dataflow.compileKeysSelector = function (scope) {
        throw new Error();
    };
    Dataflow.compileValuesSelector = function (scope) {
        throw new Error();
    };
    Dataflow.compileChildrenSelector = function (scope) {
        throw new Error();
    };
    Dataflow.compileDescendantsSelector = function (scope) {
        throw new Error();
    };
    Dataflow.compileFilterSelector = function (selector, scope) {
        throw new Error();
    };
    Dataflow.compileOperator = function (operator, scope) {
        if (operator instanceof ConditionalOperator) {
            return Dataflow.compileConditionalOperator(operator, scope);
        }
        else if (operator instanceof BinaryOperator) {
            return Dataflow.compileBinaryOperator(operator, scope);
        }
        else if (operator instanceof UnaryOperator) {
            return Dataflow.compileUnaryOperator(operator, scope);
        }
        else if (operator instanceof InvokeOperator) {
            return Dataflow.compileInvokeOperator(operator, scope);
        }
        throw new TypeError("" + operator);
    };
    Dataflow.compileConditionalOperator = function (operator, scope) {
        var outlet = new ConditionalOutlet();
        var ifTerm = operator.ifTerm().toValue();
        var thenTerm = operator.thenTerm().toValue();
        var elseTerm = operator.elseTerm().toValue();
        var ifOutlet = Dataflow.compile(ifTerm, scope);
        var thenOutlet = Dataflow.compile(thenTerm, scope);
        var elseOutlet = Dataflow.compile(elseTerm, scope);
        outlet.ifInlet().bindInput(ifOutlet);
        outlet.thenInlet().bindInput(thenOutlet);
        outlet.elseInlet().bindInput(elseOutlet);
        return outlet;
    };
    Dataflow.compileBinaryOperator = function (operator, scope) {
        if (operator instanceof OrOperator) {
            return Dataflow.compileOrOperator(operator, scope);
        }
        else if (operator instanceof AndOperator) {
            return Dataflow.compileAndOperator(operator, scope);
        }
        else if (operator instanceof BitwiseOrOperator) {
            return Dataflow.compileBitwiseOrOperator(operator, scope);
        }
        else if (operator instanceof BitwiseXorOperator) {
            return Dataflow.compileBitwiseXorOperator(operator, scope);
        }
        else if (operator instanceof BitwiseAndOperator) {
            return Dataflow.compileBitwiseAndOperator(operator, scope);
        }
        else if (operator instanceof LtOperator) {
            return Dataflow.compileLtOperator(operator, scope);
        }
        else if (operator instanceof LeOperator) {
            return Dataflow.compileLeOperator(operator, scope);
        }
        else if (operator instanceof EqOperator) {
            return Dataflow.compileEqOperator(operator, scope);
        }
        else if (operator instanceof NeOperator) {
            return Dataflow.compileNeOperator(operator, scope);
        }
        else if (operator instanceof GeOperator) {
            return Dataflow.compileGeOperator(operator, scope);
        }
        else if (operator instanceof GtOperator) {
            return Dataflow.compileGtOperator(operator, scope);
        }
        else if (operator instanceof PlusOperator) {
            return Dataflow.compilePlusOperator(operator, scope);
        }
        else if (operator instanceof MinusOperator) {
            return Dataflow.compileMinusOperator(operator, scope);
        }
        else if (operator instanceof TimesOperator) {
            return Dataflow.compileTimesOperator(operator, scope);
        }
        else if (operator instanceof DivideOperator) {
            return Dataflow.compileDivideOperator(operator, scope);
        }
        else if (operator instanceof ModuloOperator) {
            return Dataflow.compileModuloOperator(operator, scope);
        }
        throw new TypeError("" + operator);
    };
    Dataflow.compileBinaryOutlet = function (operator, outlet, scope) {
        var operand1 = operator.operand1().toValue();
        var operand2 = operator.operand2().toValue();
        var operand1Outlet = Dataflow.compile(operand1, scope);
        var operand2Outlet = Dataflow.compile(operand2, scope);
        outlet.operand1Inlet().bindInput(operand1Outlet);
        outlet.operand2Inlet().bindInput(operand2Outlet);
        return outlet;
    };
    Dataflow.compileOrOperator = function (operator, scope) {
        var outlet = new OrOutlet();
        var operand1 = operator.operand1().toValue();
        var operand2 = operator.operand2().toValue();
        var operand1Outlet = Dataflow.compile(operand1, scope);
        var operand2Outlet = Dataflow.compile(operand2, scope);
        outlet.operand1Inlet().bindInput(operand1Outlet);
        outlet.operand2Inlet().bindInput(operand2Outlet);
        return outlet;
    };
    Dataflow.compileAndOperator = function (operator, scope) {
        var outlet = new AndOutlet();
        var operand1 = operator.operand1().toValue();
        var operand2 = operator.operand2().toValue();
        var operand1Outlet = Dataflow.compile(operand1, scope);
        var operand2Outlet = Dataflow.compile(operand2, scope);
        outlet.operand1Inlet().bindInput(operand1Outlet);
        outlet.operand2Inlet().bindInput(operand2Outlet);
        return outlet;
    };
    Dataflow.compileBitwiseOrOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new BitwiseOrOutlet(), scope);
    };
    Dataflow.compileBitwiseXorOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new BitwiseXorOutlet(), scope);
    };
    Dataflow.compileBitwiseAndOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new BitwiseAndOutlet(), scope);
    };
    Dataflow.compileLtOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new LtOutlet(), scope);
    };
    Dataflow.compileLeOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new LeOutlet(), scope);
    };
    Dataflow.compileEqOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new EqOutlet(), scope);
    };
    Dataflow.compileNeOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new NeOutlet(), scope);
    };
    Dataflow.compileGeOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new GeOutlet(), scope);
    };
    Dataflow.compileGtOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new GtOutlet(), scope);
    };
    Dataflow.compilePlusOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new PlusOutlet(), scope);
    };
    Dataflow.compileMinusOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new MinusOutlet(), scope);
    };
    Dataflow.compileTimesOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new TimesOutlet(), scope);
    };
    Dataflow.compileDivideOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new DivideOutlet(), scope);
    };
    Dataflow.compileModuloOperator = function (operator, scope) {
        return Dataflow.compileBinaryOutlet(operator, new ModuloOutlet(), scope);
    };
    Dataflow.compileUnaryOperator = function (operator, scope) {
        if (operator instanceof NotOperator) {
            return Dataflow.compileNotOperator(operator, scope);
        }
        else if (operator instanceof BitwiseNotOperator) {
            return Dataflow.compileBitwiseNotOperator(operator, scope);
        }
        else if (operator instanceof NegativeOperator) {
            return Dataflow.compileNegativeOperator(operator, scope);
        }
        else if (operator instanceof PositiveOperator) {
            return Dataflow.compilePositiveOperator(operator, scope);
        }
        throw new TypeError("" + operator);
    };
    Dataflow.compileUnaryOutlet = function (operator, outlet, scope) {
        var operand = operator.operand().toValue();
        var operandOutlet = Dataflow.compile(operand, scope);
        outlet.operandInlet().bindInput(operandOutlet);
        return outlet;
    };
    Dataflow.compileNotOperator = function (operator, scope) {
        return Dataflow.compileUnaryOutlet(operator, new NotOutlet(), scope);
    };
    Dataflow.compileBitwiseNotOperator = function (operator, scope) {
        return Dataflow.compileUnaryOutlet(operator, new BitwiseNotOutlet(), scope);
    };
    Dataflow.compileNegativeOperator = function (operator, scope) {
        return Dataflow.compileUnaryOutlet(operator, new NegativeOutlet(), scope);
    };
    Dataflow.compilePositiveOperator = function (operator, scope) {
        return Dataflow.compileUnaryOutlet(operator, new PositiveOutlet(), scope);
    };
    Dataflow.compileInvokeOperator = function (operator, scope) {
        var func = operator.func();
        var args = operator.args();
        var invokeOutlet = new InvokeOutlet(scope);
        var funcOutlet = Dataflow.compile(func, scope);
        var argsOutlet = Dataflow.compile(args, scope);
        invokeOutlet.funcInlet().bindInput(funcOutlet);
        invokeOutlet.argsInlet().bindInput(argsOutlet);
        return invokeOutlet;
    };
    return Dataflow;
}());
export { Dataflow };
RecordOutlet.Dataflow = Dataflow;
//# sourceMappingURL=Dataflow.js.map