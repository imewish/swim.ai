import { __extends } from "tslib";
import { Item, Slot, Value, Text, Num } from "@swim/structure";
import { AbstractStreamlet, StreamletInlet, StreamletOutlet, StreamletInoutlet, } from "@swim/streamlet";
import { RecordStreamlet } from "./RecordStreamlet";
var AbstractRecordStreamlet = (function (_super) {
    __extends(AbstractRecordStreamlet, _super);
    function AbstractRecordStreamlet(scope) {
        if (scope === void 0) { scope = null; }
        var _this = _super.call(this) || this;
        _this.scope = scope;
        _this.context = null;
        _this._version = -1;
        return _this;
    }
    AbstractRecordStreamlet.prototype.streamletScope = function () {
        return this.scope;
    };
    AbstractRecordStreamlet.prototype.setStreamletScope = function (scope) {
        this.scope = scope;
    };
    AbstractRecordStreamlet.prototype.streamletContext = function () {
        if (this.context) {
            return this.context;
        }
        var scope = this.streamletScope();
        if (scope !== null) {
            return scope.streamletContext();
        }
        return null;
    };
    AbstractRecordStreamlet.prototype.setStreamletContext = function (context) {
        this.context = context;
    };
    AbstractRecordStreamlet.prototype.isEmpty = function () {
        return this.length !== 0;
    };
    Object.defineProperty(AbstractRecordStreamlet.prototype, "length", {
        get: function () {
            return AbstractStreamlet.reflectOutletCount(this.streamletClass());
        },
        enumerable: true,
        configurable: true
    });
    AbstractRecordStreamlet.prototype.has = function (key) {
        if (key instanceof Text) {
            key = key.value;
        }
        else if (typeof key !== "string") {
            return false;
        }
        var outlet = this.outlet(key);
        return outlet !== null;
    };
    AbstractRecordStreamlet.prototype.get = function (key) {
        if (key instanceof Text) {
            key = key.value;
        }
        else if (typeof key !== "string") {
            return Value.absent();
        }
        var outlet = this.outlet(key);
        if (outlet !== null) {
            var output = outlet.get();
            if (output !== void 0) {
                return output;
            }
        }
        return Value.absent();
    };
    AbstractRecordStreamlet.prototype.getAttr = function (key) {
        return Value.absent();
    };
    AbstractRecordStreamlet.prototype.getSlot = function (key) {
        return this.get(key);
    };
    AbstractRecordStreamlet.prototype.getField = function (key) {
        if (typeof key === "string") {
            key = Text.from(key);
        }
        else if (!(key instanceof Text)) {
            return void 0;
        }
        var value = this.get(key);
        if (value.isDefined()) {
            return Slot.of(key, value);
        }
        return void 0;
    };
    AbstractRecordStreamlet.prototype.getItem = function (index) {
        if (index instanceof Num) {
            index = index.value;
        }
        var entry = AbstractStreamlet.reflectOutletIndex(index, this, this.streamletClass());
        if (entry !== null) {
            var name_1 = entry[0];
            var output = entry[1].get();
            if (output === void 0) {
                output = Value.extant();
            }
            return Slot.of(name_1, output);
        }
        return Item.absent();
    };
    AbstractRecordStreamlet.prototype.set = function (key, newValue) {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.setAttr = function (key, newValue) {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.setSlot = function (key, newValue) {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.setItem = function (index, item) {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.push = function () {
        var items = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            items[_i] = arguments[_i];
        }
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.splice = function (start, deleteCount) {
        var newItems = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            newItems[_i - 2] = arguments[_i];
        }
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.delete = function (key) {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.clear = function () {
        throw new Error("unsupported");
    };
    AbstractRecordStreamlet.prototype.forEach = function (callback, thisArg) {
        return AbstractStreamlet.reflectEachOutlet(this, this.streamletClass(), function (outlet, name, index) {
            var output = outlet.get();
            if (output !== void 0) {
                var result = callback.call(thisArg, output, index);
                if (result !== void 0) {
                    return result;
                }
            }
        }, this);
    };
    AbstractRecordStreamlet.prototype.inlet = function (key) {
        if (key === void 0) {
            return new StreamletInlet(this);
        }
        else {
            return AbstractStreamlet.reflectInletKey(key, this, this.streamletClass());
        }
    };
    AbstractRecordStreamlet.prototype.bindInput = function (key, input) {
        var inlet = this.inlet(key);
        if (inlet === null) {
            throw new Error("" + key);
        }
        inlet.bindInput(input);
    };
    AbstractRecordStreamlet.prototype.unbindInput = function (key) {
        var inlet = this.inlet(key);
        if (inlet === null) {
            throw new Error("" + key);
        }
        inlet.unbindInput();
    };
    AbstractRecordStreamlet.prototype.outlet = function (key) {
        if (key === void 0) {
            return new StreamletOutlet(this);
        }
        else if (typeof key === "string") {
            return AbstractStreamlet.reflectOutletKey(key, this, this.streamletClass());
        }
        else {
            return key;
        }
    };
    AbstractRecordStreamlet.prototype.inoutlet = function () {
        return new StreamletInoutlet(this);
    };
    AbstractRecordStreamlet.prototype.invalidate = function () {
        if (this._version >= 0) {
            this.willInvalidate();
            this._version = -1;
            this.onInvalidate();
            this.onInvalidateOutlets();
            this.didInvalidate();
        }
    };
    AbstractRecordStreamlet.prototype.reconcile = function (version) {
        if (this._version < 0) {
            this.willReconcile(version);
            this._version = version;
            this.onReconcileInlets(version);
            this.onReconcile(version);
            this.onReconcileOutlets(version);
            this.didReconcile(version);
        }
    };
    AbstractRecordStreamlet.prototype.getInput = function (inlet, orElse) {
        if (typeof inlet === "string") {
            inlet = this.inlet(inlet);
        }
        var object;
        if (inlet !== null) {
            var input = inlet.input();
            if (input !== null) {
                object = input.get();
            }
        }
        if (object === void 0) {
            object = orElse;
        }
        return object;
    };
    AbstractRecordStreamlet.prototype.castInput = function (inlet, form, orElse) {
        var input = this.getInput(inlet);
        var object;
        if (input !== void 0) {
            object = form.cast(input);
        }
        if (object === void 0) {
            object = orElse;
        }
        return object;
    };
    AbstractRecordStreamlet.prototype.coerceInput = function (inlet, form, orElse) {
        var input = this.getInput(inlet);
        var object;
        if (input !== void 0) {
            object = form.cast(input);
        }
        if (object === void 0) {
            object = form.unit();
        }
        if (object === void 0) {
            object = orElse;
        }
        return object;
    };
    AbstractRecordStreamlet.prototype.getOutput = function (outlet) {
        return void 0;
    };
    AbstractRecordStreamlet.prototype.disconnectInputs = function () {
        AbstractStreamlet.disconnectInputs(this, this.streamletClass());
    };
    AbstractRecordStreamlet.prototype.disconnectOutputs = function () {
        AbstractStreamlet.disconnectOutputs(this, this.streamletClass());
    };
    AbstractRecordStreamlet.prototype.willInvalidateInlet = function (inlet) {
    };
    AbstractRecordStreamlet.prototype.didInvalidateInlet = function (inlet) {
        this.invalidate();
    };
    AbstractRecordStreamlet.prototype.willReconcileInlet = function (inlet, version) {
    };
    AbstractRecordStreamlet.prototype.didReconcileInlet = function (inlet, version) {
        this.reconcile(version);
    };
    AbstractRecordStreamlet.prototype.willInvalidateOutlet = function (outlet) {
    };
    AbstractRecordStreamlet.prototype.didInvalidateOutlet = function (outlet) {
    };
    AbstractRecordStreamlet.prototype.willReconcileOutlet = function (outlet, version) {
    };
    AbstractRecordStreamlet.prototype.didReconcileOutlet = function (outlet, version) {
    };
    AbstractRecordStreamlet.prototype.willInvalidate = function () {
    };
    AbstractRecordStreamlet.prototype.onInvalidate = function () {
    };
    AbstractRecordStreamlet.prototype.didInvalidate = function () {
    };
    AbstractRecordStreamlet.prototype.onInvalidateOutlets = function () {
        AbstractStreamlet.invalidateOutlets(this, this.streamletClass());
    };
    AbstractRecordStreamlet.prototype.willReconcile = function (version) {
    };
    AbstractRecordStreamlet.prototype.onReconcileInlets = function (version) {
        AbstractStreamlet.reconcileInlets(version, this, this.streamletClass());
    };
    AbstractRecordStreamlet.prototype.onReconcile = function (version) {
    };
    AbstractRecordStreamlet.prototype.onReconcileOutlets = function (version) {
        AbstractStreamlet.reconcileOutlets(version, this, this.streamletClass());
    };
    AbstractRecordStreamlet.prototype.didReconcile = function (version) {
    };
    return AbstractRecordStreamlet;
}(RecordStreamlet));
export { AbstractRecordStreamlet };
//# sourceMappingURL=AbstractRecordStreamlet.js.map