import { __extends } from "tslib";
import { WriterException, Writer } from "@swim/codec";
var LambdaFuncWriter = (function (_super) {
    __extends(LambdaFuncWriter, _super);
    function LambdaFuncWriter(recon, bindings, template, part, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._bindings = bindings;
        _this._template = template;
        _this._part = part;
        _this._step = step;
        return _this;
    }
    LambdaFuncWriter.prototype.pull = function (output) {
        return LambdaFuncWriter.write(output, this._recon, this._bindings, this._template, this._part, this._step);
    };
    LambdaFuncWriter.sizeOf = function (recon, bindings, template) {
        var size = 0;
        size += recon.sizeOfPrimary(bindings);
        size += 4;
        size += recon.sizeOfValue(template);
        return size;
    };
    LambdaFuncWriter.write = function (output, recon, bindings, template, part, step) {
        if (step === void 0) { step = 1; }
        if (step === 1) {
            if (!part) {
                part = recon.writePrimary(bindings, output);
            }
            else {
                part = part.pull(output);
            }
            if (part.isDone()) {
                part = void 0;
                step = 2;
            }
            else if (part.isError()) {
                return part.asError();
            }
        }
        if (step === 2 && output.isCont()) {
            output = output.write(32);
            step = 3;
        }
        if (step === 3 && output.isCont()) {
            output = output.write(61);
            step = 4;
        }
        if (step === 4 && output.isCont()) {
            output = output.write(62);
            step = 5;
        }
        if (step === 5 && output.isCont()) {
            output = output.write(32);
            step = 6;
        }
        if (step === 6) {
            if (part == null) {
                part = recon.writeValue(template, output);
            }
            else {
                part = part.pull(output);
            }
            if (part.isDone()) {
                return Writer.done();
            }
            else if (part.isError()) {
                return part.asError();
            }
        }
        if (output.isDone()) {
            return Writer.error(new WriterException("truncated"));
        }
        else if (output.isError()) {
            return Writer.error(output.trap());
        }
        return new LambdaFuncWriter(recon, bindings, template, part, step);
    };
    return LambdaFuncWriter;
}(Writer));
export { LambdaFuncWriter };
//# sourceMappingURL=LambdaFuncWriter.js.map