import { Builder } from "@swim/util";
import { Input, Output, Parser } from "@swim/codec";
export declare abstract class ReconParser<I, V> {
    abstract isDistinct(value: V): boolean;
    abstract item(value: V): I;
    abstract value(item: I): V;
    abstract attr(key: V, value: V): I;
    abstract attr(key: V): I;
    abstract slot(key: V, value: V): I;
    abstract slot(key: V): I;
    abstract valueBuilder(): Builder<I, V>;
    abstract recordBuilder(): Builder<I, V>;
    abstract dataOutput(): Output<V>;
    abstract textOutput(): Output<V>;
    abstract ident(value: V): V;
    abstract num(value: number | string): V;
    abstract uint32(value: number): V;
    abstract uint64(value: number): V;
    abstract bool(value: boolean): V;
    abstract selector(): V;
    abstract extant(): V;
    abstract absent(): V;
    abstract conditional(ifTerm: V, thenTerm: V, elseTerm: V): V;
    abstract or(lhs: V, rhs: V): V;
    abstract and(lhs: V, rhs: V): V;
    abstract bitwiseOr(lhs: V, rhs: V): V;
    abstract bitwiseXor(lhs: V, rhs: V): V;
    abstract bitwiseAnd(lhs: V, rhs: V): V;
    abstract lt(lhs: V, rhs: V): V;
    abstract le(lhs: V, rhs: V): V;
    abstract eq(lhs: V, rhs: V): V;
    abstract ne(lhs: V, rhs: V): V;
    abstract ge(lhs: V, rhs: V): V;
    abstract gt(lhs: V, rhs: V): V;
    abstract plus(lhs: V, rhs: V): V;
    abstract minus(lhs: V, rhs: V): V;
    abstract times(lhs: V, rhs: V): V;
    abstract divide(lhs: V, rhs: V): V;
    abstract modulo(lhs: V, rhs: V): V;
    abstract not(rhs: V): V;
    abstract bitwiseNot(rhs: V): V;
    abstract negative(rhs: V): V;
    abstract positive(rhs: V): V;
    abstract invoke(func: V, args: V): V;
    abstract lambda(bindings: V, template: V): V;
    abstract get(selector: V, key: V): V;
    abstract getAttr(selector: V, key: V): V;
    abstract getItem(selector: V, index: V): I;
    abstract children(selector: V): V;
    abstract descendants(selector: V): V;
    abstract keys(selector: V): V;
    abstract values(selector: V): V;
    abstract filter(selector: V, predicate: V): V;
    parseBlock(input: Input): Parser<V>;
    parseAttr(input: Input): Parser<I>;
    parseBlockItem(input: Input): Parser<V>;
    parseInlineItem(input: Input): Parser<V>;
    parseRecord(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseMarkup(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseData(input: Input): Parser<V>;
    parseIdent(input: Input): Parser<V>;
    parseString(input: Input): Parser<V>;
    parseNumber(input: Input): Parser<V>;
    parseInteger(input: Input): Parser<V>;
    parseBlockExpression(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseLambdaFunc(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseConditionalOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseXorOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseBitwiseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseComparisonOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAttrExpression(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseAdditiveOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseMultiplicativeOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parsePrefixOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseInvokeOperator(input: Input, builder?: Builder<I, V>): Parser<V>;
    parsePrimary(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseLiteral(input: Input, builder?: Builder<I, V>): Parser<V>;
    parseSelector(input: Input, builder?: Builder<I, V>): Parser<V>;
    blockParser(): Parser<V>;
    parseBlockString(string: string): V;
    parseNumberString(string: string): V;
}
//# sourceMappingURL=ReconParser.d.ts.map