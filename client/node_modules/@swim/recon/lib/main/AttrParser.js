import { __extends } from "tslib";
import { Parser, Diagnostic } from "@swim/codec";
import { Recon } from "./Recon";
var AttrParser = (function (_super) {
    __extends(AttrParser, _super);
    function AttrParser(recon, keyParser, valueParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._keyParser = keyParser;
        _this._valueParser = valueParser;
        _this._step = step;
        return _this;
    }
    AttrParser.prototype.feed = function (input) {
        return AttrParser.parse(input, this._recon, this._keyParser, this._valueParser, this._step);
    };
    AttrParser.parse = function (input, recon, keyParser, valueParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        if (step === 1) {
            if (input.isCont()) {
                c = input.head();
                if (c === 64) {
                    input = input.step();
                    step = 2;
                }
                else {
                    return Parser.error(Diagnostic.expected(64, input));
                }
            }
            else if (input.isDone()) {
                return Parser.error(Diagnostic.expected(64, input));
            }
        }
        if (step === 2) {
            if (!keyParser) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 34 || c === 39) {
                        keyParser = recon.parseString(input);
                    }
                    else if (Recon.isIdentStartChar(c)) {
                        keyParser = recon.parseIdent(input);
                    }
                    else {
                        return Parser.error(Diagnostic.expected("attribute name", input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected("attribute name", input));
                }
            }
            else {
                keyParser = keyParser.feed(input);
            }
            if (keyParser) {
                if (keyParser.isDone()) {
                    step = 3;
                }
                else if (keyParser.isError()) {
                    return keyParser.asError();
                }
            }
        }
        if (step === 3) {
            if (input.isCont() && input.head() === 40) {
                input = input.step();
                step = 4;
            }
            else if (!input.isEmpty()) {
                return Parser.done(recon.attr(keyParser.bind()));
            }
        }
        if (step === 4) {
            while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                input = input.step();
            }
            if (input.isCont()) {
                if (c === 41) {
                    input = input.step();
                    return Parser.done(recon.attr(keyParser.bind()));
                }
                else {
                    step = 5;
                }
            }
            else if (input.isDone()) {
                return Parser.error(Diagnostic.expected(")", input));
            }
        }
        if (step === 5) {
            if (!valueParser) {
                valueParser = recon.parseBlock(input);
            }
            while (valueParser.isCont() && !input.isEmpty()) {
                valueParser = valueParser.feed(input);
            }
            if (valueParser.isDone()) {
                step = 6;
            }
            else if (valueParser.isError()) {
                return valueParser.asError();
            }
        }
        if (step === 6) {
            while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                input = input.step();
            }
            if (input.isCont()) {
                if (c === 41) {
                    input = input.step();
                    return Parser.done(recon.attr(keyParser.bind(), valueParser.bind()));
                }
                else {
                    return Parser.error(Diagnostic.expected(")", input));
                }
            }
            else if (input.isDone()) {
                return Parser.error(Diagnostic.expected(")", input));
            }
        }
        return new AttrParser(recon, keyParser, valueParser, step);
    };
    return AttrParser;
}(Parser));
export { AttrParser };
//# sourceMappingURL=AttrParser.js.map