import { __extends } from "tslib";
import { Parser } from "@swim/codec";
var LambdaFuncParser = (function (_super) {
    __extends(LambdaFuncParser, _super);
    function LambdaFuncParser(recon, builder, bindingsParser, templateParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._builder = builder;
        _this._bindingsParser = bindingsParser;
        _this._templateParser = templateParser;
        _this._step = step;
        return _this;
    }
    LambdaFuncParser.prototype.feed = function (input) {
        return LambdaFuncParser.parse(input, this._recon, this._builder, this._bindingsParser, this._templateParser, this._step);
    };
    LambdaFuncParser.parse = function (input, recon, builder, bindingsParser, templateParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        if (step === 1) {
            if (!bindingsParser) {
                bindingsParser = recon.parseConditionalOperator(input, builder);
            }
            while (bindingsParser.isCont() && !input.isEmpty()) {
                bindingsParser = bindingsParser.feed(input);
            }
            if (bindingsParser.isDone()) {
                step = 2;
            }
            else if (bindingsParser.isError()) {
                return bindingsParser.asError();
            }
        }
        if (step === 2) {
            if (input.isCont()) {
                c = input.head();
                if (c === 62) {
                    input = input.step();
                    step = 3;
                }
                else {
                    return bindingsParser;
                }
            }
            else if (input.isDone()) {
                return bindingsParser;
            }
        }
        if (step === 3) {
            if (!templateParser) {
                templateParser = recon.parseConditionalOperator(input);
            }
            while (templateParser.isCont() && !input.isEmpty()) {
                templateParser = templateParser.feed(input);
            }
            if (templateParser.isDone()) {
                var bindings = bindingsParser.bind();
                var template = templateParser.bind();
                return Parser.done(recon.lambda(bindings, template));
            }
            else if (templateParser.isError()) {
                return templateParser.asError();
            }
        }
        return new LambdaFuncParser(recon, builder, bindingsParser, templateParser, step);
    };
    return LambdaFuncParser;
}(Parser));
export { LambdaFuncParser };
//# sourceMappingURL=LambdaFuncParser.js.map