import { Cursor } from "@swim/util";
import { Output, Writer } from "@swim/codec";
export declare abstract class ReconWriter<I, V> {
    abstract isField(item: I): boolean;
    abstract isAttr(item: I): boolean;
    abstract isSlot(item: I): boolean;
    abstract isValue(item: I): boolean;
    abstract isRecord(item: I): boolean;
    abstract isText(item: I): boolean;
    abstract isNum(item: I): boolean;
    abstract isBool(item: I): boolean;
    abstract isExpression(item: I): boolean;
    abstract isExtant(item: I): boolean;
    abstract items(item: I): Cursor<I>;
    abstract item(value: V): I;
    abstract key(item: I): V;
    abstract value(item: I): V;
    abstract string(item: I): string;
    abstract precedence(item: I): number;
    abstract sizeOfItem(item: I): number;
    abstract writeItem(item: I, output: Output): Writer;
    abstract sizeOfValue(value: V): number;
    abstract writeValue(value: V, output: Output): Writer;
    abstract sizeOfBlockValue(value: V): number;
    abstract writeBlockValue(value: V, output: Output): Writer;
    sizeOfAttr(key: V, value: V): number;
    writeAttr(key: V, value: V, output: Output): Writer;
    sizeOfSlot(key: V, value: V): number;
    writeSlot(key: V, value: V, output: Output): Writer;
    abstract sizeOfBlockItem(item: I): number;
    abstract writeBlockItem(item: I, output: Output): Writer;
    sizeOfBlock(item: I): number;
    sizeOfBlock(items: Cursor<I>, inBlock: boolean, inMarkup: boolean): number;
    writeBlock(item: I, output: Output): Writer;
    writeBlock(items: Cursor<I>, output: Output, inBlock: boolean, inMarkup: boolean): Writer;
    sizeOfRecord(item: I): number;
    writeRecord(item: I, output: Output): Writer;
    sizeOfPrimary(value: V): number;
    writePrimary(value: V, output: Output): Writer;
    isBlockSafe(items: Cursor<I>): boolean;
    isMarkupSafe(items: Cursor<I>): boolean;
    sizeOfMarkupText(item: I | string): number;
    writeMarkupText(item: I | string, output: Output): Writer;
    sizeOfData(length: number): number;
    writeData(value: Uint8Array | undefined, output: Output): Writer;
    isIdent(value: I | string): boolean;
    sizeOfText(value: string): number;
    writeText(value: string, output: Output): Writer;
    sizeOfNum(value: number): number;
    writeNum(value: number, output: Output): Writer;
    sizeOfUint32(value: number): number;
    writeUint32(value: number, output: Output): Writer;
    sizeOfUint64(value: number): number;
    writeUint64(value: number, output: Output): Writer;
    sizeOfBool(value: boolean): number;
    writeBool(value: boolean, output: Output): Writer;
    sizeOfLambdaFunc(bindings: V, template: V): number;
    writeLambdaFunc(bindings: V, template: V, output: Output): Writer;
    sizeOfConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): number;
    writeConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number, output: Output): Writer;
    sizeOfInfixOperator(lhs: I, operator: string, rhs: I, precedence: number): number;
    writeInfixOperator(lhs: I, operator: string, rhs: I, precedence: number, output: Output): Writer;
    sizeOfPrefixOperator(operator: string, rhs: I, precedence: number): number;
    writePrefixOperator(operator: string, rhs: I, precedence: number, output: Output): Writer;
    sizeOfInvokeOperator(func: V, args: V): number;
    writeInvokeOperator(func: V, args: V, output: Output): Writer;
    abstract sizeOfThen(then: V): number;
    abstract writeThen(then: V, output: Output): Writer;
    sizeOfIdentitySelector(): number;
    writeIdentitySelector(output: Output): Writer;
    sizeOfThenIdentitySelector(): number;
    writeThenIdentitySelector(output: Output): Writer;
    sizeOfLiteralSelector(item: I, then: V): number;
    writeLiteralSelector(item: I, then: V, output: Output): Writer;
    sizeOfThenLiteralSelector(item: I, then: V): number;
    writeThenLiteralSelector(item: I, then: V, output: Output): Writer;
    sizeOfGetSelector(key: V, then: V): number;
    writeGetSelector(key: V, then: V, output: Output): Writer;
    sizeOfThenGetSelector(key: V, then: V): number;
    writeThenGetSelector(key: V, then: V, output: Output): Writer;
    sizeOfGetAttrSelector(key: V, then: V): number;
    writeGetAttrSelector(key: V, then: V, output: Output): Writer;
    sizeOfThenGetAttrSelector(key: V, then: V): number;
    writeThenGetAttrSelector(key: V, then: V, output: Output): Writer;
    sizeOfGetItemSelector(index: V, then: V): number;
    writeGetItemSelector(index: V, then: V, output: Output): Writer;
    sizeOfThenGetItemSelector(index: V, then: V): number;
    writeThenGetItemSelector(index: V, then: V, output: Output): Writer;
    sizeOfKeysSelector(then: V): number;
    writeKeysSelector(then: V, output: Output): Writer;
    sizeOfThenKeysSelector(then: V): number;
    writeThenKeysSelector(then: V, output: Output): Writer;
    sizeOfValuesSelector(then: V): number;
    writeValuesSelector(then: V, output: Output): Writer;
    sizeOfThenValuesSelector(then: V): number;
    writeThenValuesSelector(then: V, output: Output): Writer;
    sizeOfChildrenSelector(then: V): number;
    writeChildrenSelector(then: V, output: Output): Writer;
    sizeOfThenChildrenSelector(then: V): number;
    writeThenChildrenSelector(then: V, output: Output): Writer;
    sizeOfDescendantsSelector(then: V): number;
    writeDescendantsSelector(then: V, output: Output): Writer;
    sizeOfThenDescendantsSelector(then: V): number;
    writeThenDescendantsSelector(then: V, output: Output): Writer;
    sizeOfFilterSelector(predicate: V, then: V): number;
    writeFilterSelector(predicate: V, then: V, output: Output): Writer;
    sizeOfThenFilterSelector(predicate: V, then: V): number;
    writeThenFilterSelector(predicate: V, then: V, output: Output): Writer;
    sizeOfExtant(): number;
    writeExtant(output: Output): Writer;
    sizeOfAbsent(): number;
    writeAbsent(output: Output): Writer;
}
//# sourceMappingURL=ReconWriter.d.ts.map