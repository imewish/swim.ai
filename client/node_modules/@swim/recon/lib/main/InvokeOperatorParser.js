import { __extends } from "tslib";
import { Parser, Diagnostic } from "@swim/codec";
import { Recon } from "./Recon";
var InvokeOperatorParser = (function (_super) {
    __extends(InvokeOperatorParser, _super);
    function InvokeOperatorParser(recon, builder, exprParser, argsParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._builder = builder;
        _this._exprParser = exprParser;
        _this._argsParser = argsParser;
        _this._step = step;
        return _this;
    }
    InvokeOperatorParser.prototype.feed = function (input) {
        return InvokeOperatorParser.parse(input, this._recon, this._builder, this._exprParser, this._argsParser, this._step);
    };
    InvokeOperatorParser.parse = function (input, recon, builder, exprParser, argsParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        if (step === 1) {
            if (!exprParser) {
                exprParser = recon.parsePrimary(input, builder);
            }
            while (exprParser.isCont() && !input.isEmpty()) {
                exprParser = exprParser.feed(input);
            }
            if (exprParser.isDone()) {
                step = 2;
            }
            else if (exprParser.isError()) {
                return exprParser.asError();
            }
        }
        do {
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 40) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        return exprParser;
                    }
                }
                else if (input.isDone()) {
                    return exprParser;
                }
            }
            if (step === 3) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        var expr = exprParser.bind();
                        exprParser = Parser.done(recon.invoke(expr, recon.extant()));
                        step = 2;
                        continue;
                    }
                    else {
                        step = 4;
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(41, input));
                }
            }
            if (step === 4) {
                if (!argsParser) {
                    argsParser = recon.parseBlock(input);
                }
                while (argsParser.isCont() && !input.isEmpty()) {
                    argsParser = argsParser.feed(input);
                }
                if (argsParser.isDone()) {
                    step = 5;
                }
                else if (argsParser.isError()) {
                    return argsParser.asError();
                }
            }
            if (step === 5) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        var expr = exprParser.bind();
                        var args = argsParser.bind();
                        exprParser = Parser.done(recon.invoke(expr, args));
                        argsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else {
                        return Parser.error(Diagnostic.expected(41, input));
                    }
                }
                else if (input.isDone()) {
                    return Parser.error(Diagnostic.expected(41, input));
                }
            }
            break;
        } while (true);
        return new InvokeOperatorParser(recon, builder, exprParser, argsParser, step);
    };
    return InvokeOperatorParser;
}(Parser));
export { InvokeOperatorParser };
//# sourceMappingURL=InvokeOperatorParser.js.map