import { __extends } from "tslib";
import { Parser, Diagnostic } from "@swim/codec";
import { Recon } from "./Recon";
var ConditionalOperatorParser = (function (_super) {
    __extends(ConditionalOperatorParser, _super);
    function ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._builder = builder;
        _this._ifParser = ifParser;
        _this._thenParser = thenParser;
        _this._elseParser = elseParser;
        _this._step = step;
        return _this;
    }
    ConditionalOperatorParser.prototype.feed = function (input) {
        return ConditionalOperatorParser.parse(input, this._recon, this._builder, this._ifParser, this._thenParser, this._elseParser, this._step);
    };
    ConditionalOperatorParser.parse = function (input, recon, builder, ifParser, thenParser, elseParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        if (step === 1) {
            if (!ifParser) {
                ifParser = recon.parseOrOperator(input, builder);
            }
            while (ifParser.isCont() && !input.isEmpty()) {
                ifParser = ifParser.feed(input);
            }
            if (ifParser.isDone()) {
                step = 2;
            }
            else if (ifParser.isError()) {
                return ifParser.asError();
            }
        }
        if (step === 2) {
            while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                input = input.step();
            }
            if (input.isCont()) {
                if (c === 63) {
                    input = input.step();
                    step = 3;
                }
                else {
                    return ifParser;
                }
            }
            else if (input.isDone()) {
                return ifParser;
            }
        }
        if (step === 3) {
            if (!thenParser) {
                thenParser = recon.parseConditionalOperator(input, builder);
            }
            while (thenParser.isCont() && !input.isEmpty()) {
                thenParser = thenParser.feed(input);
            }
            if (thenParser.isDone()) {
                step = 4;
            }
            else if (thenParser.isError()) {
                return thenParser.asError();
            }
        }
        if (step === 4) {
            while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                input = input.step();
            }
            if (input.isCont()) {
                if (c === 58) {
                    input = input.step();
                    step = 5;
                }
                else {
                    return Parser.error(Diagnostic.expected(58, input));
                }
            }
            else if (input.isDone()) {
                return Parser.error(Diagnostic.expected(58, input));
            }
        }
        if (step === 5) {
            if (!elseParser) {
                elseParser = recon.parseConditionalOperator(input, builder);
            }
            while (elseParser.isCont() && !input.isEmpty()) {
                elseParser = elseParser.feed(input);
            }
            if (elseParser.isDone()) {
                var ifTerm = ifParser.bind();
                var thenTerm = thenParser.bind();
                var elseTerm = elseParser.bind();
                return Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));
            }
            else if (elseParser.isError()) {
                return elseParser.asError();
            }
        }
        return new ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step);
    };
    return ConditionalOperatorParser;
}(Parser));
export { ConditionalOperatorParser };
//# sourceMappingURL=ConditionalOperatorParser.js.map