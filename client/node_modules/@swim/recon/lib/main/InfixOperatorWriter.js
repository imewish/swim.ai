import { __extends } from "tslib";
import { WriterException, Writer, Unicode, Utf8 } from "@swim/codec";
var InfixOperatorWriter = (function (_super) {
    __extends(InfixOperatorWriter, _super);
    function InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._lhs = lhs;
        _this._operator = operator;
        _this._rhs = rhs;
        _this._precedence = precedence;
        _this._part = part;
        _this._step = step;
        return _this;
    }
    InfixOperatorWriter.prototype.pull = function (output) {
        return InfixOperatorWriter.write(output, this._recon, this._lhs, this._operator, this._rhs, this._precedence, this._part, this._step);
    };
    InfixOperatorWriter.sizeOf = function (recon, lhs, operator, rhs, precedence) {
        var size = 0;
        if (recon.precedence(lhs) < precedence) {
            size += 1;
            size += recon.sizeOfItem(lhs);
            size += 1;
        }
        else {
            size += recon.sizeOfItem(lhs);
        }
        size += 1;
        size += Utf8.sizeOf(operator);
        size += 1;
        if (recon.precedence(rhs) < precedence) {
            size += 1;
            size += recon.sizeOfItem(rhs);
            size += 1;
        }
        else {
            size += recon.sizeOfItem(rhs);
        }
        return size;
    };
    InfixOperatorWriter.write = function (output, recon, lhs, operator, rhs, precedence, part, step) {
        if (step === void 0) { step = 1; }
        if (step === 1) {
            if (recon.precedence(lhs) < precedence) {
                if (output.isCont()) {
                    output = output.write(40);
                    step = 2;
                }
            }
            else {
                step = 2;
            }
        }
        if (step === 2) {
            if (!part) {
                part = recon.writeItem(lhs, output);
            }
            else {
                part = part.pull(output);
            }
            if (part.isDone()) {
                part = void 0;
                step = 3;
            }
            else if (part.isError()) {
                return part.asError();
            }
        }
        if (step === 3) {
            if (recon.precedence(lhs) < precedence) {
                if (output.isCont()) {
                    output = output.write(41);
                    step = 4;
                }
            }
            else {
                step = 4;
            }
        }
        if (step === 4 && output.isCont()) {
            output = output.write(32);
            step = 5;
        }
        if (step === 5) {
            if (!part) {
                part = Unicode.writeString(operator, output);
            }
            else {
                part = part.pull(output);
            }
            if (part.isDone()) {
                part = void 0;
                step = 6;
            }
            else if (part.isError()) {
                return part.asError();
            }
        }
        if (step === 6 && output.isCont()) {
            output = output.write(32);
            step = 7;
        }
        if (step === 7) {
            if (recon.precedence(rhs) < precedence) {
                if (output.isCont()) {
                    output = output.write(40);
                    step = 8;
                }
            }
            else {
                step = 8;
            }
        }
        if (step === 8) {
            if (!part) {
                part = recon.writeItem(rhs, output);
            }
            else {
                part = part.pull(output);
            }
            if (part.isDone()) {
                part = void 0;
                step = 9;
            }
            else if (part.isError()) {
                return part.asError();
            }
        }
        if (step === 9) {
            if (recon.precedence(rhs) < precedence) {
                if (output.isCont()) {
                    output = output.write(41);
                    return Writer.done();
                }
            }
            else {
                return Writer.done();
            }
        }
        if (output.isDone()) {
            return Writer.error(new WriterException("truncated"));
        }
        else if (output.isError()) {
            return Writer.error(output.trap());
        }
        return new InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step);
    };
    return InfixOperatorWriter;
}(Writer));
export { InfixOperatorWriter };
//# sourceMappingURL=InfixOperatorWriter.js.map