import { __extends } from "tslib";
import { Parser, Diagnostic } from "@swim/codec";
import { Recon } from "./Recon";
var MultiplicativeOperatorParser = (function (_super) {
    __extends(MultiplicativeOperatorParser, _super);
    function MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._builder = builder;
        _this._lhsParser = lhsParser;
        _this._operator = operator;
        _this._rhsParser = rhsParser;
        _this._step = step;
        return _this;
    }
    MultiplicativeOperatorParser.prototype.feed = function (input) {
        return MultiplicativeOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
    };
    MultiplicativeOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        do {
            if (step === 1) {
                if (!lhsParser) {
                    lhsParser = recon.parsePrefixOperator(input, builder);
                }
                while (lhsParser.isCont() && !input.isEmpty()) {
                    lhsParser = lhsParser.feed(input);
                }
                if (lhsParser.isDone()) {
                    step = 2;
                }
                else if (lhsParser.isError()) {
                    return lhsParser.asError();
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 42) {
                        input = input.step();
                        operator = "*";
                        step = 3;
                    }
                    else if (c === 47) {
                        input = input.step();
                        operator = "/";
                        step = 3;
                    }
                    else if (c === 37) {
                        input = input.step();
                        operator = "%";
                        step = 3;
                    }
                    else {
                        return lhsParser;
                    }
                }
                else if (input.isDone()) {
                    return lhsParser;
                }
            }
            if (step === 3) {
                if (!rhsParser) {
                    rhsParser = recon.parsePrefixOperator(input, builder);
                }
                while (rhsParser.isCont() && !input.isEmpty()) {
                    rhsParser = rhsParser.feed(input);
                }
                if (rhsParser.isDone()) {
                    var lhs = lhsParser.bind();
                    var rhs = rhsParser.bind();
                    if (operator === "*") {
                        lhsParser = Parser.done(recon.times(lhs, rhs));
                    }
                    else if (operator === "/") {
                        lhsParser = Parser.done(recon.divide(lhs, rhs));
                    }
                    else if (operator === "%") {
                        lhsParser = Parser.done(recon.modulo(lhs, rhs));
                    }
                    else {
                        return Parser.error(Diagnostic.message(operator, input));
                    }
                    rhsParser = void 0;
                    operator = void 0;
                    step = 2;
                    continue;
                }
                else if (rhsParser.isError()) {
                    return rhsParser.asError();
                }
            }
            break;
        } while (true);
        return new MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
    };
    return MultiplicativeOperatorParser;
}(Parser));
export { MultiplicativeOperatorParser };
//# sourceMappingURL=MultiplicativeOperatorParser.js.map