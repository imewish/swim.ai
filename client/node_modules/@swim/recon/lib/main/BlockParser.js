import { __extends } from "tslib";
import { Parser } from "@swim/codec";
import { Recon } from "./Recon";
var BlockParser = (function (_super) {
    __extends(BlockParser, _super);
    function BlockParser(recon, builder, keyParser, valueParser, step) {
        var _this = _super.call(this) || this;
        _this._recon = recon;
        _this._builder = builder;
        _this._keyParser = keyParser;
        _this._valueParser = valueParser;
        _this._step = step;
        return _this;
    }
    BlockParser.prototype.feed = function (input) {
        return BlockParser.parse(input, this._recon, this._builder, this._keyParser, this._valueParser, this._step);
    };
    BlockParser.parse = function (input, recon, builder, keyParser, valueParser, step) {
        if (step === void 0) { step = 1; }
        var c = 0;
        block: do {
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 33 || c === 34 || c === 36 || c === 37
                        || c === 39 || c === 40 || c === 43 || c === 45
                        || c >= 48 && c <= 57 || c === 64
                        || c === 91 || c === 123 || c === 126
                        || Recon.isIdentStartChar(c)) {
                        builder = builder || recon.valueBuilder();
                        step = 2;
                    }
                    else if (c === 35) {
                        input = input.step();
                        step = 7;
                    }
                    else {
                        if (builder) {
                            return Parser.done(builder.bind());
                        }
                        else {
                            return Parser.done(recon.absent());
                        }
                    }
                }
                else if (input.isDone()) {
                    if (builder) {
                        return Parser.done(builder.bind());
                    }
                    else {
                        return Parser.done(recon.absent());
                    }
                }
            }
            if (step === 2) {
                if (!keyParser) {
                    keyParser = recon.parseBlockExpression(input);
                }
                while (keyParser.isCont() && !input.isEmpty()) {
                    keyParser = keyParser.feed(input);
                }
                if (keyParser.isDone()) {
                    step = 3;
                }
                else if (keyParser.isError()) {
                    return keyParser;
                }
            }
            if (step === 3) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 58) {
                        input = input.step();
                        step = 4;
                    }
                    else {
                        builder.push(recon.item(keyParser.bind()));
                        keyParser = void 0;
                        step = 6;
                    }
                }
                else if (input.isDone()) {
                    builder.push(recon.item(keyParser.bind()));
                    return Parser.done(builder.bind());
                }
            }
            if (step === 4) {
                while (input.isCont() && Recon.isSpace(input.head())) {
                    input = input.step();
                }
                if (input.isCont()) {
                    step = 5;
                }
                else if (input.isDone()) {
                    builder.push(recon.slot(keyParser.bind()));
                    return Parser.done(builder.bind());
                }
            }
            if (step === 5) {
                if (!valueParser) {
                    valueParser = recon.parseBlockExpression(input);
                }
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
                    keyParser = void 0;
                    valueParser = void 0;
                    step = 6;
                }
                else if (valueParser.isError()) {
                    return valueParser;
                }
            }
            if (step === 6) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 44 || c === 59 || Recon.isNewline(c)) {
                        input = input.step();
                        step = 1;
                        continue;
                    }
                    else if (c === 35) {
                        input = input.step();
                        step = 7;
                    }
                    else {
                        return Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    return Parser.done(builder.bind());
                }
            }
            if (step === 7) {
                while (input.isCont()) {
                    c = input.head();
                    if (!Recon.isNewline(c)) {
                        input = input.step();
                    }
                    else {
                        step = 1;
                        continue block;
                    }
                }
                if (input.isDone()) {
                    step = 1;
                    continue;
                }
            }
            break;
        } while (true);
        return new BlockParser(recon, builder, keyParser, valueParser, step);
    };
    return BlockParser;
}(Parser));
export { BlockParser };
//# sourceMappingURL=BlockParser.js.map