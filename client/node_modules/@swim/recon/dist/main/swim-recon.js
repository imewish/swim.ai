(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@swim/codec'), require('@swim/structure')) :
    typeof define === 'function' && define.amd ? define(['exports', '@swim/codec', '@swim/structure'], factory) :
    (global = global || self, factory(global.swim = global.swim || {}, global.swim, global.swim));
}(this, (function (exports, codec, structure) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    var BlockParser = (function (_super) {
        __extends(BlockParser, _super);
        function BlockParser(recon, builder, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        BlockParser.prototype.feed = function (input) {
            return BlockParser.parse(input, this._recon, this._builder, this._keyParser, this._valueParser, this._step);
        };
        BlockParser.parse = function (input, recon, builder, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            block: do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 33 || c === 34 || c === 36 || c === 37
                            || c === 39 || c === 40 || c === 43 || c === 45
                            || c >= 48 && c <= 57 || c === 64
                            || c === 91 || c === 123 || c === 126
                            || Recon.isIdentStartChar(c)) {
                            builder = builder || recon.valueBuilder();
                            step = 2;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 7;
                        }
                        else {
                            if (builder) {
                                return codec.Parser.done(builder.bind());
                            }
                            else {
                                return codec.Parser.done(recon.absent());
                            }
                        }
                    }
                    else if (input.isDone()) {
                        if (builder) {
                            return codec.Parser.done(builder.bind());
                        }
                        else {
                            return codec.Parser.done(recon.absent());
                        }
                    }
                }
                if (step === 2) {
                    if (!keyParser) {
                        keyParser = recon.parseBlockExpression(input);
                    }
                    while (keyParser.isCont() && !input.isEmpty()) {
                        keyParser = keyParser.feed(input);
                    }
                    if (keyParser.isDone()) {
                        step = 3;
                    }
                    else if (keyParser.isError()) {
                        return keyParser;
                    }
                }
                if (step === 3) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 58) {
                            input = input.step();
                            step = 4;
                        }
                        else {
                            builder.push(recon.item(keyParser.bind()));
                            keyParser = void 0;
                            step = 6;
                        }
                    }
                    else if (input.isDone()) {
                        builder.push(recon.item(keyParser.bind()));
                        return codec.Parser.done(builder.bind());
                    }
                }
                if (step === 4) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 5;
                    }
                    else if (input.isDone()) {
                        builder.push(recon.slot(keyParser.bind()));
                        return codec.Parser.done(builder.bind());
                    }
                }
                if (step === 5) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
                        keyParser = void 0;
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 6) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44 || c === 59 || Recon.isNewline(c)) {
                            input = input.step();
                            step = 1;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 7;
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.done(builder.bind());
                    }
                }
                if (step === 7) {
                    while (input.isCont()) {
                        c = input.head();
                        if (!Recon.isNewline(c)) {
                            input = input.step();
                        }
                        else {
                            step = 1;
                            continue block;
                        }
                    }
                    if (input.isDone()) {
                        step = 1;
                        continue;
                    }
                }
                break;
            } while (true);
            return new BlockParser(recon, builder, keyParser, valueParser, step);
        };
        return BlockParser;
    }(codec.Parser));

    var AttrParser = (function (_super) {
        __extends(AttrParser, _super);
        function AttrParser(recon, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        AttrParser.prototype.feed = function (input) {
            return AttrParser.parse(input, this._recon, this._keyParser, this._valueParser, this._step);
        };
        AttrParser.parse = function (input, recon, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 64) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(64, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(64, input));
                }
            }
            if (step === 2) {
                if (!keyParser) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 34 || c === 39) {
                            keyParser = recon.parseString(input);
                        }
                        else if (Recon.isIdentStartChar(c)) {
                            keyParser = recon.parseIdent(input);
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected("attribute name", input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected("attribute name", input));
                    }
                }
                else {
                    keyParser = keyParser.feed(input);
                }
                if (keyParser) {
                    if (keyParser.isDone()) {
                        step = 3;
                    }
                    else if (keyParser.isError()) {
                        return keyParser.asError();
                    }
                }
            }
            if (step === 3) {
                if (input.isCont() && input.head() === 40) {
                    input = input.step();
                    step = 4;
                }
                else if (!input.isEmpty()) {
                    return codec.Parser.done(recon.attr(keyParser.bind()));
                }
            }
            if (step === 4) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        return codec.Parser.done(recon.attr(keyParser.bind()));
                    }
                    else {
                        step = 5;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(")", input));
                }
            }
            if (step === 5) {
                if (!valueParser) {
                    valueParser = recon.parseBlock(input);
                }
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    step = 6;
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 6) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        return codec.Parser.done(recon.attr(keyParser.bind(), valueParser.bind()));
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(")", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(")", input));
                }
            }
            return new AttrParser(recon, keyParser, valueParser, step);
        };
        return AttrParser;
    }(codec.Parser));

    var BlockItemParser = (function (_super) {
        __extends(BlockItemParser, _super);
        function BlockItemParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        BlockItemParser.prototype.feed = function (input) {
            return BlockItemParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        BlockItemParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 64) {
                            fieldParser = recon.parseAttr(input);
                            step = 2;
                        }
                        else if (c === 123) {
                            builder = builder || recon.recordBuilder();
                            valueParser = recon.parseRecord(input, builder);
                            step = 5;
                        }
                        else if (c === 91) {
                            builder = builder || recon.recordBuilder();
                            valueParser = recon.parseMarkup(input, builder);
                            step = 5;
                        }
                        else if (Recon.isIdentStartChar(c)) {
                            valueParser = recon.parseIdent(input);
                            step = 4;
                        }
                        else if (c === 34 || c === 39) {
                            valueParser = recon.parseString(input);
                            step = 4;
                        }
                        else if (c === 45 || c >= 48 && c <= 57) {
                            valueParser = recon.parseNumber(input);
                            step = 4;
                        }
                        else if (c === 37) {
                            valueParser = recon.parseData(input);
                            step = 4;
                        }
                        else if (c === 36) {
                            valueParser = recon.parseSelector(input);
                            step = 4;
                        }
                        else if (!builder) {
                            return codec.Parser.done(recon.extant());
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        if (!builder) {
                            return codec.Parser.done(recon.extant());
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                }
                if (step === 2) {
                    while (fieldParser.isCont() && !input.isEmpty()) {
                        fieldParser = fieldParser.feed(input);
                    }
                    if (fieldParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(fieldParser.bind());
                        fieldParser = void 0;
                        step = 3;
                    }
                    else if (fieldParser.isError()) {
                        return fieldParser.asError();
                    }
                }
                if (step === 3) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 1;
                        continue;
                    }
                    else if (input.isDone()) {
                        return codec.Parser.done(builder.bind());
                    }
                }
                if (step === 4) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 5) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 6) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (input.head() === 64) {
                            step = 1;
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.done(builder.bind());
                    }
                }
                break;
            } while (true);
            return new BlockItemParser(recon, builder, fieldParser, valueParser, step);
        };
        return BlockItemParser;
    }(codec.Parser));

    var InlineItemParser = (function (_super) {
        __extends(InlineItemParser, _super);
        function InlineItemParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        InlineItemParser.prototype.feed = function (input) {
            return InlineItemParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        InlineItemParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 64) {
                        fieldParser = recon.parseAttr(input);
                        step = 2;
                    }
                    else if (c === 123) {
                        if (builder) {
                            valueParser = recon.parseRecord(input, builder);
                            step = 5;
                        }
                        else {
                            valueParser = recon.parseRecord(input);
                            step = 4;
                        }
                    }
                    else if (c === 91) {
                        if (builder) {
                            valueParser = recon.parseMarkup(input, builder);
                            step = 5;
                        }
                        else {
                            valueParser = recon.parseMarkup(input);
                            step = 4;
                        }
                    }
                    else if (!builder) {
                        return codec.Parser.done(recon.extant());
                    }
                    else {
                        return codec.Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    if (!builder) {
                        return codec.Parser.done(recon.extant());
                    }
                    else {
                        return codec.Parser.done(builder.bind());
                    }
                }
            }
            if (step === 2) {
                while (fieldParser.isCont() && !input.isEmpty()) {
                    fieldParser = fieldParser.feed(input);
                }
                if (fieldParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(fieldParser.bind());
                    fieldParser = void 0;
                    step = 3;
                }
                else if (fieldParser.isError()) {
                    return fieldParser.asError();
                }
            }
            if (step === 3) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 123) {
                        valueParser = recon.parseRecord(input, builder);
                        step = 5;
                    }
                    else if (c === 91) {
                        valueParser = recon.parseMarkup(input, builder);
                        step = 5;
                    }
                    else {
                        return codec.Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.done(builder.bind());
                }
            }
            if (step === 4) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(recon.item(valueParser.bind()));
                    return codec.Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser;
                }
            }
            if (step === 5) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    return codec.Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser;
                }
            }
            return new InlineItemParser(recon, builder, fieldParser, valueParser, step);
        };
        return InlineItemParser;
    }(codec.Parser));

    var RecordParser = (function (_super) {
        __extends(RecordParser, _super);
        function RecordParser(recon, builder, keyParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._keyParser = keyParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        RecordParser.prototype.feed = function (input) {
            return RecordParser.parse(input, this._recon, this._builder, this._keyParser, this._valueParser, this._step);
        };
        RecordParser.parse = function (input, recon, builder, keyParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 123) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(123, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(123, input));
                }
            }
            block: do {
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        builder = builder || recon.recordBuilder();
                        if (c === 125) {
                            input = input.step();
                            return codec.Parser.done(builder.bind());
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 8;
                        }
                        else {
                            step = 3;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(125, input));
                    }
                }
                if (step === 3) {
                    if (!keyParser) {
                        keyParser = recon.parseBlockExpression(input);
                    }
                    while (keyParser.isCont() && !input.isEmpty()) {
                        keyParser = keyParser.feed(input);
                    }
                    if (keyParser.isDone()) {
                        step = 4;
                    }
                    else if (keyParser.isError()) {
                        return keyParser;
                    }
                }
                if (step === 4) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 58) {
                            input = input.step();
                            step = 5;
                        }
                        else {
                            builder.push(recon.item(keyParser.bind()));
                            keyParser = void 0;
                            step = 7;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(125, input));
                    }
                }
                if (step === 5) {
                    while (input.isCont() && Recon.isSpace(input.head())) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        step = 6;
                    }
                    else if (input.isDone()) {
                        builder.push(recon.slot(keyParser.bind()));
                        return codec.Parser.done(builder.bind());
                    }
                }
                if (step === 6) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.slot(keyParser.bind(), valueParser.bind()));
                        keyParser = void 0;
                        valueParser = void 0;
                        step = 7;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 7) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44 || c === 59 || Recon.isNewline(c)) {
                            input = input.step();
                            step = 2;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 8;
                        }
                        else if (c === 125) {
                            input = input.step();
                            return codec.Parser.done(builder.bind());
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected("'}', ';', ',', or newline", input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(125, input));
                    }
                }
                if (step === 8) {
                    while (input.isCont()) {
                        c = input.head();
                        if (!Recon.isNewline(c)) {
                            input = input.step();
                        }
                        else {
                            step = 2;
                            continue block;
                        }
                    }
                    if (input.isDone()) {
                        step = 2;
                        continue;
                    }
                }
                break;
            } while (true);
            return new RecordParser(recon, builder, keyParser, valueParser, step);
        };
        return RecordParser;
    }(codec.Parser));

    var MarkupParser = (function (_super) {
        __extends(MarkupParser, _super);
        function MarkupParser(recon, builder, textOutput, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._textOutput = textOutput;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        MarkupParser.prototype.feed = function (input) {
            return MarkupParser.parse(input, this._recon, this._builder, this._textOutput, this._valueParser, this._step);
        };
        MarkupParser.parse = function (input, recon, builder, textOutput, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 91) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(91, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(91, input));
                }
            }
            do {
                if (step === 2) {
                    while (input.isCont()) {
                        c = input.head();
                        if (c !== 64 && c !== 91 && c !== 92 && c !== 93
                            && c !== 123 && c !== 125) {
                            input = input.step();
                            textOutput = textOutput || recon.textOutput();
                            textOutput.write(c);
                        }
                        else {
                            break;
                        }
                    }
                    if (input.isCont()) {
                        if (c === 93) {
                            input = input.step();
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                            }
                            return codec.Parser.done(builder.bind());
                        }
                        else if (c === 64) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseInlineItem(input);
                            step = 3;
                        }
                        else if (c === 123) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseRecord(input, builder);
                            step = 4;
                        }
                        else if (c === 91) {
                            builder = builder || recon.recordBuilder();
                            if (textOutput) {
                                builder.push(recon.item(textOutput.bind()));
                                textOutput = void 0;
                            }
                            valueParser = recon.parseMarkup(input, builder);
                            step = 4;
                        }
                        else if (c === 92) {
                            input = input.step();
                            step = 5;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.unexpected(input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.unexpected(input));
                    }
                }
                if (step === 3) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 4) {
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (valueParser.isError()) {
                        return valueParser;
                    }
                }
                if (step === 5) {
                    if (input.isCont()) {
                        c = input.head();
                        textOutput = textOutput || recon.textOutput();
                        if (c === 34 || c === 36 || c === 39 || c === 47
                            || c === 64 || c === 91 || c === 92 || c === 93
                            || c === 123 || c === 125) {
                            input = input.step();
                            textOutput.write(c);
                            step = 2;
                        }
                        else if (c === 98) {
                            input = input.step();
                            textOutput.write(8);
                            step = 2;
                        }
                        else if (c === 102) {
                            input = input.step();
                            textOutput.write(12);
                            step = 2;
                        }
                        else if (c === 110) {
                            input = input.step();
                            textOutput.write(10);
                            step = 2;
                        }
                        else if (c === 114) {
                            input = input.step();
                            textOutput.write(13);
                            step = 2;
                        }
                        else if (c === 116) {
                            input = input.step();
                            textOutput.write(9);
                            step = 2;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected("escape character", input));
                        }
                        continue;
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected("escape character", input));
                    }
                }
                break;
            } while (true);
            return new MarkupParser(recon, builder, textOutput, valueParser, step);
        };
        return MarkupParser;
    }(codec.Parser));

    var DataParser = (function (_super) {
        __extends(DataParser, _super);
        function DataParser(recon, base64Parser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._base64Parser = base64Parser;
            _this._step = step;
            return _this;
        }
        DataParser.prototype.feed = function (input) {
            return DataParser.parse(input, this._recon, this._base64Parser, this._step);
        };
        DataParser.parse = function (input, recon, base64Parser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 37) {
                        input = input.step();
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(37, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(37, input));
                }
            }
            if (step === 2) {
                if (!base64Parser) {
                    base64Parser = codec.Base64.standard().parse(input, recon.dataOutput());
                }
                while (base64Parser.isCont() && !input.isEmpty()) {
                    base64Parser = base64Parser.feed(input);
                }
                if (base64Parser.isDone()) {
                    return base64Parser;
                }
                else if (base64Parser.isError()) {
                    return base64Parser;
                }
            }
            return new DataParser(recon, base64Parser, step);
        };
        return DataParser;
    }(codec.Parser));

    var IdentParser = (function (_super) {
        __extends(IdentParser, _super);
        function IdentParser(recon, output, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._step = step;
            return _this;
        }
        IdentParser.prototype.feed = function (input) {
            return IdentParser.parse(input, this._recon, this._output, this._step);
        };
        IdentParser.parse = function (input, recon, output, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (Recon.isIdentStartChar(c)) {
                        input = input.step();
                        output = output || recon.textOutput();
                        output = output.write(c);
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("identifier", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("identifier", input));
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isIdentChar(c))) {
                    input = input.step();
                    output.write(c);
                }
                if (!input.isEmpty()) {
                    return codec.Parser.done(recon.ident(output.bind()));
                }
            }
            return new IdentParser(recon, output, step);
        };
        return IdentParser;
    }(codec.Parser));

    var StringParser = (function (_super) {
        __extends(StringParser, _super);
        function StringParser(recon, output, quote, code, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._quote = quote;
            _this._code = code;
            _this._step = step;
            return _this;
        }
        StringParser.prototype.feed = function (input) {
            return StringParser.parse(input, this._recon, this._output, this._quote, this._code, this._step);
        };
        StringParser.parse = function (input, recon, output, quote, code, step) {
            if (quote === void 0) { quote = 0; }
            if (code === void 0) { code = 0; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 34 || c === 39 && (quote === c || quote === 0)) {
                        input = input.step();
                        output = output || recon.textOutput();
                        quote = c;
                        step = 2;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("string", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("string", input));
                }
            }
            string: do {
                if (step === 2) {
                    while (input.isCont()) {
                        c = input.head();
                        if (c >= 0x20 && c !== quote && c !== 92) {
                            input = input.step();
                            output.write(c);
                        }
                        else {
                            break;
                        }
                    }
                    if (input.isCont()) {
                        if (c === quote) {
                            input = input.step();
                            return codec.Parser.done(output.bind());
                        }
                        else if (c === 92) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected(quote, input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(quote, input));
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 34 || c === 36 || c === 39 || c === 47
                            || c === 64 || c === 91 || c === 92 || c === 93
                            || c === 123 || c === 125) {
                            input = input.step();
                            output.write(c);
                            step = 2;
                            continue;
                        }
                        else if (c === 98) {
                            input = input.step();
                            output.write(8);
                            step = 2;
                            continue;
                        }
                        else if (c === 102) {
                            input = input.step();
                            output.write(12);
                            step = 2;
                            continue;
                        }
                        else if (c === 110) {
                            input = input.step();
                            output.write(10);
                            step = 2;
                            continue;
                        }
                        else if (c === 114) {
                            input = input.step();
                            output.write(13);
                            step = 2;
                            continue;
                        }
                        else if (c === 116) {
                            input = input.step();
                            output.write(9);
                            step = 2;
                            continue;
                        }
                        else if (c === 117) {
                            input = input.step();
                            step = 4;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected("escape character", input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected("escape character", input));
                    }
                }
                if (step >= 4) {
                    do {
                        if (input.isCont()) {
                            c = input.head();
                            if (codec.Base16.isDigit(c)) {
                                input = input.step();
                                code = 16 * code + codec.Base16.decodeDigit(c);
                                if (step <= 6) {
                                    step += 1;
                                    continue;
                                }
                                else {
                                    output.write(code);
                                    code = 0;
                                    step = 2;
                                    continue string;
                                }
                            }
                            else {
                                return codec.Parser.error(codec.Diagnostic.expected("hex digit", input));
                            }
                        }
                        else if (input.isDone()) {
                            return codec.Parser.error(codec.Diagnostic.expected("hex digit", input));
                        }
                        break;
                    } while (true);
                }
                break;
            } while (true);
            return new StringParser(recon, output, quote, code, step);
        };
        return StringParser;
    }(codec.Parser));

    var NumberParser = (function (_super) {
        __extends(NumberParser, _super);
        function NumberParser(recon, sign, value, mode, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._sign = sign;
            _this._value = value;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        NumberParser.prototype.feed = function (input) {
            return NumberParser.parse(input, this._recon, this._sign, this._value, this._mode, this._step);
        };
        NumberParser.parse = function (input, recon, sign, value, mode, step) {
            if (sign === void 0) { sign = 1; }
            if (value === void 0) { value = 0; }
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 45) {
                        input = input.step();
                        sign = -1;
                    }
                    step = 2;
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("number", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 48) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c >= 49 && c <= 57) {
                        input = input.step();
                        value = sign * (c - 48);
                        step = 3;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        var newValue = 10 * value + sign * (c - 48);
                        if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {
                            value = newValue;
                            input = input.step();
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.message("integer overflow", input));
                        }
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    step = 4;
                }
                else if (input.isDone()) {
                    return codec.Parser.done(recon.num(value));
                }
            }
            if (step === 4) {
                if (input.isCont()) {
                    c = input.head();
                    if (mode > 0 && c === 46 || mode > 1 && (c === 69 || c === 101)) {
                        var output = codec.Unicode.stringOutput();
                        if (sign < 0 && value === 0) {
                            output = output.write(45).write(48);
                        }
                        else {
                            output = output.write("" + value);
                        }
                        return DecimalParser.parse(input, recon, output, mode);
                    }
                    else if (c === 120 && sign > 0 && value === 0) {
                        input = input.step();
                        return HexadecimalParser.parse(input, recon);
                    }
                    else {
                        return codec.Parser.done(recon.num(value));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.done(recon.num(value));
                }
            }
            return new NumberParser(recon, sign, value, mode, step);
        };
        NumberParser.parseInteger = function (input, recon) {
            return NumberParser.parse(input, recon, void 0, void 0, 0);
        };
        NumberParser.parseDecimal = function (input, recon) {
            return NumberParser.parse(input, recon, void 0, void 0, 1);
        };
        return NumberParser;
    }(codec.Parser));
    var DecimalParser = (function (_super) {
        __extends(DecimalParser, _super);
        function DecimalParser(recon, output, mode, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._output = output;
            _this._mode = mode;
            _this._step = step;
            return _this;
        }
        DecimalParser.prototype.feed = function (input) {
            return DecimalParser.parse(input, this._recon, this._output, this._mode, this._step);
        };
        DecimalParser.parse = function (input, recon, output, mode, step) {
            if (mode === void 0) { mode = 2; }
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 46) {
                        input = input.step();
                        output = output.write(c);
                        step = 2;
                    }
                    else if (mode > 1 && (c === 69 || c === 101)) {
                        input = input.step();
                        output = output.write(c);
                        step = 5;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("decimal or exponent", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("decimal or exponent", input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 3;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                }
            }
            if (step === 3) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (input.isCont()) {
                    if (mode > 1) {
                        step = 4;
                    }
                    else {
                        return codec.Parser.done(recon.num(output.bind()));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.done(recon.num(output.bind()));
                }
            }
            if (step === 4) {
                c = input.head();
                if (c === 69 || c === 101) {
                    input = input.step();
                    output = output.write(c);
                    step = 5;
                }
                else {
                    return codec.Parser.done(recon.num(output.bind()));
                }
            }
            if (step === 5) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 43 || c === 45) {
                        input = input.step();
                        output = output.write(c);
                    }
                    step = 6;
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            if (step === 6) {
                if (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                        step = 7;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected("digit", input));
                }
            }
            if (step === 7) {
                while (input.isCont()) {
                    c = input.head();
                    if (c >= 48 && c <= 57) {
                        input = input.step();
                        output = output.write(c);
                    }
                    else {
                        break;
                    }
                }
                if (!input.isEmpty()) {
                    return codec.Parser.done(recon.num(output.bind()));
                }
            }
            return new DecimalParser(recon, output, mode, step);
        };
        return DecimalParser;
    }(codec.Parser));
    var HexadecimalParser = (function (_super) {
        __extends(HexadecimalParser, _super);
        function HexadecimalParser(recon, value, size) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._value = value;
            _this._size = size;
            return _this;
        }
        HexadecimalParser.prototype.feed = function (input) {
            return HexadecimalParser.parse(input, this._recon, this._value, this._size);
        };
        HexadecimalParser.parse = function (input, recon, value, size) {
            if (value === void 0) { value = 0; }
            if (size === void 0) { size = 0; }
            var c = 0;
            while (input.isCont()) {
                c = input.head();
                if (codec.Base16.isDigit(c)) {
                    input = input.step();
                    value = 16 * value + codec.Base16.decodeDigit(c);
                    size += 1;
                }
                else {
                    break;
                }
            }
            if (!input.isEmpty()) {
                if (size > 0) {
                    if (size <= 8) {
                        return codec.Parser.done(recon.uint32(value));
                    }
                    else {
                        return codec.Parser.done(recon.uint64(value));
                    }
                }
                else {
                    return codec.Parser.error(codec.Diagnostic.expected("hex digit", input));
                }
            }
            return new HexadecimalParser(recon, value, size);
        };
        return HexadecimalParser;
    }(codec.Parser));

    var LambdaFuncParser = (function (_super) {
        __extends(LambdaFuncParser, _super);
        function LambdaFuncParser(recon, builder, bindingsParser, templateParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._bindingsParser = bindingsParser;
            _this._templateParser = templateParser;
            _this._step = step;
            return _this;
        }
        LambdaFuncParser.prototype.feed = function (input) {
            return LambdaFuncParser.parse(input, this._recon, this._builder, this._bindingsParser, this._templateParser, this._step);
        };
        LambdaFuncParser.parse = function (input, recon, builder, bindingsParser, templateParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!bindingsParser) {
                    bindingsParser = recon.parseConditionalOperator(input, builder);
                }
                while (bindingsParser.isCont() && !input.isEmpty()) {
                    bindingsParser = bindingsParser.feed(input);
                }
                if (bindingsParser.isDone()) {
                    step = 2;
                }
                else if (bindingsParser.isError()) {
                    return bindingsParser.asError();
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 62) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        return bindingsParser;
                    }
                }
                else if (input.isDone()) {
                    return bindingsParser;
                }
            }
            if (step === 3) {
                if (!templateParser) {
                    templateParser = recon.parseConditionalOperator(input);
                }
                while (templateParser.isCont() && !input.isEmpty()) {
                    templateParser = templateParser.feed(input);
                }
                if (templateParser.isDone()) {
                    var bindings = bindingsParser.bind();
                    var template = templateParser.bind();
                    return codec.Parser.done(recon.lambda(bindings, template));
                }
                else if (templateParser.isError()) {
                    return templateParser.asError();
                }
            }
            return new LambdaFuncParser(recon, builder, bindingsParser, templateParser, step);
        };
        return LambdaFuncParser;
    }(codec.Parser));

    var ConditionalOperatorParser = (function (_super) {
        __extends(ConditionalOperatorParser, _super);
        function ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._ifParser = ifParser;
            _this._thenParser = thenParser;
            _this._elseParser = elseParser;
            _this._step = step;
            return _this;
        }
        ConditionalOperatorParser.prototype.feed = function (input) {
            return ConditionalOperatorParser.parse(input, this._recon, this._builder, this._ifParser, this._thenParser, this._elseParser, this._step);
        };
        ConditionalOperatorParser.parse = function (input, recon, builder, ifParser, thenParser, elseParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!ifParser) {
                    ifParser = recon.parseOrOperator(input, builder);
                }
                while (ifParser.isCont() && !input.isEmpty()) {
                    ifParser = ifParser.feed(input);
                }
                if (ifParser.isDone()) {
                    step = 2;
                }
                else if (ifParser.isError()) {
                    return ifParser.asError();
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 63) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        return ifParser;
                    }
                }
                else if (input.isDone()) {
                    return ifParser;
                }
            }
            if (step === 3) {
                if (!thenParser) {
                    thenParser = recon.parseConditionalOperator(input, builder);
                }
                while (thenParser.isCont() && !input.isEmpty()) {
                    thenParser = thenParser.feed(input);
                }
                if (thenParser.isDone()) {
                    step = 4;
                }
                else if (thenParser.isError()) {
                    return thenParser.asError();
                }
            }
            if (step === 4) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 58) {
                        input = input.step();
                        step = 5;
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(58, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(58, input));
                }
            }
            if (step === 5) {
                if (!elseParser) {
                    elseParser = recon.parseConditionalOperator(input, builder);
                }
                while (elseParser.isCont() && !input.isEmpty()) {
                    elseParser = elseParser.feed(input);
                }
                if (elseParser.isDone()) {
                    var ifTerm = ifParser.bind();
                    var thenTerm = thenParser.bind();
                    var elseTerm = elseParser.bind();
                    return codec.Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));
                }
                else if (elseParser.isError()) {
                    return elseParser.asError();
                }
            }
            return new ConditionalOperatorParser(recon, builder, ifParser, thenParser, elseParser, step);
        };
        return ConditionalOperatorParser;
    }(codec.Parser));

    var OrOperatorParser = (function (_super) {
        __extends(OrOperatorParser, _super);
        function OrOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        OrOperatorParser.prototype.feed = function (input) {
            return OrOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        OrOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseAndOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 124) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseAndOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = codec.Parser.done(recon.or(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new OrOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return OrOperatorParser;
    }(codec.Parser));

    var AndOperatorParser = (function (_super) {
        __extends(AndOperatorParser, _super);
        function AndOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        AndOperatorParser.prototype.feed = function (input) {
            return AndOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        AndOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseOrOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 38) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseOrOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = codec.Parser.done(recon.and(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new AndOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return AndOperatorParser;
    }(codec.Parser));

    var BitwiseOrOperatorParser = (function (_super) {
        __extends(BitwiseOrOperatorParser, _super);
        function BitwiseOrOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseOrOperatorParser.prototype.feed = function (input) {
            return BitwiseOrOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseOrOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseXorOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 124) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 124) {
                            return lhsParser;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.unexpected(input));
                    }
                }
                if (step === 4) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseXorOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = codec.Parser.done(recon.bitwiseOr(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseOrOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseOrOperatorParser;
    }(codec.Parser));

    var BitwiseXorOperatorParser = (function (_super) {
        __extends(BitwiseXorOperatorParser, _super);
        function BitwiseXorOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseXorOperatorParser.prototype.feed = function (input) {
            return BitwiseXorOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseXorOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseBitwiseAndOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 94) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseBitwiseAndOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = codec.Parser.done(recon.bitwiseXor(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseXorOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseXorOperatorParser;
    }(codec.Parser));

    var BitwiseAndOperatorParser = (function (_super) {
        __extends(BitwiseAndOperatorParser, _super);
        function BitwiseAndOperatorParser(recon, builder, lhsParser, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        BitwiseAndOperatorParser.prototype.feed = function (input) {
            return BitwiseAndOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._rhsParser, this._step);
        };
        BitwiseAndOperatorParser.parse = function (input, recon, builder, lhsParser, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseComparisonOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 38) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 38) {
                            return lhsParser;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.unexpected(input));
                    }
                }
                if (step === 4) {
                    if (!rhsParser) {
                        rhsParser = recon.parseComparisonOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        lhsParser = codec.Parser.done(recon.bitwiseAnd(lhs, rhs));
                        rhsParser = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new BitwiseAndOperatorParser(recon, builder, lhsParser, rhsParser, step);
        };
        return BitwiseAndOperatorParser;
    }(codec.Parser));

    var ComparisonOperatorParser = (function (_super) {
        __extends(ComparisonOperatorParser, _super);
        function ComparisonOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        ComparisonOperatorParser.prototype.feed = function (input) {
            return ComparisonOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        ComparisonOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!lhsParser) {
                    lhsParser = recon.parseAttrExpression(input, builder);
                }
                while (lhsParser.isCont() && !input.isEmpty()) {
                    lhsParser = lhsParser.feed(input);
                }
                if (lhsParser.isDone()) {
                    step = 2;
                }
                else if (lhsParser.isError()) {
                    return lhsParser.asError();
                }
            }
            if (step === 2) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 33) {
                        input = input.step();
                        step = 3;
                    }
                    else if (c === 60) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c === 62) {
                        input = input.step();
                        step = 5;
                    }
                    else if (c === 61) {
                        input = input.step();
                        step = 6;
                    }
                    else {
                        return lhsParser;
                    }
                }
                else if (input.isDone()) {
                    return lhsParser;
                }
            }
            if (step === 3) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "!=";
                        step = 7;
                    }
                    else {
                        operator = "!";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            if (step === 4) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "<=";
                        step = 7;
                    }
                    else {
                        operator = "<";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            if (step === 5) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = ">=";
                        step = 7;
                    }
                    else {
                        operator = ">";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            if (step === 6) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 61) {
                        input = input.step();
                        operator = "==";
                        step = 7;
                    }
                    else if (c === 62) {
                        return lhsParser;
                    }
                    else {
                        operator = "=";
                        step = 7;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            if (step === 7) {
                if (!rhsParser) {
                    rhsParser = recon.parseAttrExpression(input, builder);
                }
                while (rhsParser.isCont() && !input.isEmpty()) {
                    rhsParser = rhsParser.feed(input);
                }
                if (rhsParser.isDone()) {
                    var lhs = lhsParser.bind();
                    var rhs = rhsParser.bind();
                    if (operator === "<") {
                        return codec.Parser.done(recon.lt(lhs, rhs));
                    }
                    else if (operator === "<=") {
                        return codec.Parser.done(recon.le(lhs, rhs));
                    }
                    else if (operator === "==") {
                        return codec.Parser.done(recon.eq(lhs, rhs));
                    }
                    else if (operator === "!=") {
                        return codec.Parser.done(recon.ne(lhs, rhs));
                    }
                    else if (operator === ">=") {
                        return codec.Parser.done(recon.ge(lhs, rhs));
                    }
                    else if (operator === ">") {
                        return codec.Parser.done(recon.gt(lhs, rhs));
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.message(operator, input));
                    }
                }
                else if (rhsParser.isError()) {
                    return rhsParser.asError();
                }
            }
            return new ComparisonOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return ComparisonOperatorParser;
    }(codec.Parser));

    var AttrExpressionParser = (function (_super) {
        __extends(AttrExpressionParser, _super);
        function AttrExpressionParser(recon, builder, fieldParser, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._fieldParser = fieldParser;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        AttrExpressionParser.prototype.feed = function (input) {
            return AttrExpressionParser.parse(input, this._recon, this._builder, this._fieldParser, this._valueParser, this._step);
        };
        AttrExpressionParser.parse = function (input, recon, builder, fieldParser, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 64) {
                            step = 2;
                        }
                        else if (c === 123 || c === 91) {
                            builder = builder || recon.recordBuilder();
                            step = 5;
                        }
                        else if (c === 40) {
                            step = 4;
                        }
                        else if (c === 33 || c === 34 || c === 36 || c === 37
                            || c === 39 || c === 43 || c === 45
                            || c >= 48 && c <= 57 || c === 126
                            || Recon.isIdentStartChar(c)) {
                            step = 3;
                        }
                        else if (!builder) {
                            return codec.Parser.done(recon.extant());
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        if (!builder) {
                            return codec.Parser.done(recon.extant());
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                }
                if (step === 2) {
                    if (!fieldParser) {
                        fieldParser = recon.parseAttr(input);
                    }
                    while (fieldParser.isCont() && !input.isEmpty()) {
                        fieldParser = fieldParser.feed(input);
                    }
                    if (fieldParser.isDone()) {
                        builder = builder || recon.recordBuilder();
                        builder.push(fieldParser.bind());
                        fieldParser = void 0;
                        step = 1;
                        continue;
                    }
                    else if (fieldParser.isError()) {
                        return fieldParser.asError();
                    }
                }
                if (step === 3) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 4) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input, builder);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        if (!builder) {
                            builder = recon.valueBuilder();
                            builder.push(recon.item(valueParser.bind()));
                        }
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 5) {
                    if (!valueParser) {
                        valueParser = recon.parseAdditiveOperator(input, builder);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        valueParser = void 0;
                        step = 6;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 6) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 64) {
                            step = 1;
                            continue;
                        }
                        else {
                            return codec.Parser.done(builder.bind());
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.done(builder.bind());
                    }
                }
                break;
            } while (true);
            return new AttrExpressionParser(recon, builder, fieldParser, valueParser, step);
        };
        return AttrExpressionParser;
    }(codec.Parser));

    var AdditiveOperatorParser = (function (_super) {
        __extends(AdditiveOperatorParser, _super);
        function AdditiveOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        AdditiveOperatorParser.prototype.feed = function (input) {
            return AdditiveOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        AdditiveOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parseMultiplicativeOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 43) {
                            input = input.step();
                            operator = "+";
                            step = 3;
                        }
                        else if (c === 45) {
                            input = input.step();
                            operator = "-";
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parseMultiplicativeOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        if (operator === "+") {
                            lhsParser = codec.Parser.done(recon.plus(lhs, rhs));
                        }
                        else if (operator === "-") {
                            lhsParser = codec.Parser.done(recon.minus(lhs, rhs));
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.message(operator, input));
                        }
                        rhsParser = void 0;
                        operator = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new AdditiveOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return AdditiveOperatorParser;
    }(codec.Parser));

    var MultiplicativeOperatorParser = (function (_super) {
        __extends(MultiplicativeOperatorParser, _super);
        function MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._lhsParser = lhsParser;
            _this._operator = operator;
            _this._rhsParser = rhsParser;
            _this._step = step;
            return _this;
        }
        MultiplicativeOperatorParser.prototype.feed = function (input) {
            return MultiplicativeOperatorParser.parse(input, this._recon, this._builder, this._lhsParser, this._operator, this._rhsParser, this._step);
        };
        MultiplicativeOperatorParser.parse = function (input, recon, builder, lhsParser, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            do {
                if (step === 1) {
                    if (!lhsParser) {
                        lhsParser = recon.parsePrefixOperator(input, builder);
                    }
                    while (lhsParser.isCont() && !input.isEmpty()) {
                        lhsParser = lhsParser.feed(input);
                    }
                    if (lhsParser.isDone()) {
                        step = 2;
                    }
                    else if (lhsParser.isError()) {
                        return lhsParser.asError();
                    }
                }
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 42) {
                            input = input.step();
                            operator = "*";
                            step = 3;
                        }
                        else if (c === 47) {
                            input = input.step();
                            operator = "/";
                            step = 3;
                        }
                        else if (c === 37) {
                            input = input.step();
                            operator = "%";
                            step = 3;
                        }
                        else {
                            return lhsParser;
                        }
                    }
                    else if (input.isDone()) {
                        return lhsParser;
                    }
                }
                if (step === 3) {
                    if (!rhsParser) {
                        rhsParser = recon.parsePrefixOperator(input, builder);
                    }
                    while (rhsParser.isCont() && !input.isEmpty()) {
                        rhsParser = rhsParser.feed(input);
                    }
                    if (rhsParser.isDone()) {
                        var lhs = lhsParser.bind();
                        var rhs = rhsParser.bind();
                        if (operator === "*") {
                            lhsParser = codec.Parser.done(recon.times(lhs, rhs));
                        }
                        else if (operator === "/") {
                            lhsParser = codec.Parser.done(recon.divide(lhs, rhs));
                        }
                        else if (operator === "%") {
                            lhsParser = codec.Parser.done(recon.modulo(lhs, rhs));
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.message(operator, input));
                        }
                        rhsParser = void 0;
                        operator = void 0;
                        step = 2;
                        continue;
                    }
                    else if (rhsParser.isError()) {
                        return rhsParser.asError();
                    }
                }
                break;
            } while (true);
            return new MultiplicativeOperatorParser(recon, builder, lhsParser, operator, rhsParser, step);
        };
        return MultiplicativeOperatorParser;
    }(codec.Parser));

    var PrefixOperatorParser = (function (_super) {
        __extends(PrefixOperatorParser, _super);
        function PrefixOperatorParser(recon, builder, operator, rhsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._operator = operator;
            _this._operandParser = rhsParser;
            _this._step = step;
            return _this;
        }
        PrefixOperatorParser.prototype.feed = function (input) {
            return PrefixOperatorParser.parse(input, this._recon, this._builder, this._operator, this._operandParser, this._step);
        };
        PrefixOperatorParser.parse = function (input, recon, builder, operator, rhsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 33) {
                        input = input.step();
                        operator = "!";
                    }
                    else if (c === 126) {
                        input = input.step();
                        operator = "~";
                    }
                    else if (c === 45) {
                        input = input.step();
                        operator = "-";
                    }
                    else if (c === 43) {
                        input = input.step();
                        operator = "+";
                    }
                    else {
                        return recon.parseInvokeOperator(input, builder);
                    }
                    step = 2;
                }
                else if (input.isDone()) {
                    return recon.parseInvokeOperator(input, builder);
                }
            }
            if (step === 2) {
                if (!rhsParser) {
                    rhsParser = recon.parsePrefixOperator(input, builder);
                }
                while (rhsParser.isCont() && !input.isEmpty()) {
                    rhsParser = rhsParser.feed(input);
                }
                if (rhsParser.isDone()) {
                    var operand = rhsParser.bind();
                    if (!recon.isDistinct(operand)) {
                        return codec.Parser.error(codec.Diagnostic.expected("value", input));
                    }
                    else if (operator === "!") {
                        return codec.Parser.done(recon.not(operand));
                    }
                    else if (operator === "~") {
                        return codec.Parser.done(recon.bitwiseNot(operand));
                    }
                    else if (operator === "-") {
                        return codec.Parser.done(recon.negative(operand));
                    }
                    else if (operator === "+") {
                        return codec.Parser.done(recon.positive(operand));
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.message(operator, input));
                    }
                }
                else if (rhsParser.isError()) {
                    return rhsParser.asError();
                }
            }
            return new PrefixOperatorParser(recon, builder, operator, rhsParser, step);
        };
        return PrefixOperatorParser;
    }(codec.Parser));

    var InvokeOperatorParser = (function (_super) {
        __extends(InvokeOperatorParser, _super);
        function InvokeOperatorParser(recon, builder, exprParser, argsParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._exprParser = exprParser;
            _this._argsParser = argsParser;
            _this._step = step;
            return _this;
        }
        InvokeOperatorParser.prototype.feed = function (input) {
            return InvokeOperatorParser.parse(input, this._recon, this._builder, this._exprParser, this._argsParser, this._step);
        };
        InvokeOperatorParser.parse = function (input, recon, builder, exprParser, argsParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                if (!exprParser) {
                    exprParser = recon.parsePrimary(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    step = 2;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            do {
                if (step === 2) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 40) {
                            input = input.step();
                            step = 3;
                        }
                        else {
                            return exprParser;
                        }
                    }
                    else if (input.isDone()) {
                        return exprParser;
                    }
                }
                if (step === 3) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 41) {
                            input = input.step();
                            var expr = exprParser.bind();
                            exprParser = codec.Parser.done(recon.invoke(expr, recon.extant()));
                            step = 2;
                            continue;
                        }
                        else {
                            step = 4;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(41, input));
                    }
                }
                if (step === 4) {
                    if (!argsParser) {
                        argsParser = recon.parseBlock(input);
                    }
                    while (argsParser.isCont() && !input.isEmpty()) {
                        argsParser = argsParser.feed(input);
                    }
                    if (argsParser.isDone()) {
                        step = 5;
                    }
                    else if (argsParser.isError()) {
                        return argsParser.asError();
                    }
                }
                if (step === 5) {
                    while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 41) {
                            input = input.step();
                            var expr = exprParser.bind();
                            var args = argsParser.bind();
                            exprParser = codec.Parser.done(recon.invoke(expr, args));
                            argsParser = void 0;
                            step = 2;
                            continue;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected(41, input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(41, input));
                    }
                }
                break;
            } while (true);
            return new InvokeOperatorParser(recon, builder, exprParser, argsParser, step);
        };
        return InvokeOperatorParser;
    }(codec.Parser));

    var PrimaryParser = (function (_super) {
        __extends(PrimaryParser, _super);
        function PrimaryParser(recon, builder, exprParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._exprParser = exprParser;
            _this._step = step;
            return _this;
        }
        PrimaryParser.prototype.feed = function (input) {
            return PrimaryParser.parse(input, this._recon, this._builder, this._exprParser, this._step);
        };
        PrimaryParser.parse = function (input, recon, builder, exprParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 40) {
                        input = input.step();
                        step = 3;
                    }
                    else {
                        step = 2;
                    }
                }
                else if (input.isDone()) {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!exprParser) {
                    exprParser = recon.parseLiteral(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    return exprParser;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            if (step === 3) {
                if (!exprParser) {
                    exprParser = recon.parseBlockExpression(input, builder);
                }
                while (exprParser.isCont() && !input.isEmpty()) {
                    exprParser = exprParser.feed(input);
                }
                if (exprParser.isDone()) {
                    step = 4;
                }
                else if (exprParser.isError()) {
                    return exprParser.asError();
                }
            }
            do {
                if (step === 4) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 44) {
                            input = input.step();
                            if (exprParser) {
                                if (!builder) {
                                    builder = recon.recordBuilder();
                                    builder.push(recon.item(exprParser.bind()));
                                }
                                exprParser = void 0;
                            }
                            step = 5;
                        }
                        else if (c === 41) {
                            input = input.step();
                            if (exprParser) {
                                return exprParser;
                            }
                            else {
                                return codec.Parser.done(builder.bind());
                            }
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected(41, input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(41, input));
                    }
                }
                if (step === 5) {
                    if (!exprParser) {
                        exprParser = recon.parseBlockExpression(input, builder);
                    }
                    while (exprParser.isCont() && !input.isEmpty()) {
                        exprParser = exprParser.feed(input);
                    }
                    if (exprParser.isDone()) {
                        exprParser = void 0;
                        step = 4;
                        continue;
                    }
                    else if (exprParser.isError()) {
                        return exprParser.asError();
                    }
                }
                break;
            } while (true);
            return new PrimaryParser(recon, builder, exprParser, step);
        };
        return PrimaryParser;
    }(codec.Parser));

    var LiteralParser = (function (_super) {
        __extends(LiteralParser, _super);
        function LiteralParser(recon, builder, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        LiteralParser.prototype.feed = function (input) {
            return LiteralParser.parse(input, this._recon, this._builder, this._valueParser, this._step);
        };
        LiteralParser.parse = function (input, recon, builder, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 40) {
                        input = input.step();
                        step = 4;
                    }
                    else if (c === 123) {
                        builder = builder || recon.recordBuilder();
                        valueParser = recon.parseRecord(input, builder);
                        step = 3;
                    }
                    else if (c === 91) {
                        builder = builder || recon.recordBuilder();
                        valueParser = recon.parseMarkup(input, builder);
                        step = 3;
                    }
                    else if (Recon.isIdentStartChar(c)) {
                        valueParser = recon.parseIdent(input);
                        step = 2;
                    }
                    else if (c === 34 || c === 39) {
                        valueParser = recon.parseString(input);
                        step = 2;
                    }
                    else if (c === 45 || c >= 48 && c <= 57) {
                        valueParser = recon.parseNumber(input);
                        step = 2;
                    }
                    else if (c === 37) {
                        valueParser = recon.parseData(input);
                        step = 2;
                    }
                    else if (c === 36) {
                        valueParser = recon.parseSelector(input);
                        step = 2;
                    }
                    else if (!builder) {
                        return codec.Parser.done(recon.extant());
                    }
                    else {
                        return codec.Parser.done(builder.bind());
                    }
                }
                else if (input.isDone()) {
                    if (!builder) {
                        return codec.Parser.done(recon.extant());
                    }
                    else {
                        return codec.Parser.done(builder.bind());
                    }
                }
            }
            if (step === 2) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    builder = builder || recon.valueBuilder();
                    builder.push(recon.item(valueParser.bind()));
                    return codec.Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 3) {
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    return codec.Parser.done(builder.bind());
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 4) {
                if (!valueParser) {
                    valueParser = recon.parseBlockExpression(input);
                }
                while (valueParser.isCont() && !input.isEmpty()) {
                    valueParser = valueParser.feed(input);
                }
                if (valueParser.isDone()) {
                    step = 5;
                }
                else if (valueParser.isError()) {
                    return valueParser.asError();
                }
            }
            if (step === 5) {
                while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {
                    input = input.step();
                }
                if (input.isCont()) {
                    if (c === 41) {
                        input = input.step();
                        builder = builder || recon.valueBuilder();
                        builder.push(recon.item(valueParser.bind()));
                        return codec.Parser.done(builder.bind());
                    }
                    else {
                        return codec.Parser.error(codec.Diagnostic.expected(41, input));
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(41, input));
                }
            }
            return new LiteralParser(recon, builder, valueParser, step);
        };
        return LiteralParser;
    }(codec.Parser));

    var SelectorParser = (function (_super) {
        __extends(SelectorParser, _super);
        function SelectorParser(recon, builder, selector, valueParser, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._builder = builder;
            _this._selector = selector;
            _this._valueParser = valueParser;
            _this._step = step;
            return _this;
        }
        SelectorParser.prototype.feed = function (input) {
            return SelectorParser.parse(input, this._recon, this._builder, this._selector, this._valueParser, this._step);
        };
        SelectorParser.parse = function (input, recon, builder, selector, valueParser, step) {
            if (step === void 0) { step = 1; }
            var c = 0;
            if (step === 1) {
                while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                    input = input.step();
                }
                if (input.isCont() && c === 36) {
                    input = input.step();
                    selector = selector || recon.selector();
                    step = 2;
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.expected(36, input));
                }
            }
            if (step === 2) {
                if (input.isCont()) {
                    c = input.head();
                    if (c === 91) {
                        input = input.step();
                        step = 8;
                    }
                    else if (c === 64) {
                        input = input.step();
                        step = 7;
                    }
                    else if (c === 58) {
                        input = input.step();
                        step = 6;
                    }
                    else if (c === 42) {
                        input = input.step();
                        step = 5;
                    }
                    else if (c === 35) {
                        input = input.step();
                        step = 4;
                    }
                    else {
                        step = 3;
                    }
                }
                else if (input.isDone()) {
                    return codec.Parser.error(codec.Diagnostic.unexpected(input));
                }
            }
            do {
                if (step === 3) {
                    if (!valueParser) {
                        valueParser = recon.parseLiteral(input, recon.valueBuilder());
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.get(selector, valueParser.bind());
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 4) {
                    if (!valueParser) {
                        valueParser = recon.parseInteger(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.value(recon.getItem(selector, valueParser.bind()));
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 5) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 58) {
                            input = input.step();
                            selector = recon.keys(selector);
                            step = 10;
                        }
                        else if (c === 42) {
                            input = input.step();
                            selector = recon.descendants(selector);
                            step = 10;
                        }
                        else {
                            selector = recon.children(selector);
                            step = 10;
                        }
                    }
                    else if (input.isDone()) {
                        selector = recon.children(selector);
                        step = 10;
                    }
                }
                if (step === 6) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 42) {
                            input = input.step();
                            selector = recon.values(selector);
                            step = 10;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected(42, input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(42, input));
                    }
                }
                if (step === 7) {
                    if (!valueParser) {
                        valueParser = recon.parseIdent(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        selector = recon.getAttr(selector, valueParser.bind());
                        valueParser = void 0;
                        step = 10;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 8) {
                    if (!valueParser) {
                        valueParser = recon.parseBlockExpression(input);
                    }
                    while (valueParser.isCont() && !input.isEmpty()) {
                        valueParser = valueParser.feed(input);
                    }
                    if (valueParser.isDone()) {
                        step = 9;
                    }
                    else if (valueParser.isError()) {
                        return valueParser.asError();
                    }
                }
                if (step === 9) {
                    while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {
                        input = input.step();
                    }
                    if (input.isCont()) {
                        if (c === 93) {
                            input = input.step();
                            selector = recon.filter(selector, valueParser.bind());
                            valueParser = void 0;
                            step = 10;
                        }
                        else {
                            return codec.Parser.error(codec.Diagnostic.expected(93, input));
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.expected(93, input));
                    }
                }
                if (step === 10) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 91) {
                            input = input.step();
                            step = 8;
                            continue;
                        }
                        else if (c === 35) {
                            input = input.step();
                            step = 4;
                            continue;
                        }
                        else if (c === 46) {
                            input = input.step();
                            step = 11;
                        }
                        else if (builder) {
                            builder.push(recon.item(selector));
                            return codec.Parser.done(builder.bind());
                        }
                        else {
                            return codec.Parser.done(selector);
                        }
                    }
                    else if (input.isDone()) {
                        if (builder) {
                            builder.push(recon.item(selector));
                            return codec.Parser.done(builder.bind());
                        }
                        else {
                            return codec.Parser.done(selector);
                        }
                    }
                }
                if (step === 11) {
                    if (input.isCont()) {
                        c = input.head();
                        if (c === 64) {
                            input = input.step();
                            step = 7;
                            continue;
                        }
                        else if (c === 58) {
                            input = input.step();
                            step = 6;
                            continue;
                        }
                        else if (c === 42) {
                            input = input.step();
                            step = 5;
                            continue;
                        }
                        else {
                            step = 3;
                            continue;
                        }
                    }
                    else if (input.isDone()) {
                        return codec.Parser.error(codec.Diagnostic.unexpected(input));
                    }
                }
                break;
            } while (true);
            return new SelectorParser(recon, builder, selector, valueParser, step);
        };
        return SelectorParser;
    }(codec.Parser));

    var ReconParser = (function () {
        function ReconParser() {
        }
        ReconParser.prototype.parseBlock = function (input) {
            return BlockParser.parse(input, this);
        };
        ReconParser.prototype.parseAttr = function (input) {
            return AttrParser.parse(input, this);
        };
        ReconParser.prototype.parseBlockItem = function (input) {
            return BlockItemParser.parse(input, this);
        };
        ReconParser.prototype.parseInlineItem = function (input) {
            return InlineItemParser.parse(input, this);
        };
        ReconParser.prototype.parseRecord = function (input, builder) {
            return RecordParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseMarkup = function (input, builder) {
            return MarkupParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseData = function (input) {
            return DataParser.parse(input, this);
        };
        ReconParser.prototype.parseIdent = function (input) {
            return IdentParser.parse(input, this);
        };
        ReconParser.prototype.parseString = function (input) {
            return StringParser.parse(input, this);
        };
        ReconParser.prototype.parseNumber = function (input) {
            return NumberParser.parse(input, this);
        };
        ReconParser.prototype.parseInteger = function (input) {
            return NumberParser.parseInteger(input, this);
        };
        ReconParser.prototype.parseBlockExpression = function (input, builder) {
            return this.parseLambdaFunc(input, builder);
        };
        ReconParser.prototype.parseLambdaFunc = function (input, builder) {
            return LambdaFuncParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseConditionalOperator = function (input, builder) {
            return ConditionalOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseOrOperator = function (input, builder) {
            return OrOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAndOperator = function (input, builder) {
            return AndOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseOrOperator = function (input, builder) {
            return BitwiseOrOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseXorOperator = function (input, builder) {
            return BitwiseXorOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseBitwiseAndOperator = function (input, builder) {
            return BitwiseAndOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseComparisonOperator = function (input, builder) {
            return ComparisonOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAttrExpression = function (input, builder) {
            return AttrExpressionParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseAdditiveOperator = function (input, builder) {
            return AdditiveOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseMultiplicativeOperator = function (input, builder) {
            return MultiplicativeOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parsePrefixOperator = function (input, builder) {
            return PrefixOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseInvokeOperator = function (input, builder) {
            return InvokeOperatorParser.parse(input, this, builder);
        };
        ReconParser.prototype.parsePrimary = function (input, builder) {
            return PrimaryParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseLiteral = function (input, builder) {
            return LiteralParser.parse(input, this, builder);
        };
        ReconParser.prototype.parseSelector = function (input, builder) {
            return SelectorParser.parse(input, this, builder);
        };
        ReconParser.prototype.blockParser = function () {
            return new BlockParser(this);
        };
        ReconParser.prototype.parseBlockString = function (string) {
            var input = codec.Unicode.stringInput(string);
            while (input.isCont() && Recon.isWhitespace(input.head())) {
                input = input.step();
            }
            var parser = this.parseBlock(input);
            if (parser.isDone()) {
                while (input.isCont() && Recon.isWhitespace(input.head())) {
                    input = input.step();
                }
            }
            if (input.isCont() && !parser.isError()) {
                parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        ReconParser.prototype.parseNumberString = function (string) {
            var input = codec.Unicode.stringInput(string);
            while (input.isCont() && Recon.isWhitespace(input.head())) {
                input = input.step();
            }
            var parser = this.parseNumber(input);
            if (parser.isDone()) {
                while (input.isCont() && Recon.isWhitespace(input.head())) {
                    input = input.step();
                }
            }
            if (input.isCont() && !parser.isError()) {
                parser = codec.Parser.error(codec.Diagnostic.unexpected(input));
            }
            return parser.bind();
        };
        return ReconParser;
    }());

    var ReconStructureParser = (function (_super) {
        __extends(ReconStructureParser, _super);
        function ReconStructureParser() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReconStructureParser.prototype.isDistinct = function (value) {
            return value.isDistinct();
        };
        ReconStructureParser.prototype.item = function (value) {
            return value;
        };
        ReconStructureParser.prototype.value = function (item) {
            return item.toValue();
        };
        ReconStructureParser.prototype.attr = function (key, value) {
            return structure.Attr.of.apply(structure.Attr, arguments);
        };
        ReconStructureParser.prototype.slot = function (key, value) {
            return structure.Slot.of.apply(structure.Slot, arguments);
        };
        ReconStructureParser.prototype.valueBuilder = function () {
            return structure.Value.builder();
        };
        ReconStructureParser.prototype.recordBuilder = function () {
            return structure.Record.create();
        };
        ReconStructureParser.prototype.dataOutput = function () {
            return structure.Data.output();
        };
        ReconStructureParser.prototype.textOutput = function () {
            return structure.Text.output();
        };
        ReconStructureParser.prototype.ident = function (value) {
            if (value instanceof structure.Text) {
                var string = value.stringValue();
                if (string === "true") {
                    return structure.Bool.from(true);
                }
                else if (string === "false") {
                    return structure.Bool.from(false);
                }
            }
            return value;
        };
        ReconStructureParser.prototype.num = function (value) {
            if (typeof value === "number") {
                return structure.Num.from(value);
            }
            else if (typeof value === "string") {
                return structure.Num.from(+value);
            }
            else {
                throw new TypeError("" + value);
            }
        };
        ReconStructureParser.prototype.uint32 = function (value) {
            return structure.Num.uint32(value);
        };
        ReconStructureParser.prototype.uint64 = function (value) {
            return structure.Num.uint64(value);
        };
        ReconStructureParser.prototype.bool = function (value) {
            return structure.Bool.from(value);
        };
        ReconStructureParser.prototype.selector = function () {
            return structure.Selector.identity();
        };
        ReconStructureParser.prototype.extant = function () {
            return structure.Value.extant();
        };
        ReconStructureParser.prototype.absent = function () {
            return structure.Value.absent();
        };
        ReconStructureParser.prototype.conditional = function (ifTerm, thenTerm, elseTerm) {
            return ifTerm.conditional(thenTerm, elseTerm);
        };
        ReconStructureParser.prototype.or = function (lhs, rhs) {
            return new structure.OrOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.and = function (lhs, rhs) {
            return new structure.AndOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.bitwiseOr = function (lhs, rhs) {
            return new structure.BitwiseOrOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.bitwiseXor = function (lhs, rhs) {
            return new structure.BitwiseXorOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.bitwiseAnd = function (lhs, rhs) {
            return new structure.BitwiseAndOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.lt = function (lhs, rhs) {
            return new structure.LtOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.le = function (lhs, rhs) {
            return new structure.LeOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.eq = function (lhs, rhs) {
            return new structure.EqOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.ne = function (lhs, rhs) {
            return new structure.NeOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.ge = function (lhs, rhs) {
            return new structure.GeOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.gt = function (lhs, rhs) {
            return new structure.GtOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.plus = function (lhs, rhs) {
            return new structure.PlusOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.minus = function (lhs, rhs) {
            return new structure.MinusOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.times = function (lhs, rhs) {
            return new structure.TimesOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.divide = function (lhs, rhs) {
            return new structure.DivideOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.modulo = function (lhs, rhs) {
            return new structure.ModuloOperator(lhs, rhs);
        };
        ReconStructureParser.prototype.not = function (rhs) {
            return new structure.NotOperator(rhs);
        };
        ReconStructureParser.prototype.bitwiseNot = function (rhs) {
            return new structure.BitwiseNotOperator(rhs);
        };
        ReconStructureParser.prototype.negative = function (rhs) {
            if (rhs instanceof structure.Num) {
                return rhs.negative();
            }
            else {
                return new structure.NegativeOperator(rhs);
            }
        };
        ReconStructureParser.prototype.positive = function (rhs) {
            return new structure.PositiveOperator(rhs);
        };
        ReconStructureParser.prototype.invoke = function (func, args) {
            return new structure.InvokeOperator(func, args);
        };
        ReconStructureParser.prototype.lambda = function (bindings, template) {
            return bindings.lambda(template);
        };
        ReconStructureParser.prototype.get = function (selector, key) {
            return selector.get(key);
        };
        ReconStructureParser.prototype.getAttr = function (selector, key) {
            return selector.getAttr(key);
        };
        ReconStructureParser.prototype.getItem = function (selector, index) {
            return selector.getItem(index);
        };
        ReconStructureParser.prototype.children = function (selector) {
            return structure.Selector.literal(selector).children();
        };
        ReconStructureParser.prototype.descendants = function (selector) {
            return structure.Selector.literal(selector).descendants();
        };
        ReconStructureParser.prototype.keys = function (selector) {
            return structure.Selector.literal(selector).keys();
        };
        ReconStructureParser.prototype.values = function (selector) {
            return structure.Selector.literal(selector).values();
        };
        ReconStructureParser.prototype.filter = function (selector, predicate) {
            return selector.filter(predicate);
        };
        return ReconStructureParser;
    }(ReconParser));

    var AttrWriter = (function (_super) {
        __extends(AttrWriter, _super);
        function AttrWriter(recon, key, value, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._value = value;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        AttrWriter.prototype.pull = function (output) {
            return AttrWriter.write(output, this._recon, this._key, this._value, this._part, this._step);
        };
        AttrWriter.sizeOf = function (recon, key, value) {
            var size = 0;
            size += 1;
            size += recon.sizeOfValue(key);
            if (!recon.isExtant(recon.item(value))) {
                size += 1;
                size += recon.sizeOfBlockValue(value);
                size += 1;
            }
            return size;
        };
        AttrWriter.write = function (output, recon, key, value, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(64);
                step = 2;
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    if (recon.isExtant(recon.item(value))) {
                        return codec.Writer.done();
                    }
                    else {
                        step = 3;
                    }
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3 && output.isCont()) {
                output = output.write(40);
                step = 4;
            }
            if (step === 4) {
                if (!part) {
                    part = recon.writeBlockValue(value, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 5;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 5 && output.isCont()) {
                output = output.write(41);
                return codec.Writer.done();
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new AttrWriter(recon, key, value, part, step);
        };
        return AttrWriter;
    }(codec.Writer));

    var SlotWriter = (function (_super) {
        __extends(SlotWriter, _super);
        function SlotWriter(recon, key, value, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._value = value;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        SlotWriter.prototype.pull = function (output) {
            return SlotWriter.write(output, this._recon, this._key, this._value, this._part, this._step);
        };
        SlotWriter.sizeOf = function (recon, key, value) {
            var size = 0;
            size += recon.sizeOfValue(key);
            size += 1;
            if (!recon.isExtant(recon.item(value))) {
                size += recon.sizeOfValue(value);
            }
            return size;
        };
        SlotWriter.write = function (output, recon, key, value, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(58);
                if (recon.isExtant(recon.item(value))) {
                    return codec.Writer.done();
                }
                else {
                    step = 3;
                }
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(value, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return codec.Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new SlotWriter(recon, key, value, part, step);
        };
        return SlotWriter;
    }(codec.Writer));

    var BlockWriter = (function (_super) {
        __extends(BlockWriter, _super);
        function BlockWriter(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._items = items;
            _this._inBlock = inBlock;
            _this._inMarkup = inMarkup;
            _this._inBraces = inBraces;
            _this._inBrackets = inBrackets;
            _this._first = first;
            _this._markupSafe = markupSafe;
            _this._item = item;
            _this._next = next;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        BlockWriter.prototype.pull = function (output) {
            return BlockWriter.write(output, this._recon, this._items, this._inBlock, this._inMarkup, this._inBraces, this._inBrackets, this._first, this._markupSafe, this._item, this._next, this._part, this._step);
        };
        BlockWriter.sizeOf = function (recon, items, inBlock, inMarkup) {
            var size = 0;
            var inBraces = false;
            var inBrackets = false;
            var first = true;
            var markupSafe = true;
            var next;
            while (next || items.hasNext()) {
                var item = void 0;
                if (!next) {
                    item = items.next().value;
                }
                else {
                    item = next;
                    next = void 0;
                }
                if (items.hasNext()) {
                    next = items.next().value;
                }
                if (recon.isExpression(item)) {
                    markupSafe = false;
                }
                if (inBrackets && recon.isAttr(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    size += 1;
                    inBrackets = false;
                }
                if (recon.isAttr(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    else if (inBrackets) {
                        size += 1;
                        inBrackets = false;
                    }
                    size += recon.sizeOfItem(item);
                    first = false;
                }
                else if (inBrackets && recon.isText(item)) {
                    if (inBraces) {
                        size += 1;
                        inBraces = false;
                    }
                    size += recon.sizeOfMarkupText(item);
                }
                else if (inBraces) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += BlockWriter.sizeOfBlockItem(recon, item);
                }
                else if (inBrackets) {
                    if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
                        size += recon.sizeOfBlock(recon.items(item), false, true);
                        if (next && recon.isText(next)) {
                            size += recon.sizeOfMarkupText(next);
                            next = void 0;
                        }
                        else if (next && !recon.isAttr(next)) {
                            size += 1;
                            inBraces = true;
                            first = true;
                        }
                        else {
                            size += 1;
                            inBrackets = false;
                        }
                    }
                    else {
                        size += 1;
                        size += recon.sizeOfItem(item);
                        inBraces = true;
                        first = false;
                    }
                }
                else if (markupSafe && recon.isText(item) && next && !recon.isField(next)
                    && !recon.isText(next) && !recon.isBool(next)) {
                    size += 1;
                    size += recon.sizeOfMarkupText(item);
                    inBrackets = true;
                }
                else if (inBlock && !inBraces) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += BlockWriter.sizeOfBlockItem(recon, item);
                }
                else if (inMarkup && recon.isText(item) && !next) {
                    size += 1;
                    size += recon.sizeOfMarkupText(item);
                    size += 1;
                }
                else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)
                    && (!first && !next || next && recon.isAttr(next))) {
                    if (!first && (recon.isText(item) && recon.isIdent(item)
                        || recon.isNum(item) || recon.isBool(item))) {
                        size += 1;
                    }
                    size += recon.sizeOfItem(item);
                }
                else {
                    size += 1;
                    size += recon.sizeOfItem(item);
                    inBraces = true;
                    first = false;
                }
            }
            if (inBraces) {
                size += 1;
            }
            if (inBrackets) {
                size += 1;
            }
            return size;
        };
        BlockWriter.sizeOfBlockItem = function (recon, item) {
            var size = 0;
            if (recon.isField(item)) {
                size += recon.sizeOfSlot(recon.key(item), recon.value(item));
            }
            else {
                size += recon.sizeOfItem(item);
            }
            return size;
        };
        BlockWriter.write = function (output, recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step) {
            if (inBraces === void 0) { inBraces = false; }
            if (inBrackets === void 0) { inBrackets = false; }
            if (first === void 0) { first = true; }
            if (markupSafe === void 0) { markupSafe = true; }
            if (step === void 0) { step = 1; }
            do {
                if (step === 1) {
                    if (!next && !items.hasNext()) {
                        step = 10;
                        break;
                    }
                    else {
                        if (!next) {
                            item = items.next().value;
                        }
                        else {
                            item = next;
                            next = void 0;
                        }
                        if (items.hasNext()) {
                            next = items.next().value;
                        }
                        if (recon.isExpression(item)) {
                            markupSafe = false;
                        }
                        step = 2;
                    }
                }
                if (step === 2 && output.isCont()) {
                    if (inBrackets && recon.isAttr(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        step = 3;
                    }
                    else {
                        step = 4;
                    }
                }
                if (step === 3 && output.isCont()) {
                    output = output.write(93);
                    inBrackets = false;
                    step = 4;
                }
                if (step === 4 && output.isCont()) {
                    if (recon.isAttr(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        else if (inBrackets) {
                            output = output.write(93);
                            inBrackets = false;
                        }
                        part = recon.writeItem(item, output);
                        first = false;
                        step = 7;
                    }
                    else if (inBrackets && recon.isText(item)) {
                        if (inBraces) {
                            output = output.write(125);
                            inBraces = false;
                        }
                        part = recon.writeMarkupText(item, output);
                        step = 7;
                    }
                    else if (inBraces) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = BlockWriter.writeBlockItem(output, recon, item);
                        step = 7;
                    }
                    else if (inBrackets) {
                        if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {
                            part = recon.writeBlock(recon.items(item), output, false, true);
                            step = 5;
                        }
                        else {
                            output = output.write(123);
                            part = recon.writeItem(item, output);
                            inBraces = true;
                            first = false;
                            step = 7;
                        }
                    }
                    else if (markupSafe && recon.isText(item) && next && !recon.isField(next)
                        && !recon.isText(next) && !recon.isBool(next)) {
                        output = output.write(91);
                        part = recon.writeMarkupText(item, output);
                        inBrackets = true;
                        step = 7;
                    }
                    else if (inBlock && !inBraces) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = BlockWriter.writeBlockItem(output, recon, item);
                        step = 7;
                    }
                    else if (inMarkup && recon.isText(item) && !next) {
                        output = output.write(91);
                        part = recon.writeMarkupText(item, output);
                        step = 8;
                    }
                    else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)
                        && (!first && !next || next && recon.isAttr(next))) {
                        if (!first && (recon.isText(item) && recon.isIdent(item)
                            || recon.isNum(item) || recon.isBool(item))) {
                            output = output.write(32);
                        }
                        part = recon.writeItem(item, output);
                        step = 7;
                    }
                    else {
                        output = output.write(123);
                        part = recon.writeItem(item, output);
                        inBraces = true;
                        first = false;
                        step = 7;
                    }
                }
                if (step === 5) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 6;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 6 && output.isCont()) {
                    if (next && recon.isText(next)) {
                        part = recon.writeMarkupText(next, output);
                        next = void 0;
                        step = 7;
                    }
                    else if (next && !recon.isAttr(next)) {
                        output = output.write(123);
                        inBraces = true;
                        first = true;
                        step = 1;
                        continue;
                    }
                    else {
                        output = output.write(93);
                        inBrackets = false;
                        step = 1;
                        continue;
                    }
                }
                if (step === 7) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 1;
                        continue;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 8) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 9;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                if (step === 9 && output.isCont()) {
                    output = output.write(93);
                    step = 1;
                    continue;
                }
                break;
            } while (true);
            if (step === 10) {
                if (inBraces) {
                    if (output.isCont()) {
                        output = output.write(125);
                        step = 11;
                    }
                }
                else {
                    step = 11;
                }
            }
            if (step === 11) {
                if (inBrackets) {
                    if (output.isCont()) {
                        output = output.write(93);
                        return codec.Writer.done();
                    }
                }
                else {
                    return codec.Writer.done();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new BlockWriter(recon, items, inBlock, inMarkup, inBraces, inBrackets, first, markupSafe, item, next, part, step);
        };
        BlockWriter.writeBlockItem = function (output, recon, item) {
            if (recon.isField(item)) {
                return recon.writeSlot(recon.key(item), recon.value(item), output);
            }
            else {
                return recon.writeItem(item, output);
            }
        };
        return BlockWriter;
    }(codec.Writer));

    var PrimaryWriter = (function (_super) {
        __extends(PrimaryWriter, _super);
        function PrimaryWriter(recon, items, inParens, first, item, next, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._items = items;
            _this._inParens = inParens;
            _this._first = first;
            _this._item = item;
            _this._next = next;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        PrimaryWriter.prototype.pull = function (output) {
            return PrimaryWriter.write(output, this._recon, this._items, this._inParens, this._first, this._item, this._next, this._part, this._step);
        };
        PrimaryWriter.sizeOf = function (recon, items) {
            var size = 0;
            var inParens = false;
            var first = true;
            var next;
            while (next || items.hasNext()) {
                var item = void 0;
                if (!next) {
                    item = items.next().value;
                }
                else {
                    item = next;
                    next = void 0;
                }
                if (items.hasNext()) {
                    next = items.next().value;
                }
                if (!inParens && !first) {
                    size += 1;
                }
                if (recon.isAttr(item)) {
                    if (inParens) {
                        size += 1;
                        inParens = false;
                    }
                    size += recon.sizeOfItem(item);
                    first = false;
                }
                else if (inParens) {
                    if (!first) {
                        size += 1;
                    }
                    else {
                        first = false;
                    }
                    size += recon.sizeOfBlockItem(item);
                }
                else if (recon.isValue(item) && !recon.isRecord(item)
                    && (!first && !next || next && recon.isAttr(next))) {
                    size += recon.sizeOfItem(item);
                }
                else {
                    size += 1;
                    size += recon.sizeOfItem(item);
                    inParens = true;
                    first = false;
                }
            }
            if (inParens) {
                size += 1;
            }
            return size;
        };
        PrimaryWriter.write = function (output, recon, items, inParens, first, item, next, part, step) {
            if (inParens === void 0) { inParens = false; }
            if (first === void 0) { first = true; }
            if (step === void 0) { step = 1; }
            do {
                if (step === 1) {
                    if (!next && !items.hasNext()) {
                        step = 5;
                        break;
                    }
                    else {
                        if (!next) {
                            item = items.next().value;
                        }
                        else {
                            item = next;
                            next = void 0;
                        }
                        if (items.hasNext()) {
                            next = items.next().value;
                        }
                        step = 2;
                    }
                }
                if (step === 2 && output.isCont()) {
                    if (!inParens && !first) {
                        output = output.write(32);
                    }
                    step = 3;
                }
                if (step === 3 && output.isCont()) {
                    if (recon.isAttr(item)) {
                        if (inParens) {
                            output = output.write(41);
                            inParens = false;
                        }
                        part = recon.writeItem(item, output);
                        first = false;
                        step = 4;
                    }
                    else if (inParens) {
                        if (!first) {
                            output = output.write(44);
                        }
                        else {
                            first = false;
                        }
                        part = recon.writeBlockItem(item, output);
                        step = 4;
                    }
                    else if (recon.isValue(item) && !recon.isRecord(item)
                        && (!first && !next || next && recon.isAttr(next))) {
                        part = recon.writeItem(item, output);
                        step = 4;
                    }
                    else {
                        output = output.write(40);
                        part = recon.writeItem(item, output);
                        inParens = true;
                        first = false;
                        step = 4;
                    }
                }
                if (step === 4) {
                    part = part.pull(output);
                    if (part.isDone()) {
                        part = void 0;
                        step = 1;
                        continue;
                    }
                    else if (part.isError()) {
                        return part.asError();
                    }
                }
                break;
            } while (true);
            if (step === 5) {
                if (inParens) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return codec.Writer.done();
                    }
                }
                else {
                    return codec.Writer.done();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new PrimaryWriter(recon, items, inParens, first, item, next, part, step);
        };
        return PrimaryWriter;
    }(codec.Writer));

    var MarkupTextWriter = (function (_super) {
        __extends(MarkupTextWriter, _super);
        function MarkupTextWriter(text, index, escape, step) {
            var _this = _super.call(this) || this;
            _this._text = text;
            _this._index = index;
            _this._escape = escape;
            _this._step = step;
            return _this;
        }
        MarkupTextWriter.prototype.pull = function (output) {
            return MarkupTextWriter.write(output, this._text, this._index, this._escape, this._step);
        };
        MarkupTextWriter.sizeOf = function (text) {
            var size = 0;
            for (var i = 0, n = text.length; i < n; i = text.offsetByCodePoints(i, 1)) {
                var c = text.codePointAt(i);
                if (c === void 0) {
                    c = text.charCodeAt(i);
                }
                if (c === 36 || c === 64 || c === 91 || c === 92
                    || c === 93 || c === 123 || c === 125 || c === 8
                    || c === 12 || c === 10 || c === 13 || c === 9) {
                    size += 2;
                }
                else if (c < 0x20) {
                    size += 6;
                }
                else {
                    size += codec.Utf8.sizeOf(c);
                }
            }
            return size;
        };
        MarkupTextWriter.write = function (output, text, index, escape, step) {
            if (index === void 0) { index = 0; }
            if (escape === void 0) { escape = 0; }
            if (step === void 0) { step = 1; }
            var length = text.length;
            while (output.isCont()) {
                if (step === 1) {
                    if (index < length) {
                        var c = text.codePointAt(index);
                        if (c === void 0) {
                            c = text.charCodeAt(index);
                        }
                        index = text.offsetByCodePoints(index, 1);
                        if (c === 36 || c === 64 || c === 91 || c === 92
                            || c === 93 || c === 123 || c === 125) {
                            output = output.write(92);
                            escape = c;
                            step = 2;
                        }
                        else if (c === 8) {
                            output = output.write(92);
                            escape = 98;
                            step = 2;
                        }
                        else if (c === 12) {
                            output = output.write(92);
                            escape = 102;
                            step = 2;
                        }
                        else if (c === 10) {
                            output = output.write(92);
                            escape = 110;
                            step = 2;
                        }
                        else if (c === 13) {
                            output = output.write(92);
                            escape = 114;
                            step = 2;
                        }
                        else if (c === 9) {
                            output = output.write(92);
                            escape = 116;
                            step = 2;
                        }
                        else if (c < 0x20) {
                            output = output.write(92);
                            escape = c;
                            step = 3;
                        }
                        else {
                            output = output.write(c);
                        }
                    }
                    else {
                        return codec.Writer.done();
                    }
                }
                else if (step === 2) {
                    output = output.write(escape);
                    escape = 0;
                    step = 1;
                }
                else if (step === 3) {
                    output = output.write(117);
                    step = 4;
                }
                else if (step === 4) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));
                    step = 5;
                }
                else if (step === 5) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));
                    step = 6;
                }
                else if (step === 6) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));
                    step = 7;
                }
                else if (step === 7) {
                    output = output.write(codec.Base16.uppercase().encodeDigit(escape & 0xf));
                    escape = 0;
                    step = 1;
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new MarkupTextWriter(text, index, escape, step);
        };
        return MarkupTextWriter;
    }(codec.Writer));

    var DataWriter = (function (_super) {
        __extends(DataWriter, _super);
        function DataWriter(array, part, step) {
            var _this = _super.call(this) || this;
            _this._array = array;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        DataWriter.prototype.pull = function (output) {
            return DataWriter.write(output, this._array, this._part, this._step);
        };
        DataWriter.sizeOf = function (length) {
            return 1 + ((Math.floor(length * 4 / 3) + 3) & ~3);
        };
        DataWriter.write = function (output, array, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(37);
                step = 2;
            }
            if (step === 2) {
                if (!part) {
                    part = codec.Base64.standard().writeUint8Array(array, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    return codec.Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new DataWriter(array, part, step);
        };
        return DataWriter;
    }(codec.Writer));

    var IdentWriter = (function (_super) {
        __extends(IdentWriter, _super);
        function IdentWriter(ident, index) {
            var _this = _super.call(this) || this;
            _this._ident = ident;
            _this._index = index;
            return _this;
        }
        IdentWriter.prototype.pull = function (output) {
            return IdentWriter.write(output, this._ident, this._index);
        };
        IdentWriter.sizeOf = function (ident) {
            return codec.Utf8.sizeOf(ident);
        };
        IdentWriter.write = function (output, ident, index) {
            if (index === void 0) { index = 0; }
            var c;
            var length = ident.length;
            if (length === 0) {
                return codec.Writer.error(new codec.WriterException("empty identifier"));
            }
            if (index === 0 && output.isCont()) {
                c = ident.codePointAt(0);
                if (c === void 0) {
                    c = ident.charCodeAt(0);
                }
                if (Recon.isIdentStartChar(c)) {
                    output = output.write(c);
                    index = ident.offsetByCodePoints(0, 1);
                }
            }
            while (index < length && output.isCont()) {
                c = ident.codePointAt(index);
                if (c === void 0) {
                    c = ident.charCodeAt(index);
                }
                if (Recon.isIdentChar(c)) {
                    output = output.write(c);
                    index = ident.offsetByCodePoints(index, 1);
                }
                else {
                    return codec.Writer.error(new codec.WriterException("invalid identifier"));
                }
            }
            if (index >= length) {
                return codec.Writer.done();
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new IdentWriter(ident, index);
        };
        return IdentWriter;
    }(codec.Writer));

    var StringWriter = (function (_super) {
        __extends(StringWriter, _super);
        function StringWriter(string, index, escape, step) {
            var _this = _super.call(this) || this;
            _this._string = string;
            _this._index = index;
            _this._escape = escape;
            _this._step = step;
            return _this;
        }
        StringWriter.prototype.pull = function (output) {
            return StringWriter.write(output, this._string, this._index, this._escape, this._step);
        };
        StringWriter.sizeOf = function (string) {
            var size = 0;
            size += 1;
            for (var i = 0, n = string.length; i < n; i = string.offsetByCodePoints(i, 1)) {
                var c = string.codePointAt(i);
                if (c === void 0) {
                    c = string.charCodeAt(i);
                }
                if (c === 34 || c === 92 || c === 8 || c === 12
                    || c === 10 || c === 13 || c === 9) {
                    size += 2;
                }
                else if (c < 0x20) {
                    size += 6;
                }
                else {
                    size += codec.Utf8.sizeOf(c);
                }
            }
            size += 1;
            return size;
        };
        StringWriter.write = function (output, string, index, escape, step) {
            if (index === void 0) { index = 0; }
            if (escape === void 0) { escape = 0; }
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(34);
                step = 2;
            }
            var length = string.length;
            while (step >= 2 && step <= 8 && output.isCont()) {
                if (step === 2) {
                    if (index < length) {
                        var c = string.codePointAt(index);
                        if (c === void 0) {
                            c = string.charCodeAt(index);
                        }
                        index = string.offsetByCodePoints(index, 1);
                        if (c === 34 || c === 92) {
                            output = output.write(92);
                            escape = c;
                            step = 3;
                        }
                        else if (c === 8) {
                            output = output.write(92);
                            escape = 98;
                            step = 3;
                        }
                        else if (c === 12) {
                            output = output.write(92);
                            escape = 102;
                            step = 3;
                        }
                        else if (c === 10) {
                            output = output.write(92);
                            escape = 110;
                            step = 3;
                        }
                        else if (c === 13) {
                            output = output.write(92);
                            escape = 114;
                            step = 3;
                        }
                        else if (c === 9) {
                            output = output.write(92);
                            escape = 116;
                            step = 3;
                        }
                        else if (c < 0x20) {
                            output = output.write('\\');
                            escape = c;
                            step = 4;
                        }
                        else {
                            output = output.write(c);
                        }
                    }
                    else {
                        step = 9;
                        break;
                    }
                }
                else if (step === 3) {
                    output = output.write(escape);
                    escape = 0;
                    step = 2;
                }
                else if (step === 4) {
                    output = output.write(117);
                    step = 5;
                }
                else if (step === 5) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));
                    step = 6;
                }
                else if (step === 6) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));
                    step = 7;
                }
                else if (step === 7) {
                    output = output.write(codec.Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));
                    step = 8;
                }
                else if (step === 8) {
                    output = output.write(codec.Base16.uppercase().encodeDigit(escape & 0xf));
                    escape = 0;
                    step = 2;
                }
            }
            if (step === 9 && output.isCont()) {
                output = output.write(34);
                return codec.Writer.done();
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new StringWriter(string, index, escape, step);
        };
        return StringWriter;
    }(codec.Writer));

    var LambdaFuncWriter = (function (_super) {
        __extends(LambdaFuncWriter, _super);
        function LambdaFuncWriter(recon, bindings, template, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._bindings = bindings;
            _this._template = template;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        LambdaFuncWriter.prototype.pull = function (output) {
            return LambdaFuncWriter.write(output, this._recon, this._bindings, this._template, this._part, this._step);
        };
        LambdaFuncWriter.sizeOf = function (recon, bindings, template) {
            var size = 0;
            size += recon.sizeOfPrimary(bindings);
            size += 4;
            size += recon.sizeOfValue(template);
            return size;
        };
        LambdaFuncWriter.write = function (output, recon, bindings, template, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writePrimary(bindings, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(32);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(61);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(62);
                step = 5;
            }
            if (step === 5 && output.isCont()) {
                output = output.write(32);
                step = 6;
            }
            if (step === 6) {
                if (part == null) {
                    part = recon.writeValue(template, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return codec.Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new LambdaFuncWriter(recon, bindings, template, part, step);
        };
        return LambdaFuncWriter;
    }(codec.Writer));

    var ConditionalOperatorWriter = (function (_super) {
        __extends(ConditionalOperatorWriter, _super);
        function ConditionalOperatorWriter(recon, ifTerm, thenTerm, elseTerm, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._ifTerm = ifTerm;
            _this._thenTerm = thenTerm;
            _this._elseTerm = elseTerm;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        ConditionalOperatorWriter.prototype.pull = function (output) {
            return ConditionalOperatorWriter.write(output, this._recon, this._ifTerm, this._thenTerm, this._elseTerm, this._precedence, this._part, this._step);
        };
        ConditionalOperatorWriter.sizeOf = function (recon, ifTerm, thenTerm, elseTerm, precedence) {
            var size = 0;
            if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                size += 1;
                size += recon.sizeOfItem(ifTerm);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(ifTerm);
            }
            size += 3;
            size += recon.sizeOfItem(thenTerm);
            size += 3;
            size += recon.sizeOfItem(elseTerm);
            return size;
        };
        ConditionalOperatorWriter.write = function (output, recon, ifTerm, thenTerm, elseTerm, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(ifTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(32);
                step = 5;
            }
            if (step === 5 && output.isCont()) {
                output = output.write(63);
                step = 6;
            }
            if (step === 6 && output.isCont()) {
                output = output.write(32);
                step = 7;
            }
            if (step === 7) {
                if (!part) {
                    part = recon.writeItem(thenTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 8;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 8 && output.isCont()) {
                output = output.write(32);
                step = 9;
            }
            if (step === 9 && output.isCont()) {
                output = output.write(58);
                step = 10;
            }
            if (step === 10 && output.isCont()) {
                output = output.write(32);
                step = 11;
            }
            if (step === 11) {
                if (!part) {
                    part = recon.writeItem(elseTerm, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return codec.Writer.done();
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new ConditionalOperatorWriter(recon, ifTerm, thenTerm, elseTerm, precedence, part, step);
        };
        return ConditionalOperatorWriter;
    }(codec.Writer));

    var InfixOperatorWriter = (function (_super) {
        __extends(InfixOperatorWriter, _super);
        function InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._lhs = lhs;
            _this._operator = operator;
            _this._rhs = rhs;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        InfixOperatorWriter.prototype.pull = function (output) {
            return InfixOperatorWriter.write(output, this._recon, this._lhs, this._operator, this._rhs, this._precedence, this._part, this._step);
        };
        InfixOperatorWriter.sizeOf = function (recon, lhs, operator, rhs, precedence) {
            var size = 0;
            if (recon.precedence(lhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(lhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(lhs);
            }
            size += 1;
            size += codec.Utf8.sizeOf(operator);
            size += 1;
            if (recon.precedence(rhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(rhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(rhs);
            }
            return size;
        };
        InfixOperatorWriter.write = function (output, recon, lhs, operator, rhs, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(lhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(lhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(lhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(32);
                step = 5;
            }
            if (step === 5) {
                if (!part) {
                    part = codec.Unicode.writeString(operator, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 6;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 6 && output.isCont()) {
                output = output.write(32);
                step = 7;
            }
            if (step === 7) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 8;
                    }
                }
                else {
                    step = 8;
                }
            }
            if (step === 8) {
                if (!part) {
                    part = recon.writeItem(rhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 9;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 9) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return codec.Writer.done();
                    }
                }
                else {
                    return codec.Writer.done();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new InfixOperatorWriter(recon, lhs, operator, rhs, precedence, part, step);
        };
        return InfixOperatorWriter;
    }(codec.Writer));

    var PrefixOperatorWriter = (function (_super) {
        __extends(PrefixOperatorWriter, _super);
        function PrefixOperatorWriter(recon, operator, rhs, precedence, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._operator = operator;
            _this._rhs = rhs;
            _this._precedence = precedence;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        PrefixOperatorWriter.prototype.pull = function (output) {
            return PrefixOperatorWriter.write(output, this._recon, this._operator, this._rhs, this._precedence, this._part, this._step);
        };
        PrefixOperatorWriter.sizeOf = function (recon, operator, rhs, precedence) {
            var size = 0;
            size += codec.Utf8.sizeOf(operator);
            if (recon.precedence(rhs) < precedence) {
                size += 1;
                size += recon.sizeOfItem(rhs);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(rhs);
            }
            return size;
        };
        PrefixOperatorWriter.write = function (output, recon, operator, rhs, precedence, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = codec.Unicode.writeString(operator, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 3;
                    }
                }
                else {
                    step = 3;
                }
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeItem(rhs, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4) {
                if (recon.precedence(rhs) < precedence) {
                    if (output.isCont()) {
                        output = output.write(41);
                        return codec.Writer.done();
                    }
                }
                else {
                    return codec.Writer.done();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new PrefixOperatorWriter(recon, operator, rhs, precedence, part, step);
        };
        return PrefixOperatorWriter;
    }(codec.Writer));

    var InvokeOperatorWriter = (function (_super) {
        __extends(InvokeOperatorWriter, _super);
        function InvokeOperatorWriter(recon, func, args, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._func = func;
            _this._args = args;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        InvokeOperatorWriter.prototype.pull = function (output) {
            return InvokeOperatorWriter.write(output, this._recon, this._func, this._args, this._part, this._step);
        };
        InvokeOperatorWriter.sizeOf = function (recon, func, args) {
            var size = 0;
            size += recon.sizeOfValue(func);
            size += 1;
            size += recon.sizeOfBlockValue(args);
            size += 1;
            return size;
        };
        InvokeOperatorWriter.write = function (output, recon, func, args, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (!part) {
                    part = recon.writeValue(func, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 2;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 2 && output.isCont()) {
                output = output.write(40);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeBlockValue(args, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(41);
                return codec.Writer.done();
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new InvokeOperatorWriter(recon, func, args, part, step);
        };
        return InvokeOperatorWriter;
    }(codec.Writer));

    var LiteralSelectorWriter = (function (_super) {
        __extends(LiteralSelectorWriter, _super);
        function LiteralSelectorWriter(recon, item, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._item = item;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        LiteralSelectorWriter.prototype.pull = function (output) {
            return LiteralSelectorWriter.write(output, this._recon, this._item, this._then, this._part, this._step);
        };
        LiteralSelectorWriter.sizeOf = function (recon, item, then) {
            var size = 0;
            if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                size += 1;
                size += recon.sizeOfItem(item);
                size += 1;
            }
            else {
                size += recon.sizeOfItem(item);
            }
            size += recon.sizeOfThen(then);
            return size;
        };
        LiteralSelectorWriter.write = function (output, recon, item, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1) {
                if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                    if (output.isCont()) {
                        output = output.write(40);
                        step = 2;
                    }
                }
                else {
                    step = 2;
                }
            }
            if (step === 2) {
                if (!part) {
                    part = recon.writeItem(item, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 3;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 3) {
                if (recon.precedence(item) < recon.precedence(recon.item(then))) {
                    if (output.isCont()) {
                        output = output.write(41);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4) {
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new LiteralSelectorWriter(recon, item, then, part, step);
        };
        return LiteralSelectorWriter;
    }(codec.Writer));

    var GetSelectorWriter = (function (_super) {
        __extends(GetSelectorWriter, _super);
        function GetSelectorWriter(recon, key, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetSelectorWriter.prototype.pull = function (output) {
            return GetSelectorWriter.write(output, this._recon, this._key, this._then, this._part, this._step);
        };
        GetSelectorWriter.sizeOf = function (recon, key, then) {
            var size = 1;
            if (recon.isRecord(recon.item(key))) {
                size += 1;
                size += recon.sizeOfBlockValue(key);
                size += 1;
            }
            else {
                size += recon.sizeOfValue(key);
            }
            size += recon.sizeOfThen(then);
            return size;
        };
        GetSelectorWriter.write = function (output, recon, key, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3) {
                if (recon.isRecord(recon.item(key))) {
                    if (output.isCont()) {
                        output = output.write(123);
                        step = 4;
                    }
                }
                else {
                    step = 4;
                }
            }
            if (step === 4) {
                if (!part) {
                    if (recon.isRecord(recon.item(key))) {
                        part = recon.writeBlockValue(key, output);
                    }
                    else {
                        part = recon.writeValue(key, output);
                    }
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 5;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 5) {
                if (recon.isRecord(recon.item(key))) {
                    if (output.isCont()) {
                        output = output.write(125);
                        step = 6;
                    }
                }
                else {
                    step = 6;
                }
            }
            if (step === 6) {
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new GetSelectorWriter(recon, key, then, part, step);
        };
        GetSelectorWriter.writeThen = function (output, recon, key, then) {
            return GetSelectorWriter.write(output, recon, key, then, void 0, 2);
        };
        return GetSelectorWriter;
    }(codec.Writer));

    var GetAttrSelectorWriter = (function (_super) {
        __extends(GetAttrSelectorWriter, _super);
        function GetAttrSelectorWriter(recon, key, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._key = key;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetAttrSelectorWriter.prototype.pull = function (output) {
            return GetAttrSelectorWriter.write(output, this._recon, this._key, this._then, this._part, this._step);
        };
        GetAttrSelectorWriter.sizeOf = function (recon, key, then) {
            var size = 2;
            size += recon.sizeOfValue(key);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetAttrSelectorWriter.write = function (output, recon, key, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(64);
                step = 4;
            }
            if (step === 4) {
                if (!part) {
                    part = recon.writeValue(key, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return recon.writeThen(then, output);
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new GetAttrSelectorWriter(recon, key, then, part, step);
        };
        GetAttrSelectorWriter.writeThen = function (output, recon, key, then) {
            return GetAttrSelectorWriter.write(output, recon, key, then, void 0, 2);
        };
        return GetAttrSelectorWriter;
    }(codec.Writer));

    var GetItemSelectorWriter = (function (_super) {
        __extends(GetItemSelectorWriter, _super);
        function GetItemSelectorWriter(recon, index, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._index = index;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        GetItemSelectorWriter.prototype.pull = function (output) {
            return GetItemSelectorWriter.write(output, this._recon, this._index, this._then, this._part, this._step);
        };
        GetItemSelectorWriter.sizeOf = function (recon, index, then) {
            var size = 2;
            size += recon.sizeOfValue(index);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetItemSelectorWriter.sizeOfThen = function (recon, index, then) {
            var size = 1;
            size += recon.sizeOfValue(index);
            size += recon.sizeOfThen(then);
            return size;
        };
        GetItemSelectorWriter.write = function (output, recon, index, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(35);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(index, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    return recon.writeThen(then, output);
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new GetItemSelectorWriter(recon, index, then, part, step);
        };
        GetItemSelectorWriter.writeThen = function (output, recon, index, then) {
            return GetItemSelectorWriter.write(output, recon, index, then, void 0, 2);
        };
        return GetItemSelectorWriter;
    }(codec.Writer));

    var KeysSelectorWriter = (function (_super) {
        __extends(KeysSelectorWriter, _super);
        function KeysSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        KeysSelectorWriter.prototype.pull = function (output) {
            return KeysSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        KeysSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        KeysSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(58);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new KeysSelectorWriter(recon, then, step);
        };
        KeysSelectorWriter.writeThen = function (output, recon, then) {
            return KeysSelectorWriter.write(output, recon, then, 2);
        };
        return KeysSelectorWriter;
    }(codec.Writer));

    var ValuesSelectorWriter = (function (_super) {
        __extends(ValuesSelectorWriter, _super);
        function ValuesSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        ValuesSelectorWriter.prototype.pull = function (output) {
            return ValuesSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        ValuesSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        ValuesSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(58);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new ValuesSelectorWriter(recon, then, step);
        };
        ValuesSelectorWriter.writeThen = function (output, recon, then) {
            return ValuesSelectorWriter.write(output, recon, then, 2);
        };
        return ValuesSelectorWriter;
    }(codec.Writer));

    var ChildrenSelectorWriter = (function (_super) {
        __extends(ChildrenSelectorWriter, _super);
        function ChildrenSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        ChildrenSelectorWriter.prototype.pull = function (output) {
            return ChildrenSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        ChildrenSelectorWriter.sizeOf = function (recon, then) {
            var size = 2;
            size += recon.sizeOfThen(then);
            return size;
        };
        ChildrenSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new ChildrenSelectorWriter(recon, then, step);
        };
        ChildrenSelectorWriter.writeThen = function (output, recon, then) {
            return ChildrenSelectorWriter.write(output, recon, then, 2);
        };
        return ChildrenSelectorWriter;
    }(codec.Writer));

    var DescendantsSelectorWriter = (function (_super) {
        __extends(DescendantsSelectorWriter, _super);
        function DescendantsSelectorWriter(recon, then, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._then = then;
            _this._step = step;
            return _this;
        }
        DescendantsSelectorWriter.prototype.pull = function (output) {
            return DescendantsSelectorWriter.write(output, this._recon, this._then, this._step);
        };
        DescendantsSelectorWriter.sizeOf = function (recon, then) {
            var size = 3;
            size += recon.sizeOfThen(then);
            return size;
        };
        DescendantsSelectorWriter.write = function (output, recon, then, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 3;
            }
            else if (step === 2 && output.isCont()) {
                output = output.write(46);
                step = 3;
            }
            if (step === 3 && output.isCont()) {
                output = output.write(42);
                step = 4;
            }
            if (step === 4 && output.isCont()) {
                output = output.write(42);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new DescendantsSelectorWriter(recon, then, step);
        };
        DescendantsSelectorWriter.writeThen = function (output, recon, then) {
            return DescendantsSelectorWriter.write(output, recon, then, 2);
        };
        return DescendantsSelectorWriter;
    }(codec.Writer));

    var FilterSelectorWriter = (function (_super) {
        __extends(FilterSelectorWriter, _super);
        function FilterSelectorWriter(recon, predicate, then, part, step) {
            var _this = _super.call(this) || this;
            _this._recon = recon;
            _this._predicate = predicate;
            _this._then = then;
            _this._part = part;
            _this._step = step;
            return _this;
        }
        FilterSelectorWriter.prototype.pull = function (output) {
            return FilterSelectorWriter.write(output, this._recon, this._predicate, this._then, this._part, this._step);
        };
        FilterSelectorWriter.sizeOf = function (recon, predicate, then) {
            var size = 2;
            size += recon.sizeOfValue(predicate);
            size += 1;
            size += recon.sizeOfThen(then);
            return size;
        };
        FilterSelectorWriter.sizeOfThen = function (recon, predicate, then) {
            var size = 1;
            size += recon.sizeOfValue(predicate);
            size += 1;
            size += recon.sizeOfThen(then);
            return size;
        };
        FilterSelectorWriter.write = function (output, recon, predicate, then, part, step) {
            if (step === void 0) { step = 1; }
            if (step === 1 && output.isCont()) {
                output = output.write(36);
                step = 2;
            }
            if (step === 2 && output.isCont()) {
                output = output.write(91);
                step = 3;
            }
            if (step === 3) {
                if (!part) {
                    part = recon.writeValue(predicate, output);
                }
                else {
                    part = part.pull(output);
                }
                if (part.isDone()) {
                    part = void 0;
                    step = 4;
                }
                else if (part.isError()) {
                    return part.asError();
                }
            }
            if (step === 4 && output.isCont()) {
                output = output.write(93);
                return recon.writeThen(then, output);
            }
            if (output.isDone()) {
                return codec.Writer.error(new codec.WriterException("truncated"));
            }
            else if (output.isError()) {
                return codec.Writer.error(output.trap());
            }
            return new FilterSelectorWriter(recon, predicate, then, part, step);
        };
        FilterSelectorWriter.writeThen = function (output, recon, predicate, then) {
            return FilterSelectorWriter.write(output, recon, predicate, then, void 0, 2);
        };
        return FilterSelectorWriter;
    }(codec.Writer));

    var ReconWriter = (function () {
        function ReconWriter() {
        }
        ReconWriter.prototype.sizeOfAttr = function (key, value) {
            return AttrWriter.sizeOf(this, key, value);
        };
        ReconWriter.prototype.writeAttr = function (key, value, output) {
            return AttrWriter.write(output, this, key, value);
        };
        ReconWriter.prototype.sizeOfSlot = function (key, value) {
            return SlotWriter.sizeOf(this, key, value);
        };
        ReconWriter.prototype.writeSlot = function (key, value, output) {
            return SlotWriter.write(output, this, key, value);
        };
        ReconWriter.prototype.sizeOfBlock = function (item, inBlock, inMarkup) {
            if (arguments.length === 3) {
                return BlockWriter.sizeOf(this, item, inBlock, inMarkup);
            }
            else {
                var items = this.items(item);
                if (items.hasNext()) {
                    return BlockWriter.sizeOf(this, items, this.isBlockSafe(this.items(item)), false);
                }
                else {
                    return 2;
                }
            }
        };
        ReconWriter.prototype.writeBlock = function (item, output, inBlock, inMarkup) {
            if (arguments.length === 4) {
                return BlockWriter.write(output, this, item, inBlock, inMarkup);
            }
            else {
                var items = this.items(item);
                if (items.hasNext()) {
                    return BlockWriter.write(output, this, items, this.isBlockSafe(this.items(item)), false);
                }
                else {
                    return codec.Unicode.writeString("{}", output);
                }
            }
        };
        ReconWriter.prototype.sizeOfRecord = function (item) {
            var items = this.items(item);
            if (items.hasNext()) {
                return BlockWriter.sizeOf(this, items, false, false);
            }
            else {
                return 2;
            }
        };
        ReconWriter.prototype.writeRecord = function (item, output) {
            var items = this.items(item);
            if (items.hasNext()) {
                return BlockWriter.write(output, this, items, false, false);
            }
            else {
                return codec.Unicode.writeString("{}", output);
            }
        };
        ReconWriter.prototype.sizeOfPrimary = function (value) {
            if (this.isRecord(this.item(value))) {
                var items = this.items(this.item(value));
                if (items.hasNext()) {
                    return PrimaryWriter.sizeOf(this, items);
                }
            }
            else if (!this.isExtant(this.item(value))) {
                return this.sizeOfValue(value);
            }
            return 2;
        };
        ReconWriter.prototype.writePrimary = function (value, output) {
            if (this.isRecord(this.item(value))) {
                var items = this.items(this.item(value));
                if (items.hasNext()) {
                    return PrimaryWriter.write(output, this, items);
                }
            }
            else if (!this.isExtant(this.item(value))) {
                return this.writeValue(value, output);
            }
            return codec.Unicode.writeString("()", output);
        };
        ReconWriter.prototype.isBlockSafe = function (items) {
            while (items.hasNext()) {
                if (this.isAttr(items.next().value)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.isMarkupSafe = function (items) {
            if (!items.hasNext() || !this.isAttr(items.next().value)) {
                return false;
            }
            while (items.hasNext()) {
                if (this.isAttr(items.next().value)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.sizeOfMarkupText = function (item) {
            if (typeof item !== "string") {
                item = this.string(item);
            }
            return MarkupTextWriter.sizeOf(item);
        };
        ReconWriter.prototype.writeMarkupText = function (item, output) {
            if (typeof item !== "string") {
                item = this.string(item);
            }
            return MarkupTextWriter.write(output, item);
        };
        ReconWriter.prototype.sizeOfData = function (length) {
            return DataWriter.sizeOf(length);
        };
        ReconWriter.prototype.writeData = function (value, output) {
            if (value) {
                return DataWriter.write(output, value);
            }
            else {
                return codec.Unicode.writeString("%", output);
            }
        };
        ReconWriter.prototype.isIdent = function (value) {
            if (typeof value !== "string") {
                value = this.string(value);
            }
            var n = value.length;
            var c;
            if (n === 0 || (c = value.codePointAt(0), c !== void 0 && !Recon.isIdentStartChar(c))) {
                return false;
            }
            for (var i = value.offsetByCodePoints(0, 1); i < n; i = value.offsetByCodePoints(i, 1)) {
                c = value.codePointAt(i);
                if (c === void 0 || !Recon.isIdentChar(c)) {
                    return false;
                }
            }
            return true;
        };
        ReconWriter.prototype.sizeOfText = function (value) {
            if (this.isIdent(value)) {
                return IdentWriter.sizeOf(value);
            }
            else {
                return StringWriter.sizeOf(value);
            }
        };
        ReconWriter.prototype.writeText = function (value, output) {
            if (this.isIdent(value)) {
                return IdentWriter.write(output, value);
            }
            else {
                return StringWriter.write(output, value);
            }
        };
        ReconWriter.prototype.sizeOfNum = function (value) {
            if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
                var size = codec.Base10.countDigits(value);
                if (value < 0) {
                    size += 1;
                }
                return size;
            }
            else {
                return ("" + value).length;
            }
        };
        ReconWriter.prototype.writeNum = function (value, output) {
            if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {
                return codec.Base10.writeInteger(value, output);
            }
            else {
                return codec.Unicode.writeString("" + value, output);
            }
        };
        ReconWriter.prototype.sizeOfUint32 = function (value) {
            return 10;
        };
        ReconWriter.prototype.writeUint32 = function (value, output) {
            return codec.Base16.lowercase().writeIntegerLiteral(value, output, 8);
        };
        ReconWriter.prototype.sizeOfUint64 = function (value) {
            return 18;
        };
        ReconWriter.prototype.writeUint64 = function (value, output) {
            return codec.Base16.lowercase().writeIntegerLiteral(value, output, 16);
        };
        ReconWriter.prototype.sizeOfBool = function (value) {
            return value ? 4 : 5;
        };
        ReconWriter.prototype.writeBool = function (value, output) {
            return codec.Unicode.writeString(value ? "true" : "false", output);
        };
        ReconWriter.prototype.sizeOfLambdaFunc = function (bindings, template) {
            return LambdaFuncWriter.sizeOf(this, bindings, template);
        };
        ReconWriter.prototype.writeLambdaFunc = function (bindings, template, output) {
            return LambdaFuncWriter.write(output, this, bindings, template);
        };
        ReconWriter.prototype.sizeOfConditionalOperator = function (ifTerm, thenTerm, elseTerm, precedence) {
            return ConditionalOperatorWriter.sizeOf(this, ifTerm, thenTerm, elseTerm, precedence);
        };
        ReconWriter.prototype.writeConditionalOperator = function (ifTerm, thenTerm, elseTerm, precedence, output) {
            return ConditionalOperatorWriter.write(output, this, ifTerm, thenTerm, elseTerm, precedence);
        };
        ReconWriter.prototype.sizeOfInfixOperator = function (lhs, operator, rhs, precedence) {
            return InfixOperatorWriter.sizeOf(this, lhs, operator, rhs, precedence);
        };
        ReconWriter.prototype.writeInfixOperator = function (lhs, operator, rhs, precedence, output) {
            return InfixOperatorWriter.write(output, this, lhs, operator, rhs, precedence);
        };
        ReconWriter.prototype.sizeOfPrefixOperator = function (operator, rhs, precedence) {
            return PrefixOperatorWriter.sizeOf(this, operator, rhs, precedence);
        };
        ReconWriter.prototype.writePrefixOperator = function (operator, rhs, precedence, output) {
            return PrefixOperatorWriter.write(output, this, operator, rhs, precedence);
        };
        ReconWriter.prototype.sizeOfInvokeOperator = function (func, args) {
            return InvokeOperatorWriter.sizeOf(this, func, args);
        };
        ReconWriter.prototype.writeInvokeOperator = function (func, args, output) {
            return InvokeOperatorWriter.write(output, this, func, args);
        };
        ReconWriter.prototype.sizeOfIdentitySelector = function () {
            return 0;
        };
        ReconWriter.prototype.writeIdentitySelector = function (output) {
            return codec.Writer.done();
        };
        ReconWriter.prototype.sizeOfThenIdentitySelector = function () {
            return 0;
        };
        ReconWriter.prototype.writeThenIdentitySelector = function (output) {
            return codec.Writer.done();
        };
        ReconWriter.prototype.sizeOfLiteralSelector = function (item, then) {
            return LiteralSelectorWriter.sizeOf(this, item, then);
        };
        ReconWriter.prototype.writeLiteralSelector = function (item, then, output) {
            return LiteralSelectorWriter.write(output, this, item, then);
        };
        ReconWriter.prototype.sizeOfThenLiteralSelector = function (item, then) {
            return 0;
        };
        ReconWriter.prototype.writeThenLiteralSelector = function (item, then, output) {
            return codec.Writer.done();
        };
        ReconWriter.prototype.sizeOfGetSelector = function (key, then) {
            return GetSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeGetSelector = function (key, then, output) {
            return GetSelectorWriter.write(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfThenGetSelector = function (key, then) {
            return GetSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeThenGetSelector = function (key, then, output) {
            return GetSelectorWriter.writeThen(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfGetAttrSelector = function (key, then) {
            return GetAttrSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeGetAttrSelector = function (key, then, output) {
            return GetAttrSelectorWriter.write(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfThenGetAttrSelector = function (key, then) {
            return GetAttrSelectorWriter.sizeOf(this, key, then);
        };
        ReconWriter.prototype.writeThenGetAttrSelector = function (key, then, output) {
            return GetAttrSelectorWriter.writeThen(output, this, key, then);
        };
        ReconWriter.prototype.sizeOfGetItemSelector = function (index, then) {
            return GetItemSelectorWriter.sizeOf(this, index, then);
        };
        ReconWriter.prototype.writeGetItemSelector = function (index, then, output) {
            return GetItemSelectorWriter.write(output, this, index, then);
        };
        ReconWriter.prototype.sizeOfThenGetItemSelector = function (index, then) {
            return GetItemSelectorWriter.sizeOfThen(this, index, then);
        };
        ReconWriter.prototype.writeThenGetItemSelector = function (index, then, output) {
            return GetItemSelectorWriter.writeThen(output, this, index, then);
        };
        ReconWriter.prototype.sizeOfKeysSelector = function (then) {
            return KeysSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeKeysSelector = function (then, output) {
            return KeysSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenKeysSelector = function (then) {
            return KeysSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenKeysSelector = function (then, output) {
            return KeysSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfValuesSelector = function (then) {
            return ValuesSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeValuesSelector = function (then, output) {
            return ValuesSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenValuesSelector = function (then) {
            return ValuesSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenValuesSelector = function (then, output) {
            return ValuesSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfChildrenSelector = function (then) {
            return ChildrenSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeChildrenSelector = function (then, output) {
            return ChildrenSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenChildrenSelector = function (then) {
            return ChildrenSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenChildrenSelector = function (then, output) {
            return ChildrenSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfDescendantsSelector = function (then) {
            return DescendantsSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeDescendantsSelector = function (then, output) {
            return DescendantsSelectorWriter.write(output, this, then);
        };
        ReconWriter.prototype.sizeOfThenDescendantsSelector = function (then) {
            return DescendantsSelectorWriter.sizeOf(this, then);
        };
        ReconWriter.prototype.writeThenDescendantsSelector = function (then, output) {
            return DescendantsSelectorWriter.writeThen(output, this, then);
        };
        ReconWriter.prototype.sizeOfFilterSelector = function (predicate, then) {
            return FilterSelectorWriter.sizeOf(this, predicate, then);
        };
        ReconWriter.prototype.writeFilterSelector = function (predicate, then, output) {
            return FilterSelectorWriter.write(output, this, predicate, then);
        };
        ReconWriter.prototype.sizeOfThenFilterSelector = function (predicate, then) {
            return FilterSelectorWriter.sizeOfThen(this, predicate, then);
        };
        ReconWriter.prototype.writeThenFilterSelector = function (predicate, then, output) {
            return FilterSelectorWriter.writeThen(output, this, predicate, then);
        };
        ReconWriter.prototype.sizeOfExtant = function () {
            return 0;
        };
        ReconWriter.prototype.writeExtant = function (output) {
            return codec.Writer.done();
        };
        ReconWriter.prototype.sizeOfAbsent = function () {
            return 0;
        };
        ReconWriter.prototype.writeAbsent = function (output) {
            return codec.Writer.done();
        };
        return ReconWriter;
    }());

    var ReconStructureWriter = (function (_super) {
        __extends(ReconStructureWriter, _super);
        function ReconStructureWriter() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReconStructureWriter.prototype.isField = function (item) {
            return item instanceof structure.Field;
        };
        ReconStructureWriter.prototype.isAttr = function (item) {
            return item instanceof structure.Attr;
        };
        ReconStructureWriter.prototype.isSlot = function (item) {
            return item instanceof structure.Slot;
        };
        ReconStructureWriter.prototype.isValue = function (item) {
            return item instanceof structure.Value;
        };
        ReconStructureWriter.prototype.isRecord = function (item) {
            return item instanceof structure.Record;
        };
        ReconStructureWriter.prototype.isText = function (item) {
            return item instanceof structure.Text;
        };
        ReconStructureWriter.prototype.isNum = function (item) {
            return item instanceof structure.Num;
        };
        ReconStructureWriter.prototype.isBool = function (item) {
            return item instanceof structure.Bool;
        };
        ReconStructureWriter.prototype.isExpression = function (item) {
            return item instanceof structure.Expression;
        };
        ReconStructureWriter.prototype.isExtant = function (item) {
            return item instanceof structure.Extant;
        };
        ReconStructureWriter.prototype.items = function (item) {
            return item.iterator();
        };
        ReconStructureWriter.prototype.item = function (value) {
            return value;
        };
        ReconStructureWriter.prototype.key = function (item) {
            return item.key;
        };
        ReconStructureWriter.prototype.value = function (item) {
            return item.toValue();
        };
        ReconStructureWriter.prototype.string = function (item) {
            return item.stringValue("");
        };
        ReconStructureWriter.prototype.precedence = function (item) {
            return item.precedence();
        };
        ReconStructureWriter.prototype.sizeOfItem = function (item) {
            if (item instanceof structure.Field) {
                if (item instanceof structure.Attr) {
                    return this.sizeOfAttr(item.key, item.value);
                }
                else if (item instanceof structure.Slot) {
                    return this.sizeOfSlot(item.key, item.value);
                }
            }
            else if (item instanceof structure.Value) {
                return this.sizeOfValue(item);
            }
            throw new codec.WriterException("No Recon serialization for " + item);
        };
        ReconStructureWriter.prototype.writeItem = function (item, output) {
            if (item instanceof structure.Field) {
                if (item instanceof structure.Attr) {
                    return this.writeAttr(item.key, item.value, output);
                }
                else if (item instanceof structure.Slot) {
                    return this.writeSlot(item.key, item.value, output);
                }
            }
            else if (item instanceof structure.Value) {
                return this.writeValue(item, output);
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + item));
        };
        ReconStructureWriter.prototype.sizeOfValue = function (value) {
            if (value instanceof structure.Record) {
                return this.sizeOfRecord(value);
            }
            else if (value instanceof structure.Data) {
                return this.sizeOfData(value.size);
            }
            else if (value instanceof structure.Text) {
                return this.sizeOfText(value.value);
            }
            else if (value instanceof structure.Num) {
                if (value.isUint32()) {
                    return this.sizeOfUint32(value.value);
                }
                else if (value.isUint64()) {
                    return this.sizeOfUint64(value.value);
                }
                else {
                    return this.sizeOfNum(value.value);
                }
            }
            else if (value instanceof structure.Bool) {
                return this.sizeOfBool(value.value);
            }
            else if (value instanceof structure.Selector) {
                return this.sizeOfSelector(value);
            }
            else if (value instanceof structure.Operator) {
                return this.sizeOfOperator(value);
            }
            else if (value instanceof structure.Func) {
                return this.sizeOfFunc(value);
            }
            else if (value instanceof structure.Extant) {
                return this.sizeOfExtant();
            }
            else if (value instanceof structure.Absent) {
                return this.sizeOfAbsent();
            }
            throw new codec.WriterException("No Recon serialization for " + value);
        };
        ReconStructureWriter.prototype.writeValue = function (value, output) {
            if (value instanceof structure.Record) {
                return this.writeRecord(value, output);
            }
            else if (value instanceof structure.Data) {
                return this.writeData(value.asUint8Array(), output);
            }
            else if (value instanceof structure.Text) {
                return this.writeText(value.value, output);
            }
            else if (value instanceof structure.Num) {
                if (value.isUint32()) {
                    return this.writeUint32(value.value, output);
                }
                else if (value.isUint64()) {
                    return this.writeUint64(value.value, output);
                }
                else {
                    return this.writeNum(value.value, output);
                }
            }
            else if (value instanceof structure.Bool) {
                return this.writeBool(value.value, output);
            }
            else if (value instanceof structure.Selector) {
                return this.writeSelector(value, output);
            }
            else if (value instanceof structure.Operator) {
                return this.writeOperator(value, output);
            }
            else if (value instanceof structure.Func) {
                return this.writeFunc(value, output);
            }
            else if (value instanceof structure.Extant) {
                return this.writeExtant(output);
            }
            else if (value instanceof structure.Absent) {
                return this.writeAbsent(output);
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + value));
        };
        ReconStructureWriter.prototype.sizeOfSelector = function (selector) {
            if (selector instanceof structure.IdentitySelector) {
                return this.sizeOfIdentitySelector();
            }
            else if (selector instanceof structure.LiteralSelector) {
                return this.sizeOfLiteralSelector(selector.item(), selector.then());
            }
            else if (selector instanceof structure.GetSelector) {
                return this.sizeOfGetSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof structure.GetAttrSelector) {
                return this.sizeOfGetAttrSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof structure.GetItemSelector) {
                return this.sizeOfGetItemSelector(selector.accessor(), selector.then());
            }
            else if (selector instanceof structure.KeysSelector) {
                return this.sizeOfKeysSelector(selector.then());
            }
            else if (selector instanceof structure.ValuesSelector) {
                return this.sizeOfValuesSelector(selector.then());
            }
            else if (selector instanceof structure.ChildrenSelector) {
                return this.sizeOfChildrenSelector(selector.then());
            }
            else if (selector instanceof structure.DescendantsSelector) {
                return this.sizeOfDescendantsSelector(selector.then());
            }
            else if (selector instanceof structure.FilterSelector) {
                return this.sizeOfFilterSelector(selector.predicate(), selector.then());
            }
            throw new codec.WriterException("No Recon serialization for " + selector);
        };
        ReconStructureWriter.prototype.writeSelector = function (selector, output) {
            if (selector instanceof structure.IdentitySelector) {
                return this.writeIdentitySelector(output);
            }
            else if (selector instanceof structure.LiteralSelector) {
                return this.writeLiteralSelector(selector.item(), selector.then(), output);
            }
            else if (selector instanceof structure.GetSelector) {
                return this.writeGetSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof structure.GetAttrSelector) {
                return this.writeGetAttrSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof structure.GetItemSelector) {
                return this.writeGetItemSelector(selector.accessor(), selector.then(), output);
            }
            else if (selector instanceof structure.KeysSelector) {
                return this.writeKeysSelector(selector.then(), output);
            }
            else if (selector instanceof structure.ValuesSelector) {
                return this.writeValuesSelector(selector.then(), output);
            }
            else if (selector instanceof structure.ChildrenSelector) {
                return this.writeChildrenSelector(selector.then(), output);
            }
            else if (selector instanceof structure.DescendantsSelector) {
                return this.writeDescendantsSelector(selector.then(), output);
            }
            else if (selector instanceof structure.FilterSelector) {
                return this.writeFilterSelector(selector.predicate(), selector.then(), output);
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + selector));
        };
        ReconStructureWriter.prototype.sizeOfOperator = function (operator) {
            if (operator instanceof structure.BinaryOperator) {
                return this.sizeOfInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence());
            }
            else if (operator instanceof structure.UnaryOperator) {
                return this.sizeOfPrefixOperator(operator.operator(), operator.operand(), operator.precedence());
            }
            else if (operator instanceof structure.InvokeOperator) {
                return this.sizeOfInvokeOperator(operator.func(), operator.args());
            }
            else if (operator instanceof structure.ConditionalOperator) {
                return this.sizeOfConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence());
            }
            throw new codec.WriterException("No Recon serialization for " + operator);
        };
        ReconStructureWriter.prototype.writeOperator = function (operator, output) {
            if (operator instanceof structure.BinaryOperator) {
                return this.writeInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence(), output);
            }
            else if (operator instanceof structure.UnaryOperator) {
                return this.writePrefixOperator(operator.operator(), operator.operand(), operator.precedence(), output);
            }
            else if (operator instanceof structure.InvokeOperator) {
                return this.writeInvokeOperator(operator.func(), operator.args(), output);
            }
            else if (operator instanceof structure.ConditionalOperator) {
                return this.writeConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence(), output);
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + operator));
        };
        ReconStructureWriter.prototype.sizeOfFunc = function (func) {
            if (func instanceof structure.LambdaFunc) {
                return this.sizeOfLambdaFunc(func.bindings(), func.template());
            }
            else if (func instanceof structure.BridgeFunc) {
                return 0;
            }
            throw new codec.WriterException("No Recon serialization for " + func);
        };
        ReconStructureWriter.prototype.writeFunc = function (func, output) {
            if (func instanceof structure.LambdaFunc) {
                return this.writeLambdaFunc(func.bindings(), func.template(), output);
            }
            else if (func instanceof structure.BridgeFunc) {
                return codec.Writer.done();
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + func));
        };
        ReconStructureWriter.prototype.sizeOfBlockItem = function (item) {
            if (item instanceof structure.Field) {
                return this.sizeOfItem(item);
            }
            else if (item instanceof structure.Value) {
                return this.sizeOfBlockValue(item);
            }
            throw new codec.WriterException("No Recon serialization for " + item);
        };
        ReconStructureWriter.prototype.writeBlockItem = function (item, output) {
            if (item instanceof structure.Field) {
                return this.writeItem(item, output);
            }
            else if (item instanceof structure.Value) {
                return this.writeBlockValue(item, output);
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + item));
        };
        ReconStructureWriter.prototype.sizeOfBlockValue = function (value) {
            if (value instanceof structure.Record) {
                return this.sizeOfBlock(value);
            }
            return this.sizeOfValue(value);
        };
        ReconStructureWriter.prototype.writeBlockValue = function (value, output) {
            if (value instanceof structure.Record) {
                return this.writeBlock(value, output);
            }
            return this.writeValue(value, output);
        };
        ReconStructureWriter.prototype.sizeOfThen = function (then) {
            if (then instanceof structure.Selector) {
                if (then instanceof structure.IdentitySelector) {
                    return this.sizeOfThenIdentitySelector();
                }
                else if (then instanceof structure.LiteralSelector) {
                    return this.sizeOfThenLiteralSelector(then.item(), then.then());
                }
                else if (then instanceof structure.GetSelector) {
                    return this.sizeOfThenGetSelector(then.accessor(), then.then());
                }
                else if (then instanceof structure.GetAttrSelector) {
                    return this.sizeOfThenGetAttrSelector(then.accessor(), then.then());
                }
                else if (then instanceof structure.GetItemSelector) {
                    return this.sizeOfThenGetItemSelector(then.accessor(), then.then());
                }
                else if (then instanceof structure.KeysSelector) {
                    return this.sizeOfThenKeysSelector(then.then());
                }
                else if (then instanceof structure.ValuesSelector) {
                    return this.sizeOfThenValuesSelector(then.then());
                }
                else if (then instanceof structure.ChildrenSelector) {
                    return this.sizeOfThenChildrenSelector(then.then());
                }
                else if (then instanceof structure.DescendantsSelector) {
                    return this.sizeOfThenDescendantsSelector(then.then());
                }
                else if (then instanceof structure.FilterSelector) {
                    return this.sizeOfThenFilterSelector(then.predicate(), then.then());
                }
            }
            throw new codec.WriterException("No Recon serialization for " + then);
        };
        ReconStructureWriter.prototype.writeThen = function (then, output) {
            if (then instanceof structure.Selector) {
                if (then instanceof structure.IdentitySelector) {
                    return this.writeThenIdentitySelector(output);
                }
                else if (then instanceof structure.LiteralSelector) {
                    return this.writeThenLiteralSelector(then.item(), then.then(), output);
                }
                else if (then instanceof structure.GetSelector) {
                    return this.writeThenGetSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof structure.GetAttrSelector) {
                    return this.writeThenGetAttrSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof structure.GetItemSelector) {
                    return this.writeThenGetItemSelector(then.accessor(), then.then(), output);
                }
                else if (then instanceof structure.KeysSelector) {
                    return this.writeThenKeysSelector(then.then(), output);
                }
                else if (then instanceof structure.ValuesSelector) {
                    return this.writeThenValuesSelector(then.then(), output);
                }
                else if (then instanceof structure.ChildrenSelector) {
                    return this.writeThenChildrenSelector(then.then(), output);
                }
                else if (then instanceof structure.DescendantsSelector) {
                    return this.writeThenDescendantsSelector(then.then(), output);
                }
                else if (then instanceof structure.FilterSelector) {
                    return this.writeThenFilterSelector(then.predicate(), then.then(), output);
                }
            }
            return codec.Writer.error(new codec.WriterException("No Recon serialization for " + then));
        };
        return ReconStructureWriter;
    }(ReconWriter));

    var Recon = (function () {
        function Recon() {
        }
        Recon.isSpace = function (c) {
            return c === 0x20 || c === 0x9;
        };
        Recon.isNewline = function (c) {
            return c === 0xa || c === 0xd;
        };
        Recon.isWhitespace = function (c) {
            return Recon.isSpace(c) || Recon.isNewline(c);
        };
        Recon.isIdentStartChar = function (c) {
            return c >= 65 && c <= 90
                || c === 95
                || c >= 97 && c <= 122
                || c >= 0xc0 && c <= 0xd6
                || c >= 0xd8 && c <= 0xf6
                || c >= 0xf8 && c <= 0x2ff
                || c >= 0x370 && c <= 0x37d
                || c >= 0x37f && c <= 0x1fff
                || c >= 0x200c && c <= 0x200d
                || c >= 0x2070 && c <= 0x218f
                || c >= 0x2c00 && c <= 0x2fef
                || c >= 0x3001 && c <= 0xd7ff
                || c >= 0xf900 && c <= 0xfdcf
                || c >= 0xfdf0 && c <= 0xfffd
                || c >= 0x10000 && c <= 0xeffff;
        };
        Recon.isIdentChar = function (c) {
            return c === 45
                || c >= 48 && c <= 57
                || c >= 65 && c <= 90
                || c === 95
                || c >= 97 && c <= 122
                || c === 0xb7
                || c >= 0xc0 && c <= 0xd6
                || c >= 0xd8 && c <= 0xf6
                || c >= 0xf8 && c <= 0x37d
                || c >= 0x37f && c <= 0x1fff
                || c >= 0x200c && c <= 0x200d
                || c >= 0x203f && c <= 0x2040
                || c >= 0x2070 && c <= 0x218f
                || c >= 0x2c00 && c <= 0x2fef
                || c >= 0x3001 && c <= 0xd7ff
                || c >= 0xf900 && c <= 0xfdcf
                || c >= 0xfdf0 && c <= 0xfffd
                || c >= 0x10000 && c <= 0xeffff;
        };
        Recon.structureParser = function () {
            if (!Recon._structureParser) {
                Recon._structureParser = new ReconStructureParser();
            }
            return Recon._structureParser;
        };
        Recon.structureWriter = function () {
            if (!Recon._structureWriter) {
                Recon._structureWriter = new ReconStructureWriter();
            }
            return Recon._structureWriter;
        };
        Recon.parse = function (recon) {
            return Recon.structureParser().parseBlockString(recon);
        };
        Recon.parser = function () {
            return Recon.structureParser().blockParser();
        };
        Recon.sizeOf = function (item) {
            return Recon.structureWriter().sizeOfItem(item);
        };
        Recon.sizeOfBlock = function (item) {
            return Recon.structureWriter().sizeOfBlockItem(item);
        };
        Recon.write = function (item, output) {
            return Recon.structureWriter().writeItem(item, output);
        };
        Recon.writeBlock = function (item, output) {
            return Recon.structureWriter().writeBlockItem(item, output);
        };
        Recon.toString = function (item) {
            var output = codec.Unicode.stringOutput();
            Recon.write(item, output);
            return output.bind();
        };
        Recon.toBlockString = function (item) {
            var output = codec.Unicode.stringOutput();
            Recon.writeBlock(item, output);
            return output.bind();
        };
        Recon.toData = function (item) {
            var output = codec.Utf8.encodedOutput(structure.Data.output());
            Recon.write(item, output);
            return output.bind();
        };
        Recon.toBlockData = function (item) {
            var output = codec.Utf8.encodedOutput(structure.Data.output());
            Recon.writeBlock(item, output);
            return output.bind();
        };
        return Recon;
    }());
    structure.Item.prototype.toRecon = function () {
        return Recon.toString(this);
    };
    structure.Item.prototype.toReconBlock = function () {
        return Recon.toBlockString(this);
    };
    structure.Value.parseRecon = function (recon) {
        return Recon.parse(recon);
    };

    exports.Recon = Recon;
    exports.ReconParser = ReconParser;
    exports.ReconStructureParser = ReconStructureParser;
    exports.ReconStructureWriter = ReconStructureWriter;
    exports.ReconWriter = ReconWriter;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=swim-recon.js.map