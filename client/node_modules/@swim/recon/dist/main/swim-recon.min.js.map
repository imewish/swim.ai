{"version":3,"sources":["../../../../../node_modules/tslib/tslib.es6.js","../../main/BlockParser.ts","../../main/AttrParser.ts","../../main/BlockItemParser.ts","../../main/InlineItemParser.ts","../../main/RecordParser.ts","../../main/MarkupParser.ts","../../main/DataParser.ts","../../main/IdentParser.ts","../../main/StringParser.ts","../../main/NumberParser.ts","../../main/LambdaFuncParser.ts","../../main/ConditionalOperatorParser.ts","../../main/OrOperatorParser.ts","../../main/AndOperatorParser.ts","../../main/BitwiseOrOperatorParser.ts","../../main/BitwiseXorOperatorParser.ts","../../main/BitwiseAndOperatorParser.ts","../../main/ComparisonOperatorParser.ts","../../main/AttrExpressionParser.ts","../../main/AdditiveOperatorParser.ts","../../main/MultiplicativeOperatorParser.ts","../../main/PrefixOperatorParser.ts","../../main/InvokeOperatorParser.ts","../../main/PrimaryParser.ts","../../main/LiteralParser.ts","../../main/SelectorParser.ts","../../main/ReconParser.ts","../../main/ReconStructureParser.ts","../../main/AttrWriter.ts","../../main/SlotWriter.ts","../../main/BlockWriter.ts","../../main/PrimaryWriter.ts","../../main/MarkupTextWriter.ts","../../main/DataWriter.ts","../../main/IdentWriter.ts","../../main/StringWriter.ts","../../main/LambdaFuncWriter.ts","../../main/ConditionalOperatorWriter.ts","../../main/InfixOperatorWriter.ts","../../main/PrefixOperatorWriter.ts","../../main/InvokeOperatorWriter.ts","../../main/LiteralSelectorWriter.ts","../../main/GetSelectorWriter.ts","../../main/GetAttrSelectorWriter.ts","../../main/GetItemSelectorWriter.ts","../../main/KeysSelectorWriter.ts","../../main/ValuesSelectorWriter.ts","../../main/ChildrenSelectorWriter.ts","../../main/DescendantsSelectorWriter.ts","../../main/FilterSelectorWriter.ts","../../main/ReconWriter.ts","../../main/ReconStructureWriter.ts","../../main/Recon.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","BlockParser","_super","recon","builder","keyParser","valueParser","step","_this","call","_recon","_builder","_keyParser","_valueParser","_step","feed","input","parse","c","block","isCont","head","Recon","isWhitespace","isIdentStartChar","valueBuilder","Parser","done","bind","absent","isDone","parseBlockExpression","isEmpty","isError","isSpace","push","item","slot","isNewline","AttrParser","error","Diagnostic","expected","parseString","parseIdent","asError","attr","parseBlock","BlockItemParser","fieldParser","_fieldParser","parseAttr","recordBuilder","parseRecord","parseMarkup","parseNumber","parseData","extant","parseSelector","InlineItemParser","RecordParser","MarkupParser","textOutput","_textOutput","write","parseInlineItem","unexpected","DataParser","base64Parser","_base64Parser","Base64","standard","dataOutput","IdentParser","output","_output","isIdentChar","ident","StringParser","quote","code","_quote","_code","string","Base16","isDigit","decodeDigit","NumberParser","sign","value","mode","_sign","_value","_mode","newValue","message","num","Unicode","stringOutput","DecimalParser","HexadecimalParser","parseInteger","parseDecimal","size","_size","uint32","uint64","LambdaFuncParser","bindingsParser","templateParser","_bindingsParser","_templateParser","parseConditionalOperator","bindings","template","lambda","ConditionalOperatorParser","ifParser","thenParser","elseParser","_ifParser","_thenParser","_elseParser","parseOrOperator","ifTerm","thenTerm","elseTerm","conditional","OrOperatorParser","lhsParser","rhsParser","_lhsParser","_rhsParser","parseAndOperator","lhs","rhs","or","AndOperatorParser","parseBitwiseOrOperator","and","BitwiseOrOperatorParser","parseBitwiseXorOperator","bitwiseOr","BitwiseXorOperatorParser","parseBitwiseAndOperator","bitwiseXor","BitwiseAndOperatorParser","parseComparisonOperator","bitwiseAnd","ComparisonOperatorParser","operator","_operator","parseAttrExpression","lt","le","eq","ne","ge","gt","AttrExpressionParser","parseAdditiveOperator","AdditiveOperatorParser","parseMultiplicativeOperator","plus","minus","MultiplicativeOperatorParser","parsePrefixOperator","times","divide","modulo","PrefixOperatorParser","_operandParser","parseInvokeOperator","operand","isDistinct","not","bitwiseNot","negative","positive","InvokeOperatorParser","exprParser","argsParser","_exprParser","_argsParser","parsePrimary","expr","invoke","args","PrimaryParser","parseLiteral","LiteralParser","SelectorParser","selector","_selector","get","getItem","keys","descendants","children","values","getAttr","filter","ReconParser","parseBlockItem","parseLambdaFunc","blockParser","parseBlockString","stringInput","parser","parseNumberString","ReconStructureParser","toValue","key","Attr","of","apply","arguments","Slot","Value","Record","Data","Text","stringValue","Bool","from","Num","TypeError","bool","Selector","identity","OrOperator","AndOperator","BitwiseOrOperator","BitwiseXorOperator","BitwiseAndOperator","LtOperator","LeOperator","EqOperator","NeOperator","GeOperator","GtOperator","PlusOperator","MinusOperator","TimesOperator","DivideOperator","ModuloOperator","NotOperator","BitwiseNotOperator","NegativeOperator","PositiveOperator","func","InvokeOperator","index","literal","predicate","AttrWriter","part","_key","_part","pull","sizeOf","sizeOfValue","isExtant","sizeOfBlockValue","writeValue","Writer","writeBlockValue","WriterException","trap","SlotWriter","BlockWriter","items","inBlock","inMarkup","inBraces","inBrackets","first","markupSafe","next","_items","_inBlock","_inMarkup","_inBraces","_inBrackets","_first","_markupSafe","_item","_next","hasNext","isExpression","isAttr","sizeOfItem","isText","sizeOfMarkupText","sizeOfBlockItem","isRecord","isMarkupSafe","sizeOfBlock","isField","isBool","isValue","isIdent","isNum","sizeOfSlot","writeItem","writeMarkupText","writeBlockItem","writeBlock","writeSlot","PrimaryWriter","inParens","_inParens","MarkupTextWriter","text","escape","_text","_index","_escape","i","n","length","offsetByCodePoints","codePointAt","charCodeAt","Utf8","uppercase","encodeDigit","DataWriter","array","_array","Math","floor","writeUint8Array","IdentWriter","_ident","StringWriter","_string","LambdaFuncWriter","_bindings","_template","sizeOfPrimary","writePrimary","ConditionalOperatorWriter","precedence","_ifTerm","_thenTerm","_elseTerm","_precedence","InfixOperatorWriter","_lhs","_rhs","writeString","PrefixOperatorWriter","InvokeOperatorWriter","_func","_args","LiteralSelectorWriter","then","_then","sizeOfThen","writeThen","GetSelectorWriter","GetAttrSelectorWriter","GetItemSelectorWriter","KeysSelectorWriter","ValuesSelectorWriter","ChildrenSelectorWriter","DescendantsSelectorWriter","FilterSelectorWriter","_predicate","ReconWriter","sizeOfAttr","writeAttr","isBlockSafe","sizeOfRecord","writeRecord","sizeOfData","writeData","sizeOfText","writeText","sizeOfNum","isFinite","abs","Base10","countDigits","writeNum","writeInteger","sizeOfUint32","writeUint32","lowercase","writeIntegerLiteral","sizeOfUint64","writeUint64","sizeOfBool","writeBool","sizeOfLambdaFunc","writeLambdaFunc","sizeOfConditionalOperator","writeConditionalOperator","sizeOfInfixOperator","writeInfixOperator","sizeOfPrefixOperator","writePrefixOperator","sizeOfInvokeOperator","writeInvokeOperator","sizeOfIdentitySelector","writeIdentitySelector","sizeOfThenIdentitySelector","writeThenIdentitySelector","sizeOfLiteralSelector","writeLiteralSelector","sizeOfThenLiteralSelector","writeThenLiteralSelector","sizeOfGetSelector","writeGetSelector","sizeOfThenGetSelector","writeThenGetSelector","sizeOfGetAttrSelector","writeGetAttrSelector","sizeOfThenGetAttrSelector","writeThenGetAttrSelector","sizeOfGetItemSelector","writeGetItemSelector","sizeOfThenGetItemSelector","writeThenGetItemSelector","sizeOfKeysSelector","writeKeysSelector","sizeOfThenKeysSelector","writeThenKeysSelector","sizeOfValuesSelector","writeValuesSelector","sizeOfThenValuesSelector","writeThenValuesSelector","sizeOfChildrenSelector","writeChildrenSelector","sizeOfThenChildrenSelector","writeThenChildrenSelector","sizeOfDescendantsSelector","writeDescendantsSelector","sizeOfThenDescendantsSelector","writeThenDescendantsSelector","sizeOfFilterSelector","writeFilterSelector","sizeOfThenFilterSelector","writeThenFilterSelector","sizeOfExtant","writeExtant","sizeOfAbsent","writeAbsent","ReconStructureWriter","Field","isSlot","Expression","Extant","iterator","isUint32","isUint64","sizeOfSelector","Operator","sizeOfOperator","Func","sizeOfFunc","Absent","asUint8Array","writeSelector","writeOperator","writeFunc","IdentitySelector","LiteralSelector","GetSelector","accessor","GetAttrSelector","GetItemSelector","KeysSelector","ValuesSelector","ChildrenSelector","DescendantsSelector","FilterSelector","BinaryOperator","operand1","operand2","UnaryOperator","ConditionalOperator","LambdaFunc","BridgeFunc","structureParser","_structureParser","structureWriter","_structureWriter","toString","toBlockString","toData","encodedOutput","toBlockData","Item","toRecon","toReconBlock","parseRecon"],"mappings":";;;;;;;;;;;;;;;oFAgBA,IAAIA,EAAgB,SAASC,EAAGC,GAI5B,OAHAF,EAAgBG,OAAOC,gBAClB,CAAEC,UAAW,cAAgBC,OAAS,SAAUL,EAAGC,GAAKD,EAAEI,UAAYH,IACvE,SAAUD,EAAGC,GAAK,IAAK,IAAIK,KAAKL,EAAOA,EAAEM,eAAeD,KAAIN,EAAEM,GAAKL,EAAEK,MACpDN,EAAGC,IAGrB,SAASO,EAAUR,EAAGC,GAEzB,SAASQ,IAAOC,KAAKC,YAAcX,EADnCD,EAAcC,EAAGC,GAEjBD,EAAEY,UAAkB,OAANX,EAAaC,OAAOW,OAAOZ,IAAMQ,EAAGG,UAAYX,EAAEW,UAAW,IAAIH,GCNnF,IAAAK,EAAA,SAAAC,GAOE,SAAAD,EAAYE,EAA0BC,EAAyBC,EACnDC,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKI,WAAaP,EAClBG,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IA0IjB,OAxJuCZ,EAAAM,EAAAC,GAiBrCD,EAAAF,UAAAgB,KAAA,SAAKC,GACH,OAAOf,EAAYgB,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKe,WACxCf,KAAKgB,aAAchB,KAAKiB,QAG5Cb,EAAAgB,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCC,EAAuBC,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GACjE,IAAIW,EAAI,EACRC,EAAO,OAAG,CACR,GAAa,IAATZ,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,GAAyB,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAChD,KAANA,GAA0B,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAC1DA,GAAK,IAAaA,GAAK,IAAmB,KAANA,GAC9B,KAANA,GAAyB,MAANA,GAA0B,MAANA,GACvCI,GAAME,iBAAiBN,GAC5Bd,EAAUA,GAAWD,EAAMsB,eAC3BlB,EAAO,MACF,CAAA,GAAU,KAANW,EAIT,OAAId,EACKsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAEpBF,EAAAA,OAAOC,KAAKxB,EAAM0B,UAN3Bb,EAAQA,EAAMT,OACdA,EAAO,OAQJ,GAAIS,EAAMc,SACf,OAAI1B,EACKsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAEpBF,EAAAA,OAAOC,KAAKxB,EAAM0B,UAI/B,GAAa,IAATtB,EAAY,CAId,IAHKF,IACHA,EAAYF,EAAM4B,qBAAqBf,IAElCX,EAAUe,WAAaJ,EAAMgB,WAClC3B,EAAYA,EAAUU,KAAKC,GAE7B,GAAIX,EAAUyB,SACZvB,EAAO,OACF,GAAIF,EAAU4B,UACnB,OAAO5B,EAGX,GAAa,IAATE,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACE,KAANF,GACFF,EAAQA,EAAMT,OACdA,EAAO,IAEPH,EAAS+B,KAAKhC,EAAMiC,KAAK/B,EAAWuB,SACpCvB,OAAY,EACZE,EAAO,QAEJ,GAAIS,EAAMc,SAEf,OADA1B,EAAS+B,KAAKhC,EAAMiC,KAAK/B,EAAWuB,SAC7BF,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CACd,KAAOS,EAAMI,UAAYE,GAAMY,QAAQlB,EAAMK,SAC3CL,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACRb,EAAO,OACF,GAAIS,EAAMc,SAEf,OADA1B,EAAS+B,KAAKhC,EAAMkC,KAAKhC,EAAWuB,SAC7BF,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM4B,qBAAqBf,IAEpCV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACd1B,EAAS+B,KAAKhC,EAAMkC,KAAKhC,EAAWuB,OAAQtB,EAAYsB,SACxDvB,OAAY,EACZC,OAAc,EACdC,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,GAAyB,KAANA,GAAmBI,GAAMgB,UAAUpB,GAAI,CAC5DF,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAIT,OAAOQ,EAAAA,OAAOC,KAAKvB,EAASwB,QAH5BZ,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CACd,KAAOS,EAAMI,UAAU,CAErB,GADAF,EAAIF,EAAMK,OACLC,GAAMgB,UAAUpB,GAEd,CACLX,EAAO,EACP,SAASY,EAHTH,EAAQA,EAAMT,OAMlB,GAAIS,EAAMc,SAAU,CAClBvB,EAAO,EACP,UAGJ,MAEF,OAAO,IAAIN,EAAkBE,EAAOC,EAASC,EAAWC,EAAaC,IAEzEN,EAxJA,CAAuCyB,EAAAA,QCDvCa,EAAA,SAAArC,GAME,SAAAqC,EAAYpC,EAA0BE,EAC1BC,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKI,WAAaP,EAClBG,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IAsGjB,OAlHsCZ,EAAA4C,EAAArC,GAepCqC,EAAAxC,UAAAgB,KAAA,SAAKC,GACH,OAAOuB,EAAWtB,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKe,WACzBf,KAAKgB,aAAchB,KAAKiB,QAG3CyB,EAAAtB,MAAP,SAAmBD,EAAcb,EAA0BE,EACxCC,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GAC1C,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QAKR,OAAOK,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAHnDA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CACd,GAAKF,EAcHA,EAAYA,EAAUU,KAAKC,QAb3B,GAAIA,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,SACmB,KAANH,EACrBb,EAAYF,EAAMwC,YAAY3B,OACzB,CAAA,IAAIM,GAAME,iBAAiBN,GAGhC,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,iBAAkB1B,IAF1DX,EAAYF,EAAMyC,WAAW5B,QAI1B,GAAIA,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,iBAAkB1B,IAK9D,GAAIX,EACF,GAAIA,EAAUyB,SACZvB,EAAO,OACF,GAAIF,EAAU4B,UACnB,OAAO5B,EAAUwC,UAIvB,GAAa,IAATtC,EACF,GAAIS,EAAMI,UAA6B,KAAjBJ,EAAMK,OAC1BL,EAAQA,EAAMT,OACdA,EAAO,OACF,IAAKS,EAAMgB,UAChB,OAAON,EAAAA,OAAOC,KAAKxB,EAAM2C,KAAKzC,EAAWuB,SAG7C,GAAa,IAATrB,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAEF,OADAF,EAAQA,EAAMT,OACPmB,EAAAA,OAAOC,KAAKxB,EAAM2C,KAAKzC,EAAWuB,SAEzCrB,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAK1B,IAGjD,GAAa,IAATT,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM4C,WAAW/B,IAE1BV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdvB,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,OAAU,KAANF,GACFF,EAAQA,EAAMT,OACPmB,EAAAA,OAAOC,KAAKxB,EAAM2C,KAAKzC,EAAWuB,OAAQtB,EAAasB,UAEvDF,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAK1B,IAE1C,GAAIA,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAK1B,IAGjD,OAAO,IAAIuB,EAAiBpC,EAAOE,EAAWC,EAAaC,IAE/DgC,EAlHA,CAAsCb,EAAAA,QCCtCsB,EAAA,SAAA9C,GAOE,SAAA8C,EAAY7C,EAA0BC,EAAyB6C,EACnD3C,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK0C,aAAeD,EACpBzC,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IAwHjB,OAtI2CZ,EAAAqD,EAAA9C,GAiBzC8C,EAAAjD,UAAAgB,KAAA,SAAKC,GACH,OAAOgC,EAAgB/B,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKqD,aACxCrD,KAAKgB,aAAchB,KAAKiB,QAGhDkC,EAAA/B,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6C,EAAyB3C,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GAEnE,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EACF,GAAIS,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,QAER4B,EAAc9C,EAAMgD,UAAUnC,GAC9BT,EAAO,OACF,GAAU,MAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBAC3B9C,EAAcH,EAAMkD,YAAYrC,EAAOZ,GACvCG,EAAO,OACF,GAAU,KAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBAC3B9C,EAAcH,EAAMmD,YAAYtC,EAAOZ,GACvCG,EAAO,OACF,GAAIe,GAAME,iBAAiBN,GAChCZ,EAAcH,EAAMyC,WAAW5B,GAC/BT,EAAO,OACF,GAAU,KAANW,GAAyB,KAANA,EAC5BZ,EAAcH,EAAMwC,YAAY3B,GAChCT,EAAO,OACF,GAAU,KAANW,GAAmBA,GAAK,IAAaA,GAAK,GACnDZ,EAAcH,EAAMoD,YAAYvC,GAChCT,EAAO,OACF,GAAU,KAANW,EACTZ,EAAcH,EAAMqD,UAAUxC,GAC9BT,EAAO,MACF,CAAA,GAAU,KAANW,EAGJ,OAAKd,EAGHsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAHzBnD,EAAcH,EAAMuD,cAAc1C,GAClCT,EAAO,OAMJ,GAAIS,EAAMc,SACf,OAAK1B,EAGIsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAM/B,GAAa,IAATlD,EAAY,CACd,KAAO0C,EAAa7B,WAAaJ,EAAMgB,WACrCiB,EAAcA,EAAalC,KAAKC,GAElC,GAAIiC,EAAanB,UACf1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKc,EAAarB,QAC1BqB,OAAc,EACd1C,EAAO,OACF,GAAI0C,EAAahB,UACtB,OAAOgB,EAAaJ,UAGxB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,UAAYE,GAAMY,QAAQlB,EAAMK,SAC3CL,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClBb,EAAO,EACP,SACK,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,UACf1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKhC,EAAMiC,KAAK9B,EAAasB,SACrCtB,OAAc,EACdC,EAAO,OACF,GAAID,EAAa2B,UACtB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SACfxB,OAAc,EACdC,EAAO,OACF,GAAID,EAAa2B,UACtB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOS,EAAMI,UAAYE,GAAMY,QAAQlB,EAAMK,SAC3CL,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAqB,KAAjBJ,EAAMK,OAGR,OAAOK,EAAAA,OAAOC,KAAKvB,EAASwB,QAF5BrB,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,MAEF,OAAO,IAAIoB,EAAsB7C,EAAOC,EAAS6C,EAAa3C,EAAaC,IAE/EyC,EAtIA,CAA2CtB,EAAAA,QCD3CiC,EAAA,SAAAzD,GAOE,SAAAyD,EAAYxD,EAA0BC,EAAyB6C,EACnD3C,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK0C,aAAeD,EACpBzC,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IAmGjB,OAjH4CZ,EAAAgE,EAAAzD,GAiB1CyD,EAAA5D,UAAAgB,KAAA,SAAKC,GACH,OAAO2C,EAAiB1C,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKqD,aACxCrD,KAAKgB,aAAchB,KAAKiB,QAGjD6C,EAAA1C,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6C,EAA0B3C,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GACpE,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,QAER4B,EAAc9C,EAAMgD,UAAUnC,GAC9BT,EAAO,OACF,GAAU,MAANW,EACLd,GACFE,EAAcH,EAAMkD,YAAYrC,EAAOZ,GACvCG,EAAO,IAEPD,EAAcH,EAAMkD,YAAYrC,GAChCT,EAAO,OAEJ,CAAA,GAAU,KAANW,EAQJ,OAAKd,EAGHsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UARrBrD,GACFE,EAAcH,EAAMmD,YAAYtC,EAAOZ,GACvCG,EAAO,IAEPD,EAAcH,EAAMmD,YAAYtC,GAChCT,EAAO,QAON,GAAIS,EAAMc,SACf,OAAK1B,EAGIsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAM/B,GAAa,IAATlD,EAAY,CACd,KAAO0C,EAAa7B,WAAaJ,EAAMgB,WACrCiB,EAAcA,EAAalC,KAAKC,GAElC,GAAIiC,EAAanB,UACf1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKc,EAAarB,QAC1BqB,OAAc,EACd1C,EAAO,OACF,GAAI0C,EAAahB,UACtB,OAAOgB,EAAaJ,UAGxB,GAAa,IAATtC,EACF,GAAIS,EAAMI,SAER,GAAU,OADVF,EAAIF,EAAMK,QAERf,EAAcH,EAAMkD,YAAYrC,EAAOZ,GACvCG,EAAO,MACF,CAAA,GAAU,KAANW,EAIT,OAAOQ,EAAAA,OAAOC,KAAKvB,EAASwB,QAH5BtB,EAAcH,EAAMmD,YAAYtC,EAAOZ,GACvCG,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SAGf,OAFA1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKhC,EAAMiC,KAAK9B,EAAasB,SAC9BF,EAAAA,OAAOC,KAAKvB,EAAQwB,QACtB,GAAItB,EAAa2B,UACtB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QACvB,GAAItB,EAAa2B,UACtB,OAAO3B,EAGX,OAAO,IAAIqD,EAAuBxD,EAAOC,EAAS6C,EAAa3C,EAAaC,IAEhFoD,EAjHA,CAA4CjC,EAAAA,QCC5CkC,EAAA,SAAA1D,GAOE,SAAA0D,EAAYzD,EAA0BC,EAAyBC,EACnDC,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKI,WAAaP,EAClBG,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IA8IjB,OA5JwCZ,EAAAiE,EAAA1D,GAiBtC0D,EAAA7D,UAAAgB,KAAA,SAAKC,GACH,OAAO4C,EAAa3C,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKe,WACxCf,KAAKgB,aAAchB,KAAKiB,QAG7C8C,EAAA3C,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCC,EAAuBC,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GACjE,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,OADVF,EAAIF,EAAMK,QAKR,OAAOK,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAY1B,IAHpDA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAY1B,IAGxDG,EAAO,OAAG,CACR,GAAa,IAATZ,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAElB,GADAhB,EAAUA,GAAWD,EAAMiD,gBACjB,MAANlC,EAEF,OADAF,EAAQA,EAAMT,OACPmB,EAAAA,OAAOC,KAAKvB,EAAQwB,QACZ,KAANV,GACTF,EAAQA,EAAMT,OACdA,EAAO,GAEPA,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAY1B,IAGxD,GAAa,IAATT,EAAY,CAId,IAHKF,IACHA,EAAYF,EAAM4B,qBAAqBf,IAElCX,EAAUe,WAAaJ,EAAMgB,WAClC3B,EAAYA,EAAUU,KAAKC,GAE7B,GAAIX,EAAUyB,SACZvB,EAAO,OACF,GAAIF,EAAU4B,UACnB,OAAO5B,EAGX,GAAa,IAATE,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACE,KAANF,GACFF,EAAQA,EAAMT,OACdA,EAAO,IAEPH,EAAS+B,KAAKhC,EAAMiC,KAAK/B,EAAWuB,SACpCvB,OAAY,EACZE,EAAO,QAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAY1B,IAGxD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,UAAYE,GAAMY,QAAQlB,EAAMK,SAC3CL,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACRb,EAAO,OACF,GAAIS,EAAMc,SAEf,OADA1B,EAAS+B,KAAKhC,EAAMkC,KAAKhC,EAAWuB,SAC7BF,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,GAAa,IAATrB,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM4B,qBAAqBf,IAEpCV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACd1B,EAAS+B,KAAKhC,EAAMkC,KAAKhC,EAAWuB,OAAQtB,EAAYsB,SACxDvB,OAAY,EACZC,OAAc,EACdC,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,GAAyB,KAANA,GAAmBI,GAAMgB,UAAUpB,GAAI,CAC5DF,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAGJ,OAAU,MAANA,GACTF,EAAQA,EAAMT,OACPmB,EAAAA,OAAOC,KAAKvB,EAASwB,SAErBF,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,4BAA6B1B,IANrEA,EAAQA,EAAMT,OACdA,EAAO,OAOJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,IAAY1B,IAGxD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,UAAU,CAErB,GADAF,EAAIF,EAAMK,OACLC,GAAMgB,UAAUpB,GAEd,CACLX,EAAO,EACP,SAASY,EAHTH,EAAQA,EAAMT,OAMlB,GAAIS,EAAMc,SAAU,CAClBvB,EAAO,EACP,UAGJ,MAEF,OAAO,IAAIqD,EAAmBzD,EAAOC,EAASC,EAAWC,EAAaC,IAE1EqD,EA5JA,CAAwClC,EAAAA,QCDxCmC,EAAA,SAAA3D,GAOE,SAAA2D,EAAY1D,EAA0BC,EAAyB0D,EACnDxD,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKuD,YAAcD,EACnBtD,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IAkJjB,OAhKwCZ,EAAAkE,EAAA3D,GAiBtC2D,EAAA9D,UAAAgB,KAAA,SAAKC,GACH,OAAO6C,EAAa5C,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKkE,YACxClE,KAAKgB,aAAchB,KAAKiB,QAG7C+C,EAAA5C,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC0D,EAAwBxD,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GAClE,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QAKR,OAAOK,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAHnDA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,OAAG,CACD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,UAED,MADVF,EAAIF,EAAMK,SACmB,KAANH,GAAyB,KAANA,GAA0B,KAANA,GACjD,MAANA,GAA0B,MAANA,GACzBF,EAAQA,EAAMT,QACduD,EAAaA,GAAc3D,EAAM2D,cACtBE,MAAM9C,GAKrB,GAAIF,EAAMI,SAAU,CAClB,GAAU,KAANF,EAMF,OALAF,EAAQA,EAAMT,OACdH,EAAUA,GAAWD,EAAMiD,gBACvBU,GACF1D,EAAQ+B,KAAKhC,EAAMiC,KAAK0B,EAAWlC,SAE9BF,EAAAA,OAAOC,KAAKvB,EAAQwB,QACtB,GAAU,KAANV,EACTd,EAAUA,GAAWD,EAAMiD,gBACvBU,IACF1D,EAAQ+B,KAAKhC,EAAMiC,KAAK0B,EAAWlC,SACnCkC,OAAa,GAEfxD,EAAcH,EAAM8D,gBAAgBjD,GACpCT,EAAO,OACF,GAAU,MAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBACvBU,IACF1D,EAAQ+B,KAAKhC,EAAMiC,KAAK0B,EAAWlC,SACnCkC,OAAa,GAEfxD,EAAcH,EAAMkD,YAAYrC,EAAOZ,GACvCG,EAAO,OACF,GAAU,KAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBACvBU,IACF1D,EAAQ+B,KAAKhC,EAAMiC,KAAK0B,EAAWlC,SACnCkC,OAAa,GAEfxD,EAAcH,EAAMmD,YAAYtC,EAAOZ,GACvCG,EAAO,MACF,CAAA,GAAU,KAANW,EAIT,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAH1CA,EAAQA,EAAMT,OACdA,EAAO,QAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SAAU,CACzB1B,EAAS+B,KAAKhC,EAAMiC,KAAK9B,EAAasB,SACtCtB,OAAc,EACdC,EAAO,EACP,SACK,GAAID,EAAa2B,UACtB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SAAU,CACzBxB,OAAc,EACdC,EAAO,EACP,SACK,GAAID,EAAa2B,UACtB,OAAO3B,EAGX,GAAa,IAATC,EAAY,CACd,GAAIS,EAAMI,SAAU,CAGlB,GAFAF,EAAIF,EAAMK,OACVyC,EAAaA,GAAc3D,EAAM2D,aACvB,KAAN5C,GAAyB,KAANA,GAAyB,KAANA,GAA0B,KAANA,GACjD,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAA0B,KAANA,GACpD,MAANA,GAA0B,MAANA,EACzBF,EAAQA,EAAMT,OACduD,EAAWE,MAAM9C,GACjBX,EAAO,OACF,GAAU,KAANW,EACTF,EAAQA,EAAMT,OACduD,EAAWE,MAAM,GACjBzD,EAAO,OACF,GAAU,MAANW,EACTF,EAAQA,EAAMT,OACduD,EAAWE,MAAM,IACjBzD,EAAO,OACF,GAAU,MAANW,EACTF,EAAQA,EAAMT,OACduD,EAAWE,MAAM,IACjBzD,EAAO,OACF,GAAU,MAANW,EACTF,EAAQA,EAAMT,OACduD,EAAWE,MAAM,IACjBzD,EAAO,MACF,CAAA,GAAU,MAANW,EAKT,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,mBAAoB1B,IAJ5DA,EAAQA,EAAMT,OACduD,EAAWE,MAAM,GACjBzD,EAAO,EAIT,SACK,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,mBAAoB1B,IAGhE,MAEF,OAAO,IAAI6C,EAAmB1D,EAAOC,EAAS0D,EAAYxD,EAAaC,IAE3EsD,EAhKA,CAAwCnC,EAAAA,QCDxCyC,EAAA,SAAAjE,GAKE,SAAAiE,EAAYhE,EAA0BiE,EAA0B7D,GAAhE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK6D,cAAgBD,EACrB5D,EAAKM,MAAQP,IAsCjB,OA/CsCZ,EAAAwE,EAAAjE,GAYpCiE,EAAApE,UAAAgB,KAAA,SAAKC,GACH,OAAOmD,EAAWlD,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKwE,cAAexE,KAAKiB,QAGhEqD,EAAAlD,MAAP,SAAmBD,EAAcb,EACdiE,EAA0B7D,QAAA,IAAAA,IAAAA,EAAA,GAE3C,GAAa,IAATA,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,KADNJ,EAAMK,OAKR,OAAOK,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAHnDA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CAId,IAHK6D,IACHA,EAAeE,EAAAA,OAAOC,WAAWtD,MAAMD,EAAOb,EAAMqE,eAE/CJ,EAAahD,WAAaJ,EAAMgB,WACrCoC,EAAeA,EAAarD,KAAKC,GAEnC,GAAIoD,EAAatC,SACf,OAAOsC,EACF,GAAIA,EAAanC,UACtB,OAAOmC,EAGX,OAAO,IAAID,EAAiBhE,EAAOiE,EAAc7D,IAErD4D,EA/CA,CAAsCzC,EAAAA,QCCtC+C,EAAA,SAAAvE,GAKE,SAAAuE,EAAYtE,EAA0BuE,EAAoBnE,GAA1D,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKmE,QAAUD,EACflE,EAAKM,MAAQP,IAoCjB,OA7CuCZ,EAAA8E,EAAAvE,GAYrCuE,EAAA1E,UAAAgB,KAAA,SAAKC,GACH,OAAOyD,EAAYxD,MAAMD,EAAOnB,KAAKa,OAAQb,KAAK8E,QAAS9E,KAAKiB,QAG3D2D,EAAAxD,MAAP,SAAmBD,EAAcb,EAA0BuE,EACxCnE,QAAA,IAAAA,IAAAA,EAAA,GACjB,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAAU,CAElB,GADAF,EAAIF,EAAMK,QACNC,GAAME,iBAAiBN,GAMzB,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,aAAc1B,IALtDA,EAAQA,EAAMT,OAEdmE,GADAA,EAASA,GAAUvE,EAAM2D,cACTE,MAAM9C,GACtBX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,aAAc1B,IAG1D,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMsD,YAAY1D,KAC5DF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM9C,GAEhB,IAAKF,EAAMgB,UACT,OAAON,EAAAA,OAAOC,KAAKxB,EAAM0E,MAAMH,EAAQ9C,SAG3C,OAAO,IAAI6C,EAAkBtE,EAAOuE,EAAQnE,IAEhDkE,EA7CA,CAAuC/C,EAAAA,QCAvCoD,EAAA,SAAA5E,GAOE,SAAA4E,EAAY3E,EAA0BuE,EAAoBK,EAC9CC,EAAezE,GAD3B,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKmE,QAAUD,EACflE,EAAKyE,OAASF,EACdvE,EAAK0E,MAAQF,EACbxE,EAAKM,MAAQP,IA+HjB,OA7IwCZ,EAAAmF,EAAA5E,GAiBtC4E,EAAA/E,UAAAgB,KAAA,SAAKC,GACH,OAAO8D,EAAa7D,MAAMD,EAAOnB,KAAKa,OAAQb,KAAK8E,QAAS9E,KAAKoF,OACvCpF,KAAKqF,MAAOrF,KAAKiB,QAGtCgE,EAAA7D,MAAP,SAAmBD,EAAcb,EAA0BuE,EACxCK,EAAmBC,EAAkBzE,QAArC,IAAAwE,IAAAA,EAAA,QAAmB,IAAAC,IAAAA,EAAA,QAAkB,IAAAzE,IAAAA,EAAA,GACtD,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,IAAyB,KAANA,GAAqB6D,IAAU7D,GAAe,IAAV6D,GAMzD,OAAOrD,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,SAAU1B,IALlDA,EAAQA,EAAMT,OACdmE,EAASA,GAAUvE,EAAM2D,aACzBiB,EAAQ7D,EACRX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,SAAU1B,IAGtDmE,EAAQ,OAAG,CACT,GAAa,IAAT5E,EAAY,CACd,KAAOS,EAAMI,WACXF,EAAIF,EAAMK,SACD,IAAQH,IAAM6D,GAAe,KAAN7D,GAC9BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM9C,GAKlB,GAAIF,EAAMI,SAAU,CAClB,GAAIF,IAAM6D,EAER,OADA/D,EAAQA,EAAMT,OACPmB,EAAAA,OAAOC,KAAK+C,EAAQ9C,QACtB,GAAU,KAANV,EAIT,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAASqC,EAAO/D,IAH/CA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAASqC,EAAO/D,IAGnD,GAAa,IAATT,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,SACmB,KAANH,GAAyB,KAANA,GAA0B,KAANA,GACjD,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAA0B,KAANA,GACpD,MAANA,GAA0B,MAANA,EAAkB,CAC3CF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM9C,GACdX,EAAO,EACP,SACK,GAAU,KAANW,EAAiB,CAC1BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM,GACdzD,EAAO,EACP,SACK,GAAU,MAANW,EAAkB,CAC3BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM,IACdzD,EAAO,EACP,SACK,GAAU,MAANW,EAAkB,CAC3BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM,IACdzD,EAAO,EACP,SACK,GAAU,MAANW,EAAkB,CAC3BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM,IACdzD,EAAO,EACP,SACK,GAAU,MAANW,EAAkB,CAC3BF,EAAQA,EAAMT,OACdmE,EAAQV,MAAM,GACdzD,EAAO,EACP,SACK,GAAU,MAANW,EAIT,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,mBAAoB1B,IAH5DA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,mBAAoB1B,IAGhE,GAAIT,GAAQ,EACV,OAAG,CACD,GAAIS,EAAMI,SAAU,CAElB,GADAF,EAAIF,EAAMK,OACN+D,EAAAA,OAAOC,QAAQnE,GAAI,CAGrB,GAFAF,EAAQA,EAAMT,OACdyE,EAAO,GAAKA,EAAOI,EAAAA,OAAOE,YAAYpE,GAClCX,GAAQ,EAAG,CACbA,GAAQ,EACR,SAEAmE,EAAQV,MAAMgB,GACdA,EAAO,EACPzE,EAAO,EACP,SAAS4E,EAGX,OAAOzD,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,YAAa1B,IAElD,GAAIA,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,YAAa1B,IAEvD,MAGJ,MAEF,OAAO,IAAI8D,EAAmB3E,EAAOuE,EAAQK,EAAOC,EAAMzE,IAE9DuE,EA7IA,CAAwCpD,EAAAA,QCAxC6D,EAAA,SAAArF,GAOE,SAAAqF,EAAYpF,EAA0BqF,EAAeC,EAAgBC,EAAenF,GAApF,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKmF,MAAQH,EACbhF,EAAKoF,OAASH,EACdjF,EAAKqF,MAAQH,EACblF,EAAKM,MAAQP,IA6FjB,OA1GwCZ,EAAA4F,EAAArF,GAgBtCqF,EAAAxF,UAAAgB,KAAA,SAAKC,GACH,OAAOuE,EAAatE,MAAMD,EAAOnB,KAAKa,OAAQb,KAAK8F,MAAO9F,KAAK+F,OAAQ/F,KAAKgG,MAAOhG,KAAKiB,QAGnFyE,EAAAtE,MAAP,SAAmBD,EAAcb,EAA0BqF,EAAkBC,EAC1DC,EAAkBnF,QADsB,IAAAiF,IAAAA,EAAA,QAAkB,IAAAC,IAAAA,EAAA,QAC1D,IAAAC,IAAAA,EAAA,QAAkB,IAAAnF,IAAAA,EAAA,GACnC,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACE,KAANF,IACFF,EAAQA,EAAMT,OACdiF,GAAQ,GAEVjF,EAAO,OACF,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,SAAU1B,IAGtD,GAAa,IAATT,EACF,GAAIS,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,QAERL,EAAQA,EAAMT,OACdA,EAAO,MACF,CAAA,KAAIW,GAAK,IAAaA,GAAK,IAKhC,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAJjDA,EAAQA,EAAMT,OACdkF,EAAQD,GAAQtE,EAAI,IACpBX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAGrD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,WACXF,EAAIF,EAAMK,SACD,IAAaH,GAAK,IAFN,CAGnB,IAAM4E,EAAW,GAAKL,EAAQD,GAAQtE,EAAI,IAC1C,MAAK,kBAAoB4E,GAAYA,GAAY,kBAI/C,OAAOpE,EAAAA,OAAOc,MAAMC,EAAAA,WAAWsD,QAAQ,mBAAoB/E,IAH3DyE,EAAQK,EACR9E,EAAQA,EAAMT,OAQpB,GAAIS,EAAMI,SACRb,EAAO,OACF,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAIP,IAGjC,GAAa,IAATlF,EAAY,CACd,GAAIS,EAAMI,SAAU,CAElB,GADAF,EAAIF,EAAMK,OACNqE,EAAO,GAAW,KAANxE,GAAmBwE,EAAO,IAAY,KAANxE,GAAyB,MAANA,GAAmB,CACpF,IAAIwD,EAASuB,EAAAA,QAAQC,eAMrB,OAJExB,EADEc,EAAO,GAAe,IAAVC,EACLf,EAAOV,MAAM,IAAWA,MAAM,IAE9BU,EAAOV,MAAM,GAAKyB,GAEtBU,EAAclF,MAAMD,EAAOb,EAAOuE,EAAQgB,GAC5C,OAAU,MAANxE,GAAoBsE,EAAO,GAAe,IAAVC,GACzCzE,EAAQA,EAAMT,OACP6F,EAAkBnF,MAAMD,EAAOb,IAE/BuB,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAIP,IAE1B,GAAIzE,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAIP,IAGjC,OAAO,IAAIF,EAAmBpF,EAAOqF,EAAMC,EAAOC,EAAMnF,IAGnDgF,EAAAc,aAAP,SAA0BrF,EAAcb,GACtC,OAAOoF,EAAatE,MAAMD,EAAOb,OAAO,OAAQ,EAAQ,IAGnDoF,EAAAe,aAAP,SAA0BtF,EAAcb,GACtC,OAAOoF,EAAatE,MAAMD,EAAOb,OAAO,OAAQ,EAAQ,IAE5DoF,EA1GA,CAAwC7D,EAAAA,QA6GxCyE,EAAA,SAAAjG,GAME,SAAAiG,EAAYhG,EAA0BuE,EAAwBgB,EAAenF,GAA7E,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKmE,QAAUD,EACflE,EAAKqF,MAAQH,EACblF,EAAKM,MAAQP,IAkHjB,OA7HkCZ,EAAAwG,EAAAjG,GAchCiG,EAAApG,UAAAgB,KAAA,SAAKC,GACH,OAAOmF,EAAclF,MAAMD,EAAOnB,KAAKa,OAAQb,KAAK8E,QAAS9E,KAAKgG,MAAOhG,KAAKiB,QAGzEqF,EAAAlF,MAAP,SAAmBD,EAAcb,EAA0BuE,EACxCgB,EAAkBnF,QAAlB,IAAAmF,IAAAA,EAAA,QAAkB,IAAAnF,IAAAA,EAAA,GACnC,IAAIW,EAAI,EACR,GAAa,IAATX,EACF,GAAIS,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,QAERL,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GACtBX,EAAO,MACF,CAAA,KAAImF,EAAO,IAAY,KAANxE,GAAyB,MAANA,EAKzC,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,sBAAuB1B,IAJ/DA,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GACtBX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,sBAAuB1B,IAGnE,GAAa,IAATT,EACF,GAAIS,EAAMI,SAAU,CAElB,MADAF,EAAIF,EAAMK,SACD,IAAaH,GAAK,IAKzB,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAJjDA,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GACtBX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAGrD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,WACXF,EAAIF,EAAMK,SACD,IAAaH,GAAK,IACzBF,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GAK1B,GAAIF,EAAMI,SAAU,CAClB,KAAIsE,EAAO,GAGT,OAAOhE,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAItB,EAAO9C,SAFpCrB,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAItB,EAAO9C,SAGxC,GAAa,IAATrB,EAAY,CAEd,GAAU,MADVW,EAAIF,EAAMK,SACmB,MAANH,EAKrB,OAAOQ,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAItB,EAAO9C,SAJpCZ,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GACtBX,EAAO,EAKX,GAAa,IAATA,EACF,GAAIS,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SACmB,KAANH,IACrBF,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,IAExBX,EAAO,OACF,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EACF,GAAIS,EAAMI,SAAU,CAElB,MADAF,EAAIF,EAAMK,SACD,IAAaH,GAAK,IAKzB,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAJjDA,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GACtBX,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAGrD,GAAa,IAATT,EAAY,CACd,KAAOS,EAAMI,WACXF,EAAIF,EAAMK,SACD,IAAaH,GAAK,IACzBF,EAAQA,EAAMT,OACdmE,EAASA,EAAOV,MAAM9C,GAK1B,IAAKF,EAAMgB,UACT,OAAON,EAAAA,OAAOC,KAAKxB,EAAM6F,IAAItB,EAAO9C,SAGxC,OAAO,IAAIuE,EAAoBhG,EAAOuE,EAAQgB,EAAMnF,IAExD4F,EA7HA,CAAkCzE,EAAAA,QAgIlC0E,EAAA,SAAAlG,GAKE,SAAAkG,EAAYjG,EAA0BsF,EAAgBc,GAAtD,IAAA/F,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKoF,OAASH,EACdjF,EAAKgG,MAAQD,IAiCjB,OA1CsC5G,EAAAyG,EAAAlG,GAYpCkG,EAAArG,UAAAgB,KAAA,SAAKC,GACH,OAAOoF,EAAkBnF,MAAMD,EAAOnB,KAAKa,OAAQb,KAAK+F,OAAQ/F,KAAK2G,QAGhEJ,EAAAnF,MAAP,SAAmBD,EAAcb,EACdsF,EAAmBc,QAAnB,IAAAd,IAAAA,EAAA,QAAmB,IAAAc,IAAAA,EAAA,GAEpC,IADA,IAAIrF,EAAI,EACDF,EAAMI,WACXF,EAAIF,EAAMK,OACN+D,EAAAA,OAAOC,QAAQnE,KACjBF,EAAQA,EAAMT,OACdkF,EAAQ,GAAKA,EAAQL,EAAAA,OAAOE,YAAYpE,GACxCqF,GAAQ,EAKZ,OAAKvF,EAAMgB,UAWJ,IAAIoE,EAAwBjG,EAAOsF,EAAOc,GAV3CA,EAAO,EACLA,GAAQ,EACH7E,EAAAA,OAAOC,KAAKxB,EAAMsG,OAAOhB,IAEzB/D,EAAAA,OAAOC,KAAKxB,EAAMuG,OAAOjB,IAG3B/D,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,YAAa1B,KAK7DoF,EA1CA,CAAsC1E,EAAAA,QC7OtCiF,EAAA,SAAAzG,GAOE,SAAAyG,EAAYxG,EAA0BC,EAAyBwG,EACnDC,EAA4BtG,GADxC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKsG,gBAAkBF,EACvBpG,EAAKuG,gBAAkBF,EACvBrG,EAAKM,MAAQP,IAuDjB,OArE4CZ,EAAAgH,EAAAzG,GAiB1CyG,EAAA5G,UAAAgB,KAAA,SAAKC,GACH,OAAO2F,EAAiB1F,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKiH,gBACxCjH,KAAKkH,gBAAiBlH,KAAKiB,QAGpD6F,EAAA1F,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCwG,EAA4BC,EAA4BtG,QAAA,IAAAA,IAAAA,EAAA,GAEzE,GAAa,IAATA,EAAY,CAId,IAHKqG,IACHA,EAAiBzG,EAAM6G,yBAAyBhG,EAAOZ,IAElDwG,EAAexF,WAAaJ,EAAMgB,WACvC4E,EAAiBA,EAAe7F,KAAKC,GAEvC,GAAI4F,EAAe9E,SACjBvB,EAAO,OACF,GAAIqG,EAAe3E,UACxB,OAAO2E,EAAe/D,UAG1B,GAAa,IAATtC,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,KADNJ,EAAMK,OAMR,OAAOuF,EAHP5F,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAO8E,EAGX,GAAa,IAATrG,EAAY,CAId,IAHKsG,IACHA,EAAiB1G,EAAM6G,yBAAyBhG,IAE3C6F,EAAezF,WAAaJ,EAAMgB,WACvC6E,EAAiBA,EAAe9F,KAAKC,GAEvC,GAAI6F,EAAe/E,SAAU,CAC3B,IAAMmF,EAAWL,EAAgBhF,OAC3BsF,EAAWL,EAAejF,OAChC,OAAOF,EAAAA,OAAOC,KAAKxB,EAAMgH,OAAOF,EAAUC,IACrC,GAAIL,EAAe5E,UACxB,OAAO4E,EAAehE,UAG1B,OAAO,IAAI8D,EAAuBxG,EAAOC,EAASwG,EAAgBC,EAAgBtG,IAEtFoG,EArEA,CAA4CjF,EAAAA,QCC5C0F,EAAA,SAAAlH,GAQE,SAAAkH,EAAYjH,EAA0BC,EAAyBiH,EACnDC,EAAwBC,EAAwBhH,GAD5D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKgH,UAAYH,EACjB7G,EAAKiH,YAAcH,EACnB9G,EAAKkH,YAAcH,EACnB/G,EAAKM,MAAQP,IAsFjB,OAtGqDZ,EAAAyH,EAAAlH,GAmBnDkH,EAAArH,UAAAgB,KAAA,SAAKC,GACH,OAAOoG,EAA0BnG,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAK2H,UACxC3H,KAAK4H,YAAa5H,KAAK6H,YAAa7H,KAAKiB,QAG3EsG,EAAAnG,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCiH,EAAsBC,EACtBC,EAAwBhH,QAAA,IAAAA,IAAAA,EAAA,GACzC,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CAId,IAHK8G,IACHA,EAAWlH,EAAMwH,gBAAgB3G,EAAOZ,IAEnCiH,EAASjG,WAAaJ,EAAMgB,WACjCqF,EAAWA,EAAStG,KAAKC,GAE3B,GAAIqG,EAASvF,SACXvB,EAAO,OACF,GAAI8G,EAASpF,UAClB,OAAOoF,EAASxE,UAGpB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAIF,OAAOmG,EAHPrG,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOuF,EAGX,GAAa,IAAT9G,EAAY,CAId,IAHK+G,IACHA,EAAanH,EAAM6G,yBAAyBhG,EAAOZ,IAE9CkH,EAAWlG,WAAaJ,EAAMgB,WACnCsF,EAAaA,EAAWvG,KAAKC,GAE/B,GAAIsG,EAAWxF,SACbvB,EAAO,OACF,GAAI+G,EAAWrF,UACpB,OAAOqF,EAAWzE,UAGtB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAIF,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAHnDA,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CAId,IAHKgH,IACHA,EAAapH,EAAM6G,yBAAyBhG,EAAOZ,IAE9CmH,EAAWnG,WAAaJ,EAAMgB,WACnCuF,EAAaA,EAAWxG,KAAKC,GAE/B,GAAIuG,EAAWzF,SAAU,CACvB,IAAM8F,EAASP,EAAUzF,OACnBiG,EAAWP,EAAY1F,OACvBkG,EAAWP,EAAW3F,OAC5B,OAAOF,EAAAA,OAAOC,KAAKxB,EAAM4H,YAAYH,EAAQC,EAAUC,IAClD,GAAIP,EAAWtF,UACpB,OAAOsF,EAAW1E,UAGtB,OAAO,IAAIuE,EAAgCjH,EAAOC,EAASiH,EAAUC,EAAYC,EAAYhH,IAEjG6G,EAtGA,CAAqD1F,EAAAA,QCDrDsG,EAAA,SAAA9H,GAOE,SAAA8H,EAAY7H,EAA0BC,EAC1B6H,EAAuBC,EAAuB3H,GAD1D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA6DjB,OA3E4CZ,EAAAqI,EAAA9H,GAiB1C8H,EAAAjI,UAAAgB,KAAA,SAAKC,GACH,OAAOgH,EAAiB/G,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKsI,WACxCtI,KAAKuI,WAAYvI,KAAKiB,QAG/CkH,EAAA/G,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6H,EAAuBC,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE/D,OAAG,CACD,GAAa,IAATA,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAMkI,iBAAiBrH,EAAOZ,IAErC6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADNJ,EAAMK,OAMR,OAAO4G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMkI,iBAAiBrH,EAAOZ,IAErC8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtBqG,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMqI,GAAGF,EAAKC,IACtCL,OAAY,EACZ3H,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAImF,EAAuB7H,EAAOC,EAAS6H,EAAWC,EAAW3H,IAE5EyH,EA3EA,CAA4CtG,EAAAA,QCA5C+G,EAAA,SAAAvI,GAOE,SAAAuI,EAAYtI,EAA0BC,EAC1B6H,EAAuBC,EAAuB3H,GAD1D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA6DjB,OA3E6CZ,EAAA8I,EAAAvI,GAiB3CuI,EAAA1I,UAAAgB,KAAA,SAAKC,GACH,OAAOyH,EAAkBxH,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKsI,WACxCtI,KAAKuI,WAAYvI,KAAKiB,QAGhD2H,EAAAxH,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6H,EAAuBC,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE/D,OAAG,CACD,GAAa,IAATA,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAMuI,uBAAuB1H,EAAOZ,IAE3C6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,KADNJ,EAAMK,OAMR,OAAO4G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMuI,uBAAuB1H,EAAOZ,IAE3C8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtBqG,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMwI,IAAIL,EAAKC,IACvCL,OAAY,EACZ3H,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAI4F,EAAwBtI,EAAOC,EAAS6H,EAAWC,EAAW3H,IAE7EkI,EA3EA,CAA6C/G,EAAAA,QCC7CkH,EAAA,SAAA1I,GAOE,SAAA0I,EAAYzI,EAA0BC,EAC1B6H,EAAuBC,EAAuB3H,GAD1D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA0EjB,OAxFmDZ,EAAAiJ,EAAA1I,GAiBjD0I,EAAA7I,UAAAgB,KAAA,SAAKC,GACH,OAAO4H,EAAwB3H,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKsI,WAAYtI,KAAKuI,WAAYvI,KAAKiB,QAGvE8H,EAAA3H,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6H,EAAuBC,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE/D,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAM0I,wBAAwB7H,EAAOZ,IAE5C6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,MAANF,EAIF,OAAO+G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,OADVF,EAAIF,EAAMK,QAER,OAAO4G,EAEP1H,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAM0I,wBAAwB7H,EAAOZ,IAE5C8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtBqG,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAM2I,UAAUR,EAAKC,IAC7CL,OAAY,EACZ3H,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAI+F,EAA8BzI,EAAOC,EAAS6H,EAAWC,EAAW3H,IAEnFqI,EAxFA,CAAmDlH,EAAAA,QCAnDqH,EAAA,SAAA7I,GAOE,SAAA6I,EAAY5I,EAA0BC,EAC1B6H,EAAuBC,EAAuB3H,GAD1D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA8DjB,OA5EoDZ,EAAAoJ,EAAA7I,GAiBlD6I,EAAAhJ,UAAAgB,KAAA,SAAKC,GACH,OAAO+H,EAAyB9H,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKsI,WAAYtI,KAAKuI,WAAYvI,KAAKiB,QAGxEiI,EAAA9H,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6H,EAAuBC,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE/D,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAM6I,wBAAwBhI,EAAOZ,IAE5C6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAIF,OAAO+G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAM6I,wBAAwBhI,EAAOZ,IAE5C8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtBqG,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAM8I,WAAWX,EAAKC,IAC9CL,OAAY,EACZ3H,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAIkG,EAA+B5I,EAAOC,EAAS6H,EAAWC,EAAW3H,IAEpFwI,EA5EA,CAAoDrH,EAAAA,QCApDwH,EAAA,SAAAhJ,GAOE,SAAAgJ,EAAY/I,EAA0BC,EAC1B6H,EAAuBC,EAAuB3H,GAD1D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA0EjB,OAxFoDZ,EAAAuJ,EAAAhJ,GAiBlDgJ,EAAAnJ,UAAAgB,KAAA,SAAKC,GACH,OAAOkI,EAAyBjI,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKsI,WAAYtI,KAAKuI,WAAYvI,KAAKiB,QAGxEoI,EAAAjI,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6H,EAAuBC,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE/D,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAMgJ,wBAAwBnI,EAAOZ,IAE5C6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAIF,OAAO+G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QAER,OAAO4G,EAEP1H,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMgJ,wBAAwBnI,EAAOZ,IAE5C8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtBqG,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMiJ,WAAWd,EAAKC,IAC9CL,OAAY,EACZ3H,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAIqG,EAA+B/I,EAAOC,EAAS6H,EAAWC,EAAW3H,IAEpF2I,EAxFA,CAAoDxH,EAAAA,QCApD2H,EAAA,SAAAnJ,GAQE,SAAAmJ,EAAYlJ,EAA0BC,EAAyB6H,EACnDqB,EAAmBpB,EAAuB3H,GADtD,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK+I,UAAYD,EACjB9I,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA6IjB,OA7JoDZ,EAAA0J,EAAAnJ,GAmBlDmJ,EAAAtJ,UAAAgB,KAAA,SAAKC,GACH,OAAOqI,EAAyBpI,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKsI,WACxCtI,KAAK0J,UAAW1J,KAAKuI,WAAYvI,KAAKiB,QAGvEuI,EAAApI,MAAP,SAAmBD,EAAcb,EAA0BC,EAAyB6H,EACjEqB,EAAmBpB,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAC3D,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAMqJ,oBAAoBxI,EAAOZ,IAExC6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,EACFF,EAAQA,EAAMT,OACdA,EAAO,OACF,GAAU,KAANW,EACTF,EAAQA,EAAMT,OACdA,EAAO,OACF,GAAU,KAANW,EACTF,EAAQA,EAAMT,OACdA,EAAO,MACF,CAAA,GAAU,KAANW,EAIT,OAAO+G,EAHPjH,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EACF,GAAIS,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SAERL,EAAQA,EAAMT,OACd+I,EAAW,KACX/I,EAAO,IAEP+I,EAAW,IACX/I,EAAO,QAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EACF,GAAIS,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SAERL,EAAQA,EAAMT,OACd+I,EAAW,KACX/I,EAAO,IAEP+I,EAAW,IACX/I,EAAO,QAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EACF,GAAIS,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SAERL,EAAQA,EAAMT,OACd+I,EAAW,KACX/I,EAAO,IAEP+I,EAAW,IACX/I,EAAO,QAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EACF,GAAIS,EAAMI,SAER,GAAU,MADVF,EAAIF,EAAMK,QAERL,EAAQA,EAAMT,OACd+I,EAAW,KACX/I,EAAO,MACF,CAAA,GAAU,KAANW,EACT,OAAO+G,EAEPqB,EAAW,IACX/I,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,GAAa,IAATT,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMqJ,oBAAoBxI,EAAOZ,IAExC8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtB,MAAiB,MAAb0H,EACK5H,EAAAA,OAAOC,KAAKxB,EAAMsJ,GAAGnB,EAAKC,IACX,OAAbe,EACF5H,EAAAA,OAAOC,KAAKxB,EAAMuJ,GAAGpB,EAAKC,IACX,OAAbe,EACF5H,EAAAA,OAAOC,KAAKxB,EAAMwJ,GAAGrB,EAAKC,IACX,OAAbe,EACF5H,EAAAA,OAAOC,KAAKxB,EAAMyJ,GAAGtB,EAAKC,IACX,OAAbe,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM0J,GAAGvB,EAAKC,IACX,MAAbe,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM2J,GAAGxB,EAAKC,IAE1B7G,EAAAA,OAAOc,MAAMC,EAAAA,WAAWsD,QAAQuD,EAAWtI,IAE/C,GAAIkH,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,OAAO,IAAIwG,EAA+BlJ,EAAOC,EAAS6H,EAAWqB,EAAUpB,EAAW3H,IAE9F8I,EA7JA,CAAoD3H,EAAAA,QCApDqI,EAAA,SAAA7J,GAOE,SAAA6J,EAAY5J,EAA0BC,EAC1B6C,EAAyB3C,EAAyBC,GAD9D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK0C,aAAeD,EACpBzC,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IA8HjB,OA5IgDZ,EAAAoK,EAAA7J,GAiB9C6J,EAAAhK,UAAAgB,KAAA,SAAKC,GACH,OAAO+I,EAAqB9I,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKqD,aAAcrD,KAAKgB,aAAchB,KAAKiB,QAGxEiJ,EAAA9I,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC6C,EAAyB3C,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GAEnE,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,EACFX,EAAO,OACF,GAAU,MAANW,GAA0B,KAANA,EAC7Bd,EAAUA,GAAWD,EAAMiD,gBAC3B7C,EAAO,OACF,GAAU,KAANW,EACTX,EAAO,MACF,CAAA,KAAU,KAANW,GAAyB,KAANA,GAAyB,KAANA,GAAyB,KAANA,GACnD,KAANA,GAA0B,KAANA,GAAyB,KAANA,GACvCA,GAAK,IAAaA,GAAK,IAAmB,MAANA,GACpCI,GAAME,iBAAiBN,IAE3B,OAAKd,EAGHsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAFzBlD,EAAO,OAMJ,GAAIS,EAAMc,SACf,OAAK1B,EAGIsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAM/B,GAAa,IAATlD,EAAY,CAId,IAHK0C,IACHA,EAAc9C,EAAMgD,UAAUnC,IAEzBiC,EAAY7B,WAAaJ,EAAMgB,WACpCiB,EAAcA,EAAYlC,KAAKC,GAEjC,GAAIiC,EAAYnB,SAAU,EACxB1B,EAAUA,GAAWD,EAAMiD,iBACnBjB,KAAKc,EAAYrB,QACzBqB,OAAc,EACd1C,EAAO,EACP,SACK,GAAI0C,EAAYhB,UACrB,OAAOgB,EAAYJ,UAGvB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM6J,sBAAsBhJ,IAErCV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,UACd1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKhC,EAAMiC,KAAK9B,EAAYsB,SACpCtB,OAAc,EACdC,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM6J,sBAAsBhJ,EAAOZ,IAE5CE,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACT1B,IACHA,EAAUD,EAAMsB,gBACRU,KAAKhC,EAAMiC,KAAK9B,EAAYsB,SAEtCtB,OAAc,EACdC,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM6J,sBAAsBhJ,EAAOZ,IAE5CE,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdxB,OAAc,EACdC,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAAiB,CACnBX,EAAO,EACP,SAEA,OAAOmB,EAAAA,OAAOC,KAAKvB,EAASwB,QAEzB,GAAIZ,EAAMc,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QAGhC,MAEF,OAAO,IAAImI,EAA2B5J,EAAOC,EAAS6C,EAAa3C,EAAaC,IAEpFwJ,EA5IA,CAAgDrI,EAAAA,QCAhDuI,EAAA,SAAA/J,GAQE,SAAA+J,EAAY9J,EAA0BC,EAAyB6H,EACnDqB,EAAmBpB,EAAuB3H,GADtD,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK+I,UAAYD,EACjB9I,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IA0EjB,OA1FkDZ,EAAAsK,EAAA/J,GAmBhD+J,EAAAlK,UAAAgB,KAAA,SAAKC,GACH,OAAOiJ,EAAuBhJ,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKsI,WACxCtI,KAAK0J,UAAW1J,KAAKuI,WAAYvI,KAAKiB,QAGrEmJ,EAAAhJ,MAAP,SAAmBD,EAAcb,EAA0BC,EAAyB6H,EACjEqB,EAAmBpB,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE3D,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAM+J,4BAA4BlJ,EAAOZ,IAEhD6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,EACFF,EAAQA,EAAMT,OACd+I,EAAW,IACX/I,EAAO,MACF,CAAA,GAAU,KAANW,EAKT,OAAO+G,EAJPjH,EAAQA,EAAMT,OACd+I,EAAW,IACX/I,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAM+J,4BAA4BlJ,EAAOZ,IAEhD8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtB,GAAiB,MAAb0H,EACFrB,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMgK,KAAK7B,EAAKC,QACnC,CAAA,GAAiB,MAAbe,EAGT,OAAO5H,EAAAA,OAAOc,MAAMC,EAAAA,WAAWsD,QAAQuD,EAAWtI,IAFlDiH,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMiK,MAAM9B,EAAKC,IAI3CL,OAAY,EACZoB,OAAW,EACX/I,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAIoH,EAA6B9J,EAAOC,EAAS6H,EAAWqB,EAAUpB,EAAW3H,IAE5F0J,EA1FA,CAAkDvI,EAAAA,QCAlD2I,EAAA,SAAAnK,GAQE,SAAAmK,EAAYlK,EAA0BC,EAAyB6H,EACnDqB,EAAmBpB,EAAuB3H,GADtD,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK2H,WAAaF,EAClBzH,EAAK+I,UAAYD,EACjB9I,EAAK4H,WAAaF,EAClB1H,EAAKM,MAAQP,IAgFjB,OAhGwDZ,EAAA0K,EAAAnK,GAmBtDmK,EAAAtK,UAAAgB,KAAA,SAAKC,GACH,OAAOqJ,EAA6BpJ,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKsI,WACxCtI,KAAK0J,UAAW1J,KAAKuI,WAAYvI,KAAKiB,QAG3EuJ,EAAApJ,MAAP,SAAmBD,EAAcb,EAA0BC,EAAyB6H,EACjEqB,EAAmBpB,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAE3D,IADA,IAAIW,EAAI,IACL,CACD,GAAa,IAATX,EAAY,CAId,IAHK0H,IACHA,EAAY9H,EAAMmK,oBAAoBtJ,EAAOZ,IAExC6H,EAAU7G,WAAaJ,EAAMgB,WAClCiG,EAAYA,EAAUlH,KAAKC,GAE7B,GAAIiH,EAAUnG,SACZvB,EAAO,OACF,GAAI0H,EAAUhG,UACnB,OAAOgG,EAAUpF,UAGrB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,EACFF,EAAQA,EAAMT,OACd+I,EAAW,IACX/I,EAAO,OACF,GAAU,KAANW,EACTF,EAAQA,EAAMT,OACd+I,EAAW,IACX/I,EAAO,MACF,CAAA,GAAU,KAANW,EAKT,OAAO+G,EAJPjH,EAAQA,EAAMT,OACd+I,EAAW,IACX/I,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOmG,EAGX,GAAa,IAAT1H,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMmK,oBAAoBtJ,EAAOZ,IAExC8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAMwG,EAAML,EAAWrG,OACjB2G,EAAML,EAAUtG,OACtB,GAAiB,MAAb0H,EACFrB,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMoK,MAAMjC,EAAKC,SACpC,GAAiB,MAAbe,EACTrB,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMqK,OAAOlC,EAAKC,QACrC,CAAA,GAAiB,MAAbe,EAGT,OAAO5H,EAAAA,OAAOc,MAAMC,EAAAA,WAAWsD,QAAQuD,EAAWtI,IAFlDiH,EAAYvG,EAAAA,OAAOC,KAAKxB,EAAMsK,OAAOnC,EAAKC,IAI5CL,OAAY,EACZoB,OAAW,EACX/I,EAAO,EACP,SACK,GAAI2H,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,MAEF,OAAO,IAAIwH,EAAmClK,EAAOC,EAAS6H,EAAWqB,EAAUpB,EAAW3H,IAElG8J,EAhGA,CAAwD3I,EAAAA,QCAxDgJ,EAAA,SAAAxK,GAOE,SAAAwK,EAAYvK,EAA0BC,EAC1BkJ,EAAmBpB,EAAuB3H,GADtD,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK+I,UAAYD,EACjB9I,EAAKmK,eAAiBzC,EACtB1H,EAAKM,MAAQP,IAgEjB,OA9EgDZ,EAAA+K,EAAAxK,GAiB9CwK,EAAA3K,UAAAgB,KAAA,SAAKC,GACH,OAAO0J,EAAqBzJ,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAK0J,UAAW1J,KAAK8K,eAAgB9K,KAAKiB,QAGvE4J,EAAAzJ,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCkJ,EAAmBpB,EAAuB3H,QAAA,IAAAA,IAAAA,EAAA,GAC3D,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EACFF,EAAQA,EAAMT,OACd+I,EAAW,SACN,GAAU,MAANpI,EACTF,EAAQA,EAAMT,OACd+I,EAAW,SACN,GAAU,KAANpI,EACTF,EAAQA,EAAMT,OACd+I,EAAW,QACN,CAAA,GAAU,KAANpI,EAIT,OAAOf,EAAMyK,oBAAoB5J,EAAOZ,GAHxCY,EAAQA,EAAMT,OACd+I,EAAW,IAIb/I,EAAO,OACF,GAAIS,EAAMc,SACf,OAAO3B,EAAMyK,oBAAoB5J,EAAOZ,GAG5C,GAAa,IAATG,EAAY,CAId,IAHK2H,IACHA,EAAY/H,EAAMmK,oBAAoBtJ,EAAOZ,IAExC8H,EAAU9G,WAAaJ,EAAMgB,WAClCkG,EAAYA,EAAUnH,KAAKC,GAE7B,GAAIkH,EAAUpG,SAAU,CACtB,IAAM+I,EAAU3C,EAAUtG,OAC1B,OAAKzB,EAAM2K,WAAWD,GAEE,MAAbvB,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM4K,IAAIF,IACP,MAAbvB,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM6K,WAAWH,IACd,MAAbvB,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM8K,SAASJ,IACZ,MAAbvB,EACF5H,EAAAA,OAAOC,KAAKxB,EAAM+K,SAASL,IAE3BnJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWsD,QAAQuD,EAAWtI,IAV3CU,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,QAAS1B,IAY9C,GAAIkH,EAAUjG,UACnB,OAAOiG,EAAUrF,UAGrB,OAAO,IAAI6H,EAA2BvK,EAAOC,EAASkJ,EAAUpB,EAAW3H,IAE/EmK,EA9EA,CAAgDhJ,EAAAA,QCAhDyJ,EAAA,SAAAjL,GAOE,SAAAiL,EAAYhL,EAA0BC,EAC1BgL,EAAwBC,EAAwB9K,GAD5D,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK8K,YAAcF,EACnB5K,EAAK+K,YAAcF,EACnB7K,EAAKM,MAAQP,IA+FjB,OA7GgDZ,EAAAwL,EAAAjL,GAiB9CiL,EAAApL,UAAAgB,KAAA,SAAKC,GACH,OAAOmK,EAAqBlK,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKyL,YAAazL,KAAK0L,YAAa1L,KAAKiB,QAGtEqK,EAAAlK,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCgL,EAAwBC,EAAwB9K,QAAA,IAAAA,IAAAA,EAAA,GACjE,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CAId,IAHK6K,IACHA,EAAajL,EAAMqL,aAAaxK,EAAOZ,IAElCgL,EAAWhK,WAAaJ,EAAMgB,WACnCoJ,EAAaA,EAAWrK,KAAKC,GAE/B,GAAIoK,EAAWtJ,SACbvB,EAAO,OACF,GAAI6K,EAAWnJ,UACpB,OAAOmJ,EAAWvI,UAGtB,OAAG,CACD,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAIF,OAAOkK,EAHPpK,EAAQA,EAAMT,OACdA,EAAO,OAIJ,GAAIS,EAAMc,SACf,OAAOsJ,EAGX,GAAa,IAAT7K,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAAiB,CACnBF,EAAQA,EAAMT,OACd,IAAMkL,EAAOL,EAAYxJ,OACzBwJ,EAAa1J,EAAAA,OAAOC,KAAKxB,EAAMuL,OAAOD,EAAMtL,EAAMsD,WAClDlD,EAAO,EACP,SAEAA,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CAId,IAHK8K,IACHA,EAAalL,EAAM4C,WAAW/B,IAEzBqK,EAAWjK,WAAaJ,EAAMgB,WACnCqJ,EAAaA,EAAWtK,KAAKC,GAE/B,GAAIqK,EAAWvJ,SACbvB,EAAO,OACF,GAAI8K,EAAWpJ,UACpB,OAAOoJ,EAAWxI,UAGtB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CACpB,GAAU,KAANF,EAAiB,CACjBF,EAAQA,EAAMT,OACRkL,EAAOL,EAAYxJ,OAAzB,IACM+J,EAAON,EAAYzJ,OACzBwJ,EAAa1J,EAAAA,OAAOC,KAAKxB,EAAMuL,OAAOD,EAAME,IAC5CN,OAAa,EACb9K,EAAO,EACP,SAEA,OAAOmB,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAEhD,GAAIA,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,MAEF,OAAO,IAAImK,EAA2BhL,EAAOC,EAASgL,EAAYC,EAAY9K,IAElF4K,EA7GA,CAAgDzJ,EAAAA,QCAhDkK,EAAA,SAAA1L,GAME,SAAA0L,EAAYzL,EAA0BC,EAC1BgL,EAAwB7K,GADpC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAK8K,YAAcF,EACnB5K,EAAKM,MAAQP,IAqGjB,OAjHyCZ,EAAAiM,EAAA1L,GAevC0L,EAAA7L,UAAAgB,KAAA,SAAKC,GACH,OAAO4K,EAAc3K,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKyL,YAAazL,KAAKiB,QAG7C8K,EAAA3K,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCgL,EAAwB7K,QAAA,IAAAA,IAAAA,EAAA,GACzC,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEZS,EAAMI,SACE,KAANF,GACFF,EAAQA,EAAMT,OACdA,EAAO,GAEPA,EAAO,EAEAS,EAAMc,WACfvB,EAAO,GAGX,GAAa,IAATA,EAAY,CAId,IAHK6K,IACHA,EAAajL,EAAM0L,aAAa7K,EAAOZ,IAElCgL,EAAWhK,WAAaJ,EAAMgB,WACnCoJ,EAAaA,EAAWrK,KAAKC,GAE/B,GAAIoK,EAAWtJ,SACb,OAAOsJ,EACF,GAAIA,EAAWnJ,UACpB,OAAOmJ,EAAWvI,UAGtB,GAAa,IAATtC,EAAY,CAId,IAHK6K,IACHA,EAAajL,EAAM4B,qBAAqBf,EAAOZ,IAE1CgL,EAAWhK,WAAaJ,EAAMgB,WACnCoJ,EAAaA,EAAWrK,KAAKC,GAE/B,GAAIoK,EAAWtJ,SACbvB,EAAO,OACF,GAAI6K,EAAWnJ,UACpB,OAAOmJ,EAAWvI,UAGtB,OAAG,CACD,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAUG,OAAU,KAANA,GACTF,EAAQA,EAAMT,OACV6K,GAGK1J,EAAAA,OAAOC,KAAKvB,EAASwB,SAGvBF,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAjBnDA,EAAQA,EAAMT,OACV6K,IACGhL,IACHA,EAAUD,EAAMiD,iBACRjB,KAAKhC,EAAMiC,KAAKgJ,EAAWxJ,SAErCwJ,OAAa,GAEf7K,EAAO,OAWJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CAId,IAHK6K,IACHA,EAAajL,EAAM4B,qBAAqBf,EAAOZ,IAE1CgL,EAAWhK,WAAaJ,EAAMgB,WACnCoJ,EAAaA,EAAWrK,KAAKC,GAE/B,GAAIoK,EAAWtJ,SAAU,CACvBsJ,OAAa,EACb7K,EAAO,EACP,SACK,GAAI6K,EAAWnJ,UACpB,OAAOmJ,EAAWvI,UAGtB,MAEF,OAAO,IAAI+I,EAAoBzL,EAAOC,EAASgL,EAAY7K,IAE/DqL,EAjHA,CAAyClK,EAAAA,QCAzCoK,EAAA,SAAA5L,GAME,SAAA4L,EAAY3L,EAA0BC,EAC1BE,EAAyBC,GADrC,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IA4GjB,OAxHyCZ,EAAAmM,EAAA5L,GAevC4L,EAAA/L,UAAAgB,KAAA,SAAKC,GACH,OAAO8K,EAAc7K,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SAAUd,KAAKgB,aAAchB,KAAKiB,QAGjFgL,EAAA7K,MAAP,SAAmBD,EAAcb,EAA0BC,EACxCE,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GAC1C,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,GAAU,KAANF,EACFF,EAAQA,EAAMT,OACdA,EAAO,OACF,GAAU,MAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBAC3B9C,EAAcH,EAAMkD,YAAYrC,EAAOZ,GACvCG,EAAO,OACF,GAAU,KAANW,EACTd,EAAUA,GAAWD,EAAMiD,gBAC3B9C,EAAcH,EAAMmD,YAAYtC,EAAOZ,GACvCG,EAAO,OACF,GAAIe,GAAME,iBAAiBN,GAChCZ,EAAcH,EAAMyC,WAAW5B,GAC/BT,EAAO,OACF,GAAU,KAANW,GAAyB,KAANA,EAC5BZ,EAAcH,EAAMwC,YAAY3B,GAChCT,EAAO,OACF,GAAU,KAANW,GAAmBA,GAAK,IAAaA,GAAK,GACnDZ,EAAcH,EAAMoD,YAAYvC,GAChCT,EAAO,OACF,GAAU,KAANW,EACTZ,EAAcH,EAAMqD,UAAUxC,GAC9BT,EAAO,MACF,CAAA,GAAU,KAANW,EAGJ,OAAKd,EAGHsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAHzBnD,EAAcH,EAAMuD,cAAc1C,GAClCT,EAAO,OAMJ,GAAIS,EAAMc,SACf,OAAK1B,EAGIsB,EAAAA,OAAOC,KAAKvB,EAAQwB,QAFpBF,EAAAA,OAAOC,KAAKxB,EAAMsD,UAM/B,GAAa,IAATlD,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SAGf,OAFA1B,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKhC,EAAMiC,KAAK9B,EAAasB,SAC9BF,EAAAA,OAAOC,KAAKvB,EAAQwB,QACtB,GAAItB,EAAa2B,UACtB,OAAO3B,EAAauC,UAGxB,GAAa,IAATtC,EAAY,CACd,KAAOD,EAAac,WAAaJ,EAAMgB,WACrC1B,EAAcA,EAAaS,KAAKC,GAElC,GAAIV,EAAawB,SACf,OAAOJ,EAAAA,OAAOC,KAAKvB,EAASwB,QACvB,GAAItB,EAAa2B,UACtB,OAAO3B,EAAauC,UAGxB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM4B,qBAAqBf,IAEpCV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdvB,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMC,aAAaL,KAC7DF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SACR,OAAU,KAANF,GACFF,EAAQA,EAAMT,QACdH,EAAUA,GAAWD,EAAMsB,gBACnBU,KAAKhC,EAAMiC,KAAK9B,EAAasB,SAC9BF,EAAAA,OAAOC,KAAKvB,EAAQwB,SAEpBF,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAEhD,GAAIA,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,OAAO,IAAI8K,EAAoB3L,EAAOC,EAASE,EAAaC,IAEhEuL,EAxHA,CAAyCpK,EAAAA,QCAzCqK,EAAA,SAAA7L,GAOE,SAAA6L,EAAY5L,EAA0BC,EAC1B4L,EAAc1L,EAAyBC,GADnD,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKG,SAAWP,EAChBI,EAAKyL,UAAYD,EACjBxL,EAAKK,aAAeP,EACpBE,EAAKM,MAAQP,IAsNjB,OApO0CZ,EAAAoM,EAAA7L,GAiBxC6L,EAAAhM,UAAAgB,KAAA,SAAKC,GACH,OAAO+K,EAAe9K,MAAMD,EAAOnB,KAAKa,OAAQb,KAAKc,SACzBd,KAAKoM,UAAWpM,KAAKgB,aAAchB,KAAKiB,QAG/DiL,EAAA9K,MAAP,SAAmBD,EAAcb,EAA0BC,EACxC4L,EAAc1L,EAAyBC,QAAA,IAAAA,IAAAA,EAAA,GACxD,IAAIW,EAAI,EACR,GAAa,IAATX,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,UAAkB,KAANF,EACpBF,EAAQA,EAAMT,OACdyL,EAAWA,GAAY7L,EAAM6L,WAC7BzL,EAAO,OACF,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EACF,GAAIS,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SAERL,EAAQA,EAAMT,OACdA,EAAO,GACQ,KAANW,GACTF,EAAQA,EAAMT,OACdA,EAAO,GACQ,KAANW,GACTF,EAAQA,EAAMT,OACdA,EAAO,GACQ,KAANW,GACTF,EAAQA,EAAMT,OACdA,EAAO,GACQ,KAANW,GACTF,EAAQA,EAAMT,OACdA,EAAO,GAEPA,EAAO,OAEJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,OAAG,CACD,GAAa,IAATT,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM0L,aAAa7K,EAAOb,EAAMsB,iBAEzCnB,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdkK,EAAW7L,EAAM+L,IAAIF,EAAW1L,EAAYsB,QAC5CtB,OAAc,EACdC,EAAO,QACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAMkG,aAAarF,IAE5BV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdkK,EAAW7L,EAAMsF,MAAMtF,EAAMgM,QAAQH,EAAW1L,EAAYsB,SAC5DtB,OAAc,EACdC,EAAO,QACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAuBvB,GApBa,IAATtC,IACES,EAAMI,SAEE,MADVF,EAAIF,EAAMK,SAERL,EAAQA,EAAMT,OACdyL,EAAW7L,EAAMiM,KAAKJ,GACtBzL,EAAO,IACQ,KAANW,GACTF,EAAQA,EAAMT,OACdyL,EAAW7L,EAAMkM,YAAYL,GAC7BzL,EAAO,KAEPyL,EAAW7L,EAAMmM,SAASN,GAC1BzL,EAAO,IAEAS,EAAMc,WACfkK,EAAW7L,EAAMmM,SAASN,GAC1BzL,EAAO,KAGE,IAATA,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QAMR,OAAOK,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAJnDA,EAAQA,EAAMT,OACdyL,EAAW7L,EAAMoM,OAAOP,GACxBzL,EAAO,QAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,IAATT,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAMyC,WAAW5B,IAE1BV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdkK,EAAW7L,EAAMqM,QAAQR,EAAW1L,EAAYsB,QAChDtB,OAAc,EACdC,EAAO,QACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CAId,IAHKD,IACHA,EAAcH,EAAM4B,qBAAqBf,IAEpCV,EAAYc,WAAaJ,EAAMgB,WACpC1B,EAAcA,EAAYS,KAAKC,GAEjC,GAAIV,EAAYwB,SACdvB,EAAO,OACF,GAAID,EAAY2B,UACrB,OAAO3B,EAAYuC,UAGvB,GAAa,IAATtC,EAAY,CACd,KAAOS,EAAMI,WAAaF,EAAIF,EAAMK,OAAQC,GAAMY,QAAQhB,KACxDF,EAAQA,EAAMT,OAEhB,GAAIS,EAAMI,SAAU,CAClB,GAAU,KAANF,EAMF,OAAOQ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IALnDA,EAAQA,EAAMT,OACdyL,EAAW7L,EAAMsM,OAAOT,EAAW1L,EAAasB,QAChDtB,OAAc,EACdC,EAAO,QAIJ,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWC,SAAS,GAAW1B,IAGvD,GAAa,KAATT,EACF,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QACW,CACnBL,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAAiB,CAC1BF,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAGJ,OAAId,GACTA,EAAQ+B,KAAKhC,EAAMiC,KAAK4J,IACjBtK,EAAAA,OAAOC,KAAKvB,EAAQwB,SAEpBF,EAAAA,OAAOC,KAAKqK,GANnBhL,EAAQA,EAAMT,OACdA,EAAO,QAOJ,GAAIS,EAAMc,SACf,OAAI1B,GACFA,EAAQ+B,KAAKhC,EAAMiC,KAAK4J,IACjBtK,EAAAA,OAAOC,KAAKvB,EAAQwB,SAEpBF,EAAAA,OAAOC,KAAKqK,GAIzB,GAAa,KAATzL,EAAa,CACf,GAAIS,EAAMI,SAAU,CAElB,GAAU,MADVF,EAAIF,EAAMK,QACW,CACnBL,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAAiB,CAC1BF,EAAQA,EAAMT,OACdA,EAAO,EACP,SACK,GAAU,KAANW,EAAiB,CAC1BF,EAAQA,EAAMT,OACdA,EAAO,EACP,SAEAA,EAAO,EACP,SAEG,GAAIS,EAAMc,SACf,OAAOJ,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,IAG9C,MAEF,OAAO,IAAI+K,EAAqB5L,EAAOC,EAAS4L,EAAU1L,EAAaC,IAE3EwL,EApOA,CAA0CrK,EAAAA,qBC2B1C,SAAAgL,KA2PA,OAtJEA,EAAA3M,UAAAgD,WAAA,SAAW/B,GACT,OAAOf,EAAYgB,MAAMD,EAAOnB,OAGlC6M,EAAA3M,UAAAoD,UAAA,SAAUnC,GACR,OAAOuB,EAAWtB,MAAMD,EAAOnB,OAGjC6M,EAAA3M,UAAA4M,eAAA,SAAe3L,GACb,OAAOgC,EAAgB/B,MAAMD,EAAOnB,OAGtC6M,EAAA3M,UAAAkE,gBAAA,SAAgBjD,GACd,OAAO2C,EAAiB1C,MAAMD,EAAOnB,OAGvC6M,EAAA3M,UAAAsD,YAAA,SAAYrC,EAAcZ,GACxB,OAAOwD,EAAa3C,MAAMD,EAAOnB,KAAMO,IAGzCsM,EAAA3M,UAAAuD,YAAA,SAAYtC,EAAcZ,GACxB,OAAOyD,EAAa5C,MAAMD,EAAOnB,KAAMO,IAGzCsM,EAAA3M,UAAAyD,UAAA,SAAUxC,GACR,OAAOmD,EAAWlD,MAAMD,EAAOnB,OAGjC6M,EAAA3M,UAAA6C,WAAA,SAAW5B,GACT,OAAOyD,EAAYxD,MAAMD,EAAOnB,OAGlC6M,EAAA3M,UAAA4C,YAAA,SAAY3B,GACV,OAAO8D,EAAa7D,MAAMD,EAAOnB,OAGnC6M,EAAA3M,UAAAwD,YAAA,SAAYvC,GACV,OAAOuE,EAAatE,MAAMD,EAAOnB,OAGnC6M,EAAA3M,UAAAsG,aAAA,SAAarF,GACX,OAAOuE,EAAac,aAAarF,EAAOnB,OAG1C6M,EAAA3M,UAAAgC,qBAAA,SAAqBf,EAAcZ,GACjC,OAAOP,KAAK+M,gBAAgB5L,EAAOZ,IAGrCsM,EAAA3M,UAAA6M,gBAAA,SAAgB5L,EAAcZ,GAC5B,OAAOuG,EAAiB1F,MAAMD,EAAOnB,KAAMO,IAG7CsM,EAAA3M,UAAAiH,yBAAA,SAAyBhG,EAAcZ,GACrC,OAAOgH,EAA0BnG,MAAMD,EAAOnB,KAAMO,IAGtDsM,EAAA3M,UAAA4H,gBAAA,SAAgB3G,EAAcZ,GAC5B,OAAO4H,EAAiB/G,MAAMD,EAAOnB,KAAMO,IAG7CsM,EAAA3M,UAAAsI,iBAAA,SAAiBrH,EAAcZ,GAC7B,OAAOqI,EAAkBxH,MAAMD,EAAOnB,KAAMO,IAG9CsM,EAAA3M,UAAA2I,uBAAA,SAAuB1H,EAAcZ,GACnC,OAAOwI,EAAwB3H,MAAMD,EAAOnB,KAAMO,IAGpDsM,EAAA3M,UAAA8I,wBAAA,SAAwB7H,EAAcZ,GACpC,OAAO2I,EAAyB9H,MAAMD,EAAOnB,KAAMO,IAGrDsM,EAAA3M,UAAAiJ,wBAAA,SAAwBhI,EAAcZ,GACpC,OAAO8I,EAAyBjI,MAAMD,EAAOnB,KAAMO,IAGrDsM,EAAA3M,UAAAoJ,wBAAA,SAAwBnI,EAAcZ,GACpC,OAAOiJ,EAAyBpI,MAAMD,EAAOnB,KAAMO,IAGrDsM,EAAA3M,UAAAyJ,oBAAA,SAAoBxI,EAAcZ,GAChC,OAAO2J,EAAqB9I,MAAMD,EAAOnB,KAAMO,IAGjDsM,EAAA3M,UAAAiK,sBAAA,SAAsBhJ,EAAcZ,GAClC,OAAO6J,EAAuBhJ,MAAMD,EAAOnB,KAAMO,IAGnDsM,EAAA3M,UAAAmK,4BAAA,SAA4BlJ,EAAcZ,GACxC,OAAOiK,EAA6BpJ,MAAMD,EAAOnB,KAAMO,IAGzDsM,EAAA3M,UAAAuK,oBAAA,SAAoBtJ,EAAcZ,GAChC,OAAOsK,EAAqBzJ,MAAMD,EAAOnB,KAAMO,IAGjDsM,EAAA3M,UAAA6K,oBAAA,SAAoB5J,EAAcZ,GAChC,OAAO+K,EAAqBlK,MAAMD,EAAOnB,KAAMO,IAGjDsM,EAAA3M,UAAAyL,aAAA,SAAaxK,EAAcZ,GACzB,OAAOwL,EAAc3K,MAAMD,EAAOnB,KAAMO,IAG1CsM,EAAA3M,UAAA8L,aAAA,SAAa7K,EAAcZ,GACzB,OAAO0L,EAAc7K,MAAMD,EAAOnB,KAAMO,IAG1CsM,EAAA3M,UAAA2D,cAAA,SAAc1C,EAAcZ,GAC1B,OAAO2L,EAAe9K,MAAMD,EAAOnB,KAAMO,IAG3CsM,EAAA3M,UAAA8M,YAAA,WACE,OAAO,IAAI5M,EAAkBJ,OAG/B6M,EAAA3M,UAAA+M,iBAAA,SAAiB3H,GAEf,IADA,IAAInE,EAAQiF,EAAAA,QAAQ8G,YAAY5H,GACzBnE,EAAMI,UAAYE,GAAMC,aAAaP,EAAMK,SAChDL,EAAQA,EAAMT,OAEhB,IAAIyM,EAASnN,KAAKkD,WAAW/B,GAC7B,GAAIgM,EAAOlL,SACT,KAAOd,EAAMI,UAAYE,GAAMC,aAAaP,EAAMK,SAChDL,EAAQA,EAAMT,OAMlB,OAHIS,EAAMI,WAAa4L,EAAO/K,YAC5B+K,EAAStL,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,KAEvCgM,EAAOpL,QAIhB8K,EAAA3M,UAAAkN,kBAAA,SAAkB9H,GAEhB,IADA,IAAInE,EAAQiF,EAAAA,QAAQ8G,YAAY5H,GACzBnE,EAAMI,UAAYE,GAAMC,aAAaP,EAAMK,SAChDL,EAAQA,EAAMT,OAEhB,IAAIyM,EAASnN,KAAK0D,YAAYvC,GAC9B,GAAIgM,EAAOlL,SACT,KAAOd,EAAMI,UAAYE,GAAMC,aAAaP,EAAMK,SAChDL,EAAQA,EAAMT,OAMlB,OAHIS,EAAMI,WAAa4L,EAAO/K,YAC5B+K,EAAStL,EAAAA,OAAOc,MAAMC,EAAAA,WAAWyB,WAAWlD,KAEvCgM,EAAOpL,QAElB8K,mBCvPA,SAAAQ,mDAkNA,OAlN0CvN,EAAAuN,EAAAhN,GACxCgN,EAAAnN,UAAA+K,WAAA,SAAWrF,GACT,OAAOA,EAAMqF,cAGfoC,EAAAnN,UAAAqC,KAAA,SAAKqD,GACH,OAAOA,GAGTyH,EAAAnN,UAAA0F,MAAA,SAAMrD,GACJ,OAAOA,EAAK+K,WAGdD,EAAAnN,UAAA+C,KAAA,SAAKsK,EAAY3H,GACf,OAAO4H,EAAAA,KAAKC,GAAGC,MAAMF,EAAAA,KAAMG,YAG7BN,EAAAnN,UAAAsC,KAAA,SAAK+K,EAAY3H,GACf,OAAOgI,EAAAA,KAAKH,GAAGC,MAAME,EAAAA,KAAMD,YAG7BN,EAAAnN,UAAA0B,aAAA,WACE,OAAOiM,EAAAA,MAAMtN,WAGf8M,EAAAnN,UAAAqD,cAAA,WACE,OAAOuK,EAAAA,OAAO3N,UAGhBkN,EAAAnN,UAAAyE,WAAA,WACE,OAAOoJ,EAAAA,KAAKlJ,UAGdwI,EAAAnN,UAAA+D,WAAA,WACE,OAAO+J,EAAAA,KAAKnJ,UAGdwI,EAAAnN,UAAA8E,MAAA,SAAMY,GACJ,GAAIA,aAAiBoI,EAAAA,KAAM,CACzB,IAAM1I,EAASM,EAAMqI,cACrB,GAAe,SAAX3I,EACF,OAAO4I,EAAAA,KAAKC,MAAK,GACZ,GAAe,UAAX7I,EACT,OAAO4I,EAAAA,KAAKC,MAAK,GAGrB,OAAOvI,GAGTyH,EAAAnN,UAAAiG,IAAA,SAAIP,GACF,GAAqB,iBAAVA,EACT,OAAOwI,EAAAA,IAAID,KAAKvI,GACX,GAAqB,iBAAVA,EAChB,OAAOwI,EAAAA,IAAID,MAAMvI,GAEjB,MAAM,IAAIyI,UAAU,GAAKzI,IAI7ByH,EAAAnN,UAAA0G,OAAA,SAAOhB,GACL,OAAOwI,EAAAA,IAAIxH,OAAOhB,IAGpByH,EAAAnN,UAAA2G,OAAA,SAAOjB,GACL,OAAOwI,EAAAA,IAAIvH,OAAOjB,IAGpByH,EAAAnN,UAAAoO,KAAA,SAAK1I,GACH,OAAOsI,EAAAA,KAAKC,KAAKvI,IAGnByH,EAAAnN,UAAAiM,SAAA,WACE,OAAOoC,EAAAA,SAASC,YAGlBnB,EAAAnN,UAAA0D,OAAA,WACE,OAAOiK,EAAAA,MAAMjK,UAGfyJ,EAAAnN,UAAA8B,OAAA,WACE,OAAO6L,EAAAA,MAAM7L,UAGfqL,EAAAnN,UAAAgI,YAAA,SAAYH,EAAeC,EAAiBC,GAC1C,OAAOF,EAAOG,YAAYF,EAAUC,IAGtCoF,EAAAnN,UAAAyI,GAAA,SAAGF,EAAYC,GACb,OAAO,IAAI+F,EAAAA,WAAWhG,EAAKC,IAG7B2E,EAAAnN,UAAA4I,IAAA,SAAIL,EAAYC,GACd,OAAO,IAAIgG,EAAAA,YAAYjG,EAAKC,IAG9B2E,EAAAnN,UAAA+I,UAAA,SAAUR,EAAYC,GACpB,OAAO,IAAIiG,EAAAA,kBAAkBlG,EAAKC,IAGpC2E,EAAAnN,UAAAkJ,WAAA,SAAWX,EAAYC,GACrB,OAAO,IAAIkG,EAAAA,mBAAmBnG,EAAKC,IAGrC2E,EAAAnN,UAAAqJ,WAAA,SAAWd,EAAYC,GACrB,OAAO,IAAImG,EAAAA,mBAAmBpG,EAAKC,IAGrC2E,EAAAnN,UAAA0J,GAAA,SAAGnB,EAAYC,GACb,OAAO,IAAIoG,EAAAA,WAAWrG,EAAKC,IAG7B2E,EAAAnN,UAAA2J,GAAA,SAAGpB,EAAYC,GACb,OAAO,IAAIqG,EAAAA,WAAWtG,EAAKC,IAG7B2E,EAAAnN,UAAA4J,GAAA,SAAGrB,EAAYC,GACb,OAAO,IAAIsG,EAAAA,WAAWvG,EAAKC,IAG7B2E,EAAAnN,UAAA6J,GAAA,SAAGtB,EAAYC,GACb,OAAO,IAAIuG,EAAAA,WAAWxG,EAAKC,IAG7B2E,EAAAnN,UAAA8J,GAAA,SAAGvB,EAAYC,GACb,OAAO,IAAIwG,EAAAA,WAAWzG,EAAKC,IAG7B2E,EAAAnN,UAAA+J,GAAA,SAAGxB,EAAYC,GACb,OAAO,IAAIyG,EAAAA,WAAW1G,EAAKC,IAG7B2E,EAAAnN,UAAAoK,KAAA,SAAK7B,EAAYC,GACf,OAAO,IAAI0G,EAAAA,aAAa3G,EAAKC,IAG/B2E,EAAAnN,UAAAqK,MAAA,SAAM9B,EAAYC,GAChB,OAAO,IAAI2G,EAAAA,cAAc5G,EAAKC,IAGhC2E,EAAAnN,UAAAwK,MAAA,SAAMjC,EAAYC,GAChB,OAAO,IAAI4G,EAAAA,cAAc7G,EAAKC,IAGhC2E,EAAAnN,UAAAyK,OAAA,SAAOlC,EAAYC,GACjB,OAAO,IAAI6G,EAAAA,eAAe9G,EAAKC,IAGjC2E,EAAAnN,UAAA0K,OAAA,SAAOnC,EAAYC,GACjB,OAAO,IAAI8G,EAAAA,eAAe/G,EAAKC,IAGjC2E,EAAAnN,UAAAgL,IAAA,SAAIxC,GACF,OAAO,IAAI+G,EAAAA,YAAY/G,IAGzB2E,EAAAnN,UAAAiL,WAAA,SAAWzC,GACT,OAAO,IAAIgH,EAAAA,mBAAmBhH,IAGhC2E,EAAAnN,UAAAkL,SAAA,SAAS1C,GACP,OAAIA,aAAe0F,EAAAA,IACV1F,EAAI0C,WAEJ,IAAIuE,EAAAA,iBAAiBjH,IAIhC2E,EAAAnN,UAAAmL,SAAA,SAAS3C,GACP,OAAO,IAAIkH,EAAAA,iBAAiBlH,IAG9B2E,EAAAnN,UAAA2L,OAAA,SAAOgE,EAAa/D,GAClB,OAAO,IAAIgE,EAAAA,eAAeD,EAAM/D,IAGlCuB,EAAAnN,UAAAoH,OAAA,SAAOF,EAAiBC,GACtB,OAAOD,EAASE,OAAOD,IAGzBgG,EAAAnN,UAAAmM,IAAA,SAAIF,EAAiBoB,GACnB,OAAOpB,EAASE,IAAIkB,IAGtBF,EAAAnN,UAAAyM,QAAA,SAAQR,EAAiBoB,GACvB,OAAOpB,EAASQ,QAAQY,IAG1BF,EAAAnN,UAAAoM,QAAA,SAAQH,EAAiB4D,GACvB,OAAO5D,EAASG,QAAQyD,IAG1B1C,EAAAnN,UAAAuM,SAAA,SAASN,GACP,OAAOoC,EAAAA,SAASyB,QAAQ7D,GAAUM,YAGpCY,EAAAnN,UAAAsM,YAAA,SAAYL,GACV,OAAOoC,EAAAA,SAASyB,QAAQ7D,GAAUK,eAGpCa,EAAAnN,UAAAqM,KAAA,SAAKJ,GACH,OAAOoC,EAAAA,SAASyB,QAAQ7D,GAAUI,QAGpCc,EAAAnN,UAAAwM,OAAA,SAAOP,GACL,OAAOoC,EAAAA,SAASyB,QAAQ7D,GAAUO,UAGpCW,EAAAnN,UAAA0M,OAAA,SAAOT,EAAiB8D,GACtB,OAAO9D,EAASS,OAAOqD,IAE3B5C,GAlN0CR,GCjC1CqD,EAAA,SAAA7P,GAOE,SAAA6P,EAAY5P,EAA0BiN,EAAQ3H,EAAUuK,EAAezP,GAAvE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKyP,KAAO7C,EACZ5M,EAAKoF,OAASH,EACdjF,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAsEjB,OAnFsCZ,EAAAoQ,EAAA7P,GAgBpC6P,EAAAhQ,UAAAoQ,KAAA,SAAKzL,GACH,OAAOqL,EAAW/L,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKoQ,KAAMpQ,KAAK+F,OAAQ/F,KAAKqQ,MAAOrQ,KAAKiB,QAGjFiP,EAAAK,OAAP,SAAoBjQ,EAA0BiN,EAAQ3H,GACpD,IAAIc,EAAO,EAQX,OAPAA,GAAQ,EACRA,GAAQpG,EAAMkQ,YAAYjD,GACrBjN,EAAMmQ,SAASnQ,EAAMiC,KAAKqD,MAC7Bc,GAAQ,EACRA,GAAQpG,EAAMoQ,iBAAiB9K,GAC/Bc,GAAQ,GAEHA,GAGFwJ,EAAA/L,MAAP,SAAmBU,EAAgBvE,EAA0BiN,EAAQ3H,EAClDuK,EAAezP,GAKhC,QALgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWpD,EAAK1I,IAItB5C,SAAU,CAEjB,GADAkO,OAAO,EACH7P,EAAMmQ,SAASnQ,EAAMiC,KAAKqD,IAC5B,OAAOgL,EAAAA,OAAO9O,OAEdpB,EAAO,OAEJ,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAOhB,GAJa,IAATtC,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMuQ,gBAAgBjL,EAAOf,IAI7B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAa,IAATtC,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,QAEZ+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIb,EAAiB5P,EAAOiN,EAAK3H,EAAOuK,EAAMzP,IAEzDwP,EAnFA,CAAsCU,EAAAA,QCAtCI,EAAA,SAAA3Q,GAOE,SAAA2Q,EAAY1Q,EAA0BiN,EAAQ3H,EAAUuK,EAAezP,GAAvE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKyP,KAAO7C,EACZ5M,EAAKoF,OAASH,EACdjF,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA2DjB,OAxEsCZ,EAAAkR,EAAA3Q,GAgBpC2Q,EAAA9Q,UAAAoQ,KAAA,SAAKzL,GACH,OAAOmM,EAAW7M,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKoQ,KAAMpQ,KAAK+F,OAAQ/F,KAAKqQ,MAAOrQ,KAAKiB,QAGjF+P,EAAAT,OAAP,SAAoBjQ,EAA0BiN,EAAQ3H,GACpD,IAAIc,EAAO,EAMX,OALAA,GAAQpG,EAAMkQ,YAAYjD,GAC1B7G,GAAQ,EACHpG,EAAMmQ,SAASnQ,EAAMiC,KAAKqD,MAC7Bc,GAAQpG,EAAMkQ,YAAY5K,IAErBc,GAGFsK,EAAA7M,MAAP,SAAmBU,EAAgBvE,EAA0BiN,EAAQ3H,EAClDuK,EAAezP,GAChC,QADgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWpD,EAAK1I,IAItB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,GAAcmE,EAAOtD,SAAU,CAEjC,GADAsD,EAASA,EAAOV,MAAM,IAClB7D,EAAMmQ,SAASnQ,EAAMiC,KAAKqD,IAC5B,OAAOgL,EAAAA,OAAO9O,OAEdpB,EAAO,EAGX,GAAa,IAATA,EAAY,CAMd,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAW/K,EAAOf,IAIxB5C,SACP,OAAO2O,EAAAA,OAAO9O,OACT,GAAIqO,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIC,EAAiB1Q,EAAOiN,EAAK3H,EAAOuK,EAAMzP,IAEzDsQ,EAxEA,CAAsCJ,EAAAA,QCCtCK,EAAA,SAAA5Q,GAcE,SAAA4Q,EAAY3Q,EAA0B4Q,EAAkBC,EAAkBC,EAC9DC,EAAoBC,EAAsBC,EAAiBC,EAC3DjP,EAAUkP,EAAUtB,EAAezP,GAF/C,IAAAC,EAGEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK+Q,OAASR,EACdvQ,EAAKgR,SAAWR,EAChBxQ,EAAKiR,UAAYR,EACjBzQ,EAAKkR,UAAYR,EACjB1Q,EAAKmR,YAAcR,EACnB3Q,EAAKoR,OAASR,EACd5Q,EAAKqR,YAAcR,EACnB7Q,EAAKsR,MAAQ1P,EACb5B,EAAKuR,MAAQT,EACb9Q,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA6UjB,OA1WuCZ,EAAAmR,EAAA5Q,GAgCrC4Q,EAAA/Q,UAAAoQ,KAAA,SAAKzL,GACH,OAAOoM,EAAY9M,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAK0R,OAAQ1R,KAAK2R,SAAU3R,KAAK4R,UACtD5R,KAAK6R,UAAW7R,KAAK8R,YAAa9R,KAAK+R,OAAQ/R,KAAKgS,YACpDhS,KAAKiS,MAAOjS,KAAKkS,MAAOlS,KAAKqQ,MAAOrQ,KAAKiB,QAG7DgQ,EAAAV,OAAP,SAAoBjQ,EAA0B4Q,EAC1BC,EAAkBC,GAOpC,IANA,IAKIK,EALA/K,EAAO,EACP2K,GAAW,EACXC,GAAa,EACbC,GAAQ,EACRC,GAAa,EAEVC,GAAQP,EAAMiB,WAAW,CAC9B,IAAI5P,OAAI,EACHkP,GAGHlP,EAAOkP,EACPA,OAAO,GAHPlP,EAAO2O,EAAMO,OAAO7L,MAKlBsL,EAAMiB,YACRV,EAAOP,EAAMO,OAAO7L,OAElBtF,EAAM8R,aAAa7P,KACrBiP,GAAa,GAEXF,GAAchR,EAAM+R,OAAO9P,KACzB8O,IACF3K,GAAQ,EACR2K,GAAW,GAEb3K,GAAQ,EACR4K,GAAa,GAEXhR,EAAM+R,OAAO9P,IACX8O,GACF3K,GAAQ,EACR2K,GAAW,GACFC,IACT5K,GAAQ,EACR4K,GAAa,GAEf5K,GAAQpG,EAAMgS,WAAW/P,GACzBgP,GAAQ,GACCD,GAAchR,EAAMiS,OAAOhQ,IAChC8O,IACF3K,GAAQ,EACR2K,GAAW,GAEb3K,GAAQpG,EAAMkS,iBAAiBjQ,IACtB8O,GACJE,EAGHA,GAAQ,EAFR7K,GAAQ,EAIVA,GAAQuK,EAAYwB,gBAAgBnS,EAAOiC,IAClC+O,EACLhR,EAAMoS,SAASnQ,IAASjC,EAAMqS,aAAarS,EAAM4Q,MAAM3O,KACzDmE,GAAQpG,EAAMsS,YAAYtS,EAAM4Q,MAAM3O,IAAO,GAAO,GAChDkP,GAAQnR,EAAMiS,OAAOd,IACvB/K,GAAQpG,EAAMkS,iBAAiBf,GAC/BA,OAAO,GACEA,IAASnR,EAAM+R,OAAOZ,IAC/B/K,GAAQ,EACR2K,GAAW,EACXE,GAAQ,IAER7K,GAAQ,EACR4K,GAAa,KAGf5K,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW/P,GACzB8O,GAAW,EACXE,GAAQ,GAEDC,GAAclR,EAAMiS,OAAOhQ,IAASkP,IAASnR,EAAMuS,QAAQpB,KAC1DnR,EAAMiS,OAAOd,KAAUnR,EAAMwS,OAAOrB,IAC9C/K,GAAQ,EACRA,GAAQpG,EAAMkS,iBAAiBjQ,GAC/B+O,GAAa,GACJH,IAAYE,GAChBE,EAGHA,GAAQ,EAFR7K,GAAQ,EAIVA,GAAQuK,EAAYwB,gBAAgBnS,EAAOiC,IAClC6O,GAAY9Q,EAAMiS,OAAOhQ,KAAUkP,GAC5C/K,GAAQ,EACRA,GAAQpG,EAAMkS,iBAAiBjQ,GAC/BmE,GAAQ,IACE0K,GAAY9Q,EAAMyS,QAAQxQ,KAAUjC,EAAMoS,SAASnQ,MACnDgP,IAAUE,GAAQA,GAAQnR,EAAM+R,OAAOZ,MAC5CF,IAAUjR,EAAMiS,OAAOhQ,IAASjC,EAAM0S,QAAQzQ,IACpCjC,EAAM2S,MAAM1Q,IAASjC,EAAMwS,OAAOvQ,MAC/CmE,GAAQ,GAEVA,GAAQpG,EAAMgS,WAAW/P,KAEzBmE,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW/P,GACzB8O,GAAW,EACXE,GAAQ,GASZ,OANIF,IACF3K,GAAQ,GAEN4K,IACF5K,GAAQ,GAEHA,GAGFuK,EAAAwB,gBAAP,SAA6BnS,EAA0BiC,GACrD,IAAImE,EAAO,EAMX,OALIpG,EAAMuS,QAAQtQ,GAChBmE,GAAQpG,EAAM4S,WAAW5S,EAAMiN,IAAIhL,GAAOjC,EAAMsF,MAAMrD,IAEtDmE,GAAQpG,EAAMgS,WAAW/P,GAEpBmE,GAGFuK,EAAA9M,MAAP,SAAmBU,EAAgBvE,EAA0B4Q,EAC1CC,EAAkBC,EAAmBC,EACrCC,EAA6BC,EAAuBC,EACpDjP,EAAUkP,EAAUtB,EAAezP,GACpD,SAHsD,IAAA2Q,IAAAA,GAAA,QACrC,IAAAC,IAAAA,GAAA,QAA6B,IAAAC,IAAAA,GAAA,QAAuB,IAAAC,IAAAA,GAAA,QACjB,IAAA9Q,IAAAA,EAAA,KACjD,CACD,GAAa,IAATA,EAAY,CACd,IAAK+Q,IAASP,EAAMiB,UAAW,CAC7BzR,EAAO,GACP,MAEK+Q,GAGHlP,EAAOkP,EACPA,OAAO,GAHPlP,EAAO2O,EAAMO,OAAO7L,MAKlBsL,EAAMiB,YACRV,EAAOP,EAAMO,OAAO7L,OAElBtF,EAAM8R,aAAa7P,KACrBiP,GAAa,GAEf9Q,EAAO,EA2FX,GAxFa,IAATA,GAAcmE,EAAOtD,WACnB+P,GAAchR,EAAM+R,OAAO9P,IACzB8O,IACFxM,EAASA,EAAOV,MAAM,KACtBkN,GAAW,GAEb3Q,EAAO,GAEPA,EAAO,GAGE,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBmN,GAAa,EACb5Q,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACnBjB,EAAM+R,OAAO9P,IACX8O,GACFxM,EAASA,EAAOV,MAAM,KACtBkN,GAAW,GACFC,IACTzM,EAASA,EAAOV,MAAM,IACtBmN,GAAa,GAEfnB,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9B0M,GAAQ,EACR7Q,EAAO,GACE4Q,GAAchR,EAAMiS,OAAOhQ,IAChC8O,IACFxM,EAASA,EAAOV,MAAM,KACtBkN,GAAW,GAEblB,EAAO7P,EAAM8S,gBAAgB7Q,EAAOsC,GACpCnE,EAAO,GACE2Q,GACJE,EAGHA,GAAQ,EAFR1M,EAASA,EAAOV,MAAM,IAIxBgM,EAAOc,EAAYoC,eAAexO,EAAQvE,EAAOiC,GACjD7B,EAAO,GACE4Q,EACLhR,EAAMoS,SAASnQ,IAAUjC,EAAMqS,aAAarS,EAAM4Q,MAAM3O,KAC1D4N,EAAO7P,EAAMgT,WAAWhT,EAAM4Q,MAAM3O,GAAQsC,GAAQ,GAAO,GAC3DnE,EAAO,IAEPmE,EAASA,EAAOV,MAAM,KACtBgM,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9BwM,GAAW,EACXE,GAAQ,EACR7Q,EAAO,GAEA8Q,GAAclR,EAAMiS,OAAOhQ,IAAUkP,IAASnR,EAAMuS,QAAQpB,KAC3DnR,EAAMiS,OAAOd,KAAUnR,EAAMwS,OAAOrB,IAC9C5M,EAASA,EAAOV,MAAM,IACtBgM,EAAO7P,EAAM8S,gBAAgB7Q,EAAOsC,GACpCyM,GAAa,EACb5Q,EAAO,GACEyQ,IAAYE,GAChBE,EAGHA,GAAQ,EAFR1M,EAASA,EAAOV,MAAM,IAIxBgM,EAAOc,EAAYoC,eAAexO,EAAQvE,EAAOiC,GACjD7B,EAAO,GACE0Q,GAAY9Q,EAAMiS,OAAOhQ,KAAWkP,GAC7C5M,EAASA,EAAOV,MAAM,IACtBgM,EAAO7P,EAAM8S,gBAAgB7Q,EAAOsC,GACpCnE,EAAO,IACG0Q,GAAY9Q,EAAMyS,QAAQxQ,KAAWjC,EAAMoS,SAASnQ,MACpDgP,IAAUE,GAAQA,GAAQnR,EAAM+R,OAAOZ,MAC5CF,IAAUjR,EAAMiS,OAAOhQ,IAAUjC,EAAM0S,QAAQzQ,IACrCjC,EAAM2S,MAAM1Q,IAAUjC,EAAMwS,OAAOvQ,MAChDsC,EAASA,EAAOV,MAAM,KAExBgM,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9BnE,EAAO,IAEPmE,EAASA,EAAOV,MAAM,KACtBgM,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9BwM,GAAW,EACXE,GAAQ,EACR7Q,EAAO,IAGE,IAATA,EAEF,IADAyP,EAAOA,EAAMG,KAAKzL,IACT5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,GAAcmE,EAAOtD,SAAU,CACjC,IAAIkQ,IAAQnR,EAAMiS,OAAOd,GAIlB,CAAA,GAAIA,IAASnR,EAAM+R,OAAOZ,GAAO,CACtC5M,EAASA,EAAOV,MAAM,KACtBkN,GAAW,EACXE,GAAQ,EACR7Q,EAAO,EACP,SAEAmE,EAASA,EAAOV,MAAM,IACtBmN,GAAa,EACb5Q,EAAO,EACP,SAbAyP,EAAO7P,EAAM8S,gBAAgB3B,EAAM5M,GACnC4M,OAAO,EACP/Q,EAAO,EAcX,GAAa,IAATA,EAAY,CAEd,IADAyP,EAAOA,EAAMG,KAAKzL,IACT5C,SAAU,CACjBkO,OAAO,EACPzP,EAAO,EACP,SACK,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,EAEF,IADAyP,EAAOA,EAAMG,KAAKzL,IACT5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,IAAcmE,EAAOtD,SAKzB,MAJEsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,EAeX,GAVa,KAATA,IACE2Q,EACExM,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,KACtBzD,EAAO,IAGTA,EAAO,IAGE,KAATA,EAAa,CACf,IAAI4Q,EAMF,OAAOV,EAAAA,OAAO9O,OALd,GAAI+C,EAAOtD,SAET,OADAsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,OAMpB,OAAI+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIE,EAAkB3Q,EAAO4Q,EAAOC,EAASC,EAAUC,EAAUC,EAC3CC,EAAOC,EAAYjP,EAAMkP,EAAMtB,EAAMzP,IAG7DuQ,EAAAoC,eAAP,SAA4BxO,EAAgBvE,EAA0BiC,GACpE,OAAIjC,EAAMuS,QAAQtQ,GACTjC,EAAMiT,UAAUjT,EAAMiN,IAAIhL,GAAOjC,EAAMsF,MAAMrD,GAAOsC,GAEpDvE,EAAM6S,UAAU5Q,EAAMsC,IAGnCoM,EA1WA,CAAuCL,EAAAA,QCAvC4C,EAAA,SAAAnT,GAUE,SAAAmT,EAAYlT,EAA0B4Q,EAAkBuC,EAC5ClC,EAAiBhP,EAAUkP,EAAUtB,EAAezP,GADhE,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK+Q,OAASR,EACdvQ,EAAK+S,UAAYD,EACjB9S,EAAKoR,OAASR,EACd5Q,EAAKsR,MAAQ1P,EACb5B,EAAKuR,MAAQT,EACb9Q,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA8IjB,OAlKyCZ,EAAA0T,EAAAnT,GAuBvCmT,EAAAtT,UAAAoQ,KAAA,SAAKzL,GACH,OAAO2O,EAAcrP,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAK0R,OAAQ1R,KAAK0T,UAAW1T,KAAK+R,OACvD/R,KAAKiS,MAAOjS,KAAKkS,MAAOlS,KAAKqQ,MAAOrQ,KAAKiB,QAG/DuS,EAAAjD,OAAP,SAAoBjQ,EAA0B4Q,GAK5C,IAJA,IAGIO,EAHA/K,EAAO,EACP+M,GAAW,EACXlC,GAAQ,EAELE,GAAQP,EAAMiB,WAAW,CAC9B,IAAI5P,OAAI,EACHkP,GAGHlP,EAAOkP,EACPA,OAAO,GAHPlP,EAAO2O,EAAMO,OAAO7L,MAKlBsL,EAAMiB,YACRV,EAAOP,EAAMO,OAAO7L,OAEjB6N,GAAalC,IAChB7K,GAAQ,GAENpG,EAAM+R,OAAO9P,IACXkR,IACF/M,GAAQ,EACR+M,GAAW,GAEb/M,GAAQpG,EAAMgS,WAAW/P,GACzBgP,GAAQ,GACCkC,GACJlC,EAGHA,GAAQ,EAFR7K,GAAQ,EAIVA,GAAQpG,EAAMmS,gBAAgBlQ,IACrBjC,EAAMyS,QAAQxQ,KAAUjC,EAAMoS,SAASnQ,MACtCgP,IAAUE,GAAQA,GAAQnR,EAAM+R,OAAOZ,IACjD/K,GAAQpG,EAAMgS,WAAW/P,IAEzBmE,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW/P,GACzBkR,GAAW,EACXlC,GAAQ,GAMZ,OAHIkC,IACF/M,GAAQ,GAEHA,GAGF8M,EAAArP,MAAP,SAAmBU,EAAgBvE,EAA0B4Q,EAC1CuC,EAA2BlC,EAAuBhP,EAClDkP,EAAUtB,EAAezP,GAC1C,SAFiB,IAAA+S,IAAAA,GAAA,QAA2B,IAAAlC,IAAAA,GAAA,QACF,IAAA7Q,IAAAA,EAAA,KACvC,CACD,GAAa,IAATA,EAAY,CACd,IAAK+Q,IAASP,EAAMiB,UAAW,CAC7BzR,EAAO,EACP,MAEK+Q,GAGHlP,EAAOkP,EACPA,OAAO,GAHPlP,EAAO2O,EAAMO,OAAO7L,MAKlBsL,EAAMiB,YACRV,EAAOP,EAAMO,OAAO7L,OAEtBlF,EAAO,EAsCX,GAnCa,IAATA,GAAcmE,EAAOtD,WAClBkS,GAAalC,IAChB1M,EAASA,EAAOV,MAAM,KAExBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACnBjB,EAAM+R,OAAO9P,IACXkR,IACF5O,EAASA,EAAOV,MAAM,IACtBsP,GAAW,GAEbtD,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9B0M,GAAQ,EACR7Q,EAAO,GACE+S,GACJlC,EAGHA,GAAQ,EAFR1M,EAASA,EAAOV,MAAM,IAIxBgM,EAAO7P,EAAM+S,eAAe9Q,EAAOsC,GACnCnE,EAAO,GACEJ,EAAMyS,QAAQxQ,KAAWjC,EAAMoS,SAASnQ,MACvCgP,IAAUE,GAAQA,GAAQnR,EAAM+R,OAAOZ,KACjDtB,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9BnE,EAAO,IAEPmE,EAASA,EAAOV,MAAM,IACtBgM,EAAO7P,EAAM6S,UAAU5Q,EAAOsC,GAC9B4O,GAAW,EACXlC,GAAQ,EACR7Q,EAAO,IAGE,IAATA,EAAY,CAEd,IADAyP,EAAOA,EAAMG,KAAKzL,IACT5C,SAAU,CACjBkO,OAAO,EACPzP,EAAO,EACP,SACK,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,MAEF,GAAa,IAATtC,EAAY,CACd,IAAI+S,EAMF,OAAO7C,EAAAA,OAAO9O,OALd,GAAI+C,EAAOtD,SAET,OADAsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,OAMpB,OAAI+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIyC,EAAoBlT,EAAO4Q,EAAOuC,EAAUlC,EAAOhP,EAAMkP,EAAMtB,EAAMzP,IAEpF8S,EAlKA,CAAyC5C,EAAAA,QCFzC+C,EAAA,SAAAtT,GAME,SAAAsT,EAAYC,EAAc7D,EAAgB8D,EAAiBnT,GAA3D,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKmT,MAAQF,EACbjT,EAAKoT,OAAShE,EACdpP,EAAKqT,QAAUH,EACflT,EAAKM,MAAQP,IAsGjB,OAjHsCZ,EAAA6T,EAAAtT,GAcpCsT,EAAAzT,UAAAoQ,KAAA,SAAKzL,GACH,OAAO8O,EAAiBxP,MAAMU,EAAQ7E,KAAK8T,MAAO9T,KAAK+T,OAAQ/T,KAAKgU,QAAShU,KAAKiB,QAG7E0S,EAAApD,OAAP,SAAcqD,GAEZ,IADA,IAAIlN,EAAO,EACFuN,EAAI,EAAGC,EAAIN,EAAKO,OAAQF,EAAIC,EAAGD,EAAIL,EAAKQ,mBAAmBH,EAAG,GAAI,CACzE,IAAI5S,EAAIuS,EAAKS,YAAYJ,QACf,IAAN5S,IACFA,EAAIuS,EAAKU,WAAWL,IAKpBvN,GAHQ,KAANrF,GAAyB,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAChD,KAANA,GAAyB,MAANA,GAA0B,MAANA,GAA0B,IAANA,GACrD,KAANA,GAA0B,KAANA,GAA0B,KAANA,GAA0B,IAANA,EACzD,EACCA,EAAI,GACL,EAEAkT,EAAAA,KAAKhE,OAAOlP,GAGxB,OAAOqF,GAGFiN,EAAAxP,MAAP,SAAaU,EAAgB+O,EAAc7D,EAC9B8D,EAAoBnT,QADU,IAAAqP,IAAAA,EAAA,QAC9B,IAAA8D,IAAAA,EAAA,QAAoB,IAAAnT,IAAAA,EAAA,GAE/B,IADA,IAAMyT,EAASP,EAAKO,OACbtP,EAAOtD,UACZ,GAAa,IAATb,EAAY,CACd,KAAIqP,EAAQoE,GAuCV,OAAOvD,EAAAA,OAAO9O,OAtCd,IAAIT,EAAIuS,EAAKS,YAAYtE,QACf,IAAN1O,IACFA,EAAIuS,EAAKU,WAAWvE,IAEtBA,EAAQ6D,EAAKQ,mBAAmBrE,EAAO,GAC7B,KAAN1O,GAAyB,KAANA,GAAyB,KAANA,GAAyB,KAANA,GAChD,KAANA,GAAyB,MAANA,GAA0B,MAANA,GAC5CwD,EAASA,EAAOV,MAAM,IACtB0P,EAASxS,EACTX,EAAO,GACQ,IAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,GACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,IAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACEW,EAAI,IACbwD,EAASA,EAAOV,MAAM,IACtB0P,EAASxS,EACTX,EAAO,GAEPmE,EAASA,EAAOV,MAAM9C,QAKR,IAATX,GACTmE,EAASA,EAAOV,MAAM0P,GACtBA,EAAS,EACTnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAM,KACtBzD,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,GAAM,KACvEnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,EAAK,KACtEnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,EAAK,KACtEnT,EAAO,GACW,IAATA,IACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAqB,GAATZ,IACrDA,EAAS,EACTnT,EAAO,GAGX,OAAImE,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI4C,EAAiBC,EAAM7D,EAAO8D,EAAQnT,IAErDiT,EAjHA,CAAsC/C,EAAAA,QCAtC8D,EAAA,SAAArU,GAKE,SAAAqU,EAAYC,EAAmBxE,EAAezP,GAA9C,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKiU,OAASD,EACdhU,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAqCjB,OA9CgCZ,EAAA4U,EAAArU,GAY9BqU,EAAAxU,UAAAoQ,KAAA,SAAKzL,GACH,OAAO6P,EAAWvQ,MAAMU,EAAQ7E,KAAK4U,OAAQ5U,KAAKqQ,MAAOrQ,KAAKiB,QAGzDyT,EAAAnE,OAAP,SAAc4D,GACZ,OAAO,GAAMU,KAAKC,MAAe,EAATX,EAAa,GAAK,GAAK,IAG1CO,EAAAvQ,MAAP,SAAaU,EAAgB8P,EAAmBxE,EACnCzP,GAKX,QALW,IAAAA,IAAAA,EAAA,GACE,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAAY,CAMd,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVJ,EAAAA,OAAOC,WAAWqQ,gBAAgBJ,EAAO9P,IAIzC5C,SAEP,OADAkO,OAAO,EACAS,EAAAA,OAAO9O,OACT,GAAIqO,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI2D,EAAWC,EAAOxE,EAAMzP,IAEvCgU,EA9CA,CAAgC9D,EAAAA,QCChCoE,EAAA,SAAA3U,GAIE,SAAA2U,EAAYhQ,EAAe+K,GAA3B,IAAApP,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKsU,OAASjQ,EACdrE,EAAKoT,OAAShE,IAiDlB,OAxDiCjQ,EAAAkV,EAAA3U,GAU/B2U,EAAA9U,UAAAoQ,KAAA,SAAKzL,GACH,OAAOmQ,EAAY7Q,MAAMU,EAAQ7E,KAAKiV,OAAQjV,KAAK+T,SAG9CiB,EAAAzE,OAAP,SAAcvL,GACZ,OAAOuP,EAAAA,KAAKhE,OAAOvL,IAGdgQ,EAAA7Q,MAAP,SAAaU,EAAgBG,EAAe+K,GAC1C,IAAI1O,OADsC,IAAA0O,IAAAA,EAAA,GAE1C,IAAMoE,EAASnP,EAAMmP,OACrB,GAAe,IAAXA,EACF,OAAOvD,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,qBAY1C,IAVc,IAAVf,GAAelL,EAAOtD,gBAEd,KADVF,EAAI2D,EAAMqP,YAAY,MAEpBhT,EAAI2D,EAAMsP,WAAW,IAEnB7S,GAAME,iBAAiBN,KACzBwD,EAASA,EAAOV,MAAM9C,GACtB0O,EAAQ/K,EAAMoP,mBAAmB,EAAG,KAGjCrE,EAAQoE,GAAUtP,EAAOtD,UAAU,CAKxC,QAHU,KADVF,EAAI2D,EAAMqP,YAAYtE,MAEpB1O,EAAI2D,EAAMsP,WAAWvE,KAEnBtO,GAAMsD,YAAY1D,GAIpB,OAAOuP,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,uBAHxCjM,EAASA,EAAOV,MAAM9C,GACtB0O,EAAQ/K,EAAMoP,mBAAmBrE,EAAO,GAK5C,OAAIA,GAASoE,EACJvD,EAAAA,OAAO9O,OAEZ+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIiE,EAAYhQ,EAAO+K,IAElCiF,EAxDA,CAAiCpE,EAAAA,QCDjCsE,EAAA,SAAA7U,GAME,SAAA6U,EAAY5P,EAAgByK,EAAgB8D,EAAiBnT,GAA7D,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKwU,QAAU7P,EACf3E,EAAKoT,OAAShE,EACdpP,EAAKqT,QAAUH,EACflT,EAAKM,MAAQP,IA+GjB,OA1HkCZ,EAAAoV,EAAA7U,GAchC6U,EAAAhV,UAAAoQ,KAAA,SAAKzL,GACH,OAAOqQ,EAAa/Q,MAAMU,EAAQ7E,KAAKmV,QAASnV,KAAK+T,OAAQ/T,KAAKgU,QAAShU,KAAKiB,QAG3EiU,EAAA3E,OAAP,SAAcjL,GACZ,IAAIoB,EAAO,EACXA,GAAQ,EACR,IAAK,IAAIuN,EAAI,EAAGC,EAAI5O,EAAO6O,OAAQF,EAAIC,EAAGD,EAAI3O,EAAO8O,mBAAmBH,EAAG,GAAI,CAC7E,IAAI5S,EAAIiE,EAAO+O,YAAYJ,QACjB,IAAN5S,IACFA,EAAIiE,EAAOgP,WAAWL,IAItBvN,GAFQ,KAANrF,GAAyB,KAANA,GAA0B,IAANA,GAAyB,KAANA,GACjD,KAANA,GAA0B,KAANA,GAA0B,IAANA,EACrC,EACCA,EAAI,GACL,EAEAkT,EAAAA,KAAKhE,OAAOlP,GAIxB,OADAqF,GAAQ,GAIHwO,EAAA/Q,MAAP,SAAaU,EAAgBS,EAAgByK,EAAmB8D,EACnDnT,QADgC,IAAAqP,IAAAA,EAAA,QAAmB,IAAA8D,IAAAA,EAAA,QACnD,IAAAnT,IAAAA,EAAA,GACE,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGT,IADA,IAAMyT,EAAS7O,EAAO6O,OACfzT,GAAQ,GAAKA,GAAQ,GAAKmE,EAAOtD,UACtC,GAAa,IAATb,EAAY,CACd,KAAIqP,EAAQoE,GAqCL,CACLzT,EAAO,EACP,MAtCA,IAAIW,EAAIiE,EAAO+O,YAAYtE,QACjB,IAAN1O,IACFA,EAAIiE,EAAOgP,WAAWvE,IAExBA,EAAQzK,EAAO8O,mBAAmBrE,EAAO,GAC/B,KAAN1O,GAAyB,KAANA,GACrBwD,EAASA,EAAOV,MAAM,IACtB0P,EAASxS,EACTX,EAAO,GACQ,IAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,GACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,KAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACQ,IAANW,GACTwD,EAASA,EAAOV,MAAM,IACtB0P,EAAS,IACTnT,EAAO,GACEW,EAAI,IACbwD,EAASA,EAAOV,MAAM,MACtB0P,EAASxS,EACTX,EAAO,GAEPmE,EAASA,EAAOV,MAAM9C,QAMR,IAATX,GACTmE,EAASA,EAAOV,MAAM0P,GACtBA,EAAS,EACTnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAM,KACtBzD,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,GAAM,KACvEnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,EAAK,KACtEnT,EAAO,GACW,IAATA,GACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAaZ,IAAW,EAAK,KACtEnT,EAAO,GACW,IAATA,IACTmE,EAASA,EAAOV,MAAMoB,EAAAA,OAAOiP,YAAYC,YAAqB,GAATZ,IACrDA,EAAS,EACTnT,EAAO,GAGX,OAAa,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,QAEZ+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAImE,EAAa5P,EAAQyK,EAAO8D,EAAQnT,IAEnDwU,EA1HA,CAAkCtE,EAAAA,QCClCwE,EAAA,SAAA/U,GAOE,SAAA+U,EAAY9U,EAA0B8G,EAAaC,EACvC8I,EAAezP,GAD3B,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK0U,UAAYjO,EACjBzG,EAAK2U,UAAYjO,EACjB1G,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAkEjB,OAhF4CZ,EAAAsV,EAAA/U,GAiB1C+U,EAAAlV,UAAAoQ,KAAA,SAAKzL,GACH,OAAOuQ,EAAiBjR,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKqV,UAAWrV,KAAKsV,UAC1CtV,KAAKqQ,MAAOrQ,KAAKiB,QAG1CmU,EAAA7E,OAAP,SAAoBjQ,EAA0B8G,EAAaC,GACzD,IAAIX,EAAO,EAIX,OAHAA,GAAQpG,EAAMiV,cAAcnO,GAC5BV,GAAQ,EACRA,GAAQpG,EAAMkQ,YAAYnJ,IAIrB+N,EAAAjR,MAAP,SAAmBU,EAAgBvE,EAA0B8G,EAAaC,EACvD8I,EAAezP,GAChC,QADgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMkV,aAAapO,EAAUvC,IAI7B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAmBhB,GAhBa,IAATtC,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAAY,CAMd,IAJEyP,EADU,MAARA,EACK7P,EAAMqQ,WAAWtJ,EAAUxC,GAE3BsL,EAAKG,KAAKzL,IAEV5C,SACP,OAAO2O,EAAAA,OAAO9O,OACT,GAAIqO,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIqE,EAAuB9U,EAAO8G,EAAUC,EAAU8I,EAAMzP,IAEvE0U,EAhFA,CAA4CxE,EAAAA,QCA5C6E,EAAA,SAAApV,GASE,SAAAoV,EAAYnV,EAA0ByH,EAAWC,EAAaC,EAClDyN,EAAoBvF,EAAezP,GAD/C,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKgV,QAAU5N,EACfpH,EAAKiV,UAAY5N,EACjBrH,EAAKkV,UAAY5N,EACjBtH,EAAKmV,YAAcJ,EACnB/U,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAqHjB,OAvIqDZ,EAAA2V,EAAApV,GAqBnDoV,EAAAvV,UAAAoQ,KAAA,SAAKzL,GACH,OAAO4Q,EAA0BtR,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAK2V,QAAS3V,KAAK4V,UACxC5V,KAAK6V,UAAW7V,KAAK8V,YAAa9V,KAAKqQ,MAAOrQ,KAAKiB,QAGrFwU,EAAAlF,OAAP,SAAoBjQ,EAA0ByH,EAAWC,EACrCC,EAAayN,GAC/B,IAAIhP,EAAO,EAYX,OAXIpG,EAAMoV,WAAW3N,GAAU,GAAKzH,EAAMoV,WAAW3N,IAAW2N,GAC9DhP,GAAQ,EACRA,GAAQpG,EAAMgS,WAAWvK,GACzBrB,GAAQ,GAERA,GAAQpG,EAAMgS,WAAWvK,GAE3BrB,GAAQ,EACRA,GAAQpG,EAAMgS,WAAWtK,GACzBtB,GAAQ,EACRA,GAAQpG,EAAMgS,WAAWrK,IAIpBwN,EAAAtR,MAAP,SAAmBU,EAAgBvE,EAA0ByH,EAAWC,EAAaC,EAClEyN,EAAoBvF,EAAezP,GAWpD,QAXoD,IAAAA,IAAAA,EAAA,GACvC,IAATA,IACEJ,EAAMoV,WAAW3N,GAAU,GAAKzH,EAAMoV,WAAW3N,IAAW2N,EAC1D7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAUpL,EAAQlD,IAIxB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAyBhB,GAtBa,IAATtC,IACEJ,EAAMoV,WAAW3N,GAAU,GAAKzH,EAAMoV,WAAW3N,IAAW2N,EAC1D7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAUnL,EAAUnD,IAI1B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAehB,GAZa,IAATtC,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,IAEI,KAATA,GAAemE,EAAOtD,WACxBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,IAEI,KAATA,EAAa,CAMf,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAUlL,EAAUpD,IAI1B5C,SACP,OAAO2O,EAAAA,OAAO9O,OACT,GAAIqO,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI0E,EAAgCnV,EAAOyH,EAAQC,EAAUC,EACzByN,EAAYvF,EAAMzP,IAEjE+U,EAvIA,CAAqD7E,EAAAA,QCArDmF,EAAA,SAAA1V,GASE,SAAA0V,EAAYzV,EAA0BmI,EAAQgB,EAAkBf,EACpDgN,EAAoBvF,EAAezP,GAD/C,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKqV,KAAOvN,EACZ9H,EAAK+I,UAAYD,EACjB9I,EAAKsV,KAAOvN,EACZ/H,EAAKmV,YAAcJ,EACnB/U,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA8HjB,OAhJ+CZ,EAAAiW,EAAA1V,GAqB7C0V,EAAA7V,UAAAoQ,KAAA,SAAKzL,GACH,OAAOkR,EAAoB5R,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKgW,KAAMhW,KAAK0J,UAAW1J,KAAKiW,KACrDjW,KAAK8V,YAAa9V,KAAKqQ,MAAOrQ,KAAKiB,QAG/D8U,EAAAxF,OAAP,SAAoBjQ,EAA0BmI,EAAQgB,EAAkBf,EAAQgN,GAC9E,IAAIhP,EAAO,EAkBX,OAjBIpG,EAAMoV,WAAWjN,GAAOiN,GAC1BhP,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW7J,GACzB/B,GAAQ,GAERA,GAAQpG,EAAMgS,WAAW7J,GAE3B/B,GAAQ,EACRA,GAAQ6N,EAAAA,KAAKhE,OAAO9G,GACpB/C,GAAQ,EACJpG,EAAMoV,WAAWhN,GAAOgN,GAC1BhP,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW5J,GACzBhC,GAAQ,GAERA,GAAQpG,EAAMgS,WAAW5J,GAEpBhC,GAGFqP,EAAA5R,MAAP,SAAmBU,EAAgBvE,EAA0BmI,EAAQgB,EAAkBf,EACpEgN,EAAoBvF,EAAezP,GAWpD,QAXoD,IAAAA,IAAAA,EAAA,GACvC,IAATA,IACEJ,EAAMoV,WAAWjN,GAAOiN,EACtB7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAU1K,EAAK5D,IAIrB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAiBhB,GAda,IAATtC,IACEJ,EAAMoV,WAAWjN,GAAOiN,EACtB7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVuB,EAAAA,QAAQ8P,YAAYzM,EAAU5E,IAI9B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAiBhB,GAda,IAATtC,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,IACEJ,EAAMoV,WAAWhN,GAAOgN,EACtB7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAUzK,EAAK7D,IAIrB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,EAAY,CACd,KAAIJ,EAAMoV,WAAWhN,GAAOgN,GAM1B,OAAO9E,EAAAA,OAAO9O,OALd,GAAI+C,EAAOtD,SAET,OADAsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,OAMpB,OAAI+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIgF,EAA0BzV,EAAOmI,EAAKgB,EAAUf,EAAKgN,EAAYvF,EAAMzP,IAEtFqV,EAhJA,CAA+CnF,EAAAA,QCA/CuF,EAAA,SAAA9V,GAQE,SAAA8V,EAAY7V,EAA0BmJ,EAAkBf,EAC5CgN,EAAoBvF,EAAezP,GAD/C,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK+I,UAAYD,EACjB9I,EAAKsV,KAAOvN,EACZ/H,EAAKmV,YAAcJ,EACnB/U,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA4EjB,OA5FgDZ,EAAAqW,EAAA9V,GAmB9C8V,EAAAjW,UAAAoQ,KAAA,SAAKzL,GACH,OAAOsR,EAAqBhS,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAK0J,UAAW1J,KAAKiW,KAC1CjW,KAAK8V,YAAa9V,KAAKqQ,MAAOrQ,KAAKiB,QAGhEkV,EAAA5F,OAAP,SAAoBjQ,EAA0BmJ,EAAkBf,EAAQgN,GACtE,IAAIhP,EAAO,EASX,OARAA,GAAQ6N,EAAAA,KAAKhE,OAAO9G,GAChBnJ,EAAMoV,WAAWhN,GAAOgN,GAC1BhP,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW5J,GACzBhC,GAAQ,GAERA,GAAQpG,EAAMgS,WAAW5J,GAEpBhC,GAGFyP,EAAAhS,MAAP,SAAmBU,EAAgBvE,EAA0BmJ,EAAkBf,EAC5DgN,EAAoBvF,EAAezP,GACpD,QADoD,IAAAA,IAAAA,EAAA,GACvC,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVuB,EAAAA,QAAQ8P,YAAYzM,EAAU5E,IAI9B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAahB,GAVa,IAATtC,IACEJ,EAAMoV,WAAWhN,GAAOgN,EACtB7Q,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAUzK,EAAK7D,IAIrB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,GAAa,IAATtC,EAAY,CACd,KAAIJ,EAAMoV,WAAWhN,GAAOgN,GAM1B,OAAO9E,EAAAA,OAAO9O,OALd,GAAI+C,EAAOtD,SAET,OADAsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,OAMpB,OAAI+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIoF,EAA2B7V,EAAOmJ,EAAUf,EAAKgN,EAAYvF,EAAMzP,IAElFyV,EA5FA,CAAgDvF,EAAAA,QCAhDwF,EAAA,SAAA/V,GAOE,SAAA+V,EAAY9V,EAA0BuP,EAAS/D,EAASqE,EAAezP,GAAvE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK0V,MAAQxG,EACblP,EAAK2V,MAAQxK,EACbnL,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA4DjB,OAzEgDZ,EAAAsW,EAAA/V,GAgB9C+V,EAAAlW,UAAAoQ,KAAA,SAAKzL,GACH,OAAOuR,EAAqBjS,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKqW,MAAOrW,KAAKsW,MACtCtW,KAAKqQ,MAAOrQ,KAAKiB,QAG9CmV,EAAA7F,OAAP,SAAoBjQ,EAA0BuP,EAAS/D,GACrD,IAAIpF,EAAO,EAKX,OAJAA,GAAQpG,EAAMkQ,YAAYX,GAC1BnJ,GAAQ,EACRA,GAAQpG,EAAMoQ,iBAAiB5E,GAC/BpF,GAAQ,GAIH0P,EAAAjS,MAAP,SAAmBU,EAAgBvE,EAA0BuP,EAAS/D,EACnDqE,EAAezP,GAChC,QADgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWd,EAAMhL,IAIvB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAOhB,GAJa,IAATtC,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMuQ,gBAAgB/E,EAAMjH,IAI5B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAa,IAATtC,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACfyM,EAAAA,OAAO9O,QAEZ+C,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIqF,EAA2B9V,EAAOuP,EAAM/D,EAAMqE,EAAMzP,IAEnE0V,EAzEA,CAAgDxF,EAAAA,QCAhD2F,EAAA,SAAAlW,GAOE,SAAAkW,EAAYjW,EAA0BiC,EAASiU,EAASrG,EAAezP,GAAvE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKsR,MAAQ1P,EACb5B,EAAK8V,MAAQD,EACb7V,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAkEjB,OA/EiDZ,EAAAyW,EAAAlW,GAgB/CkW,EAAArW,UAAAoQ,KAAA,SAAKzL,GACH,OAAO0R,EAAsBpS,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKiS,MAAOjS,KAAKyW,MACtCzW,KAAKqQ,MAAOrQ,KAAKiB,QAG/CsV,EAAAhG,OAAP,SAAoBjQ,EAA0BiC,EAASiU,GACrD,IAAI9P,EAAO,EASX,OARIpG,EAAMoV,WAAWnT,GAAQjC,EAAMoV,WAAWpV,EAAMiC,KAAKiU,KACvD9P,GAAQ,EACRA,GAAQpG,EAAMgS,WAAW/P,GACzBmE,GAAQ,GAERA,GAAQpG,EAAMgS,WAAW/P,GAE3BmE,GAAQpG,EAAMoW,WAAWF,IAIpBD,EAAApS,MAAP,SAAmBU,EAAgBvE,EAA0BiC,EAASiU,EACnDrG,EAAezP,GAWhC,QAXgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,IACEJ,EAAMoV,WAAWnT,GAAQjC,EAAMoV,WAAWpV,EAAMiC,KAAKiU,IACnD3R,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAM6S,UAAU5Q,EAAMsC,IAItB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAahB,OAVa,IAATtC,IACEJ,EAAMoV,WAAWnT,GAAQjC,EAAMoV,WAAWpV,EAAMiC,KAAKiU,IACnD3R,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EACKJ,EAAMqW,UAAUH,EAAM3R,GAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIwF,EAA4BjW,EAAOiC,EAAMiU,EAAMrG,EAAMzP,IAEpE6V,EA/EA,CAAiD3F,EAAAA,QCAjDgG,EAAA,SAAAvW,GAOE,SAAAuW,EAAYtW,EAA0BiN,EAAQiJ,EAASrG,EAAezP,GAAtE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKyP,KAAO7C,EACZ5M,EAAK8V,MAAQD,EACb7V,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAgFjB,OA7F6CZ,EAAA8W,EAAAvW,GAgB3CuW,EAAA1W,UAAAoQ,KAAA,SAAKzL,GACH,OAAO+R,EAAkBzS,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKoQ,KAAMpQ,KAAKyW,MAAOzW,KAAKqQ,MAAOrQ,KAAKiB,QAGvF2V,EAAArG,OAAP,SAAoBjQ,EAA0BiN,EAAQiJ,GACpD,IAAI9P,EAAO,EASX,OARIpG,EAAMoS,SAASpS,EAAMiC,KAAKgL,KAC5B7G,GAAQ,EACRA,GAAQpG,EAAMoQ,iBAAiBnD,GAC/B7G,GAAQ,GAERA,GAAQpG,EAAMkQ,YAAYjD,GAE5B7G,GAAQpG,EAAMoW,WAAWF,IAIpBI,EAAAzS,MAAP,SAAmBU,EAAgBvE,EAA0BiN,EAAQiJ,EAClDrG,EAAezP,GAkBhC,QAlBgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,IACEJ,EAAMoS,SAASpS,EAAMiC,KAAKgL,IACxB1I,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,KACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EAUF,IAFEyP,EAPGA,EAOIA,EAAKG,KAAKzL,GANbvE,EAAMoS,SAASpS,EAAMiC,KAAKgL,IACrBjN,EAAMuQ,gBAAgBtD,EAAK1I,GAE3BvE,EAAMqQ,WAAWpD,EAAK1I,IAKxB5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAahB,OAVa,IAATtC,IACEJ,EAAMoS,SAASpS,EAAMiC,KAAKgL,IACxB1I,EAAOtD,WACTsD,EAASA,EAAOV,MAAM,KACtBzD,EAAO,GAGTA,EAAO,GAGE,IAATA,EACKJ,EAAMqW,UAAUH,EAAM3R,GAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI6F,EAAwBtW,EAAOiN,EAAKiJ,EAAMrG,EAAMzP,IAGtDkW,EAAAD,UAAP,SAAuB9R,EAAgBvE,EAA0BiN,EAAQiJ,GACvE,OAAOI,EAAkBzS,MAAMU,EAAQvE,EAAOiN,EAAKiJ,OAAM,EAAQ,IAErEI,EA7FA,CAA6ChG,EAAAA,QCA7CiG,EAAA,SAAAxW,GAOE,SAAAwW,EAAYvW,EAA0BiN,EAAQiJ,EAASrG,EAAezP,GAAtE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAAUP,EACfK,EAAKyP,KAAO7C,EACZ5M,EAAK8V,MAAQD,EACb7V,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAmDjB,OAhEiDZ,EAAA+W,EAAAxW,GAgB/CwW,EAAA3W,UAAAoQ,KAAA,SAAKzL,GACH,OAAOgS,EAAsB1S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKoQ,KAAMpQ,KAAKyW,MACrCzW,KAAKqQ,MAAOrQ,KAAKiB,QAG/C4V,EAAAtG,OAAP,SAAoBjQ,EAA0BiN,EAAQiJ,GACpD,IAAI9P,EAAO,EAGX,OAFAA,GAAQpG,EAAMkQ,YAAYjD,GAC1B7G,GAAQpG,EAAMoW,WAAWF,IAIpBK,EAAA1S,MAAP,SAAmBU,EAAgBvE,EAA0BiN,EAAQiJ,EAClDrG,EAAezP,GAYhC,QAZgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAAY,CAMd,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWpD,EAAK1I,IAItB5C,SACP,OAAO3B,EAAMqW,UAAUH,EAAM3R,GACxB,GAAIsL,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI8F,EAA4BvW,EAAOiN,EAAKiJ,EAAMrG,EAAMzP,IAG1DmW,EAAAF,UAAP,SAAuB9R,EAAgBvE,EAA0BiN,EAAQiJ,GACvE,OAAOK,EAAsB1S,MAAMU,EAAQvE,EAAOiN,EAAKiJ,OAAM,EAAQ,IAEzEK,EAhEA,CAAiDjG,EAAAA,QCAjDkG,EAAA,SAAAzW,GAOE,SAAAyW,EAAYxW,EAA0ByP,EAAUyG,EAASrG,EAAezP,GAAxE,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKoT,OAAShE,EACdpP,EAAK8V,MAAQD,EACb7V,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IAuDjB,OApEiDZ,EAAAgX,EAAAzW,GAgB/CyW,EAAA5W,UAAAoQ,KAAA,SAAKzL,GACH,OAAOiS,EAAsB3S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAK+T,OAAQ/T,KAAKyW,MACvCzW,KAAKqQ,MAAOrQ,KAAKiB,QAG/C6V,EAAAvG,OAAP,SAAoBjQ,EAA0ByP,EAAUyG,GACtD,IAAI9P,EAAO,EAGX,OAFAA,GAAQpG,EAAMkQ,YAAYT,GAC1BrJ,GAAQpG,EAAMoW,WAAWF,IAIpBM,EAAAJ,WAAP,SAAwBpW,EAA0ByP,EAAUyG,GAC1D,IAAI9P,EAAO,EAGX,OAFAA,GAAQpG,EAAMkQ,YAAYT,GAC1BrJ,GAAQpG,EAAMoW,WAAWF,IAIpBM,EAAA3S,MAAP,SAAmBU,EAAgBvE,EAA0ByP,EAAUyG,EACpDrG,EAAezP,GAShC,QATgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAAY,CAMd,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWZ,EAAOlL,IAIxB5C,SACP,OAAO3B,EAAMqW,UAAUH,EAAM3R,GACxB,GAAIsL,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAI6B,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAI+F,EAA4BxW,EAAOyP,EAAOyG,EAAMrG,EAAMzP,IAG5DoW,EAAAH,UAAP,SAAuB9R,EAAgBvE,EAA0ByP,EAAUyG,GACzE,OAAOM,EAAsB3S,MAAMU,EAAQvE,EAAOyP,EAAOyG,OAAM,EAAQ,IAE3EM,EApEA,CAAiDlG,EAAAA,QCAjDmG,EAAA,SAAA1W,GAKE,SAAA0W,EAAYzW,EAA0BkW,EAAS9V,GAA/C,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK8V,MAAQD,EACb7V,EAAKM,MAAQP,IAyCjB,OAlD8CZ,EAAAiX,EAAA1W,GAY5C0W,EAAA7W,UAAAoQ,KAAA,SAAKzL,GACH,OAAOkS,EAAmB5S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKyW,MAAOzW,KAAKiB,QAGjE8V,EAAAxG,OAAP,SAAoBjQ,EAA0BkW,GAC5C,IAAI9P,EAAO,EAEX,OADAA,GAAQpG,EAAMoW,WAAWF,IAIpBO,EAAA5S,MAAP,SAAmBU,EAAgBvE,EAA0BkW,EAC1C9V,GAYjB,YAZiB,IAAAA,IAAAA,EAAA,GACJ,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACf7D,EAAMqW,UAAUH,EAAM3R,IAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIgG,EAAyBzW,EAAOkW,EAAM9V,IAG5CqW,EAAAJ,UAAP,SAAuB9R,EAAgBvE,EAA0BkW,GAC/D,OAAOO,EAAmB5S,MAAMU,EAAQvE,EAAOkW,EAAM,IAEzDO,EAlDA,CAA8CnG,EAAAA,QCA9CoG,EAAA,SAAA3W,GAKE,SAAA2W,EAAY1W,EAA0BkW,EAAS9V,GAA/C,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK8V,MAAQD,EACb7V,EAAKM,MAAQP,IAyCjB,OAlDgDZ,EAAAkX,EAAA3W,GAY9C2W,EAAA9W,UAAAoQ,KAAA,SAAKzL,GACH,OAAOmS,EAAqB7S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKyW,MAAOzW,KAAKiB,QAGnE+V,EAAAzG,OAAP,SAAoBjQ,EAA0BkW,GAC5C,IAAI9P,EAAO,EAEX,OADAA,GAAQpG,EAAMoW,WAAWF,IAIpBQ,EAAA7S,MAAP,SAAmBU,EAAgBvE,EAA0BkW,EAC1C9V,GAYjB,YAZiB,IAAAA,IAAAA,EAAA,GACJ,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACf7D,EAAMqW,UAAUH,EAAM3R,IAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIiG,EAA2B1W,EAAOkW,EAAM9V,IAG9CsW,EAAAL,UAAP,SAAuB9R,EAAgBvE,EAA0BkW,GAC/D,OAAOQ,EAAqB7S,MAAMU,EAAQvE,EAAOkW,EAAM,IAE3DQ,EAlDA,CAAgDpG,EAAAA,QCAhDqG,GAAA,SAAA5W,GAKE,SAAA4W,EAAY3W,EAA0BkW,EAAS9V,GAA/C,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK8V,MAAQD,EACb7V,EAAKM,MAAQP,IAqCjB,OA9CkDZ,EAAAmX,EAAA5W,GAYhD4W,EAAA/W,UAAAoQ,KAAA,SAAKzL,GACH,OAAOoS,EAAuB9S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKyW,MAAOzW,KAAKiB,QAGrEgW,EAAA1G,OAAP,SAAoBjQ,EAA0BkW,GAC5C,IAAI9P,EAAO,EAEX,OADAA,GAAQpG,EAAMoW,WAAWF,IAIpBS,EAAA9S,MAAP,SAAmBU,EAAgBvE,EAA0BkW,EAC1C9V,GAQjB,YARiB,IAAAA,IAAAA,EAAA,GACJ,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACf7D,EAAMqW,UAAUH,EAAM3R,IAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIkG,EAA6B3W,EAAOkW,EAAM9V,IAGhDuW,EAAAN,UAAP,SAAuB9R,EAAgBvE,EAA0BkW,GAC/D,OAAOS,EAAuB9S,MAAMU,EAAQvE,EAAOkW,EAAM,IAE7DS,EA9CA,CAAkDrG,EAAAA,QCAlDsG,GAAA,SAAA7W,GAKE,SAAA6W,EAAY5W,EAA0BkW,EAAS9V,GAA/C,IAAAC,EACEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAK8V,MAAQD,EACb7V,EAAKM,MAAQP,IAyCjB,OAlDqDZ,EAAAoX,EAAA7W,GAYnD6W,EAAAhX,UAAAoQ,KAAA,SAAKzL,GACH,OAAOqS,EAA0B/S,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKyW,MAAOzW,KAAKiB,QAGxEiW,EAAA3G,OAAP,SAAoBjQ,EAA0BkW,GAC5C,IAAI9P,EAAO,EAEX,OADAA,GAAQpG,EAAMoW,WAAWF,IAIpBU,EAAA/S,MAAP,SAAmBU,EAAgBvE,EAA0BkW,EAC1C9V,GAYjB,YAZiB,IAAAA,IAAAA,EAAA,GACJ,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GACW,IAATA,GAAcmE,EAAOtD,WAC9BsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACf7D,EAAMqW,UAAUH,EAAM3R,IAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAImG,EAAgC5W,EAAOkW,EAAM9V,IAGnDwW,EAAAP,UAAP,SAAuB9R,EAAgBvE,EAA0BkW,GAC/D,OAAOU,EAA0B/S,MAAMU,EAAQvE,EAAOkW,EAAM,IAEhEU,EAlDA,CAAqDtG,EAAAA,QCArDuG,GAAA,SAAA9W,GAOE,SAAA8W,EAAY7W,EAA0B2P,EAAcuG,EACxCrG,EAAezP,GAD3B,IAAAC,EAEEN,EAAAO,KAAAZ,OAAOA,YACPW,EAAKE,OAASP,EACdK,EAAKyW,WAAanH,EAClBtP,EAAK8V,MAAQD,EACb7V,EAAK0P,MAAQF,EACbxP,EAAKM,MAAQP,IA+DjB,OA7EgDZ,EAAAqX,EAAA9W,GAiB9C8W,EAAAjX,UAAAoQ,KAAA,SAAKzL,GACH,OAAOsS,EAAqBhT,MAAMU,EAAQ7E,KAAKa,OAAQb,KAAKoX,WAC1BpX,KAAKyW,MAAOzW,KAAKqQ,MAAOrQ,KAAKiB,QAG1DkW,EAAA5G,OAAP,SAAoBjQ,EAA0B2P,EAAcuG,GAC1D,IAAI9P,EAAO,EAIX,OAHAA,GAAQpG,EAAMkQ,YAAYP,GAC1BvJ,GAAQ,EACRA,GAAQpG,EAAMoW,WAAWF,IAIpBW,EAAAT,WAAP,SAAwBpW,EAA0B2P,EAAcuG,GAC9D,IAAI9P,EAAO,EAIX,OAHAA,GAAQpG,EAAMkQ,YAAYP,GAC1BvJ,GAAQ,EACRA,GAAQpG,EAAMoW,WAAWF,IAIpBW,EAAAhT,MAAP,SAAmBU,EAAgBvE,EAA0B2P,EAAcuG,EACxDrG,EAAezP,GAShC,QATgC,IAAAA,IAAAA,EAAA,GACnB,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,GAAcmE,EAAOtD,WACvBsD,EAASA,EAAOV,MAAM,IACtBzD,EAAO,GAEI,IAATA,EAMF,IAFEyP,EAHGA,EAGIA,EAAKG,KAAKzL,GAFVvE,EAAMqQ,WAAWV,EAAWpL,IAI5B5C,SACPkO,OAAO,EACPzP,EAAO,OACF,GAAIyP,EAAK/N,UACd,OAAO+N,EAAKnN,UAGhB,OAAa,IAATtC,GAAcmE,EAAOtD,UACvBsD,EAASA,EAAOV,MAAM,IACf7D,EAAMqW,UAAUH,EAAM3R,IAE3BA,EAAO5C,SACF2O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,cAC/BjM,EAAOzC,UACTwO,EAAAA,OAAOjO,MAAMkC,EAAOkM,QAEtB,IAAIoG,EAA2B7W,EAAO2P,EAAWuG,EAAMrG,EAAMzP,IAG/DyW,EAAAR,UAAP,SAAuB9R,EAAgBvE,EAChB2P,EAAcuG,GACnC,OAAOW,EAAqBhT,MAAMU,EAAQvE,EAAO2P,EAAWuG,OAAM,EAAQ,IAE9EW,EA7EA,CAAgDvG,EAAAA,sBCyBhD,SAAAyG,KAieA,OApbEA,EAAAnX,UAAAoX,WAAA,SAAW/J,EAAQ3H,GACjB,OAAOsK,EAAWK,OAAOvQ,KAAMuN,EAAK3H,IAGtCyR,EAAAnX,UAAAqX,UAAA,SAAUhK,EAAQ3H,EAAUf,GAC1B,OAAOqL,EAAW/L,MAAMU,EAAQ7E,KAAMuN,EAAK3H,IAG7CyR,EAAAnX,UAAAgT,WAAA,SAAW3F,EAAQ3H,GACjB,OAAOoL,EAAWT,OAAOvQ,KAAMuN,EAAK3H,IAGtCyR,EAAAnX,UAAAqT,UAAA,SAAUhG,EAAQ3H,EAAUf,GAC1B,OAAOmM,EAAW7M,MAAMU,EAAQ7E,KAAMuN,EAAK3H,IAS7CyR,EAAAnX,UAAA0S,YAAA,SAAYrQ,EAAqB4O,EAAmBC,GAClD,GAAyB,IAArBzD,UAAUwG,OACZ,OAAOlD,EAAYV,OAAOvQ,KAAMuC,EAAmB4O,EAAUC,GAE7D,IAAMF,EAAQlR,KAAKkR,MAAM3O,GACzB,OAAI2O,EAAMiB,UACDlB,EAAYV,OAAOvQ,KAAMkR,EAAOlR,KAAKwX,YAAYxX,KAAKkR,MAAM3O,KAAa,GAEzE,GAOb8U,EAAAnX,UAAAoT,WAAA,SAAW/Q,EAAqBsC,EAAgBsM,EAAmBC,GACjE,GAAyB,IAArBzD,UAAUwG,OACZ,OAAOlD,EAAY9M,MAAMU,EAAQ7E,KAAMuC,EAAmB4O,EAAUC,GAEpE,IAAMF,EAAQlR,KAAKkR,MAAM3O,GACzB,OAAI2O,EAAMiB,UACDlB,EAAY9M,MAAMU,EAAQ7E,KAAMkR,EAAOlR,KAAKwX,YAAYxX,KAAKkR,MAAM3O,KAAa,GAEhF6D,EAAAA,QAAQ8P,YAAY,KAAMrR,IAKvCwS,EAAAnX,UAAAuX,aAAA,SAAalV,GACX,IAAM2O,EAAQlR,KAAKkR,MAAM3O,GACzB,OAAI2O,EAAMiB,UACDlB,EAAYV,OAAOvQ,KAAMkR,GAAO,GAAO,GAEvC,GAIXmG,EAAAnX,UAAAwX,YAAA,SAAYnV,EAASsC,GACnB,IAAMqM,EAAQlR,KAAKkR,MAAM3O,GACzB,OAAI2O,EAAMiB,UACDlB,EAAY9M,MAAMU,EAAQ7E,KAAMkR,GAAO,GAAO,GAE9C9K,EAAAA,QAAQ8P,YAAY,KAAMrR,IAIrCwS,EAAAnX,UAAAqV,cAAA,SAAc3P,GACZ,GAAI5F,KAAK0S,SAAS1S,KAAKuC,KAAKqD,IAAS,CACnC,IAAMsL,EAAQlR,KAAKkR,MAAMlR,KAAKuC,KAAKqD,IACnC,GAAIsL,EAAMiB,UACR,OAAOqB,EAAcjD,OAAOvQ,KAAMkR,QAE/B,IAAKlR,KAAKyQ,SAASzQ,KAAKuC,KAAKqD,IAClC,OAAO5F,KAAKwQ,YAAY5K,GAE1B,OAAO,GAGTyR,EAAAnX,UAAAsV,aAAA,SAAa5P,EAAUf,GACrB,GAAI7E,KAAK0S,SAAS1S,KAAKuC,KAAKqD,IAAS,CACnC,IAAMsL,EAAQlR,KAAKkR,MAAMlR,KAAKuC,KAAKqD,IACnC,GAAIsL,EAAMiB,UACR,OAAOqB,EAAcrP,MAAMU,EAAQ7E,KAAMkR,QAEtC,IAAKlR,KAAKyQ,SAASzQ,KAAKuC,KAAKqD,IAClC,OAAO5F,KAAK2Q,WAAW/K,EAAOf,GAEhC,OAAOuB,EAAAA,QAAQ8P,YAAY,KAAMrR,IAGnCwS,EAAAnX,UAAAsX,YAAA,SAAYtG,GACV,KAAOA,EAAMiB,WACX,GAAInS,KAAKqS,OAAOnB,EAAMO,OAAO7L,OAC3B,OAAO,EAGX,OAAO,GAGTyR,EAAAnX,UAAAyS,aAAA,SAAazB,GACX,IAAKA,EAAMiB,YAAcnS,KAAKqS,OAAOnB,EAAMO,OAAO7L,OAChD,OAAO,EAET,KAAOsL,EAAMiB,WACX,GAAInS,KAAKqS,OAAOnB,EAAMO,OAAO7L,OAC3B,OAAO,EAGX,OAAO,GAGTyR,EAAAnX,UAAAsS,iBAAA,SAAiBjQ,GAIf,MAHoB,iBAATA,IACTA,EAAOvC,KAAKsF,OAAO/C,IAEdoR,EAAiBpD,OAAOhO,IAGjC8U,EAAAnX,UAAAkT,gBAAA,SAAgB7Q,EAAkBsC,GAIhC,MAHoB,iBAATtC,IACTA,EAAOvC,KAAKsF,OAAO/C,IAEdoR,EAAiBxP,MAAMU,EAAQtC,IAGxC8U,EAAAnX,UAAAyX,WAAA,SAAWxD,GACT,OAAOO,EAAWnE,OAAO4D,IAG3BkD,EAAAnX,UAAA0X,UAAA,SAAUhS,EAA+Bf,GACvC,OAAIe,EACK8O,EAAWvQ,MAAMU,EAAQe,GAEzBQ,EAAAA,QAAQ8P,YAAY,IAAKrR,IAIpCwS,EAAAnX,UAAA8S,QAAA,SAAQpN,GACe,iBAAVA,IACTA,EAAQ5F,KAAKsF,OAAOM,IAEtB,IACIvE,EADE6S,EAAItO,EAAMuO,OAEhB,GAAU,IAAND,QAA4C,KAAhC7S,EAAIuE,EAAMyO,YAAY,MAAqB5S,GAAME,iBAAiBN,GAChF,OAAO,EAET,IAAK,IAAI4S,EAAIrO,EAAMwO,mBAAmB,EAAG,GAAIH,EAAIC,EAAGD,EAAIrO,EAAMwO,mBAAmBH,EAAG,GAElF,QAAU,KADV5S,EAAIuE,EAAMyO,YAAYJ,MACDxS,GAAMsD,YAAY1D,GACrC,OAAO,EAGX,OAAO,GAGTgW,EAAAnX,UAAA2X,WAAA,SAAWjS,GACT,OAAI5F,KAAKgT,QAAQpN,GACRoP,EAAYzE,OAAO3K,GAEnBsP,EAAa3E,OAAO3K,IAI/ByR,EAAAnX,UAAA4X,UAAA,SAAUlS,EAAef,GACvB,OAAI7E,KAAKgT,QAAQpN,GACRoP,EAAY7Q,MAAMU,EAAQe,GAE1BsP,EAAa/Q,MAAMU,EAAQe,IAItCyR,EAAAnX,UAAA6X,UAAA,SAAUnS,GACR,GAAIoS,SAASpS,IAAUiP,KAAKC,MAAMlP,KAAWA,GAASiP,KAAKoD,IAAIrS,GAAS,WAAY,CAClF,IAAIc,EAAOwR,EAAAA,OAAOC,YAAYvS,GAI9B,OAHIA,EAAQ,IACVc,GAAQ,GAEHA,EAEP,OAAQ,GAAKd,GAAOuO,QAIxBkD,EAAAnX,UAAAkY,SAAA,SAASxS,EAAef,GACtB,OAAImT,SAASpS,IAAUiP,KAAKC,MAAMlP,KAAWA,GAASiP,KAAKoD,IAAIrS,GAAS,WAC/DsS,EAAAA,OAAOG,aAAazS,EAAOf,GAE3BuB,EAAAA,QAAQ8P,YAAY,GAAKtQ,EAAOf,IAI3CwS,EAAAnX,UAAAoY,aAAA,SAAa1S,GACX,OAAO,IAGTyR,EAAAnX,UAAAqY,YAAA,SAAY3S,EAAef,GACzB,OAAOU,EAAAA,OAAOiT,YAAYC,oBAAoB7S,EAAOf,EAAQ,IAG/DwS,EAAAnX,UAAAwY,aAAA,SAAa9S,GACX,OAAO,IAGTyR,EAAAnX,UAAAyY,YAAA,SAAY/S,EAAef,GACzB,OAAOU,EAAAA,OAAOiT,YAAYC,oBAAoB7S,EAAOf,EAAQ,KAG/DwS,EAAAnX,UAAA0Y,WAAA,SAAWhT,GACT,OAAOA,EAAQ,EAAI,GAGrByR,EAAAnX,UAAA2Y,UAAA,SAAUjT,EAAgBf,GACxB,OAAOuB,EAAAA,QAAQ8P,YAAYtQ,EAAQ,OAAS,QAASf,IAGvDwS,EAAAnX,UAAA4Y,iBAAA,SAAiB1R,EAAaC,GAC5B,OAAO+N,EAAiB7E,OAAOvQ,KAAMoH,EAAUC,IAGjDgQ,EAAAnX,UAAA6Y,gBAAA,SAAgB3R,EAAaC,EAAaxC,GACxC,OAAOuQ,EAAiBjR,MAAMU,EAAQ7E,KAAMoH,EAAUC,IAGxDgQ,EAAAnX,UAAA8Y,0BAAA,SAA0BjR,EAAWC,EAAaC,EAAayN,GAC7D,OAAOD,EAA0BlF,OAAOvQ,KAAM+H,EAAQC,EAAUC,EAAUyN,IAG5E2B,EAAAnX,UAAA+Y,yBAAA,SAAyBlR,EAAWC,EAAaC,EAAayN,EAAoB7Q,GAChF,OAAO4Q,EAA0BtR,MAAMU,EAAQ7E,KAAM+H,EAAQC,EAAUC,EAAUyN,IAGnF2B,EAAAnX,UAAAgZ,oBAAA,SAAoBzQ,EAAQgB,EAAkBf,EAAQgN,GACpD,OAAOK,EAAoBxF,OAAOvQ,KAAMyI,EAAKgB,EAAUf,EAAKgN,IAG9D2B,EAAAnX,UAAAiZ,mBAAA,SAAmB1Q,EAAQgB,EAAkBf,EAAQgN,EAAoB7Q,GACvE,OAAOkR,EAAoB5R,MAAMU,EAAQ7E,KAAMyI,EAAKgB,EAAUf,EAAKgN,IAGrE2B,EAAAnX,UAAAkZ,qBAAA,SAAqB3P,EAAkBf,EAAQgN,GAC7C,OAAOS,EAAqB5F,OAAOvQ,KAAMyJ,EAAUf,EAAKgN,IAG1D2B,EAAAnX,UAAAmZ,oBAAA,SAAoB5P,EAAkBf,EAAQgN,EAAoB7Q,GAChE,OAAOsR,EAAqBhS,MAAMU,EAAQ7E,KAAMyJ,EAAUf,EAAKgN,IAGjE2B,EAAAnX,UAAAoZ,qBAAA,SAAqBzJ,EAAS/D,GAC5B,OAAOsK,EAAqB7F,OAAOvQ,KAAM6P,EAAM/D,IAGjDuL,EAAAnX,UAAAqZ,oBAAA,SAAoB1J,EAAS/D,EAASjH,GACpC,OAAOuR,EAAqBjS,MAAMU,EAAQ7E,KAAM6P,EAAM/D,IAOxDuL,EAAAnX,UAAAsZ,uBAAA,WACE,OAAO,GAGTnC,EAAAnX,UAAAuZ,sBAAA,SAAsB5U,GACpB,OAAO+L,EAAAA,OAAO9O,QAGhBuV,EAAAnX,UAAAwZ,2BAAA,WACE,OAAO,GAGTrC,EAAAnX,UAAAyZ,0BAAA,SAA0B9U,GACxB,OAAO+L,EAAAA,OAAO9O,QAGhBuV,EAAAnX,UAAA0Z,sBAAA,SAAsBrX,EAASiU,GAC7B,OAAOD,EAAsBhG,OAAOvQ,KAAMuC,EAAMiU,IAGlDa,EAAAnX,UAAA2Z,qBAAA,SAAqBtX,EAASiU,EAAS3R,GACrC,OAAO0R,EAAsBpS,MAAMU,EAAQ7E,KAAMuC,EAAMiU,IAGzDa,EAAAnX,UAAA4Z,0BAAA,SAA0BvX,EAASiU,GACjC,OAAO,GAGTa,EAAAnX,UAAA6Z,yBAAA,SAAyBxX,EAASiU,EAAS3R,GACzC,OAAO+L,EAAAA,OAAO9O,QAGhBuV,EAAAnX,UAAA8Z,kBAAA,SAAkBzM,EAAQiJ,GACxB,OAAOI,EAAkBrG,OAAOvQ,KAAMuN,EAAKiJ,IAG7Ca,EAAAnX,UAAA+Z,iBAAA,SAAiB1M,EAAQiJ,EAAS3R,GAChC,OAAO+R,EAAkBzS,MAAMU,EAAQ7E,KAAMuN,EAAKiJ,IAGpDa,EAAAnX,UAAAga,sBAAA,SAAsB3M,EAAQiJ,GAC5B,OAAOI,EAAkBrG,OAAOvQ,KAAMuN,EAAKiJ,IAG7Ca,EAAAnX,UAAAia,qBAAA,SAAqB5M,EAAQiJ,EAAS3R,GACpC,OAAO+R,EAAkBD,UAAU9R,EAAQ7E,KAAMuN,EAAKiJ,IAGxDa,EAAAnX,UAAAka,sBAAA,SAAsB7M,EAAQiJ,GAC5B,OAAOK,EAAsBtG,OAAOvQ,KAAMuN,EAAKiJ,IAGjDa,EAAAnX,UAAAma,qBAAA,SAAqB9M,EAAQiJ,EAAS3R,GACpC,OAAOgS,EAAsB1S,MAAMU,EAAQ7E,KAAMuN,EAAKiJ,IAGxDa,EAAAnX,UAAAoa,0BAAA,SAA0B/M,EAAQiJ,GAChC,OAAOK,EAAsBtG,OAAOvQ,KAAMuN,EAAKiJ,IAGjDa,EAAAnX,UAAAqa,yBAAA,SAAyBhN,EAAQiJ,EAAS3R,GACxC,OAAOgS,EAAsBF,UAAU9R,EAAQ7E,KAAMuN,EAAKiJ,IAG5Da,EAAAnX,UAAAsa,sBAAA,SAAsBzK,EAAUyG,GAC9B,OAAOM,EAAsBvG,OAAOvQ,KAAM+P,EAAOyG,IAGnDa,EAAAnX,UAAAua,qBAAA,SAAqB1K,EAAUyG,EAAS3R,GACtC,OAAOiS,EAAsB3S,MAAMU,EAAQ7E,KAAM+P,EAAOyG,IAG1Da,EAAAnX,UAAAwa,0BAAA,SAA0B3K,EAAUyG,GAClC,OAAOM,EAAsBJ,WAAW1W,KAAM+P,EAAOyG,IAGvDa,EAAAnX,UAAAya,yBAAA,SAAyB5K,EAAUyG,EAAS3R,GAC1C,OAAOiS,EAAsBH,UAAU9R,EAAQ7E,KAAM+P,EAAOyG,IAG9Da,EAAAnX,UAAA0a,mBAAA,SAAmBpE,GACjB,OAAOO,EAAmBxG,OAAOvQ,KAAMwW,IAGzCa,EAAAnX,UAAA2a,kBAAA,SAAkBrE,EAAS3R,GACzB,OAAOkS,EAAmB5S,MAAMU,EAAQ7E,KAAMwW,IAGhDa,EAAAnX,UAAA4a,uBAAA,SAAuBtE,GACrB,OAAOO,EAAmBxG,OAAOvQ,KAAMwW,IAGzCa,EAAAnX,UAAA6a,sBAAA,SAAsBvE,EAAS3R,GAC7B,OAAOkS,EAAmBJ,UAAU9R,EAAQ7E,KAAMwW,IAGpDa,EAAAnX,UAAA8a,qBAAA,SAAqBxE,GACnB,OAAOQ,EAAqBzG,OAAOvQ,KAAMwW,IAG3Ca,EAAAnX,UAAA+a,oBAAA,SAAoBzE,EAAS3R,GAC3B,OAAOmS,EAAqB7S,MAAMU,EAAQ7E,KAAMwW,IAGlDa,EAAAnX,UAAAgb,yBAAA,SAAyB1E,GACvB,OAAOQ,EAAqBzG,OAAOvQ,KAAMwW,IAG3Ca,EAAAnX,UAAAib,wBAAA,SAAwB3E,EAAS3R,GAC/B,OAAOmS,EAAqBL,UAAU9R,EAAQ7E,KAAMwW,IAGtDa,EAAAnX,UAAAkb,uBAAA,SAAuB5E,GACrB,OAAOS,GAAuB1G,OAAOvQ,KAAMwW,IAG7Ca,EAAAnX,UAAAmb,sBAAA,SAAsB7E,EAAS3R,GAC7B,OAAOoS,GAAuB9S,MAAMU,EAAQ7E,KAAMwW,IAGpDa,EAAAnX,UAAAob,2BAAA,SAA2B9E,GACzB,OAAOS,GAAuB1G,OAAOvQ,KAAMwW,IAG7Ca,EAAAnX,UAAAqb,0BAAA,SAA0B/E,EAAS3R,GACjC,OAAOoS,GAAuBN,UAAU9R,EAAQ7E,KAAMwW,IAGxDa,EAAAnX,UAAAsb,0BAAA,SAA0BhF,GACxB,OAAOU,GAA0B3G,OAAOvQ,KAAMwW,IAGhDa,EAAAnX,UAAAub,yBAAA,SAAyBjF,EAAS3R,GAChC,OAAOqS,GAA0B/S,MAAMU,EAAQ7E,KAAMwW,IAGvDa,EAAAnX,UAAAwb,8BAAA,SAA8BlF,GAC5B,OAAOU,GAA0B3G,OAAOvQ,KAAMwW,IAGhDa,EAAAnX,UAAAyb,6BAAA,SAA6BnF,EAAS3R,GACpC,OAAOqS,GAA0BP,UAAU9R,EAAQ7E,KAAMwW,IAG3Da,EAAAnX,UAAA0b,qBAAA,SAAqB3L,EAAcuG,GACjC,OAAOW,GAAqB5G,OAAOvQ,KAAMiQ,EAAWuG,IAGtDa,EAAAnX,UAAA2b,oBAAA,SAAoB5L,EAAcuG,EAAS3R,GACzC,OAAOsS,GAAqBhT,MAAMU,EAAQ7E,KAAMiQ,EAAWuG,IAG7Da,EAAAnX,UAAA4b,yBAAA,SAAyB7L,EAAcuG,GACrC,OAAOW,GAAqBT,WAAW1W,KAAMiQ,EAAWuG,IAG1Da,EAAAnX,UAAA6b,wBAAA,SAAwB9L,EAAcuG,EAAS3R,GAC7C,OAAOsS,GAAqBR,UAAU9R,EAAQ7E,KAAMiQ,EAAWuG,IAGjEa,EAAAnX,UAAA8b,aAAA,WACE,OAAO,GAGT3E,EAAAnX,UAAA+b,YAAA,SAAYpX,GACV,OAAO+L,EAAAA,OAAO9O,QAGhBuV,EAAAnX,UAAAgc,aAAA,WACE,OAAO,GAGT7E,EAAAnX,UAAAic,YAAA,SAAYtX,GACV,OAAO+L,EAAAA,OAAO9O,QAElBuV,oBCxdA,SAAA+E,mDA4UA,OA5U0Ctc,EAAAsc,EAAA/b,GACxC+b,EAAAlc,UAAA2S,QAAA,SAAQtQ,GACN,OAAOA,aAAgB8Z,EAAAA,OAGzBD,EAAAlc,UAAAmS,OAAA,SAAO9P,GACL,OAAOA,aAAgBiL,EAAAA,MAGzB4O,EAAAlc,UAAAoc,OAAA,SAAO/Z,GACL,OAAOA,aAAgBqL,EAAAA,MAGzBwO,EAAAlc,UAAA6S,QAAA,SAAQxQ,GACN,OAAOA,aAAgBsL,EAAAA,OAGzBuO,EAAAlc,UAAAwS,SAAA,SAASnQ,GACP,OAAOA,aAAgBuL,EAAAA,QAGzBsO,EAAAlc,UAAAqS,OAAA,SAAOhQ,GACL,OAAOA,aAAgByL,EAAAA,MAGzBoO,EAAAlc,UAAA+S,MAAA,SAAM1Q,GACJ,OAAOA,aAAgB6L,EAAAA,KAGzBgO,EAAAlc,UAAA4S,OAAA,SAAOvQ,GACL,OAAOA,aAAgB2L,EAAAA,MAGzBkO,EAAAlc,UAAAkS,aAAA,SAAa7P,GACX,OAAOA,aAAgBga,EAAAA,YAGzBH,EAAAlc,UAAAuQ,SAAA,SAASlO,GACP,OAAOA,aAAgBia,EAAAA,QAGzBJ,EAAAlc,UAAAgR,MAAA,SAAM3O,GACJ,OAAOA,EAAKka,YAGdL,EAAAlc,UAAAqC,KAAA,SAAKqD,GACH,OAAOA,GAGTwW,EAAAlc,UAAAqN,IAAA,SAAIhL,GACF,OAAOA,EAAKgL,KAGd6O,EAAAlc,UAAA0F,MAAA,SAAMrD,GACJ,OAAOA,EAAK+K,WAGd8O,EAAAlc,UAAAoF,OAAA,SAAO/C,GACL,OAAOA,EAAK0L,YAAY,KAG1BmO,EAAAlc,UAAAwV,WAAA,SAAWnT,GACT,OAAOA,EAAKmT,cAGd0G,EAAAlc,UAAAoS,WAAA,SAAW/P,GACT,GAAIA,aAAgB8Z,EAAAA,MAAO,CACzB,GAAI9Z,aAAgBiL,EAAAA,KAClB,OAAOxN,KAAKsX,WAAW/U,EAAKgL,IAAKhL,EAAKqD,OACjC,GAAIrD,aAAgBqL,EAAAA,KACzB,OAAO5N,KAAKkT,WAAW3Q,EAAKgL,IAAKhL,EAAKqD,YAEnC,GAAIrD,aAAgBsL,EAAAA,MACzB,OAAO7N,KAAKwQ,YAAYjO,GAE1B,MAAM,IAAIuO,EAAAA,gBAAgB,8BAAgCvO,IAG5D6Z,EAAAlc,UAAAiT,UAAA,SAAU5Q,EAAYsC,GACpB,GAAItC,aAAgB8Z,EAAAA,MAAO,CACzB,GAAI9Z,aAAgBiL,EAAAA,KAClB,OAAOxN,KAAKuX,UAAUhV,EAAKgL,IAAKhL,EAAKqD,MAAOf,GACvC,GAAItC,aAAgBqL,EAAAA,KACzB,OAAO5N,KAAKuT,UAAUhR,EAAKgL,IAAKhL,EAAKqD,MAAOf,QAEzC,GAAItC,aAAgBsL,EAAAA,MACzB,OAAO7N,KAAK2Q,WAAWpO,EAAMsC,GAE/B,OAAO+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgCvO,KAG1E6Z,EAAAlc,UAAAsQ,YAAA,SAAY5K,GACV,GAAIA,aAAiBkI,EAAAA,OACnB,OAAO9N,KAAKyX,aAAa7R,GACpB,GAAIA,aAAiBmI,EAAAA,KAC1B,OAAO/N,KAAK2X,WAAW/R,EAAMc,MACxB,GAAId,aAAiBoI,EAAAA,KAC1B,OAAOhO,KAAK6X,WAAWjS,EAAMA,OACxB,GAAIA,aAAiBwI,EAAAA,IAC1B,OAAIxI,EAAM8W,WACD1c,KAAKsY,aAAa1S,EAAMA,OACtBA,EAAM+W,WACR3c,KAAK0Y,aAAa9S,EAAMA,OAExB5F,KAAK+X,UAAUnS,EAAMA,OAEzB,GAAIA,aAAiBsI,EAAAA,KAC1B,OAAOlO,KAAK4Y,WAAWhT,EAAMA,OACxB,GAAIA,aAAiB2I,EAAAA,SAC1B,OAAOvO,KAAK4c,eAAehX,GACtB,GAAIA,aAAiBiX,EAAAA,SAC1B,OAAO7c,KAAK8c,eAAelX,GACtB,GAAIA,aAAiBmX,EAAAA,KAC1B,OAAO/c,KAAKgd,WAAWpX,GAClB,GAAIA,aAAiB4W,EAAAA,OAC1B,OAAOxc,KAAKgc,eACP,GAAIpW,aAAiBqX,EAAAA,OAC1B,OAAOjd,KAAKkc,eAEd,MAAM,IAAIpL,EAAAA,gBAAgB,8BAAgClL,IAG5DwW,EAAAlc,UAAAyQ,WAAA,SAAW/K,EAAcf,GACvB,OAAIe,aAAiBkI,EAAAA,OACZ9N,KAAK0X,YAAY9R,EAAOf,GACtBe,aAAiBmI,EAAAA,KACnB/N,KAAK4X,UAAUhS,EAAMsX,eAAgBrY,GACnCe,aAAiBoI,EAAAA,KACnBhO,KAAK8X,UAAUlS,EAAMA,MAAOf,GAC1Be,aAAiBwI,EAAAA,IACtBxI,EAAM8W,WACD1c,KAAKuY,YAAY3S,EAAMA,MAAOf,GAC5Be,EAAM+W,WACR3c,KAAK2Y,YAAY/S,EAAMA,MAAOf,GAE9B7E,KAAKoY,SAASxS,EAAMA,MAAOf,GAE3Be,aAAiBsI,EAAAA,KACnBlO,KAAK6Y,UAAUjT,EAAMA,MAAOf,GAC1Be,aAAiB2I,EAAAA,SACnBvO,KAAKmd,cAAcvX,EAAOf,GACxBe,aAAiBiX,EAAAA,SACnB7c,KAAKod,cAAcxX,EAAOf,GACxBe,aAAiBmX,EAAAA,KACnB/c,KAAKqd,UAAUzX,EAAOf,GACpBe,aAAiB4W,EAAAA,OACnBxc,KAAKic,YAAYpX,GACfe,aAAiBqX,EAAAA,OACnBjd,KAAKmc,YAAYtX,GAEnB+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgClL,KAG1EwW,EAAAlc,UAAA0c,eAAA,SAAezQ,GACb,GAAIA,aAAoBmR,EAAAA,iBACtB,OAAOtd,KAAKwZ,yBACP,GAAIrN,aAAoBoR,EAAAA,gBAC7B,OAAOvd,KAAK4Z,sBAAsBzN,EAAS5J,OAAQ4J,EAASqK,QACvD,GAAIrK,aAAoBqR,EAAAA,YAC7B,OAAOxd,KAAKga,kBAAkB7N,EAASsR,WAAYtR,EAASqK,QACvD,GAAIrK,aAAoBuR,EAAAA,gBAC7B,OAAO1d,KAAKoa,sBAAsBjO,EAASsR,WAAYtR,EAASqK,QAC3D,GAAIrK,aAAoBwR,EAAAA,gBAC7B,OAAO3d,KAAKwa,sBAAsBrO,EAASsR,WAAYtR,EAASqK,QAC3D,GAAIrK,aAAoByR,EAAAA,aAC7B,OAAO5d,KAAK4a,mBAAmBzO,EAASqK,QACnC,GAAIrK,aAAoB0R,EAAAA,eAC7B,OAAO7d,KAAKgb,qBAAqB7O,EAASqK,QACrC,GAAIrK,aAAoB2R,EAAAA,iBAC7B,OAAO9d,KAAKob,uBAAuBjP,EAASqK,QACvC,GAAIrK,aAAoB4R,EAAAA,oBAC7B,OAAO/d,KAAKwb,0BAA0BrP,EAASqK,QAC1C,GAAIrK,aAAoB6R,EAAAA,eAC7B,OAAOhe,KAAK4b,qBAAqBzP,EAAS8D,YAAa9D,EAASqK,QAElE,MAAM,IAAI1F,EAAAA,gBAAgB,8BAAgC3E,IAG5DiQ,EAAAlc,UAAAid,cAAA,SAAchR,EAAoBtH,GAChC,OAAIsH,aAAoBmR,EAAAA,iBACftd,KAAKyZ,sBAAsB5U,GACzBsH,aAAoBoR,EAAAA,gBACtBvd,KAAK6Z,qBAAqB1N,EAAS5J,OAAQ4J,EAASqK,OAAQ3R,GAC1DsH,aAAoBqR,EAAAA,YACtBxd,KAAKia,iBAAiB9N,EAASsR,WAAYtR,EAASqK,OAAQ3R,GAC1DsH,aAAoBuR,EAAAA,gBACtB1d,KAAKqa,qBAAqBlO,EAASsR,WAAYtR,EAASqK,OAAQ3R,GAC9DsH,aAAoBwR,EAAAA,gBACtB3d,KAAKya,qBAAqBtO,EAASsR,WAAYtR,EAASqK,OAAQ3R,GAC9DsH,aAAoByR,EAAAA,aACtB5d,KAAK6a,kBAAkB1O,EAASqK,OAAQ3R,GACtCsH,aAAoB0R,EAAAA,eACtB7d,KAAKib,oBAAoB9O,EAASqK,OAAQ3R,GACxCsH,aAAoB2R,EAAAA,iBACtB9d,KAAKqb,sBAAsBlP,EAASqK,OAAQ3R,GAC1CsH,aAAoB4R,EAAAA,oBACtB/d,KAAKyb,yBAAyBtP,EAASqK,OAAQ3R,GAC7CsH,aAAoB6R,EAAAA,eACtBhe,KAAK6b,oBAAoB1P,EAAS8D,YAAa9D,EAASqK,OAAQ3R,GAElE+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgC3E,KAG1EiQ,EAAAlc,UAAA4c,eAAA,SAAerT,GACb,GAAIA,aAAoBwU,EAAAA,eACtB,OAAOje,KAAKkZ,oBAAoBzP,EAASyU,WAAYzU,EAASA,WAAYA,EAAS0U,WAAY1U,EAASiM,cACnG,GAAIjM,aAAoB2U,EAAAA,cAC7B,OAAOpe,KAAKoZ,qBAAqB3P,EAASA,WAAYA,EAASuB,UAAWvB,EAASiM,cAC9E,GAAIjM,aAAoBqG,EAAAA,eAC7B,OAAO9P,KAAKsZ,qBAAqB7P,EAASoG,OAAQpG,EAASqC,QACtD,GAAIrC,aAAoB4U,EAAAA,oBAC7B,OAAOre,KAAKgZ,0BAA0BvP,EAAS1B,SAAU0B,EAASzB,WAAYyB,EAASxB,WAAYwB,EAASiM,cAE9G,MAAM,IAAI5E,EAAAA,gBAAgB,8BAAgCrH,IAG5D2S,EAAAlc,UAAAkd,cAAA,SAAc3T,EAAoB5E,GAChC,OAAI4E,aAAoBwU,EAAAA,eACfje,KAAKmZ,mBAAmB1P,EAASyU,WAAYzU,EAASA,WAAYA,EAAS0U,WAAY1U,EAASiM,aAAc7Q,GAC5G4E,aAAoB2U,EAAAA,cACtBpe,KAAKqZ,oBAAoB5P,EAASA,WAAYA,EAASuB,UAAWvB,EAASiM,aAAc7Q,GACvF4E,aAAoBqG,EAAAA,eACtB9P,KAAKuZ,oBAAoB9P,EAASoG,OAAQpG,EAASqC,OAAQjH,GACzD4E,aAAoB4U,EAAAA,oBACtBre,KAAKiZ,yBAAyBxP,EAAS1B,SAAU0B,EAASzB,WAAYyB,EAASxB,WAAYwB,EAASiM,aAAc7Q,GAEpH+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgCrH,KAG1E2S,EAAAlc,UAAA8c,WAAA,SAAWnN,GACT,GAAIA,aAAgByO,EAAAA,WAClB,OAAOte,KAAK8Y,iBAAiBjJ,EAAKzI,WAAYyI,EAAKxI,YAC9C,GAAIwI,aAAgB0O,EAAAA,WACzB,OAAO,EAET,MAAM,IAAIzN,EAAAA,gBAAgB,8BAAgCjB,IAG5DuM,EAAAlc,UAAAmd,UAAA,SAAUxN,EAAYhL,GACpB,OAAIgL,aAAgByO,EAAAA,WACXte,KAAK+Y,gBAAgBlJ,EAAKzI,WAAYyI,EAAKxI,WAAYxC,GACrDgL,aAAgB0O,EAAAA,WAClB3N,EAAAA,OAAO9O,OAET8O,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgCjB,KAG1EuM,EAAAlc,UAAAuS,gBAAA,SAAgBlQ,GACd,GAAIA,aAAgB8Z,EAAAA,MAClB,OAAOrc,KAAKsS,WAAW/P,GAClB,GAAIA,aAAgBsL,EAAAA,MACzB,OAAO7N,KAAK0Q,iBAAiBnO,GAE/B,MAAM,IAAIuO,EAAAA,gBAAgB,8BAAgCvO,IAG5D6Z,EAAAlc,UAAAmT,eAAA,SAAe9Q,EAAYsC,GACzB,OAAItC,aAAgB8Z,EAAAA,MACXrc,KAAKmT,UAAU5Q,EAAMsC,GACnBtC,aAAgBsL,EAAAA,MAClB7N,KAAK6Q,gBAAgBtO,EAAMsC,GAE7B+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgCvO,KAG1E6Z,EAAAlc,UAAAwQ,iBAAA,SAAiB9K,GACf,OAAIA,aAAiBkI,EAAAA,OACZ9N,KAAK4S,YAAYhN,GAEnB5F,KAAKwQ,YAAY5K,IAG1BwW,EAAAlc,UAAA2Q,gBAAA,SAAgBjL,EAAcf,GAC5B,OAAIe,aAAiBkI,EAAAA,OACZ9N,KAAKsT,WAAW1N,EAAOf,GAEzB7E,KAAK2Q,WAAW/K,EAAOf,IAGhCuX,EAAAlc,UAAAwW,WAAA,SAAWF,GACT,GAAIA,aAAgBjI,EAAAA,SAAU,CAC5B,GAAIiI,aAAgB8G,EAAAA,iBAClB,OAAOtd,KAAK0Z,6BACP,GAAIlD,aAAgB+G,EAAAA,gBACzB,OAAOvd,KAAK8Z,0BAA0BtD,EAAKjU,OAAQiU,EAAKA,QACnD,GAAIA,aAAgBgH,EAAAA,YACzB,OAAOxd,KAAKka,sBAAsB1D,EAAKiH,WAAYjH,EAAKA,QACnD,GAAIA,aAAgBkH,EAAAA,gBACzB,OAAO1d,KAAKsa,0BAA0B9D,EAAKiH,WAAYjH,EAAKA,QACvD,GAAIA,aAAgBmH,EAAAA,gBACzB,OAAO3d,KAAK0a,0BAA0BlE,EAAKiH,WAAYjH,EAAKA,QACvD,GAAIA,aAAgBoH,EAAAA,aACzB,OAAO5d,KAAK8a,uBAAuBtE,EAAKA,QACnC,GAAIA,aAAgBqH,EAAAA,eACzB,OAAO7d,KAAKkb,yBAAyB1E,EAAKA,QACrC,GAAIA,aAAgBsH,EAAAA,iBACzB,OAAO9d,KAAKsb,2BAA2B9E,EAAKA,QACvC,GAAIA,aAAgBuH,EAAAA,oBACzB,OAAO/d,KAAK0b,8BAA8BlF,EAAKA,QAC1C,GAAIA,aAAgBwH,EAAAA,eACzB,OAAOhe,KAAK8b,yBAAyBtF,EAAKvG,YAAauG,EAAKA,QAGhE,MAAM,IAAI1F,EAAAA,gBAAgB,8BAAgC0F,IAG5D4F,EAAAlc,UAAAyW,UAAA,SAAUH,EAAa3R,GACrB,GAAI2R,aAAgBjI,EAAAA,SAAU,CAC5B,GAAIiI,aAAgB8G,EAAAA,iBAClB,OAAOtd,KAAK2Z,0BAA0B9U,GACjC,GAAI2R,aAAgB+G,EAAAA,gBACzB,OAAOvd,KAAK+Z,yBAAyBvD,EAAKjU,OAAQiU,EAAKA,OAAQ3R,GAC1D,GAAI2R,aAAgBgH,EAAAA,YACzB,OAAOxd,KAAKma,qBAAqB3D,EAAKiH,WAAYjH,EAAKA,OAAQ3R,GAC1D,GAAI2R,aAAgBkH,EAAAA,gBACzB,OAAO1d,KAAKua,yBAAyB/D,EAAKiH,WAAYjH,EAAKA,OAAQ3R,GAC9D,GAAI2R,aAAgBmH,EAAAA,gBACzB,OAAO3d,KAAK2a,yBAAyBnE,EAAKiH,WAAYjH,EAAKA,OAAQ3R,GAC9D,GAAI2R,aAAgBoH,EAAAA,aACzB,OAAO5d,KAAK+a,sBAAsBvE,EAAKA,OAAQ3R,GAC1C,GAAI2R,aAAgBqH,EAAAA,eACzB,OAAO7d,KAAKmb,wBAAwB3E,EAAKA,OAAQ3R,GAC5C,GAAI2R,aAAgBsH,EAAAA,iBACzB,OAAO9d,KAAKub,0BAA0B/E,EAAKA,OAAQ3R,GAC9C,GAAI2R,aAAgBuH,EAAAA,oBACzB,OAAO/d,KAAK2b,6BAA6BnF,EAAKA,OAAQ3R,GACjD,GAAI2R,aAAgBwH,EAAAA,eACzB,OAAOhe,KAAK+b,wBAAwBvF,EAAKvG,YAAauG,EAAKA,OAAQ3R,GAGvE,OAAO+L,EAAAA,OAAOjO,MAAM,IAAImO,EAAAA,gBAAgB,8BAAgC0F,KAE5E4F,GA5U0C/E,kBC3BxC,SAAA5V,KA4HF,OAvHSA,EAAAY,QAAP,SAAehB,GACb,OAAa,KAANA,GAAoB,IAANA,GAIhBI,EAAAgB,UAAP,SAAiBpB,GACf,OAAa,KAANA,GAAmB,KAANA,GAIfI,EAAAC,aAAP,SAAoBL,GAClB,OAAOI,EAAMY,QAAQhB,IAAMI,EAAMgB,UAAUpB,IAItCI,EAAAE,iBAAP,SAAwBN,GACtB,OAAOA,GAAK,IAAaA,GAAK,IACjB,KAANA,GACAA,GAAK,IAAaA,GAAK,KACvBA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAASA,GAAK,KACnBA,GAAK,KAASA,GAAK,MACnBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAWA,GAAK,QAIvBI,EAAAsD,YAAP,SAAmB1D,GACjB,OAAa,KAANA,GACAA,GAAK,IAAaA,GAAK,IACvBA,GAAK,IAAaA,GAAK,IACjB,KAANA,GACAA,GAAK,IAAaA,GAAK,KACjB,MAANA,GACAA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAAQA,GAAK,KAClBA,GAAK,KAASA,GAAK,MACnBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,MAAUA,GAAK,MACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAUA,GAAK,OACpBA,GAAK,OAAWA,GAAK,QAMvBI,EAAA+c,gBAAP,WAIE,OAHK/c,EAAMgd,mBACThd,EAAMgd,iBAAmB,IAAIpR,GAExB5L,EAAMgd,kBAGRhd,EAAAid,gBAAP,WAIE,OAHKjd,EAAMkd,mBACTld,EAAMkd,iBAAmB,IAAIvC,IAExB3a,EAAMkd,kBAGRld,EAAAL,MAAP,SAAad,GACX,OAAOmB,EAAM+c,kBAAkBvR,iBAAiB3M,IAG3CmB,EAAA0L,OAAP,WACE,OAAO1L,EAAM+c,kBAAkBxR,eAG1BvL,EAAA8O,OAAP,SAAchO,GACZ,OAAOd,EAAMid,kBAAkBpM,WAAW/P,IAGrCd,EAAAmR,YAAP,SAAmBrQ,GACjB,OAAOd,EAAMid,kBAAkBjM,gBAAgBlQ,IAG1Cd,EAAA0C,MAAP,SAAa5B,EAAYsC,GACvB,OAAOpD,EAAMid,kBAAkBvL,UAAU5Q,EAAMsC,IAG1CpD,EAAA6R,WAAP,SAAkB/Q,EAAYsC,GAC5B,OAAOpD,EAAMid,kBAAkBrL,eAAe9Q,EAAMsC,IAG/CpD,EAAAmd,SAAP,SAAgBrc,GACd,IAAMsC,EAASuB,EAAAA,QAAQC,eAEvB,OADA5E,EAAM0C,MAAM5B,EAAMsC,GACXA,EAAO9C,QAGTN,EAAAod,cAAP,SAAqBtc,GACnB,IAAMsC,EAASuB,EAAAA,QAAQC,eAEvB,OADA5E,EAAM6R,WAAW/Q,EAAMsC,GAChBA,EAAO9C,QAGTN,EAAAqd,OAAP,SAAcvc,GACZ,IAAMsC,EAAS0P,EAAAA,KAAKwK,cAAchR,EAAAA,KAAKlJ,UAEvC,OADApD,EAAM0C,MAAM5B,EAAMsC,GACXA,EAAO9C,QAGTN,EAAAud,YAAP,SAAmBzc,GACjB,IAAMsC,EAAS0P,EAAAA,KAAKwK,cAAchR,EAAAA,KAAKlJ,UAEvC,OADApD,EAAM6R,WAAW/Q,EAAMsC,GAChBA,EAAO9C,QAElBN,KAEAwd,EAAAA,KAAK/e,UAAUgf,QAAU,WACvB,OAAOzd,GAAMmd,SAAS5e,OAGxBif,EAAAA,KAAK/e,UAAUif,aAAe,WAC5B,OAAO1d,GAAMod,cAAc7e,OAG7B6N,EAAAA,MAAMuR,WAAa,SAAU9e,GAC3B,OAAOmB,GAAML,MAAMd","file":"/Users/c9r/Swim/Code/swim-platform/swim-system-js/swim-core-js/@swim/recon/dist/main/swim-recon.min.js","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class BlockParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _keyParser: Parser<V> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._keyParser = keyParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return BlockParser.parse(input, this._recon, this._builder, this._keyParser,\n                             this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     keyParser?: Parser<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    block: do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 33/*'!'*/ || c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 37/*'%'*/\n              || c === 39/*'\\''*/ || c === 40/*'('*/ || c === 43/*'+'*/ || c === 45/*'-'*/\n              || c >= 48/*'0'*/ && c <= 57/*'9'*/ || c === 64/*'@'*/\n              || c === 91/*'['*/ || c === 123/*'{'*/ || c === 126/*'~'*/\n              || Recon.isIdentStartChar(c)) {\n            builder = builder || recon.valueBuilder();\n            step = 2;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 7;\n          } else {\n            if (builder) {\n              return Parser.done(builder.bind());\n            } else {\n              return Parser.done(recon.absent());\n            }\n          }\n        } else if (input.isDone()) {\n          if (builder) {\n            return Parser.done(builder.bind());\n          } else {\n            return Parser.done(recon.absent());\n          }\n        }\n      }\n      if (step === 2) {\n        if (!keyParser) {\n          keyParser = recon.parseBlockExpression(input);\n        }\n        while (keyParser.isCont() && !input.isEmpty()) {\n          keyParser = keyParser.feed(input);\n        }\n        if (keyParser.isDone()) {\n          step = 3;\n        } else if (keyParser.isError()) {\n          return keyParser;\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 58/*':'*/) {\n            input = input.step();\n            step = 4;\n          } else {\n            builder!.push(recon.item(keyParser!.bind()));\n            keyParser = void 0;\n            step = 6;\n          }\n        } else if (input.isDone()) {\n          builder!.push(recon.item(keyParser!.bind()));\n          return Parser.done(builder!.bind());\n        }\n      }\n      if (step === 4) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 5;\n        } else if (input.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind()));\n          return Parser.done(builder!.bind());\n        }\n      }\n      if (step === 5) {\n        if (!valueParser) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind(), valueParser.bind()));\n          keyParser = void 0;\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser;\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/ || c === 59/*';'*/ || Recon.isNewline(c)) {\n            input = input.step();\n            step = 1;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 7;\n          } else {\n            return Parser.done(builder!.bind());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.bind());\n        }\n      }\n      if (step === 7) {\n        while (input.isCont()) {\n          c = input.head();\n          if (!Recon.isNewline(c)) {\n            input = input.step();\n          } else {\n            step = 1;\n            continue block;\n          }\n        }\n        if (input.isDone()) {\n          step = 1;\n          continue;\n        }\n      }\n      break;\n    } while (true);\n    return new BlockParser<I, V>(recon, builder, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class AttrParser<I, V> extends Parser<I> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _keyParser: Parser<V> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._keyParser = keyParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<I> {\n    return AttrParser.parse(input, this._recon, this._keyParser,\n                            this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, keyParser?: Parser<V>,\n                     valueParser?: Parser<V>, step: number = 1): Parser<I> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 64/*'@'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(64/*'@'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (!keyParser) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n            keyParser = recon.parseString(input);\n          } else if (Recon.isIdentStartChar(c)) {\n            keyParser = recon.parseIdent(input);\n          } else {\n            return Parser.error(Diagnostic.expected(\"attribute name\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"attribute name\", input));\n        }\n      } else {\n        keyParser = keyParser.feed(input);\n      }\n      if (keyParser) {\n        if (keyParser.isDone()) {\n          step = 3;\n        } else if (keyParser.isError()) {\n          return keyParser.asError();\n        }\n      }\n    }\n    if (step === 3) {\n      if (input.isCont() && input.head() === 40/*'('*/) {\n        input = input.step();\n        step = 4;\n      } else if (!input.isEmpty()) {\n        return Parser.done(recon.attr(keyParser!.bind()));\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          return Parser.done(recon.attr(keyParser!.bind()));\n        } else {\n          step = 5;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    if (step === 5) {\n      if (!valueParser) {\n        valueParser = recon.parseBlock(input);\n      }\n      while (valueParser.isCont() && !input.isEmpty()) {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 6;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 6) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          return Parser.done(recon.attr(keyParser!.bind(), valueParser!.bind()));\n        } else {\n          return Parser.error(Diagnostic.expected(\")\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\")\", input));\n      }\n    }\n    return new AttrParser<I, V>(recon, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class BlockItemParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _fieldParser: Parser<I> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, fieldParser?: Parser<I>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._fieldParser = fieldParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return BlockItemParser.parse(input, this._recon, this._builder, this._fieldParser,\n                                 this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 64/*'@'*/) {\n            fieldParser = recon.parseAttr(input);\n            step = 2;\n          } else if (c === 123/*'{'*/) {\n            builder = builder || recon.recordBuilder();\n            valueParser = recon.parseRecord(input, builder);\n            step = 5;\n          } else if (c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            valueParser = recon.parseMarkup(input, builder);\n            step = 5;\n          } else if (Recon.isIdentStartChar(c)) {\n            valueParser = recon.parseIdent(input);\n            step = 4;\n          } else if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n            valueParser = recon.parseString(input);\n            step = 4;\n          } else if (c === 45/*'-'*/ || c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n            valueParser = recon.parseNumber(input);\n            step = 4;\n          } else if (c === 37/*'%'*/) {\n            valueParser = recon.parseData(input);\n            step = 4;\n          } else if (c === 36/*'$'*/) {\n            valueParser = recon.parseSelector(input);\n            step = 4;\n          } else if (!builder) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.bind());\n          }\n        } else if (input.isDone()) {\n          if (!builder) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.bind());\n          }\n        }\n      }\n      if (step === 2) {\n        while (fieldParser!.isCont() && !input.isEmpty()) {\n          fieldParser = fieldParser!.feed(input);\n        }\n        if (fieldParser!.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(fieldParser!.bind());\n          fieldParser = void 0;\n          step = 3;\n        } else if (fieldParser!.isError()) {\n          return fieldParser!.asError();\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 1;\n          continue;\n        } else if (input.isDone()) {\n          return Parser.done(builder!.bind());\n        }\n      }\n      if (step === 4) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser!.bind()));\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 5) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (input.head() === 64/*'@'*/) {\n            step = 1;\n          } else {\n            return Parser.done(builder!.bind());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.bind());\n        }\n      }\n      break;\n    } while (true);\n    return new BlockItemParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class InlineItemParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _fieldParser: Parser<I> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, fieldParser?: Parser<I>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._fieldParser = fieldParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return InlineItemParser.parse(input, this._recon, this._builder, this._fieldParser,\n                                  this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>,  valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 64/*'@'*/) {\n          fieldParser = recon.parseAttr(input);\n          step = 2;\n        } else if (c === 123/*'{'*/) {\n          if (builder) {\n            valueParser = recon.parseRecord(input, builder);\n            step = 5;\n          } else {\n            valueParser = recon.parseRecord(input);\n            step = 4;\n          }\n        } else if (c === 91/*'['*/) {\n          if (builder) {\n            valueParser = recon.parseMarkup(input, builder);\n            step = 5;\n          } else {\n            valueParser = recon.parseMarkup(input);\n            step = 4;\n          }\n        } else if (!builder) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.bind());\n        }\n      } else if (input.isDone()) {\n        if (!builder) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.bind());\n        }\n      }\n    }\n    if (step === 2) {\n      while (fieldParser!.isCont() && !input.isEmpty()) {\n        fieldParser = fieldParser!.feed(input);\n      }\n      if (fieldParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(fieldParser!.bind());\n        fieldParser = void 0;\n        step = 3;\n      } else if (fieldParser!.isError()) {\n        return fieldParser!.asError();\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 123/*'{'*/) {\n          valueParser = recon.parseRecord(input, builder);\n          step = 5;\n        } else if (c === 91/*'['*/) {\n          valueParser = recon.parseMarkup(input, builder);\n          step = 5;\n        } else {\n          return Parser.done(builder!.bind());\n        }\n      } else if (input.isDone()) {\n        return Parser.done(builder!.bind());\n      }\n    }\n    if (step === 4) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(recon.item(valueParser!.bind()));\n        return Parser.done(builder.bind());\n      } else if (valueParser!.isError()) {\n        return valueParser!;\n      }\n    }\n    if (step === 5) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        return Parser.done(builder!.bind());\n      } else if (valueParser!.isError()) {\n        return valueParser!;\n      }\n    }\n    return new InlineItemParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class RecordParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _keyParser: Parser<V> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, keyParser?: Parser<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._keyParser = keyParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return RecordParser.parse(input, this._recon, this._builder, this._keyParser,\n                              this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     keyParser?: Parser<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 123/*'{'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(123/*'{'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(123/*'{'*/, input));\n      }\n    }\n    block: do {\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          builder = builder || recon.recordBuilder();\n          if (c === 125/*'}'*/) {\n            input = input.step();\n            return Parser.done(builder.bind());\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else {\n            step = 3;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 3) {\n        if (!keyParser) {\n          keyParser = recon.parseBlockExpression(input);\n        }\n        while (keyParser.isCont() && !input.isEmpty()) {\n          keyParser = keyParser.feed(input);\n        }\n        if (keyParser.isDone()) {\n          step = 4;\n        } else if (keyParser.isError()) {\n          return keyParser;\n        }\n      }\n      if (step === 4) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 58/*':'*/) {\n            input = input.step();\n            step = 5;\n          } else {\n            builder!.push(recon.item(keyParser!.bind()));\n            keyParser = void 0;\n            step = 7;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 5) {\n        while (input.isCont() && Recon.isSpace(input.head())) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          step = 6;\n        } else if (input.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind()));\n          return Parser.done(builder!.bind());\n        }\n      }\n      if (step === 6) {\n        if (!valueParser) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder!.push(recon.slot(keyParser!.bind(), valueParser.bind()));\n          keyParser = void 0;\n          valueParser = void 0;\n          step = 7;\n        } else if (valueParser.isError()) {\n          return valueParser;\n        }\n      }\n      if (step === 7) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/ || c === 59/*';'*/ || Recon.isNewline(c)) {\n            input = input.step();\n            step = 2;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 8;\n          } else if (c === 125/*'}'*/) {\n            input = input.step();\n            return Parser.done(builder!.bind());\n          } else {\n            return Parser.error(Diagnostic.expected(\"'}', ';', ',', or newline\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(125/*'}'*/, input));\n        }\n      }\n      if (step === 8) {\n        while (input.isCont()) {\n          c = input.head();\n          if (!Recon.isNewline(c)) {\n            input = input.step();\n          } else {\n            step = 2;\n            continue block;\n          }\n        }\n        if (input.isDone()) {\n          step = 2;\n          continue;\n        }\n      }\n      break;\n    } while (true);\n    return new RecordParser<I, V>(recon, builder, keyParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Output, Parser, Diagnostic} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class MarkupParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _textOutput: Output<V> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, textOutput?: Output<V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._textOutput = textOutput;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return MarkupParser.parse(input, this._recon, this._builder, this._textOutput,\n                              this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     textOutput?: Output<V>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 91/*'['*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(91/*'['*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(91/*'['*/, input));\n      }\n    }\n    do {\n      if (step === 2) {\n        while (input.isCont()) {\n          c = input.head();\n          if (c !== 64/*'@'*/ && c !== 91/*'['*/ && c !== 92/*'\\\\'*/ && c !== 93/*']'*/\n              && c !== 123/*'{'*/ && c !== 125/*'}'*/) {\n            input = input.step();\n            textOutput = textOutput || recon.textOutput();\n            textOutput.write(c);\n          } else {\n            break;\n          }\n        }\n        if (input.isCont()) {\n          if (c === 93/*']'*/) {\n            input = input.step();\n            builder = builder || recon.recordBuilder();\n            if (textOutput) {\n              builder.push(recon.item(textOutput.bind()));\n            }\n            return Parser.done(builder.bind());\n          } else if (c === 64/*'@'*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseInlineItem(input);\n            step = 3;\n          } else if (c === 123/*'{'*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseRecord(input, builder);\n            step = 4;\n          } else if (c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            if (textOutput) {\n              builder.push(recon.item(textOutput.bind()));\n              textOutput = void 0;\n            }\n            valueParser = recon.parseMarkup(input, builder);\n            step = 4;\n          } else if (c === 92/*'\\\\'*/) {\n            input = input.step();\n            step = 5;\n          } else {\n            return Parser.error(Diagnostic.unexpected(input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 3) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          builder!.push(recon.item(valueParser!.bind()));\n          valueParser = void 0;\n          step = 2;\n          continue;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 4) {\n        while (valueParser!.isCont() && !input.isEmpty()) {\n          valueParser = valueParser!.feed(input);\n        }\n        if (valueParser!.isDone()) {\n          valueParser = void 0;\n          step = 2;\n          continue;\n        } else if (valueParser!.isError()) {\n          return valueParser!;\n        }\n      }\n      if (step === 5) {\n        if (input.isCont()) {\n          c = input.head();\n          textOutput = textOutput || recon.textOutput();\n          if (c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 39/*'\\''*/ || c === 47/*'/'*/\n              || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/ || c === 93/*']'*/\n              || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            input = input.step();\n            textOutput.write(c);\n            step = 2;\n          } else if (c === 98/*'b'*/) {\n            input = input.step();\n            textOutput.write(8/*'\\b'*/);\n            step = 2;\n          } else if (c === 102/*'f'*/) {\n            input = input.step();\n            textOutput.write(12/*'\\f'*/);\n            step = 2;\n          } else if (c === 110/*'n'*/) {\n            input = input.step();\n            textOutput.write(10/*'\\n'*/);\n            step = 2;\n          } else if (c === 114/*'r'*/) {\n            input = input.step();\n            textOutput.write(13/*'\\r'*/);\n            step = 2;\n          } else if (c === 116/*'t'*/) {\n            input = input.step();\n            textOutput.write(9/*'\\t'*/);\n            step = 2;\n          } else {\n            return Parser.error(Diagnostic.expected(\"escape character\", input));\n          }\n          continue;\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"escape character\", input));\n        }\n      }\n      break;\n    } while (true);\n    return new MarkupParser<I, V>(recon, builder, textOutput, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Parser, Diagnostic, Base64} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class DataParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _base64Parser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, base64Parser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._base64Parser = base64Parser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return DataParser.parse(input, this._recon, this._base64Parser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>,\n                     base64Parser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 37/*'%'*/) {\n          input = input.step();\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(37/*'%'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(37/*'%'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (!base64Parser) {\n        base64Parser = Base64.standard().parse(input, recon.dataOutput());\n      }\n      while (base64Parser.isCont() && !input.isEmpty()) {\n        base64Parser = base64Parser.feed(input);\n      }\n      if (base64Parser.isDone()) {\n        return base64Parser;\n      } else if (base64Parser.isError()) {\n        return base64Parser;\n      }\n    }\n    return new DataParser<I, V>(recon, base64Parser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class IdentParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _output: Output<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output?: Output<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._output = output;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return IdentParser.parse(input, this._recon, this._output, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output?: Output<V>,\n                     step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (Recon.isIdentStartChar(c)) {\n          input = input.step();\n          output = output || recon.textOutput();\n          output = output.write(c);\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"identifier\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"identifier\", input));\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isIdentChar(c))) {\n        input = input.step();\n        output!.write(c);\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(recon.ident(output!.bind()));\n      }\n    }\n    return new IdentParser<I, V>(recon, output, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Base16} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class StringParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _output: Output<V> | undefined;\n  private readonly _quote: number | undefined;\n  private readonly _code: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output?: Output<V>, quote?: number,\n              code?: number, step?: number) {\n    super();\n    this._recon = recon;\n    this._output = output;\n    this._quote = quote;\n    this._code = code;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return StringParser.parse(input, this._recon, this._output, this._quote,\n                              this._code, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output?: Output<V>,\n                     quote: number = 0, code: number = 0, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 34/*'\"'*/ || c === 39/*'\\''*/ && (quote === c || quote === 0)) {\n          input = input.step();\n          output = output || recon.textOutput();\n          quote = c;\n          step = 2;\n        } else {\n          return Parser.error(Diagnostic.expected(\"string\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"string\", input));\n      }\n    }\n    string: do {\n      if (step === 2) {\n        while (input.isCont()) {\n          c = input.head();\n          if (c >= 0x20 && c !== quote && c !== 92/*'\\\\'*/) {\n            input = input.step();\n            output!.write(c);\n          } else {\n            break;\n          }\n        }\n        if (input.isCont()) {\n          if (c === quote) {\n            input = input.step();\n            return Parser.done(output!.bind());\n          } else if (c === 92/*'\\\\'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return Parser.error(Diagnostic.expected(quote, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(quote, input));\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 39/*'\\''*/ || c === 47/*'/'*/\n              || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/ || c === 93/*']'*/\n              || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            input = input.step();\n            output!.write(c);\n            step = 2;\n            continue;\n          } else if (c === 98/*'b'*/) {\n            input = input.step();\n            output!.write(8/*'\\b'*/);\n            step = 2;\n            continue;\n          } else if (c === 102/*'f'*/) {\n            input = input.step();\n            output!.write(12/*'\\f'*/);\n            step = 2;\n            continue;\n          } else if (c === 110/*'n'*/) {\n            input = input.step();\n            output!.write(10/*'\\n'*/);\n            step = 2;\n            continue;\n          } else if (c === 114/*'r'*/) {\n            input = input.step();\n            output!.write(13/*'\\r'*/);\n            step = 2;\n            continue;\n          } else if (c === 116/*'t'*/) {\n            input = input.step();\n            output!.write(9/*'\\t'*/);\n            step = 2;\n            continue;\n          } else if (c === 117/*'u'*/) {\n            input = input.step();\n            step = 4;\n          } else {\n            return Parser.error(Diagnostic.expected(\"escape character\", input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(\"escape character\", input));\n        }\n      }\n      if (step >= 4) {\n        do {\n          if (input.isCont()) {\n            c = input.head();\n            if (Base16.isDigit(c)) {\n              input = input.step();\n              code = 16 * code + Base16.decodeDigit(c);\n              if (step <= 6) {\n                step += 1;\n                continue;\n              } else {\n                output!.write(code);\n                code = 0;\n                step = 2;\n                continue string;\n              }\n            } else {\n              return Parser.error(Diagnostic.expected(\"hex digit\", input));\n            }\n          } else if (input.isDone()) {\n            return Parser.error(Diagnostic.expected(\"hex digit\", input));\n          }\n          break;\n        } while (true);\n      }\n      break;\n    } while (true);\n    return new StringParser<I, V>(recon, output, quote, code, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Input, Output, Parser, Diagnostic, Unicode, Base16} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class NumberParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _sign: number | undefined;\n  private readonly _value: number | undefined;\n  private readonly _mode: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, sign?: number, value?: number, mode?: number, step?: number) {\n    super();\n    this._recon = recon;\n    this._sign = sign;\n    this._value = value;\n    this._mode = mode;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return NumberParser.parse(input, this._recon, this._sign, this._value, this._mode, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, sign: number = 1, value: number = 0,\n                     mode: number = 2, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 45/*'-'*/) {\n          input = input.step();\n          sign = -1;\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"number\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 48/*'0'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c >= 49/*'1'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          value = sign * (c - 48/*'0'*/);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          const newValue = 10 * value + sign * (c - 48/*'0'*/);\n          if (-9007199254740991 <= newValue && newValue <= 9007199254740992) {\n            value = newValue;\n            input = input.step();\n          } else {\n            return Parser.error(Diagnostic.message(\"integer overflow\", input));\n          }\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        step = 4;\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(value));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (mode > 0 && c === 46/*'.'*/ || mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          let output = Unicode.stringOutput();\n          if (sign < 0 && value === 0) {\n            output = output.write(45/*'-'*/).write(48/*'0'*/);\n          } else {\n            output = output.write(\"\" + value);\n          }\n          return DecimalParser.parse(input, recon, output, mode);\n        } else if (c === 120/*'x'*/ && sign > 0 && value === 0) {\n          input = input.step();\n          return HexadecimalParser.parse(input, recon);\n        } else {\n          return Parser.done(recon.num(value));\n        }\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(value));\n      }\n    }\n    return new NumberParser<I, V>(recon, sign, value, mode, step);\n  }\n\n  static parseInteger<I, V>(input: Input, recon: ReconParser<I, V>): Parser<V> {\n    return NumberParser.parse(input, recon, void 0, void 0, 0);\n  }\n\n  static parseDecimal<I, V>(input: Input, recon: ReconParser<I, V>): Parser<V> {\n    return NumberParser.parse(input, recon, void 0, void 0, 1);\n  }\n}\n\n/** @hidden */\nclass DecimalParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _output: Output<string>;\n  private readonly _mode: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, output: Output<string>, mode?: number, step?: number) {\n    super();\n    this._recon = recon;\n    this._output = output;\n    this._mode = mode;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return DecimalParser.parse(input, this._recon, this._output, this._mode, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, output: Output<string>,\n                     mode: number = 2, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 46/*'.'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 2;\n        } else if (mode > 1 && (c === 69/*'E'*/ || c === 101/*'e'*/)) {\n          input = input.step();\n          output = output.write(c);\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"decimal or exponent\", input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 3;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 3) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (input.isCont()) {\n        if (mode > 1) {\n          step = 4;\n        } else {\n          return Parser.done(recon.num(output.bind()));\n        }\n      } else if (input.isDone()) {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    if (step === 4) {\n      c = input.head();\n      if (c === 69/*'E'*/ || c === 101/*'e'*/) {\n        input = input.step();\n        output = output.write(c);\n        step = 5;\n      } else {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 43/*'+'*/ || c === 45/*'-'*/) {\n          input = input.step();\n          output = output.write(c);\n        }\n        step = 6;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n          step = 7;\n        } else {\n          return Parser.error(Diagnostic.expected(\"digit\", input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(\"digit\", input));\n      }\n    }\n    if (step === 7) {\n      while (input.isCont()) {\n        c = input.head();\n        if (c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          input = input.step();\n          output = output.write(c);\n        } else {\n          break;\n        }\n      }\n      if (!input.isEmpty()) {\n        return Parser.done(recon.num(output.bind()));\n      }\n    }\n    return new DecimalParser<I, V>(recon, output, mode, step);\n  }\n}\n\n/** @hidden */\nclass HexadecimalParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _value: number | undefined;\n  private readonly _size: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, value?: number, size?: number) {\n    super();\n    this._recon = recon;\n    this._value = value;\n    this._size = size;\n  }\n\n  feed(input: Input): Parser<V> {\n    return HexadecimalParser.parse(input, this._recon, this._value, this._size);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>,\n                     value: number = 0, size: number = 0): Parser<V> {\n    let c = 0;\n    while (input.isCont()) {\n      c = input.head();\n      if (Base16.isDigit(c)) {\n        input = input.step();\n        value = 16 * value + Base16.decodeDigit(c);\n        size += 1;\n      } else {\n        break;\n      }\n    }\n    if (!input.isEmpty()) {\n      if (size > 0) {\n        if (size <= 8) {\n          return Parser.done(recon.uint32(value));\n        } else {\n          return Parser.done(recon.uint64(value));\n        }\n      } else {\n        return Parser.error(Diagnostic.expected(\"hex digit\", input));\n      }\n    }\n    return new HexadecimalParser<I, V>(recon, value, size);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class LambdaFuncParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _bindingsParser: Parser<V> | undefined;\n  private readonly _templateParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, bindingsParser?: Parser<V>,\n              templateParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._bindingsParser = bindingsParser;\n    this._templateParser = templateParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return LambdaFuncParser.parse(input, this._recon, this._builder, this._bindingsParser,\n                                  this._templateParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     bindingsParser?: Parser<V>, templateParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (!bindingsParser) {\n        bindingsParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (bindingsParser.isCont() && !input.isEmpty()) {\n        bindingsParser = bindingsParser.feed(input);\n      }\n      if (bindingsParser.isDone()) {\n        step = 2;\n      } else if (bindingsParser.isError()) {\n        return bindingsParser.asError();\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 62/*'>'*/) {\n          // leading '=' consumed by ComparisonOperatorParser\n          input = input.step();\n          step = 3;\n        } else {\n          return bindingsParser!;\n        }\n      } else if (input.isDone()) {\n        return bindingsParser!;\n      }\n    }\n    if (step === 3) {\n      if (!templateParser) {\n        templateParser = recon.parseConditionalOperator(input);\n      }\n      while (templateParser.isCont() && !input.isEmpty()) {\n        templateParser = templateParser.feed(input);\n      }\n      if (templateParser.isDone()) {\n        const bindings = bindingsParser!.bind();\n        const template = templateParser.bind();\n        return Parser.done(recon.lambda(bindings, template));\n      } else if (templateParser.isError()) {\n        return templateParser.asError();\n      }\n    }\n    return new LambdaFuncParser<I, V>(recon, builder, bindingsParser, templateParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class ConditionalOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _ifParser: Parser<V> | undefined;\n  private readonly _thenParser: Parser<V> | undefined;\n  private readonly _elseParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, ifParser?: Parser<V>,\n              thenParser?: Parser<V>, elseParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._ifParser = ifParser;\n    this._thenParser = thenParser;\n    this._elseParser = elseParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return ConditionalOperatorParser.parse(input, this._recon, this._builder, this._ifParser,\n                                           this._thenParser, this._elseParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     ifParser?: Parser<V>, thenParser?: Parser<V>,\n                     elseParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (!ifParser) {\n        ifParser = recon.parseOrOperator(input, builder);\n      }\n      while (ifParser.isCont() && !input.isEmpty()) {\n        ifParser = ifParser.feed(input);\n      }\n      if (ifParser.isDone()) {\n        step = 2;\n      } else if (ifParser.isError()) {\n        return ifParser.asError();\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 63/*'?'*/) {\n          input = input.step();\n          step = 3;\n        } else {\n          return ifParser!;\n        }\n      } else if (input.isDone()) {\n        return ifParser!;\n      }\n    }\n    if (step === 3) {\n      if (!thenParser) {\n        thenParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (thenParser.isCont() && !input.isEmpty()) {\n        thenParser = thenParser.feed(input);\n      }\n      if (thenParser.isDone()) {\n        step = 4;\n      } else if (thenParser.isError()) {\n        return thenParser.asError();\n      }\n    }\n    if (step === 4) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 58/*':'*/) {\n          input = input.step();\n          step = 5;\n        } else {\n          return Parser.error(Diagnostic.expected(58/*':'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(58/*':'*/, input));\n      }\n    }\n    if (step === 5) {\n      if (!elseParser) {\n        elseParser = recon.parseConditionalOperator(input, builder);\n      }\n      while (elseParser.isCont() && !input.isEmpty()) {\n        elseParser = elseParser.feed(input);\n      }\n      if (elseParser.isDone()) {\n        const ifTerm = ifParser!.bind();\n        const thenTerm = thenParser!.bind();\n        const elseTerm = elseParser.bind();\n        return Parser.done(recon.conditional(ifTerm, thenTerm, elseTerm));\n      } else if (elseParser.isError()) {\n        return elseParser.asError();\n      }\n    }\n    return new ConditionalOperatorParser<I, V>(recon, builder, ifParser, thenParser, elseParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class OrOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return OrOperatorParser.parse(input, this._recon, this._builder, this._lhsParser,\n                                  this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseAndOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 124/*'|'*/) {\n            // first '|' consumed by BitwiseOrOperatorParser\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (!rhsParser) {\n          rhsParser = recon.parseAndOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.or(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new OrOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class AndOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return AndOperatorParser.parse(input, this._recon, this._builder, this._lhsParser,\n                                   this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseBitwiseOrOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 38/*'&'*/) {\n            // first '&' consumed by BitwiseAndOperatorParser\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (!rhsParser) {\n          rhsParser = recon.parseBitwiseOrOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.and(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new AndOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class BitwiseOrOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return BitwiseOrOperatorParser.parse(input, this._recon, this._builder,\n                                         this._lhsParser, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseBitwiseXorOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 124/*'|'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 124/*'|'*/) {\n            return lhsParser!;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 4) {\n        if (!rhsParser) {\n          rhsParser = recon.parseBitwiseXorOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseOr(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseOrOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class BitwiseXorOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return BitwiseXorOperatorParser.parse(input, this._recon, this._builder,\n                                          this._lhsParser, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseBitwiseAndOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 94/*'^'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (!rhsParser) {\n          rhsParser = recon.parseBitwiseAndOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseXor(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseXorOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class BitwiseAndOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              lhsParser?: Parser<V>, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return BitwiseAndOperatorParser.parse(input, this._recon, this._builder,\n                                          this._lhsParser, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     lhsParser?: Parser<V>, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseComparisonOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 38/*'&'*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 38/*'&'*/) {\n            return lhsParser!;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      if (step === 4) {\n        if (!rhsParser) {\n          rhsParser = recon.parseComparisonOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          lhsParser = Parser.done(recon.bitwiseAnd(lhs, rhs));\n          rhsParser = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new BitwiseAndOperatorParser<I, V>(recon, builder, lhsParser, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class ComparisonOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _operator: string | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._operator = operator;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return ComparisonOperatorParser.parse(input, this._recon, this._builder, this._lhsParser,\n                                          this._operator, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (!lhsParser) {\n        lhsParser = recon.parseAttrExpression(input, builder);\n      }\n      while (lhsParser.isCont() && !input.isEmpty()) {\n        lhsParser = lhsParser.feed(input);\n      }\n      if (lhsParser.isDone()) {\n        step = 2;\n      } else if (lhsParser.isError()) {\n        return lhsParser.asError();\n      }\n    }\n    if (step === 2) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 33/*'!'*/) {\n          input = input.step();\n          step = 3;\n        } else if (c === 60/*'<'*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 62/*'>'*/) {\n          input = input.step();\n          step = 5;\n        } else if (c === 61/*'='*/) {\n          input = input.step();\n          step = 6;\n        } else {\n          return lhsParser!;\n        }\n      } else if (input.isDone()) {\n        return lhsParser!;\n      }\n    }\n    if (step === 3) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"!=\";\n          step = 7;\n        } else {\n          operator = \"!\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 4) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"<=\";\n          step = 7;\n        } else {\n          operator = \"<\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 5) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \">=\";\n          step = 7;\n        } else {\n          operator = \">\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 6) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 61/*'='*/) {\n          input = input.step();\n          operator = \"==\";\n          step = 7;\n        } else if (c === 62/*'>'*/) {\n          return lhsParser!;\n        } else {\n          operator = \"=\";\n          step = 7;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    if (step === 7) {\n      if (!rhsParser) {\n        rhsParser = recon.parseAttrExpression(input, builder);\n      }\n      while (rhsParser.isCont() && !input.isEmpty()) {\n        rhsParser = rhsParser.feed(input);\n      }\n      if (rhsParser.isDone()) {\n        const lhs = lhsParser!.bind();\n        const rhs = rhsParser.bind();\n        if (operator === \"<\") {\n          return Parser.done(recon.lt(lhs, rhs));\n        } else if (operator === \"<=\") {\n          return Parser.done(recon.le(lhs, rhs));\n        } else if (operator === \"==\") {\n          return Parser.done(recon.eq(lhs, rhs));\n        } else if (operator === \"!=\") {\n          return Parser.done(recon.ne(lhs, rhs));\n        } else if (operator === \">=\") {\n          return Parser.done(recon.ge(lhs, rhs));\n        } else if (operator === \">\") {\n          return Parser.done(recon.gt(lhs, rhs));\n        } else {\n          return Parser.error(Diagnostic.message(operator!, input));\n        }\n      } else if (rhsParser.isError()) {\n        return rhsParser.asError();\n      }\n    }\n    return new ComparisonOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class AttrExpressionParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _fieldParser: Parser<I> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              fieldParser?: Parser<I>, valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._fieldParser = fieldParser;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return AttrExpressionParser.parse(input, this._recon, this._builder,\n                                      this._fieldParser, this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     fieldParser?: Parser<I>, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 64/*'@'*/) {\n            step = 2;\n          } else if (c === 123/*'{'*/ || c === 91/*'['*/) {\n            builder = builder || recon.recordBuilder();\n            step = 5;\n          } else if (c === 40/*'('*/) {\n            step = 4;\n          } else if (c === 33/*'!'*/ || c === 34/*'\"'*/ || c === 36/*'$'*/ || c === 37/*'%'*/\n                  || c === 39/*'\\''*/ || c === 43/*'+'*/ || c === 45/*'-'*/\n                  || c >= 48/*'0'*/ && c <= 57/*'9'*/ || c === 126/*'~'*/\n                  || Recon.isIdentStartChar(c)) {\n            step = 3;\n          } else if (!builder) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.bind());\n          }\n        } else if (input.isDone()) {\n          if (!builder) {\n            return Parser.done(recon.extant());\n          } else {\n            return Parser.done(builder.bind());\n          }\n        }\n      }\n      if (step === 2) {\n        if (!fieldParser) {\n          fieldParser = recon.parseAttr(input);\n        }\n        while (fieldParser.isCont() && !input.isEmpty()) {\n          fieldParser = fieldParser.feed(input);\n        }\n        if (fieldParser.isDone()) {\n          builder = builder || recon.recordBuilder();\n          builder.push(fieldParser.bind());\n          fieldParser = void 0;\n          step = 1;\n          continue;\n        } else if (fieldParser.isError()) {\n          return fieldParser.asError();\n        }\n      }\n      if (step === 3) {\n        if (!valueParser) {\n          valueParser = recon.parseAdditiveOperator(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser.bind()));\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 4) {\n        if (!valueParser) {\n          valueParser = recon.parseAdditiveOperator(input, builder);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          if (!builder) {\n            builder = recon.valueBuilder();\n            builder.push(recon.item(valueParser.bind()));\n          }\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 5) {\n        if (!valueParser) {\n          valueParser = recon.parseAdditiveOperator(input, builder);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          valueParser = void 0;\n          step = 6;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 6) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 64/*'@'*/) {\n            step = 1;\n            continue;\n          } else {\n            return Parser.done(builder!.bind());\n          }\n        } else if (input.isDone()) {\n          return Parser.done(builder!.bind());\n        }\n      }\n      break;\n    } while (true);\n    return new AttrExpressionParser<I, V>(recon, builder, fieldParser, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class AdditiveOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _operator: string | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._operator = operator;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return AdditiveOperatorParser.parse(input, this._recon, this._builder, this._lhsParser,\n                                        this._operator, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parseMultiplicativeOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 43/*'+'*/) {\n            input = input.step();\n            operator = \"+\";\n            step = 3;\n          } else if (c === 45/*'-'*/) {\n            input = input.step();\n            operator = \"-\";\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (!rhsParser) {\n          rhsParser = recon.parseMultiplicativeOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          if (operator === \"+\") {\n            lhsParser = Parser.done(recon.plus(lhs, rhs));\n          } else if (operator === \"-\") {\n            lhsParser = Parser.done(recon.minus(lhs, rhs));\n          } else {\n            return Parser.error(Diagnostic.message(operator!, input));\n          }\n          rhsParser = void 0;\n          operator = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new AdditiveOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class MultiplicativeOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _lhsParser: Parser<V> | undefined;\n  private readonly _operator: string | undefined;\n  private readonly _rhsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._lhsParser = lhsParser;\n    this._operator = operator;\n    this._rhsParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return MultiplicativeOperatorParser.parse(input, this._recon, this._builder, this._lhsParser,\n                                              this._operator, this._rhsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>, lhsParser?: Parser<V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    do {\n      if (step === 1) {\n        if (!lhsParser) {\n          lhsParser = recon.parsePrefixOperator(input, builder);\n        }\n        while (lhsParser.isCont() && !input.isEmpty()) {\n          lhsParser = lhsParser.feed(input);\n        }\n        if (lhsParser.isDone()) {\n          step = 2;\n        } else if (lhsParser.isError()) {\n          return lhsParser.asError();\n        }\n      }\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 42/*'*'*/) {\n            input = input.step();\n            operator = \"*\";\n            step = 3;\n          } else if (c === 47/*'/'*/) {\n            input = input.step();\n            operator = \"/\";\n            step = 3;\n          } else if (c === 37/*'%'*/) {\n            input = input.step();\n            operator = \"%\";\n            step = 3;\n          } else {\n            return lhsParser!;\n          }\n        } else if (input.isDone()) {\n          return lhsParser!;\n        }\n      }\n      if (step === 3) {\n        if (!rhsParser) {\n          rhsParser = recon.parsePrefixOperator(input, builder);\n        }\n        while (rhsParser.isCont() && !input.isEmpty()) {\n          rhsParser = rhsParser.feed(input);\n        }\n        if (rhsParser.isDone()) {\n          const lhs = lhsParser!.bind();\n          const rhs = rhsParser.bind();\n          if (operator === \"*\") {\n            lhsParser = Parser.done(recon.times(lhs, rhs));\n          } else if (operator === \"/\") {\n            lhsParser = Parser.done(recon.divide(lhs, rhs));\n          } else if (operator === \"%\") {\n            lhsParser = Parser.done(recon.modulo(lhs, rhs));\n          } else {\n            return Parser.error(Diagnostic.message(operator!, input));\n          }\n          rhsParser = void 0;\n          operator = void 0;\n          step = 2;\n          continue;\n        } else if (rhsParser.isError()) {\n          return rhsParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new MultiplicativeOperatorParser<I, V>(recon, builder, lhsParser, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class PrefixOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _operator: string | undefined;\n  private readonly _operandParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              operator?: string, rhsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._operator = operator;\n    this._operandParser = rhsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return PrefixOperatorParser.parse(input, this._recon, this._builder,\n                                      this._operator, this._operandParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     operator?: string, rhsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 33/*'!'*/) {\n          input = input.step();\n          operator = \"!\";\n        } else if (c === 126/*'~'*/) {\n          input = input.step();\n          operator = \"~\";\n        } else if (c === 45/*'-'*/) {\n          input = input.step();\n          operator = \"-\";\n        } else if (c === 43/*'+'*/) {\n          input = input.step();\n          operator = \"+\";\n        } else {\n          return recon.parseInvokeOperator(input, builder);\n        }\n        step = 2;\n      } else if (input.isDone()) {\n        return recon.parseInvokeOperator(input, builder);\n      }\n    }\n    if (step === 2) {\n      if (!rhsParser) {\n        rhsParser = recon.parsePrefixOperator(input, builder);\n      }\n      while (rhsParser.isCont() && !input.isEmpty()) {\n        rhsParser = rhsParser.feed(input);\n      }\n      if (rhsParser.isDone()) {\n        const operand = rhsParser.bind();\n        if (!recon.isDistinct(operand)) {\n          return Parser.error(Diagnostic.expected(\"value\", input));\n        } else if (operator === \"!\") {\n          return Parser.done(recon.not(operand));\n        } else if (operator === \"~\") {\n          return Parser.done(recon.bitwiseNot(operand));\n        } else if (operator === \"-\") {\n          return Parser.done(recon.negative(operand));\n        } else if (operator === \"+\") {\n          return Parser.done(recon.positive(operand));\n        } else {\n          return Parser.error(Diagnostic.message(operator!, input));\n        }\n      } else if (rhsParser.isError()) {\n        return rhsParser.asError();\n      }\n    }\n    return new PrefixOperatorParser<I, V>(recon, builder, operator, rhsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class InvokeOperatorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _exprParser: Parser<V> | undefined;\n  private readonly _argsParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              exprParser?: Parser<V>, argsParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._exprParser = exprParser;\n    this._argsParser = argsParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return InvokeOperatorParser.parse(input, this._recon, this._builder,\n                                      this._exprParser, this._argsParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     exprParser?: Parser<V>, argsParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      if (!exprParser) {\n        exprParser = recon.parsePrimary(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        step = 2;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    do {\n      if (step === 2) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 40/*'('*/) {\n            input = input.step();\n            step = 3;\n          } else {\n            return exprParser!;\n          }\n        } else if (input.isDone()) {\n          return exprParser!;\n        }\n      }\n      if (step === 3) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 41/*')'*/) {\n            input = input.step();\n            const expr = exprParser!.bind();\n            exprParser = Parser.done(recon.invoke(expr, recon.extant()));\n            step = 2;\n            continue;\n          } else {\n            step = 4;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      if (step === 4) {\n        if (!argsParser) {\n          argsParser = recon.parseBlock(input);\n        }\n        while (argsParser.isCont() && !input.isEmpty()) {\n          argsParser = argsParser.feed(input);\n        }\n        if (argsParser.isDone()) {\n          step = 5;\n        } else if (argsParser.isError()) {\n          return argsParser.asError();\n        }\n      }\n      if (step === 5) {\n        while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n        if (c === 41/*')'*/) {\n            input = input.step();\n            const expr = exprParser!.bind();\n            const args = argsParser!.bind();\n            exprParser = Parser.done(recon.invoke(expr, args));\n            argsParser = void 0;\n            step = 2;\n            continue;\n          } else {\n            return Parser.error(Diagnostic.expected(41/*')'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      break;\n    } while (true);\n    return new InvokeOperatorParser<I, V>(recon, builder, exprParser, argsParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class PrimaryParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _exprParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              exprParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._exprParser = exprParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return PrimaryParser.parse(input, this._recon, this._builder,\n                               this._exprParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     exprParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 40/*'('*/) {\n          input = input.step();\n          step = 3;\n        } else {\n          step = 2;\n        }\n      } else if (input.isDone()) {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (!exprParser) {\n        exprParser = recon.parseLiteral(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        return exprParser;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    if (step === 3) {\n      if (!exprParser) {\n        exprParser = recon.parseBlockExpression(input, builder);\n      }\n      while (exprParser.isCont() && !input.isEmpty()) {\n        exprParser = exprParser.feed(input);\n      }\n      if (exprParser.isDone()) {\n        step = 4;\n      } else if (exprParser.isError()) {\n        return exprParser.asError();\n      }\n    }\n    do {\n      if (step === 4) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 44/*','*/) {\n            input = input.step();\n            if (exprParser) {\n              if (!builder) {\n                builder = recon.recordBuilder();\n                builder.push(recon.item(exprParser.bind()));\n              }\n              exprParser = void 0;\n            }\n            step = 5;\n          } else if (c === 41/*')'*/) {\n            input = input.step();\n            if (exprParser) {\n              return exprParser;\n            } else {\n              return Parser.done(builder!.bind());\n            }\n          } else {\n            return Parser.error(Diagnostic.expected(41/*')'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      }\n      if (step === 5) {\n        if (!exprParser) {\n          exprParser = recon.parseBlockExpression(input, builder);\n        }\n        while (exprParser.isCont() && !input.isEmpty()) {\n          exprParser = exprParser.feed(input);\n        }\n        if (exprParser.isDone()) {\n          exprParser = void 0;\n          step = 4;\n          continue;\n        } else if (exprParser.isError()) {\n          return exprParser.asError();\n        }\n      }\n      break;\n    } while (true);\n    return new PrimaryParser<I, V>(recon, builder, exprParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class LiteralParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return LiteralParser.parse(input, this._recon, this._builder, this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 40/*'('*/) {\n          input = input.step();\n          step = 4;\n        } else if (c === 123/*'{'*/) {\n          builder = builder || recon.recordBuilder();\n          valueParser = recon.parseRecord(input, builder);\n          step = 3;\n        } else if (c === 91/*'['*/) {\n          builder = builder || recon.recordBuilder();\n          valueParser = recon.parseMarkup(input, builder);\n          step = 3;\n        } else if (Recon.isIdentStartChar(c)) {\n          valueParser = recon.parseIdent(input);\n          step = 2;\n        } else if (c === 34/*'\"'*/ || c === 39/*'\\''*/) {\n          valueParser = recon.parseString(input);\n          step = 2;\n        } else if (c === 45/*'-'*/ || c >= 48/*'0'*/ && c <= 57/*'9'*/) {\n          valueParser = recon.parseNumber(input);\n          step = 2;\n        } else if (c === 37/*'%'*/) {\n          valueParser = recon.parseData(input);\n          step = 2;\n        } else if (c === 36/*'$'*/) {\n          valueParser = recon.parseSelector(input);\n          step = 2;\n        } else if (!builder) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.bind());\n        }\n      } else if (input.isDone()) {\n        if (!builder) {\n          return Parser.done(recon.extant());\n        } else {\n          return Parser.done(builder.bind());\n        }\n      }\n    }\n    if (step === 2) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        builder = builder || recon.valueBuilder();\n        builder.push(recon.item(valueParser!.bind()));\n        return Parser.done(builder.bind());\n      } else if (valueParser!.isError()) {\n        return valueParser!.asError();\n      }\n    }\n    if (step === 3) {\n      while (valueParser!.isCont() && !input.isEmpty()) {\n        valueParser = valueParser!.feed(input);\n      }\n      if (valueParser!.isDone()) {\n        return Parser.done(builder!.bind());\n      } else if (valueParser!.isError()) {\n        return valueParser!.asError();\n      }\n    }\n    if (step === 4) {\n      if (!valueParser) {\n        valueParser = recon.parseBlockExpression(input);\n      }\n      while (valueParser.isCont() && !input.isEmpty()) {\n        valueParser = valueParser.feed(input);\n      }\n      if (valueParser.isDone()) {\n        step = 5;\n      } else if (valueParser.isError()) {\n        return valueParser.asError();\n      }\n    }\n    if (step === 5) {\n      while (input.isCont() && (c = input.head(), Recon.isWhitespace(c))) {\n        input = input.step();\n      }\n      if (input.isCont()) {\n        if (c === 41/*')'*/) {\n          input = input.step();\n          builder = builder || recon.valueBuilder();\n          builder.push(recon.item(valueParser!.bind()));\n          return Parser.done(builder.bind());\n        } else {\n          return Parser.error(Diagnostic.expected(41/*')'*/, input));\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(41/*')'*/, input));\n      }\n    }\n    return new LiteralParser<I, V>(recon, builder, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Parser, Diagnostic} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {ReconParser} from \"./ReconParser\";\n\n/** @hidden */\nexport class SelectorParser<I, V> extends Parser<V> {\n  private readonly _recon: ReconParser<I, V>;\n  private readonly _builder: Builder<I, V> | undefined;\n  private readonly _selector: V | undefined;\n  private readonly _valueParser: Parser<V> | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconParser<I, V>, builder?: Builder<I, V>,\n              selector?: V, valueParser?: Parser<V>, step?: number) {\n    super();\n    this._recon = recon;\n    this._builder = builder;\n    this._selector = selector;\n    this._valueParser = valueParser;\n    this._step = step;\n  }\n\n  feed(input: Input): Parser<V> {\n    return SelectorParser.parse(input, this._recon, this._builder,\n                                this._selector, this._valueParser, this._step);\n  }\n\n  static parse<I, V>(input: Input, recon: ReconParser<I, V>, builder?: Builder<I, V>,\n                     selector?: V, valueParser?: Parser<V>, step: number = 1): Parser<V> {\n    let c = 0;\n    if (step === 1) {\n      while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n        input = input.step();\n      }\n      if (input.isCont() && c === 36/*'$'*/) {\n        input = input.step();\n        selector = selector || recon.selector();\n        step = 2;\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.expected(36/*'$'*/, input));\n      }\n    }\n    if (step === 2) {\n      if (input.isCont()) {\n        c = input.head();\n        if (c === 91/*'['*/) {\n          input = input.step();\n          step = 8;\n        } else if (c === 64/*'@'*/) {\n          input = input.step();\n          step = 7;\n        } else if (c === 58/*':'*/) {\n          input = input.step();\n          step = 6;\n        } else if (c === 42/*'*'*/) {\n          input = input.step();\n          step = 5;\n        } else if (c === 35/*'#'*/) {\n          input = input.step();\n          step = 4;\n        } else {\n          step = 3;\n        }\n      } else if (input.isDone()) {\n        return Parser.error(Diagnostic.unexpected(input));\n      }\n    }\n    do {\n      if (step === 3) {\n        if (!valueParser) {\n          valueParser = recon.parseLiteral(input, recon.valueBuilder());\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.get(selector!, valueParser.bind());\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 4) {\n        if (!valueParser) {\n          valueParser = recon.parseInteger(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.value(recon.getItem(selector!, valueParser.bind()));\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 5) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 58/*':'*/) {\n            input = input.step();\n            selector = recon.keys(selector!);\n            step = 10;\n          } else if (c === 42/*'*'*/) {\n            input = input.step();\n            selector = recon.descendants(selector!);\n            step = 10;\n          } else {\n            selector = recon.children(selector!);\n            step = 10;\n          }\n        } else if (input.isDone()) {\n          selector = recon.children(selector!);\n          step = 10;\n        }\n      }\n      if (step === 6) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 42/*'*'*/) {\n            input = input.step();\n            selector = recon.values(selector!);\n            step = 10;\n          } else {\n            return Parser.error(Diagnostic.expected(42/*'*'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(42/*'*'*/, input));\n        }\n      }\n      if (step === 7) {\n        if (!valueParser) {\n          valueParser = recon.parseIdent(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          selector = recon.getAttr(selector!, valueParser.bind());\n          valueParser = void 0;\n          step = 10;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 8) {\n        if (!valueParser) {\n          valueParser = recon.parseBlockExpression(input);\n        }\n        while (valueParser.isCont() && !input.isEmpty()) {\n          valueParser = valueParser.feed(input);\n        }\n        if (valueParser.isDone()) {\n          step = 9;\n        } else if (valueParser.isError()) {\n          return valueParser.asError();\n        }\n      }\n      if (step === 9) {\n        while (input.isCont() && (c = input.head(), Recon.isSpace(c))) {\n          input = input.step();\n        }\n        if (input.isCont()) {\n          if (c === 93/*']'*/) {\n            input = input.step();\n            selector = recon.filter(selector!, valueParser!.bind());\n            valueParser = void 0;\n            step = 10;\n          } else {\n            return Parser.error(Diagnostic.expected(93/*']'*/, input));\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.expected(93/*']'*/, input));\n        }\n      }\n      if (step === 10) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 91/*'['*/) {\n            input = input.step();\n            step = 8;\n            continue;\n          } else if (c === 35/*'#'*/) {\n            input = input.step();\n            step = 4;\n            continue;\n          } else if (c === 46/*'.'*/) {\n            input = input.step();\n            step = 11;\n          } else if (builder) {\n            builder.push(recon.item(selector!));\n            return Parser.done(builder.bind());\n          } else {\n            return Parser.done(selector!);\n          }\n        } else if (input.isDone()) {\n          if (builder) {\n            builder.push(recon.item(selector!));\n            return Parser.done(builder.bind());\n          } else {\n            return Parser.done(selector!);\n          }\n        }\n      }\n      if (step === 11) {\n        if (input.isCont()) {\n          c = input.head();\n          if (c === 64/*'@'*/) {\n            input = input.step();\n            step = 7;\n            continue;\n          } else if (c === 58/*':'*/) {\n            input = input.step();\n            step = 6;\n            continue;\n          } else if (c === 42/*'*'*/) {\n            input = input.step();\n            step = 5;\n            continue;\n          } else {\n            step = 3;\n            continue;\n          }\n        } else if (input.isDone()) {\n          return Parser.error(Diagnostic.unexpected(input));\n        }\n      }\n      break;\n    } while (true);\n    return new SelectorParser<I, V>(recon, builder, selector, valueParser, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Input, Output, Parser, Diagnostic, Unicode} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {BlockParser} from \"./BlockParser\";\nimport {AttrParser} from \"./AttrParser\";\nimport {BlockItemParser} from \"./BlockItemParser\";\nimport {InlineItemParser} from \"./InlineItemParser\";\nimport {RecordParser} from \"./RecordParser\";\nimport {MarkupParser} from \"./MarkupParser\";\nimport {DataParser} from \"./DataParser\";\nimport {IdentParser} from \"./IdentParser\";\nimport {StringParser} from \"./StringParser\";\nimport {NumberParser} from \"./NumberParser\";\nimport {LambdaFuncParser} from \"./LambdaFuncParser\";\nimport {ConditionalOperatorParser} from \"./ConditionalOperatorParser\";\nimport {OrOperatorParser} from \"./OrOperatorParser\";\nimport {AndOperatorParser} from \"./AndOperatorParser\";\nimport {BitwiseOrOperatorParser} from \"./BitwiseOrOperatorParser\";\nimport {BitwiseXorOperatorParser} from \"./BitwiseXorOperatorParser\";\nimport {BitwiseAndOperatorParser} from \"./BitwiseAndOperatorParser\";\nimport {ComparisonOperatorParser} from \"./ComparisonOperatorParser\";\nimport {AttrExpressionParser} from \"./AttrExpressionParser\";\nimport {AdditiveOperatorParser} from \"./AdditiveOperatorParser\";\nimport {MultiplicativeOperatorParser} from \"./MultiplicativeOperatorParser\";\nimport {PrefixOperatorParser} from \"./PrefixOperatorParser\";\nimport {InvokeOperatorParser} from \"./InvokeOperatorParser\";\nimport {PrimaryParser} from \"./PrimaryParser\";\nimport {LiteralParser} from \"./LiteralParser\";\nimport {SelectorParser} from \"./SelectorParser\";\n\n/**\n * Factory for constructing Recon parsers and parse trees.\n */\nexport abstract class ReconParser<I, V> {\n  abstract isDistinct(value: V): boolean;\n\n  abstract item(value: V): I;\n\n  abstract value(item: I): V;\n\n  abstract attr(key: V, value: V): I;\n\n  abstract attr(key: V): I;\n\n  abstract slot(key: V, value: V): I;\n\n  abstract slot(key: V): I;\n\n  abstract valueBuilder(): Builder<I, V>;\n\n  abstract recordBuilder(): Builder<I, V>;\n\n  abstract dataOutput(): Output<V>;\n\n  abstract textOutput(): Output<V>;\n\n  abstract ident(value: V): V;\n\n  abstract num(value: number | string): V;\n\n  abstract uint32(value: number): V;\n\n  abstract uint64(value: number): V;\n\n  abstract bool(value: boolean): V;\n\n  abstract selector(): V;\n\n  abstract extant(): V;\n\n  abstract absent(): V;\n\n  abstract conditional(ifTerm: V, thenTerm: V, elseTerm: V): V;\n\n  abstract or(lhs: V, rhs: V): V;\n\n  abstract and(lhs: V, rhs: V): V;\n\n  abstract bitwiseOr(lhs: V, rhs: V): V;\n\n  abstract bitwiseXor(lhs: V, rhs: V): V;\n\n  abstract bitwiseAnd(lhs: V, rhs: V): V;\n\n  abstract lt(lhs: V, rhs: V): V;\n\n  abstract le(lhs: V, rhs: V): V;\n\n  abstract eq(lhs: V, rhs: V): V;\n\n  abstract ne(lhs: V, rhs: V): V;\n\n  abstract ge(lhs: V, rhs: V): V;\n\n  abstract gt(lhs: V, rhs: V): V;\n\n  abstract plus(lhs: V, rhs: V): V;\n\n  abstract minus(lhs: V, rhs: V): V;\n\n  abstract times(lhs: V, rhs: V): V;\n\n  abstract divide(lhs: V, rhs: V): V;\n\n  abstract modulo(lhs: V, rhs: V): V;\n\n  abstract not(rhs: V): V;\n\n  abstract bitwiseNot(rhs: V): V;\n\n  abstract negative(rhs: V): V;\n\n  abstract positive(rhs: V): V;\n\n  abstract invoke(func: V, args: V): V;\n\n  abstract lambda(bindings: V, template: V): V;\n\n  abstract get(selector: V, key: V): V;\n\n  abstract getAttr(selector: V, key: V): V;\n\n  abstract getItem(selector: V, index: V): I;\n\n  abstract children(selector: V): V;\n\n  abstract descendants(selector: V): V;\n\n  abstract keys(selector: V): V;\n\n  abstract values(selector: V): V;\n\n  abstract filter(selector: V, predicate: V): V;\n\n  parseBlock(input: Input): Parser<V> {\n    return BlockParser.parse(input, this);\n  }\n\n  parseAttr(input: Input): Parser<I> {\n    return AttrParser.parse(input, this);\n  }\n\n  parseBlockItem(input: Input): Parser<V> {\n    return BlockItemParser.parse(input, this);\n  }\n\n  parseInlineItem(input: Input): Parser<V> {\n    return InlineItemParser.parse(input, this);\n  }\n\n  parseRecord(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return RecordParser.parse(input, this, builder);\n  }\n\n  parseMarkup(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return MarkupParser.parse(input, this, builder);\n  }\n\n  parseData(input: Input): Parser<V> {\n    return DataParser.parse(input, this);\n  }\n\n  parseIdent(input: Input): Parser<V> {\n    return IdentParser.parse(input, this);\n  }\n\n  parseString(input: Input): Parser<V> {\n    return StringParser.parse(input, this);\n  }\n\n  parseNumber(input: Input): Parser<V> {\n    return NumberParser.parse(input, this);\n  }\n\n  parseInteger(input: Input): Parser<V> {\n    return NumberParser.parseInteger(input, this);\n  }\n\n  parseBlockExpression(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return this.parseLambdaFunc(input, builder);\n  }\n\n  parseLambdaFunc(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return LambdaFuncParser.parse(input, this, builder);\n  }\n\n  parseConditionalOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return ConditionalOperatorParser.parse(input, this, builder);\n  }\n\n  parseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return OrOperatorParser.parse(input, this, builder);\n  }\n\n  parseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AndOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseOrOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseOrOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseXorOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseXorOperatorParser.parse(input, this, builder);\n  }\n\n  parseBitwiseAndOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return BitwiseAndOperatorParser.parse(input, this, builder);\n  }\n\n  parseComparisonOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return ComparisonOperatorParser.parse(input, this, builder);\n  }\n\n  parseAttrExpression(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AttrExpressionParser.parse(input, this, builder);\n  }\n\n  parseAdditiveOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return AdditiveOperatorParser.parse(input, this, builder);\n  }\n\n  parseMultiplicativeOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return MultiplicativeOperatorParser.parse(input, this, builder);\n  }\n\n  parsePrefixOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return PrefixOperatorParser.parse(input, this, builder);\n  }\n\n  parseInvokeOperator(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return InvokeOperatorParser.parse(input, this, builder);\n  }\n\n  parsePrimary(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return PrimaryParser.parse(input, this, builder);\n  }\n\n  parseLiteral(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return LiteralParser.parse(input, this, builder);\n  }\n\n  parseSelector(input: Input, builder?: Builder<I, V>): Parser<V> {\n    return SelectorParser.parse(input, this, builder);\n  }\n\n  blockParser(): Parser<V> {\n    return new BlockParser<I, V>(this);\n  }\n\n  parseBlockString(string: string): V {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Recon.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = this.parseBlock(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Recon.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n\n  /** @hidden */\n  parseNumberString(string: string): V {\n    let input = Unicode.stringInput(string);\n    while (input.isCont() && Recon.isWhitespace(input.head())) {\n      input = input.step();\n    }\n    let parser = this.parseNumber(input);\n    if (parser.isDone()) {\n      while (input.isCont() && Recon.isWhitespace(input.head())) {\n        input = input.step();\n      }\n    }\n    if (input.isCont() && !parser.isError()) {\n      parser = Parser.error(Diagnostic.unexpected(input));\n    }\n    return parser.bind();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Builder} from \"@swim/util\";\nimport {Output} from \"@swim/codec\";\nimport {\n  Item,\n  Attr,\n  Slot,\n  Value,\n  Record,\n  Data,\n  Text,\n  Num,\n  Bool,\n  Selector,\n  AndOperator,\n  BitwiseAndOperator,\n  BitwiseNotOperator,\n  BitwiseOrOperator,\n  BitwiseXorOperator,\n  DivideOperator,\n  EqOperator,\n  GeOperator,\n  GtOperator,\n  InvokeOperator,\n  LeOperator,\n  LtOperator,\n  MinusOperator,\n  ModuloOperator,\n  NeOperator,\n  NegativeOperator,\n  NotOperator,\n  OrOperator,\n  PlusOperator,\n  PositiveOperator,\n  TimesOperator,\n} from \"@swim/structure\";\nimport {ReconParser} from \"./ReconParser\";\n\nexport class ReconStructureParser extends ReconParser<Item, Value> {\n  isDistinct(value: Value): boolean {\n    return value.isDistinct();\n  }\n\n  item(value: Value): Item {\n    return value;\n  }\n\n  value(item: Item): Value {\n    return item.toValue();\n  }\n\n  attr(key: Value, value?: Value): Item {\n    return Attr.of.apply(Attr, arguments);\n  }\n\n  slot(key: Value, value?: Value): Item {\n    return Slot.of.apply(Slot, arguments);\n  }\n\n  valueBuilder(): Builder<Item, Value> {\n    return Value.builder();\n  }\n\n  recordBuilder(): Builder<Item, Value> {\n    return Record.create();\n  }\n\n  dataOutput(): Output<Value> {\n    return Data.output();\n  }\n\n  textOutput(): Output<Value> {\n    return Text.output();\n  }\n\n  ident(value: Value): Value {\n    if (value instanceof Text) {\n      const string = value.stringValue();\n      if (string === \"true\") {\n        return Bool.from(true);\n      } else if (string === \"false\") {\n        return Bool.from(false);\n      }\n    }\n    return value;\n  }\n\n  num(value: number | string): Value {\n    if (typeof value === \"number\") {\n      return Num.from(value);\n    } else if (typeof value === \"string\") {\n      return Num.from(+value);\n    } else {\n      throw new TypeError(\"\" + value);\n    }\n  }\n\n  uint32(value: number): Value {\n    return Num.uint32(value);\n  }\n\n  uint64(value: number): Value {\n    return Num.uint64(value);\n  }\n\n  bool(value: boolean): Value {\n    return Bool.from(value);\n  }\n\n  selector(): Value {\n    return Selector.identity();\n  }\n\n  extant(): Value {\n    return Value.extant();\n  }\n\n  absent(): Value {\n    return Value.absent();\n  }\n\n  conditional(ifTerm: Value, thenTerm: Value, elseTerm: Value): Value {\n    return ifTerm.conditional(thenTerm, elseTerm);\n  }\n\n  or(lhs: Value, rhs: Value): Value {\n    return new OrOperator(lhs, rhs);\n  }\n\n  and(lhs: Value, rhs: Value): Value {\n    return new AndOperator(lhs, rhs);\n  }\n\n  bitwiseOr(lhs: Value, rhs: Value): Value {\n    return new BitwiseOrOperator(lhs, rhs);\n  }\n\n  bitwiseXor(lhs: Value, rhs: Value): Value {\n    return new BitwiseXorOperator(lhs, rhs);\n  }\n\n  bitwiseAnd(lhs: Value, rhs: Value): Value {\n    return new BitwiseAndOperator(lhs, rhs);\n  }\n\n  lt(lhs: Value, rhs: Value): Value {\n    return new LtOperator(lhs, rhs);\n  }\n\n  le(lhs: Value, rhs: Value): Value {\n    return new LeOperator(lhs, rhs);\n  }\n\n  eq(lhs: Value, rhs: Value): Value {\n    return new EqOperator(lhs, rhs);\n  }\n\n  ne(lhs: Value, rhs: Value): Value {\n    return new NeOperator(lhs, rhs);\n  }\n\n  ge(lhs: Value, rhs: Value): Value {\n    return new GeOperator(lhs, rhs);\n  }\n\n  gt(lhs: Value, rhs: Value): Value {\n    return new GtOperator(lhs, rhs);\n  }\n\n  plus(lhs: Value, rhs: Value): Value {\n    return new PlusOperator(lhs, rhs);\n  }\n\n  minus(lhs: Value, rhs: Value): Value {\n    return new MinusOperator(lhs, rhs);\n  }\n\n  times(lhs: Value, rhs: Value): Value {\n    return new TimesOperator(lhs, rhs);\n  }\n\n  divide(lhs: Value, rhs: Value): Value {\n    return new DivideOperator(lhs, rhs);\n  }\n\n  modulo(lhs: Value, rhs: Value): Value {\n    return new ModuloOperator(lhs, rhs);\n  }\n\n  not(rhs: Value): Value {\n    return new NotOperator(rhs);\n  }\n\n  bitwiseNot(rhs: Value): Value {\n    return new BitwiseNotOperator(rhs);\n  }\n\n  negative(rhs: Value): Value {\n    if (rhs instanceof Num) {\n      return rhs.negative();\n    } else {\n      return new NegativeOperator(rhs);\n    }\n  }\n\n  positive(rhs: Value): Value {\n    return new PositiveOperator(rhs);\n  }\n\n  invoke(func: Value, args: Value): Value {\n    return new InvokeOperator(func, args);\n  }\n\n  lambda(bindings: Value, template: Value): Value {\n    return bindings.lambda(template);\n  }\n\n  get(selector: Value, key: Value): Value {\n    return selector.get(key);\n  }\n\n  getAttr(selector: Value, key: Value): Value {\n    return selector.getAttr(key as Text);\n  }\n\n  getItem(selector: Value, index: Value): Item {\n    return selector.getItem(index as Num);\n  }\n\n  children(selector: Value): Value {\n    return Selector.literal(selector).children();\n  }\n\n  descendants(selector: Value): Value {\n    return Selector.literal(selector).descendants();\n  }\n\n  keys(selector: Value): Value {\n    return Selector.literal(selector).keys();\n  }\n\n  values(selector: Value): Value {\n    return Selector.literal(selector).values();\n  }\n\n  filter(selector: Value, predicate: Value): Value {\n    return selector.filter(predicate);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class AttrWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _key: V;\n  private readonly _value: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, value: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._key = key;\n    this._value = value;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return AttrWriter.write(output, this._recon, this._key, this._value, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, value: V): number {\n    let size = 0;\n    size += 1; // '@'\n    size += recon.sizeOfValue(key);\n    if (!recon.isExtant(recon.item(value))) {\n      size += 1; // '(';\n      size += recon.sizeOfBlockValue(value);\n      size += 1; // ')';\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, value: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(64/*'@'*/);\n      step = 2;\n    }\n    if (step === 2) {\n      if (!part) {\n        part = recon.writeValue(key, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        if (recon.isExtant(recon.item(value))) {\n          return Writer.done();\n        } else {\n          step = 3;\n        }\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(40/*'('*/);\n      step = 4;\n    }\n    if (step === 4) {\n      if (!part) {\n        part = recon.writeBlockValue(value, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 5;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(41/*')'*/);\n      return Writer.done();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new AttrWriter<I, V>(recon, key, value, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class SlotWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _key: V;\n  private readonly _value: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, value: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._key = key;\n    this._value = value;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return SlotWriter.write(output, this._recon, this._key, this._value, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, value: V): number {\n    let size = 0;\n    size += recon.sizeOfValue(key);\n    size += 1; // ':'\n    if (!recon.isExtant(recon.item(value))) {\n      size += recon.sizeOfValue(value);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, value: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (!part) {\n        part = recon.writeValue(key, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      if (recon.isExtant(recon.item(value))) {\n        return Writer.done();\n      } else {\n        step = 3;\n      }\n    }\n    if (step === 3) {\n      if (!part) {\n        part = recon.writeValue(value, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.done();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new SlotWriter<I, V>(recon, key, value, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class BlockWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _items: Cursor<I>;\n  private readonly _inBlock: boolean;\n  private readonly _inMarkup: boolean;\n  private readonly _inBraces: boolean | undefined;\n  private readonly _inBrackets: boolean | undefined;\n  private readonly _first: boolean | undefined;\n  private readonly _markupSafe: boolean | undefined;\n  private readonly _item: I | undefined;\n  private readonly _next: I | undefined;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, items: Cursor<I>, inBlock: boolean, inMarkup: boolean,\n              inBraces?: boolean, inBrackets?: boolean, first?: boolean, markupSafe?: boolean,\n              item?: I, next?: I, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._items = items;\n    this._inBlock = inBlock;\n    this._inMarkup = inMarkup;\n    this._inBraces = inBraces;\n    this._inBrackets = inBrackets;\n    this._first = first;\n    this._markupSafe = markupSafe;\n    this._item = item;\n    this._next = next;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return BlockWriter.write(output, this._recon, this._items, this._inBlock, this._inMarkup,\n                             this._inBraces, this._inBrackets, this._first, this._markupSafe,\n                             this._item, this._next, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, items: Cursor<I>,\n                      inBlock: boolean, inMarkup: boolean): number {\n    let size = 0;\n    let inBraces = false;\n    let inBrackets = false;\n    let first = true;\n    let markupSafe = true;\n    let next: I | undefined;\n    while (next || items.hasNext()) {\n      let item: I | undefined;\n      if (!next ) {\n        item = items.next().value!;\n      } else {\n        item = next;\n        next = void 0;\n      }\n      if (items.hasNext()) {\n        next = items.next().value!;\n      }\n      if (recon.isExpression(item)) {\n        markupSafe = false;\n      }\n      if (inBrackets && recon.isAttr(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        }\n        size += 1; // ']'\n        inBrackets = false;\n      }\n      if (recon.isAttr(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        } else if (inBrackets) { // FIXME: case already covered?\n          size += 1; // ']'\n          inBrackets = false;\n        }\n        size += recon.sizeOfItem(item);\n        first = false;\n      } else if (inBrackets && recon.isText(item)) {\n        if (inBraces) {\n          size += 1; // '}'\n          inBraces = false;\n        }\n        size += recon.sizeOfMarkupText(item);\n      } else if (inBraces) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += BlockWriter.sizeOfBlockItem(recon, item);\n      } else if (inBrackets) {\n        if (recon.isRecord(item) && recon.isMarkupSafe(recon.items(item))) {\n          size += recon.sizeOfBlock(recon.items(item), false, true);\n          if (next && recon.isText(next)) {\n            size += recon.sizeOfMarkupText(next);\n            next = void 0;\n          } else if (next && !recon.isAttr(next)) {\n            size += 1; // '{'\n            inBraces = true;\n            first = true;\n          } else {\n            size += 1; // ']'\n            inBrackets = false;\n          }\n        } else {\n          size += 1; // '{'\n          size += recon.sizeOfItem(item);\n          inBraces = true;\n          first = false;\n        }\n      } else if (markupSafe && recon.isText(item) && next && !recon.isField(next)\n              && !recon.isText(next) && !recon.isBool(next)) {\n        size += 1; // '['\n        size += recon.sizeOfMarkupText(item);\n        inBrackets = true;\n      } else if (inBlock && !inBraces) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += BlockWriter.sizeOfBlockItem(recon, item);\n      } else if (inMarkup && recon.isText(item) && !next) {\n        size += 1; // '['\n        size += recon.sizeOfMarkupText(item);\n        size += 1; // ']'\n      } else if (!inMarkup && recon.isValue(item) && !recon.isRecord(item)\n             && (!first && !next || next && recon.isAttr(next))) {\n        if (!first && (recon.isText(item) && recon.isIdent(item)\n                    || recon.isNum(item) || recon.isBool(item))) {\n          size += 1; // ' '\n        }\n        size += recon.sizeOfItem(item);\n      } else {\n        size += 1; // '{'\n        size += recon.sizeOfItem(item);\n        inBraces = true;\n        first = false;\n      }\n    }\n    if (inBraces) {\n      size += 1; // '}'\n    }\n    if (inBrackets) {\n      size += 1; // ']'\n    }\n    return size;\n  }\n\n  static sizeOfBlockItem<I, V>(recon: ReconWriter<I, V>, item: I): number {\n    let size = 0;\n    if (recon.isField(item)) {\n      size += recon.sizeOfSlot(recon.key(item), recon.value(item));\n    } else {\n      size += recon.sizeOfItem(item);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, items: Cursor<I>,\n                     inBlock: boolean, inMarkup: boolean, inBraces: boolean = false,\n                     inBrackets: boolean = false, first: boolean = true, markupSafe: boolean = true,\n                     item?: I, next?: I, part?: Writer, step: number = 1): Writer {\n    do {\n      if (step === 1) {\n        if (!next && !items.hasNext()) {\n          step = 10;\n          break;\n        } else {\n          if (!next) {\n            item = items.next().value!;\n          } else {\n            item = next;\n            next = void 0;\n          }\n          if (items.hasNext()) {\n            next = items.next().value!;\n          }\n          if (recon.isExpression(item)) {\n            markupSafe = false;\n          }\n          step = 2;\n        }\n      }\n      if (step === 2 && output.isCont()) {\n        if (inBrackets && recon.isAttr(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          }\n          step = 3;\n        } else {\n          step = 4;\n        }\n      }\n      if (step === 3 && output.isCont()) {\n        output = output.write(93/*']'*/);\n        inBrackets = false;\n        step = 4;\n      }\n      if (step === 4 && output.isCont()) {\n        if (recon.isAttr(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          } else if (inBrackets) {\n            output = output.write(93/*']'*/);\n            inBrackets = false;\n          }\n          part = recon.writeItem(item!, output);\n          first = false;\n          step = 7;\n        } else if (inBrackets && recon.isText(item!)) {\n          if (inBraces) {\n            output = output.write(125/*'}'*/);\n            inBraces = false;\n          }\n          part = recon.writeMarkupText(item!, output);\n          step = 7;\n        } else if (inBraces) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = BlockWriter.writeBlockItem(output, recon, item!);\n          step = 7;\n        } else if (inBrackets) {\n          if (recon.isRecord(item!) && recon.isMarkupSafe(recon.items(item!))) {\n            part = recon.writeBlock(recon.items(item!), output, false, true);\n            step = 5;\n          } else {\n            output = output.write(123/*'{'*/);\n            part = recon.writeItem(item!, output);\n            inBraces = true;\n            first = false;\n            step = 7;\n          }\n        } else if (markupSafe && recon.isText(item!) && next && !recon.isField(next)\n                && !recon.isText(next) && !recon.isBool(next)) {\n          output = output.write(91/*'['*/);\n          part = recon.writeMarkupText(item!, output);\n          inBrackets = true;\n          step = 7;\n        } else if (inBlock && !inBraces) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = BlockWriter.writeBlockItem(output, recon, item!);\n          step = 7;\n        } else if (inMarkup && recon.isText(item!) && !next) {\n          output = output.write(91/*'['*/);\n          part = recon.writeMarkupText(item!, output);\n          step = 8;\n        } else if (!inMarkup && recon.isValue(item!) && !recon.isRecord(item!)\n               && (!first && !next || next && recon.isAttr(next))) {\n          if (!first && (recon.isText(item!) && recon.isIdent(item!)\n                      || recon.isNum(item!) || recon.isBool(item!))) {\n            output = output.write(32/*' '*/);\n          }\n          part = recon.writeItem(item!, output);\n          step = 7;\n        } else {\n          output = output.write(123/*'{'*/);\n          part = recon.writeItem(item!, output);\n          inBraces = true;\n          first = false;\n          step = 7;\n        }\n      }\n      if (step === 5) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 6;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 6 && output.isCont()) {\n        if (next && recon.isText(next)) {\n          part = recon.writeMarkupText(next, output);\n          next = void 0;\n          step = 7;\n        } else if (next && !recon.isAttr(next)) {\n          output = output.write(123/*'{'*/);\n          inBraces = true;\n          first = true;\n          step = 1;\n          continue;\n        } else {\n          output = output.write(93/*']'*/);\n          inBrackets = false;\n          step = 1;\n          continue;\n        }\n      }\n      if (step === 7) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 1;\n          continue;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 8) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 9;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      if (step === 9 && output.isCont()) {\n        output = output.write(93/*']'*/);\n        step = 1;\n        continue;\n      }\n      break;\n    } while (true);\n    if (step === 10) {\n      if (inBraces) {\n        if (output.isCont()) {\n          output = output.write(125/*'}'*/);\n          step = 11;\n        }\n      } else {\n        step = 11;\n      }\n    }\n    if (step === 11) {\n      if (inBrackets) {\n        if (output.isCont()) {\n          output = output.write(93/*']'*/);\n          return Writer.done();\n        }\n      } else {\n        return Writer.done();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new BlockWriter<I, V>(recon, items, inBlock, inMarkup, inBraces, inBrackets,\n                                 first, markupSafe, item, next, part, step);\n  }\n\n  static writeBlockItem<I, V>(output: Output, recon: ReconWriter<I, V>, item: I): Writer {\n    if (recon.isField(item)) {\n      return recon.writeSlot(recon.key(item), recon.value(item), output);\n    } else {\n      return recon.writeItem(item, output);\n    }\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class PrimaryWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _items: Cursor<I>;\n  private readonly _inParens: boolean | undefined;\n  private readonly _first: boolean | undefined;\n  private readonly _item: I | undefined;\n  private readonly _next: I | undefined;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, items: Cursor<I>, inParens?: boolean,\n              first?: boolean, item?: I, next?: I, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._items = items;\n    this._inParens = inParens;\n    this._first = first;\n    this._item = item;\n    this._next = next;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return PrimaryWriter.write(output, this._recon, this._items, this._inParens, this._first,\n                               this._item, this._next, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, items: Cursor<I>): number {\n    let size = 0;\n    let inParens = false;\n    let first = true;\n    let next: I | undefined;\n    while (next || items.hasNext()) {\n      let item: I | undefined;\n      if (!next) {\n        item = items.next().value!;\n      } else {\n        item = next;\n        next = void 0;\n      }\n      if (items.hasNext()) {\n        next = items.next().value!;\n      }\n      if (!inParens && !first) {\n        size += 1; // ' '\n      }\n      if (recon.isAttr(item)) {\n        if (inParens) {\n          size += 1; // ')'\n          inParens = false;\n        }\n        size += recon.sizeOfItem(item);\n        first = false;\n      } else if (inParens) {\n        if (!first) {\n          size += 1; // ','\n        } else {\n          first = false;\n        }\n        size += recon.sizeOfBlockItem(item);\n      } else if (recon.isValue(item) && !recon.isRecord(item)\n             && (!first && !next || next && recon.isAttr(next))) {\n        size += recon.sizeOfItem(item);\n      } else {\n        size += 1; // '('\n        size += recon.sizeOfItem(item);\n        inParens = true;\n        first = false;\n      }\n    }\n    if (inParens) {\n      size += 1; // ')'\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, items: Cursor<I>,\n                     inParens: boolean = false, first: boolean = true, item?: I,\n                     next?: I, part?: Writer, step: number = 1): Writer {\n    do {\n      if (step === 1) {\n        if (!next && !items.hasNext()) {\n          step = 5;\n          break;\n        } else {\n          if (!next) {\n            item = items.next().value!;\n          } else {\n            item = next;\n            next = void 0;\n          }\n          if (items.hasNext()) {\n            next = items.next().value!;\n          }\n          step = 2;\n        }\n      }\n      if (step === 2 && output.isCont()) {\n        if (!inParens && !first) {\n          output = output.write(32/*' '*/);\n        }\n        step = 3;\n      }\n      if (step === 3 && output.isCont()) {\n        if (recon.isAttr(item!)) {\n          if (inParens) {\n            output = output.write(41/*')'*/);\n            inParens = false;\n          }\n          part = recon.writeItem(item!, output);\n          first = false;\n          step = 4;\n        } else if (inParens) {\n          if (!first) {\n            output = output.write(44/*','*/);\n          } else {\n            first = false;\n          }\n          part = recon.writeBlockItem(item!, output);\n          step = 4;\n        } else if (recon.isValue(item!) && !recon.isRecord(item!)\n               && (!first && !next || next && recon.isAttr(next))) {\n          part = recon.writeItem(item!, output);\n          step = 4;\n        } else {\n          output = output.write(40/*'('*/);\n          part = recon.writeItem(item!, output);\n          inParens = true;\n          first = false;\n          step = 4;\n        }\n      }\n      if (step === 4) {\n        part = part!.pull(output);\n        if (part.isDone()) {\n          part = void 0;\n          step = 1;\n          continue;\n        } else if (part.isError()) {\n          return part.asError();\n        }\n      }\n      break;\n    } while (true);\n    if (step === 5) {\n      if (inParens) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.done();\n        }\n      } else {\n        return Writer.done();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new PrimaryWriter<I, V>(recon, items, inParens, first, item, next, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Utf8, Base16} from \"@swim/codec\";\n\n/** @hidden */\nexport class MarkupTextWriter extends Writer {\n  private readonly _text: string;\n  private readonly _index: number | undefined;\n  private readonly _escape: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(text: string, index?: number, escape?: number, step?: number) {\n    super();\n    this._text = text;\n    this._index = index;\n    this._escape = escape;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return MarkupTextWriter.write(output, this._text, this._index, this._escape, this._step);\n  }\n\n  static sizeOf(text: string): number {\n    let size = 0;\n    for (let i = 0, n = text.length; i < n; i = text.offsetByCodePoints(i, 1)) {\n      let c = text.codePointAt(i);\n      if (c === void 0) {\n        c = text.charCodeAt(i);\n      }\n      if (c === 36/*'$'*/ || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/\n          || c === 93/*']'*/ || c === 123/*'{'*/ || c === 125/*'}'*/ || c === 8/*'\\b'*/\n          || c === 12/*'\\f'*/ || c === 10/*'\\n'*/ || c === 13/*'\\r'*/ || c === 9/*'\\t'*/) {\n        size += 2;\n      } else if (c < 0x20) {\n        size += 6;\n      } else {\n        size += Utf8.sizeOf(c);\n      }\n    }\n    return size;\n  }\n\n  static write(output: Output, text: string, index: number = 0,\n               escape: number = 0, step: number = 1): Writer {\n    const length = text.length;\n    while (output.isCont()) {\n      if (step === 1) {\n        if (index < length) {\n          let c = text.codePointAt(index);\n          if (c === void 0) {\n            c = text.charCodeAt(index);\n          }\n          index = text.offsetByCodePoints(index, 1);\n          if (c === 36/*'$'*/ || c === 64/*'@'*/ || c === 91/*'['*/ || c === 92/*'\\\\'*/\n              || c === 93/*']'*/ || c === 123/*'{'*/ || c === 125/*'}'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 2;\n          } else if (c === 8/*'\\b'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 98/*'b'*/;\n            step = 2;\n          } else if (c === 12/*'\\f'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 102/*'f'*/;\n            step = 2;\n          } else if (c === 10/*'\\n'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 110/*'n'*/;\n            step = 2;\n          } else if (c === 13/*'\\r'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 114/*'r'*/;\n            step = 2;\n          } else if (c === 9/*'\\t'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 116/*'t'*/;\n            step = 2;\n          } else if (c < 0x20) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 3;\n          } else {\n            output = output.write(c);\n          }\n        } else {\n          return Writer.done();\n        }\n      } else if (step === 2) {\n        output = output.write(escape);\n        escape = 0;\n        step = 1;\n      } else if (step === 3) {\n        output = output.write(117/*'u'*/);\n        step = 4;\n      } else if (step === 4) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));\n        step = 5;\n      } else if (step === 5) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));\n        step = 6;\n      } else if (step === 6) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));\n        step = 7;\n      } else if (step === 7) {\n        output = output.write(Base16.uppercase().encodeDigit(escape & 0xf));\n        escape = 0;\n        step = 1;\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new MarkupTextWriter(text, index, escape, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Base64} from \"@swim/codec\";\n\n/** @hidden */\nexport class DataWriter extends Writer {\n  private readonly _array: Uint8Array;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(array: Uint8Array, part?: Writer, step?: number) {\n    super();\n    this._array = array;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return DataWriter.write(output, this._array, this._part, this._step);\n  }\n\n  static sizeOf(length: number): number {\n    return 1 + ((Math.floor(length * 4 / 3) + 3) & ~3);\n  }\n\n  static write(output: Output, array: Uint8Array, part?: Writer,\n               step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(37/*'%'*/);\n      step = 2;\n    }\n    if (step === 2) {\n      if (!part) {\n        part = Base64.standard().writeUint8Array(array, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        return Writer.done();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new DataWriter(array, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Utf8} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\n\n/** @hidden */\nexport class IdentWriter extends Writer {\n  private readonly _ident: string;\n  private readonly _index: number | undefined;\n\n  constructor(ident: string, index?: number) {\n    super();\n    this._ident = ident;\n    this._index = index;\n  }\n\n  pull(output: Output): Writer {\n    return IdentWriter.write(output, this._ident, this._index);\n  }\n\n  static sizeOf(ident: string): number {\n    return Utf8.sizeOf(ident);\n  }\n\n  static write(output: Output, ident: string, index: number = 0): Writer {\n    let c: number | undefined;\n    const length = ident.length;\n    if (length === 0) {\n      return Writer.error(new WriterException(\"empty identifier\"));\n    }\n    if (index === 0 && output.isCont()) {\n      c = ident.codePointAt(0);\n      if (c === void 0) {\n        c = ident.charCodeAt(0);\n      }\n      if (Recon.isIdentStartChar(c)) {\n        output = output.write(c);\n        index = ident.offsetByCodePoints(0, 1);\n      }\n    }\n    while (index < length && output.isCont()) {\n      c = ident.codePointAt(index);\n      if (c === void 0) {\n        c = ident.charCodeAt(index);\n      }\n      if (Recon.isIdentChar(c)) {\n        output = output.write(c);\n        index = ident.offsetByCodePoints(index, 1);\n      } else {\n        return Writer.error(new WriterException(\"invalid identifier\"));\n      }\n    }\n    if (index >= length) {\n      return Writer.done();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new IdentWriter(ident, index);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Utf8, Base16} from \"@swim/codec\";\n\n/** @hidden */\nexport class StringWriter extends Writer {\n  private readonly _string: string;\n  private readonly _index: number | undefined;\n  private readonly _escape: number | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(string: string, index?: number, escape?: number, step?: number) {\n    super();\n    this._string = string;\n    this._index = index;\n    this._escape = escape;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return StringWriter.write(output, this._string, this._index, this._escape, this._step);\n  }\n\n  static sizeOf(string: string): number {\n    let size = 0;\n    size += 1; // '\"';\n    for (let i = 0, n = string.length; i < n; i = string.offsetByCodePoints(i, 1)) {\n      let c = string.codePointAt(i);\n      if (c === void 0) {\n        c = string.charCodeAt(i);\n      }\n      if (c === 34/*'\"'*/ || c === 92/*'\\\\'*/ || c === 8/*'\\b'*/ || c === 12/*'\\f'*/\n          || c === 10/*'\\n'*/ || c === 13/*'\\r'*/ || c === 9/*'\\t'*/) {\n        size += 2;\n      } else if (c < 0x20) {\n        size += 6;\n      } else {\n        size += Utf8.sizeOf(c);\n      }\n    }\n    size += 1; // '\"';\n    return size;\n  }\n\n  static write(output: Output, string: string, index: number = 0, escape: number = 0,\n               step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(34/*'\"'*/);\n      step = 2;\n    }\n    const length = string.length;\n    while (step >= 2 && step <= 8 && output.isCont()) {\n      if (step === 2) {\n        if (index < length) {\n          let c = string.codePointAt(index);\n          if (c === void 0) {\n            c = string.charCodeAt(index);\n          }\n          index = string.offsetByCodePoints(index, 1);\n          if (c === 34/*'\"'*/ || c === 92/*'\\\\'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = c;\n            step = 3;\n          } else if (c === 8/*'\\b'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 98/*'b'*/;\n            step = 3;\n          } else if (c === 12/*'\\f'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 102/*'f'*/;\n            step = 3;\n          } else if (c === 10/*'\\n'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 110/*'n'*/;\n            step = 3;\n          } else if (c === 13/*'\\r'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 114/*'r'*/;\n            step = 3;\n          } else if (c === 9/*'\\t'*/) {\n            output = output.write(92/*'\\\\'*/);\n            escape = 116/*'t'*/;\n            step = 3;\n          } else if (c < 0x20) {\n            output = output.write('\\\\');\n            escape = c;\n            step = 4;\n          } else {\n            output = output.write(c);\n          }\n        } else {\n          step = 9;\n          break;\n        }\n      } else if (step === 3) {\n        output = output.write(escape);\n        escape = 0;\n        step = 2;\n      } else if (step === 4) {\n        output = output.write(117/*'u'*/);\n        step = 5;\n      } else if (step === 5) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 12) & 0xf));\n        step = 6;\n      } else if (step === 6) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 8) & 0xf));\n        step = 7;\n      } else if (step === 7) {\n        output = output.write(Base16.uppercase().encodeDigit((escape >>> 4) & 0xf));\n        step = 8;\n      } else if (step === 8) {\n        output = output.write(Base16.uppercase().encodeDigit(escape & 0xf));\n        escape = 0;\n        step = 2;\n      }\n    }\n    if (step === 9 && output.isCont()) {\n      output = output.write(34/*'\"'*/);\n      return Writer.done();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new StringWriter(string, index, escape, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class LambdaFuncWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _bindings: V;\n  private readonly _template: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, bindings: V, template: V,\n              part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._bindings = bindings;\n    this._template = template;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return LambdaFuncWriter.write(output, this._recon, this._bindings, this._template,\n                                  this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, bindings: V, template: V): number {\n    let size = 0;\n    size += recon.sizeOfPrimary(bindings);\n    size += 4; // \" => \"\n    size += recon.sizeOfValue(template);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, bindings: V, template: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (!part) {\n        part = recon.writePrimary(bindings, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(61/*'='*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(62/*'>'*/);\n      step = 5;\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 6;\n    }\n    if (step === 6) {\n      if (part == null) {\n        part = recon.writeValue(template, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.done();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new LambdaFuncWriter<I, V>(recon, bindings, template, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class ConditionalOperatorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _ifTerm: I;\n  private readonly _thenTerm: I;\n  private readonly _elseTerm: I;\n  private readonly _precedence: number;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I, elseTerm: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._ifTerm = ifTerm;\n    this._thenTerm = thenTerm;\n    this._elseTerm = elseTerm;\n    this._precedence = precedence;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return ConditionalOperatorWriter.write(output, this._recon, this._ifTerm, this._thenTerm,\n                                           this._elseTerm, this._precedence, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I,\n                      elseTerm: I, precedence: number): number {\n    let size = 0;\n    if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(ifTerm);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(ifTerm);\n    }\n    size += 3; // \" ? \"\n    size += recon.sizeOfItem(thenTerm);\n    size += 3; // \" : \"\n    size += recon.sizeOfItem(elseTerm);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, ifTerm: I, thenTerm: I, elseTerm: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (!part) {\n        part = recon.writeItem(ifTerm, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(ifTerm) > 0 && recon.precedence(ifTerm) <= precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 5;\n    }\n    if (step === 5 && output.isCont()) {\n      output = output.write(63/*'?'*/);\n      step = 6;\n    }\n    if (step === 6 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 7;\n    }\n    if (step === 7) {\n      if (!part) {\n        part = recon.writeItem(thenTerm, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 8;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 8 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 9;\n    }\n    if (step === 9 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      step = 10;\n    }\n    if (step === 10 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 11;\n    }\n    if (step === 11) {\n      if (!part) {\n        part = recon.writeItem(elseTerm, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return Writer.done();\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ConditionalOperatorWriter<I, V>(recon, ifTerm, thenTerm, elseTerm,\n                                               precedence, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Unicode, Utf8} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class InfixOperatorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _lhs: I;\n  private readonly _operator: string;\n  private readonly _rhs: I;\n  private readonly _precedence: number;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._lhs = lhs;\n    this._operator = operator;\n    this._rhs = rhs;\n    this._precedence = precedence;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return InfixOperatorWriter.write(output, this._recon, this._lhs, this._operator, this._rhs,\n                                     this._precedence, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I, precedence: number): number {\n    let size = 0;\n    if (recon.precedence(lhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(lhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(lhs);\n    }\n    size += 1; // ' '\n    size += Utf8.sizeOf(operator);\n    size += 1; // ' '\n    if (recon.precedence(rhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(rhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(rhs);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, lhs: I, operator: string, rhs: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(lhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (!part) {\n        part = recon.writeItem(lhs, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(lhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 5;\n    }\n    if (step === 5) {\n      if (!part) {\n        part = Unicode.writeString(operator, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 6;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 6 && output.isCont()) {\n      output = output.write(32/*' '*/);\n      step = 7;\n    }\n    if (step === 7) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 8;\n        }\n      } else {\n        step = 8;\n      }\n    }\n    if (step === 8) {\n      if (!part) {\n        part = recon.writeItem(rhs, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 9;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 9) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.done();\n        }\n      } else {\n        return Writer.done();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new InfixOperatorWriter<I, V>(recon, lhs, operator, rhs, precedence, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer, Unicode, Utf8} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class PrefixOperatorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _operator: string;\n  private readonly _rhs: I;\n  private readonly _precedence: number;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, operator: string, rhs: I,\n              precedence: number, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._operator = operator;\n    this._rhs = rhs;\n    this._precedence = precedence;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return PrefixOperatorWriter.write(output, this._recon, this._operator, this._rhs,\n                                      this._precedence, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, operator: string, rhs: I, precedence: number): number {\n    let size = 0;\n    size += Utf8.sizeOf(operator);\n    if (recon.precedence(rhs) < precedence) {\n      size += 1; // '('\n      size += recon.sizeOfItem(rhs);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(rhs);\n    }\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, operator: string, rhs: I,\n                     precedence: number, part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (!part) {\n        part = Unicode.writeString(operator, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 3;\n        }\n      } else {\n        step = 3;\n      }\n    }\n    if (step === 3) {\n      if (!part) {\n        part = recon.writeItem(rhs, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4) {\n      if (recon.precedence(rhs) < precedence) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          return Writer.done();\n        }\n      } else {\n        return Writer.done();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new PrefixOperatorWriter<I, V>(recon, operator, rhs, precedence, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class InvokeOperatorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _func: V;\n  private readonly _args: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, func: V, args: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._func = func;\n    this._args = args;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return InvokeOperatorWriter.write(output, this._recon, this._func, this._args,\n                                      this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, func: V, args: V): number {\n    let size = 0;\n    size += recon.sizeOfValue(func);\n    size += 1; // '('\n    size += recon.sizeOfBlockValue(args);\n    size += 1; // ')'\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, func: V, args: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (!part) {\n        part = recon.writeValue(func, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 2;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(40/*'('*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (!part) {\n        part = recon.writeBlockValue(args, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(41/*')'*/);\n      return Writer.done();\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new InvokeOperatorWriter<I, V>(recon, func, args, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class LiteralSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _item: I;\n  private readonly _then: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, item: I, then: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._item = item;\n    this._then = then;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return LiteralSelectorWriter.write(output, this._recon, this._item, this._then,\n                                       this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, item: I, then: V): number {\n    let size = 0;\n    if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n      size += 1; // '('\n      size += recon.sizeOfItem(item);\n      size += 1; // ')'\n    } else {\n      size += recon.sizeOfItem(item);\n    }\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, item: I, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1) {\n      if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n        if (output.isCont()) {\n          output = output.write(40/*'('*/);\n          step = 2;\n        }\n      } else {\n        step = 2;\n      }\n    }\n    if (step === 2) {\n      if (!part) {\n        part = recon.writeItem(item, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 3;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 3) {\n      if (recon.precedence(item) < recon.precedence(recon.item(then))) {\n        if (output.isCont()) {\n          output = output.write(41/*')'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new LiteralSelectorWriter<I, V>(recon, item, then, part, step);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class GetSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _key: V;\n  private readonly _then: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, then: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._key = key;\n    this._then = then;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return GetSelectorWriter.write(output, this._recon, this._key, this._then, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, then: V): number {\n    let size = 1; // '$' | '.'\n    if (recon.isRecord(recon.item(key))) {\n      size += 1; // '{'\n      size += recon.sizeOfBlockValue(key);\n      size += 1; // '}'\n    } else {\n      size += recon.sizeOfValue(key);\n    }\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (recon.isRecord(recon.item(key))) {\n        if (output.isCont()) {\n          output = output.write(123/*'{'*/);\n          step = 4;\n        }\n      } else {\n        step = 4;\n      }\n    }\n    if (step === 4) {\n      if (!part) {\n        if (recon.isRecord(recon.item(key))) {\n          part = recon.writeBlockValue(key, output);\n        } else {\n          part = recon.writeValue(key, output);\n        }\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 5;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 5) {\n      if (recon.isRecord(recon.item(key))) {\n        if (output.isCont()) {\n          output = output.write(125/*'}'*/);\n          step = 6;\n        }\n      } else {\n        step = 6;\n      }\n    }\n    if (step === 6) {\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetSelectorWriter<I, V>(recon, key, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V): Writer {\n    return GetSelectorWriter.write(output, recon, key, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class GetAttrSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _key: V;\n  private readonly _then: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, key: V, then: V, part?: Writer, step?: number) {\n    super();\n    this._recon  = recon;\n    this._key = key;\n    this._then = then;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return GetAttrSelectorWriter.write(output, this._recon, this._key, this._then,\n                                       this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, key: V, then: V): number {\n    let size = 2; // ('$' | '.') '@'\n    size += recon.sizeOfValue(key);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(64/*'@'*/);\n      step = 4;\n    }\n    if (step === 4) {\n      if (!part) {\n        part = recon.writeValue(key, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return recon.writeThen(then, output);\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetAttrSelectorWriter<I, V>(recon, key, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, key: V, then: V): Writer {\n    return GetAttrSelectorWriter.write(output, recon, key, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class GetItemSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _index: V;\n  private readonly _then: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, index: V, then: V, part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._index = index;\n    this._then = then;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return GetItemSelectorWriter.write(output, this._recon, this._index, this._then,\n                                       this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, index: V, then: V): number {\n    let size = 2; // \"$#\"\n    size += recon.sizeOfValue(index);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static sizeOfThen<I, V>(recon: ReconWriter<I, V>, index: V, then: V): number {\n    let size = 1; // '#'\n    size += recon.sizeOfValue(index);\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, index: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(35/*'#'*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (!part) {\n        part = recon.writeValue(index, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        return recon.writeThen(then, output);\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new GetItemSelectorWriter<I, V>(recon, index, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, index: V, then: V): Writer {\n    return GetItemSelectorWriter.write(output, recon, index, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class KeysSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _then: V;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this._recon = recon;\n    this._then = then;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return KeysSelectorWriter.write(output, this._recon, this._then, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') '*' ':'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new KeysSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return KeysSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class ValuesSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _then: V;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this._recon = recon;\n    this._then = then;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return ValuesSelectorWriter.write(output, this._recon, this._then, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') ':' '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(58/*':'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ValuesSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return ValuesSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class ChildrenSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _then: V;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this._recon = recon;\n    this._then = then;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return ChildrenSelectorWriter.write(output, this._recon, this._then, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 2; // ('$' | '.') '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new ChildrenSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return ChildrenSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class DescendantsSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _then: V;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, then: V, step?: number) {\n    super();\n    this._recon = recon;\n    this._then = then;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return DescendantsSelectorWriter.write(output, this._recon, this._then, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, then: V): number {\n    let size = 3; // ('$' | '.') '*' '*'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, then: V,\n                     step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 3;\n    } else if (step === 2 && output.isCont()) {\n      output = output.write(46/*'.'*/);\n      step = 3;\n    }\n    if (step === 3 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      step = 4;\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(42/*'*'*/);\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new DescendantsSelectorWriter<I, V>(recon, then, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>, then: V): Writer {\n    return DescendantsSelectorWriter.write(output, recon, then, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {ReconWriter} from \"./ReconWriter\";\n\n/** @hidden */\nexport class FilterSelectorWriter<I, V> extends Writer {\n  private readonly _recon: ReconWriter<I, V>;\n  private readonly _predicate: V;\n  private readonly _then: V;\n  private readonly _part: Writer | undefined;\n  private readonly _step: number | undefined;\n\n  constructor(recon: ReconWriter<I, V>, predicate: V, then: V,\n              part?: Writer, step?: number) {\n    super();\n    this._recon = recon;\n    this._predicate = predicate;\n    this._then = then;\n    this._part = part;\n    this._step = step;\n  }\n\n  pull(output: Output): Writer {\n    return FilterSelectorWriter.write(output, this._recon, this._predicate,\n                                      this._then, this._part, this._step);\n  }\n\n  static sizeOf<I, V>(recon: ReconWriter<I, V>, predicate: V, then: V): number {\n    let size = 2; // '$' '['\n    size += recon.sizeOfValue(predicate);\n    size += 1; // ']'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static sizeOfThen<I, V>(recon: ReconWriter<I, V>, predicate: V, then: V): number {\n    let size = 1; // '['\n    size += recon.sizeOfValue(predicate);\n    size += 1; // ']'\n    size += recon.sizeOfThen(then);\n    return size;\n  }\n\n  static write<I, V>(output: Output, recon: ReconWriter<I, V>, predicate: V, then: V,\n                     part?: Writer, step: number = 1): Writer {\n    if (step === 1 && output.isCont()) {\n      output = output.write(36/*'$'*/);\n      step = 2;\n    }\n    if (step === 2 && output.isCont()) {\n      output = output.write(91/*'['*/);\n      step = 3;\n    }\n    if (step === 3) {\n      if (!part) {\n        part = recon.writeValue(predicate, output);\n      } else {\n        part = part.pull(output);\n      }\n      if (part.isDone()) {\n        part = void 0;\n        step = 4;\n      } else if (part.isError()) {\n        return part.asError();\n      }\n    }\n    if (step === 4 && output.isCont()) {\n      output = output.write(93/*']'*/);\n      return recon.writeThen(then, output);\n    }\n    if (output.isDone()) {\n      return Writer.error(new WriterException(\"truncated\"));\n    } else if (output.isError()) {\n      return Writer.error(output.trap());\n    }\n    return new FilterSelectorWriter<I, V>(recon, predicate, then, part, step);\n  }\n\n  static writeThen<I, V>(output: Output, recon: ReconWriter<I, V>,\n                         predicate: V, then: V): Writer {\n    return FilterSelectorWriter.write(output, recon, predicate, then, void 0, 2);\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Output, Writer, Unicode, Base10, Base16} from \"@swim/codec\";\nimport {Recon} from \"./Recon\";\nimport {AttrWriter} from \"./AttrWriter\";\nimport {SlotWriter} from \"./SlotWriter\";\nimport {BlockWriter} from \"./BlockWriter\";\nimport {PrimaryWriter} from \"./PrimaryWriter\";\nimport {MarkupTextWriter} from \"./MarkupTextWriter\";\nimport {DataWriter} from \"./DataWriter\";\nimport {IdentWriter} from \"./IdentWriter\";\nimport {StringWriter} from \"./StringWriter\";\nimport {LambdaFuncWriter} from \"./LambdaFuncWriter\";\nimport {ConditionalOperatorWriter} from \"./ConditionalOperatorWriter\";\nimport {InfixOperatorWriter} from \"./InfixOperatorWriter\";\nimport {PrefixOperatorWriter} from \"./PrefixOperatorWriter\";\nimport {InvokeOperatorWriter} from \"./InvokeOperatorWriter\";\nimport {LiteralSelectorWriter} from \"./LiteralSelectorWriter\";\nimport {GetSelectorWriter} from \"./GetSelectorWriter\";\nimport {GetAttrSelectorWriter} from \"./GetAttrSelectorWriter\";\nimport {GetItemSelectorWriter} from \"./GetItemSelectorWriter\";\nimport {KeysSelectorWriter} from \"./KeysSelectorWriter\";\nimport {ValuesSelectorWriter} from \"./ValuesSelectorWriter\";\nimport {ChildrenSelectorWriter} from \"./ChildrenSelectorWriter\";\nimport {DescendantsSelectorWriter} from \"./DescendantsSelectorWriter\";\nimport {FilterSelectorWriter} from \"./FilterSelectorWriter\";\n\n/**\n * Factory for constructing Recon writers.\n */\nexport abstract class ReconWriter<I, V> {\n  abstract isField(item: I): boolean;\n\n  abstract isAttr(item: I): boolean;\n\n  abstract isSlot(item: I): boolean;\n\n  abstract isValue(item: I): boolean;\n\n  abstract isRecord(item: I): boolean;\n\n  abstract isText(item: I): boolean;\n\n  abstract isNum(item: I): boolean;\n\n  abstract isBool(item: I): boolean;\n\n  abstract isExpression(item: I): boolean;\n\n  abstract isExtant(item: I): boolean;\n\n  abstract items(item: I): Cursor<I>;\n\n  abstract item(value: V): I;\n\n  abstract key(item: I): V;\n\n  abstract value(item: I): V;\n\n  abstract string(item: I): string;\n\n  abstract precedence(item: I): number;\n\n  abstract sizeOfItem(item: I): number;\n\n  abstract writeItem(item: I, output: Output): Writer;\n\n  abstract sizeOfValue(value: V): number;\n\n  abstract writeValue(value: V, output: Output): Writer;\n\n  abstract sizeOfBlockValue(value: V): number;\n\n  abstract writeBlockValue(value: V, output: Output): Writer;\n\n  sizeOfAttr(key: V, value: V): number {\n    return AttrWriter.sizeOf(this, key, value);\n  }\n\n  writeAttr(key: V, value: V, output: Output): Writer {\n    return AttrWriter.write(output, this, key, value);\n  }\n\n  sizeOfSlot(key: V, value: V): number {\n    return SlotWriter.sizeOf(this, key, value);\n  }\n\n  writeSlot(key: V, value: V, output: Output): Writer {\n    return SlotWriter.write(output, this, key, value);\n  }\n\n  abstract sizeOfBlockItem(item: I): number;\n\n  abstract writeBlockItem(item: I, output: Output): Writer;\n\n  sizeOfBlock(item: I): number;\n  sizeOfBlock(items: Cursor<I>, inBlock: boolean, inMarkup: boolean): number;\n  sizeOfBlock(item: I | Cursor<I>, inBlock?: boolean, inMarkup?: boolean): number {\n    if (arguments.length === 3) {\n      return BlockWriter.sizeOf(this, item as Cursor<I>, inBlock!, inMarkup!);\n    } else {\n      const items = this.items(item as I);\n      if (items.hasNext()) {\n        return BlockWriter.sizeOf(this, items, this.isBlockSafe(this.items(item as I)), false);\n      } else {\n        return 2; // \"{}\"\n      }\n    }\n  }\n\n  writeBlock(item: I, output: Output): Writer;\n  writeBlock(items: Cursor<I>, output: Output, inBlock: boolean, inMarkup: boolean): Writer;\n  writeBlock(item: I | Cursor<I>, output: Output, inBlock?: boolean, inMarkup?: boolean): Writer {\n    if (arguments.length === 4) {\n      return BlockWriter.write(output, this, item as Cursor<I>, inBlock!, inMarkup!);\n    } else {\n      const items = this.items(item as I);\n      if (items.hasNext()) {\n        return BlockWriter.write(output, this, items, this.isBlockSafe(this.items(item as I)), false);\n      } else {\n        return Unicode.writeString(\"{}\", output);\n      }\n    }\n  }\n\n  sizeOfRecord(item: I): number {\n    const items = this.items(item);\n    if (items.hasNext()) {\n      return BlockWriter.sizeOf(this, items, false, false);\n    } else {\n      return 2; // \"{}\"\n    }\n  }\n\n  writeRecord(item: I, output: Output): Writer {\n    const items = this.items(item);\n    if (items.hasNext()) {\n      return BlockWriter.write(output, this, items, false, false);\n    } else {\n      return Unicode.writeString(\"{}\", output);\n    }\n  }\n\n  sizeOfPrimary(value: V): number {\n    if (this.isRecord(this.item(value))) {\n      const items = this.items(this.item(value));\n      if (items.hasNext()) {\n        return PrimaryWriter.sizeOf(this, items);\n      }\n    } else if (!this.isExtant(this.item(value))) {\n      return this.sizeOfValue(value);\n    }\n    return 2; // \"()\"\n  }\n\n  writePrimary(value: V, output: Output): Writer {\n    if (this.isRecord(this.item(value))) {\n      const items = this.items(this.item(value));\n      if (items.hasNext()) {\n        return PrimaryWriter.write(output, this, items);\n      }\n    } else if (!this.isExtant(this.item(value))) {\n      return this.writeValue(value, output);\n    }\n    return Unicode.writeString(\"()\", output);\n  }\n\n  isBlockSafe(items: Cursor<I>): boolean {\n    while (items.hasNext()) {\n      if (this.isAttr(items.next().value!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  isMarkupSafe(items: Cursor<I>): boolean {\n    if (!items.hasNext() || !this.isAttr(items.next().value!)) {\n      return false;\n    }\n    while (items.hasNext()) {\n      if (this.isAttr(items.next().value!)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sizeOfMarkupText(item: I | string): number {\n    if (typeof item !== \"string\") {\n      item = this.string(item);\n    }\n    return MarkupTextWriter.sizeOf(item);\n  }\n\n  writeMarkupText(item: I | string, output: Output): Writer {\n    if (typeof item !== \"string\") {\n      item = this.string(item);\n    }\n    return MarkupTextWriter.write(output, item);\n  }\n\n  sizeOfData(length: number): number {\n    return DataWriter.sizeOf(length);\n  }\n\n  writeData(value: Uint8Array | undefined, output: Output): Writer {\n    if (value) {\n      return DataWriter.write(output, value);\n    } else {\n      return Unicode.writeString(\"%\", output);\n    }\n  }\n\n  isIdent(value: I | string): boolean {\n    if (typeof value !== \"string\") {\n      value = this.string(value);\n    }\n    const n = value.length;\n    let c: number | undefined;\n    if (n === 0 || (c = value.codePointAt(0), c !== void 0 && !Recon.isIdentStartChar(c))) {\n      return false;\n    }\n    for (let i = value.offsetByCodePoints(0, 1); i < n; i = value.offsetByCodePoints(i, 1)) {\n      c = value.codePointAt(i);\n      if (c === void 0 || !Recon.isIdentChar(c)) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  sizeOfText(value: string): number {\n    if (this.isIdent(value)) {\n      return IdentWriter.sizeOf(value);\n    } else {\n      return StringWriter.sizeOf(value);\n    }\n  }\n\n  writeText(value: string, output: Output): Writer {\n    if (this.isIdent(value)) {\n      return IdentWriter.write(output, value);\n    } else {\n      return StringWriter.write(output, value);\n    }\n  }\n\n  sizeOfNum(value: number): number {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      let size = Base10.countDigits(value);\n      if (value < 0) {\n        size += 1;\n      }\n      return size;\n    } else {\n      return (\"\" + value).length;\n    }\n  }\n\n  writeNum(value: number, output: Output): Writer {\n    if (isFinite(value) && Math.floor(value) === value && Math.abs(value) < 2147483648) {\n      return Base10.writeInteger(value, output);\n    } else {\n      return Unicode.writeString(\"\" + value, output);\n    }\n  }\n\n  sizeOfUint32(value: number): number {\n    return 10;\n  }\n\n  writeUint32(value: number, output: Output): Writer {\n    return Base16.lowercase().writeIntegerLiteral(value, output, 8);\n  }\n\n  sizeOfUint64(value: number): number {\n    return 18;\n  }\n\n  writeUint64(value: number, output: Output): Writer {\n    return Base16.lowercase().writeIntegerLiteral(value, output, 16);\n  }\n\n  sizeOfBool(value: boolean): number {\n    return value ? 4 : 5;\n  }\n\n  writeBool(value: boolean, output: Output): Writer {\n    return Unicode.writeString(value ? \"true\" : \"false\", output);\n  }\n\n  sizeOfLambdaFunc(bindings: V, template: V): number {\n    return LambdaFuncWriter.sizeOf(this, bindings, template);\n  }\n\n  writeLambdaFunc(bindings: V, template: V, output: Output): Writer {\n    return LambdaFuncWriter.write(output, this, bindings, template);\n  }\n\n  sizeOfConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number): number {\n    return ConditionalOperatorWriter.sizeOf(this, ifTerm, thenTerm, elseTerm, precedence);\n  }\n\n  writeConditionalOperator(ifTerm: I, thenTerm: I, elseTerm: I, precedence: number, output: Output): Writer {\n    return ConditionalOperatorWriter.write(output, this, ifTerm, thenTerm, elseTerm, precedence);\n  }\n\n  sizeOfInfixOperator(lhs: I, operator: string, rhs: I, precedence: number): number {\n    return InfixOperatorWriter.sizeOf(this, lhs, operator, rhs, precedence);\n  }\n\n  writeInfixOperator(lhs: I, operator: string, rhs: I, precedence: number, output: Output): Writer {\n    return InfixOperatorWriter.write(output, this, lhs, operator, rhs, precedence);\n  }\n\n  sizeOfPrefixOperator(operator: string, rhs: I, precedence: number): number {\n    return PrefixOperatorWriter.sizeOf(this, operator, rhs, precedence);\n  }\n\n  writePrefixOperator(operator: string, rhs: I, precedence: number, output: Output): Writer {\n    return PrefixOperatorWriter.write(output, this, operator, rhs, precedence);\n  }\n\n  sizeOfInvokeOperator(func: V, args: V): number {\n    return InvokeOperatorWriter.sizeOf(this, func, args);\n  }\n\n  writeInvokeOperator(func: V, args: V, output: Output): Writer {\n    return InvokeOperatorWriter.write(output, this, func, args);\n  }\n\n  abstract sizeOfThen(then: V): number;\n\n  abstract writeThen(then: V, output: Output): Writer;\n\n  sizeOfIdentitySelector(): number {\n    return 0;\n  }\n\n  writeIdentitySelector(output: Output): Writer {\n    return Writer.done();\n  }\n\n  sizeOfThenIdentitySelector(): number {\n    return 0;\n  }\n\n  writeThenIdentitySelector(output: Output): Writer {\n    return Writer.done();\n  }\n\n  sizeOfLiteralSelector(item: I, then: V): number {\n    return LiteralSelectorWriter.sizeOf(this, item, then);\n  }\n\n  writeLiteralSelector(item: I, then: V, output: Output): Writer {\n    return LiteralSelectorWriter.write(output, this, item, then);\n  }\n\n  sizeOfThenLiteralSelector(item: I, then: V): number {\n    return 0;\n  }\n\n  writeThenLiteralSelector(item: I, then: V, output: Output): Writer {\n    return Writer.done();\n  }\n\n  sizeOfGetSelector(key: V, then: V): number {\n    return GetSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeGetSelector(key: V, then: V, output: Output): Writer {\n    return GetSelectorWriter.write(output, this, key, then);\n  }\n\n  sizeOfThenGetSelector(key: V, then: V): number {\n    return GetSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeThenGetSelector(key: V, then: V, output: Output): Writer {\n    return GetSelectorWriter.writeThen(output, this, key, then);\n  }\n\n  sizeOfGetAttrSelector(key: V, then: V): number {\n    return GetAttrSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeGetAttrSelector(key: V, then: V, output: Output): Writer {\n    return GetAttrSelectorWriter.write(output, this, key, then);\n  }\n\n  sizeOfThenGetAttrSelector(key: V, then: V): number {\n    return GetAttrSelectorWriter.sizeOf(this, key, then);\n  }\n\n  writeThenGetAttrSelector(key: V, then: V, output: Output): Writer {\n    return GetAttrSelectorWriter.writeThen(output, this, key, then);\n  }\n\n  sizeOfGetItemSelector(index: V, then: V): number {\n    return GetItemSelectorWriter.sizeOf(this, index, then);\n  }\n\n  writeGetItemSelector(index: V, then: V, output: Output): Writer {\n    return GetItemSelectorWriter.write(output, this, index, then);\n  }\n\n  sizeOfThenGetItemSelector(index: V, then: V): number {\n    return GetItemSelectorWriter.sizeOfThen(this, index, then);\n  }\n\n  writeThenGetItemSelector(index: V, then: V, output: Output): Writer {\n    return GetItemSelectorWriter.writeThen(output, this, index, then);\n  }\n\n  sizeOfKeysSelector(then: V): number {\n    return KeysSelectorWriter.sizeOf(this, then);\n  }\n\n  writeKeysSelector(then: V, output: Output): Writer {\n    return KeysSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenKeysSelector(then: V): number {\n    return KeysSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenKeysSelector(then: V, output: Output): Writer {\n    return KeysSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfValuesSelector(then: V): number {\n    return ValuesSelectorWriter.sizeOf(this, then);\n  }\n\n  writeValuesSelector(then: V, output: Output): Writer {\n    return ValuesSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenValuesSelector(then: V): number {\n    return ValuesSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenValuesSelector(then: V, output: Output): Writer {\n    return ValuesSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfChildrenSelector(then: V): number {\n    return ChildrenSelectorWriter.sizeOf(this, then);\n  }\n\n  writeChildrenSelector(then: V, output: Output): Writer {\n    return ChildrenSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenChildrenSelector(then: V): number {\n    return ChildrenSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenChildrenSelector(then: V, output: Output): Writer {\n    return ChildrenSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfDescendantsSelector(then: V): number {\n    return DescendantsSelectorWriter.sizeOf(this, then);\n  }\n\n  writeDescendantsSelector(then: V, output: Output): Writer {\n    return DescendantsSelectorWriter.write(output, this, then);\n  }\n\n  sizeOfThenDescendantsSelector(then: V): number {\n    return DescendantsSelectorWriter.sizeOf(this, then);\n  }\n\n  writeThenDescendantsSelector(then: V, output: Output): Writer {\n    return DescendantsSelectorWriter.writeThen(output, this, then);\n  }\n\n  sizeOfFilterSelector(predicate: V, then: V): number {\n    return FilterSelectorWriter.sizeOf(this, predicate, then);\n  }\n\n  writeFilterSelector(predicate: V, then: V, output: Output): Writer {\n    return FilterSelectorWriter.write(output, this, predicate, then);\n  }\n\n  sizeOfThenFilterSelector(predicate: V, then: V): number {\n    return FilterSelectorWriter.sizeOfThen(this, predicate, then);\n  }\n\n  writeThenFilterSelector(predicate: V, then: V, output: Output): Writer {\n    return FilterSelectorWriter.writeThen(output, this, predicate, then);\n  }\n\n  sizeOfExtant(): number {\n    return 0;\n  }\n\n  writeExtant(output: Output): Writer {\n    return Writer.done();\n  }\n\n  sizeOfAbsent(): number {\n    return 0;\n  }\n\n  writeAbsent(output: Output): Writer {\n    return Writer.done();\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Cursor} from \"@swim/util\";\nimport {Output, WriterException, Writer} from \"@swim/codec\";\nimport {\n  Item,\n  Field,\n  Attr,\n  Slot,\n  Value,\n  Record,\n  Data,\n  Text,\n  Num,\n  Bool,\n  Expression,\n  Operator,\n  Selector,\n  Func,\n  Extant,\n  Absent,\n  ChildrenSelector,\n  DescendantsSelector,\n  FilterSelector,\n  GetAttrSelector,\n  GetItemSelector,\n  GetSelector,\n  IdentitySelector,\n  KeysSelector,\n  LiteralSelector,\n  ValuesSelector,\n  BinaryOperator,\n  ConditionalOperator,\n  InvokeOperator,\n  UnaryOperator,\n  BridgeFunc,\n  LambdaFunc,\n} from \"@swim/structure\";\nimport {ReconWriter} from \"./ReconWriter\";\n\nexport class ReconStructureWriter extends ReconWriter<Item, Value> {\n  isField(item: Item): boolean {\n    return item instanceof Field;\n  }\n\n  isAttr(item: Item): boolean {\n    return item instanceof Attr;\n  }\n\n  isSlot(item: Item): boolean {\n    return item instanceof Slot;\n  }\n\n  isValue(item: Item): boolean {\n    return item instanceof Value;\n  }\n\n  isRecord(item: Item): boolean {\n    return item instanceof Record;\n  }\n\n  isText(item: Item): boolean {\n    return item instanceof Text;\n  }\n\n  isNum(item: Item): boolean {\n    return item instanceof Num;\n  }\n\n  isBool(item: Item): boolean {\n    return item instanceof Bool;\n  }\n\n  isExpression(item: Item): boolean {\n    return item instanceof Expression;\n  }\n\n  isExtant(item: Item): boolean {\n    return item instanceof Extant;\n  }\n\n  items(item: Item): Cursor<Item> {\n    return item.iterator();\n  }\n\n  item(value: Value): Item {\n    return value;\n  }\n\n  key(item: Item): Value {\n    return item.key;\n  }\n\n  value(item: Item): Value {\n    return item.toValue();\n  }\n\n  string(item: Item): string {\n    return item.stringValue(\"\");\n  }\n\n  precedence(item: Item): number {\n    return item.precedence();\n  }\n\n  sizeOfItem(item: Item): number {\n    if (item instanceof Field) {\n      if (item instanceof Attr) {\n        return this.sizeOfAttr(item.key, item.value);\n      } else if (item instanceof Slot) {\n        return this.sizeOfSlot(item.key, item.value);\n      }\n    } else if (item instanceof Value) {\n      return this.sizeOfValue(item);\n    }\n    throw new WriterException(\"No Recon serialization for \" + item);\n  }\n\n  writeItem(item: Item, output: Output): Writer {\n    if (item instanceof Field) {\n      if (item instanceof Attr) {\n        return this.writeAttr(item.key, item.value, output);\n      } else if (item instanceof Slot) {\n        return this.writeSlot(item.key, item.value, output);\n      }\n    } else if (item instanceof Value) {\n      return this.writeValue(item, output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + item));\n  }\n\n  sizeOfValue(value: Value): number {\n    if (value instanceof Record) {\n      return this.sizeOfRecord(value);\n    } else if (value instanceof Data) {\n      return this.sizeOfData(value.size);\n    } else if (value instanceof Text) {\n      return this.sizeOfText(value.value);\n    } else if (value instanceof Num) {\n      if (value.isUint32()) {\n        return this.sizeOfUint32(value.value);\n      } else if (value.isUint64()) {\n        return this.sizeOfUint64(value.value);\n      } else {\n        return this.sizeOfNum(value.value);\n      }\n    } else if (value instanceof Bool) {\n      return this.sizeOfBool(value.value);\n    } else if (value instanceof Selector) {\n      return this.sizeOfSelector(value);\n    } else if (value instanceof Operator) {\n      return this.sizeOfOperator(value);\n    } else if (value instanceof Func) {\n      return this.sizeOfFunc(value);\n    } else if (value instanceof Extant) {\n      return this.sizeOfExtant();\n    } else if (value instanceof Absent) {\n      return this.sizeOfAbsent();\n    }\n    throw new WriterException(\"No Recon serialization for \" + value);\n  }\n\n  writeValue(value: Value, output: Output): Writer {\n    if (value instanceof Record) {\n      return this.writeRecord(value, output);\n    } else if (value instanceof Data) {\n      return this.writeData(value.asUint8Array(), output);\n    } else if (value instanceof Text) {\n      return this.writeText(value.value, output);\n    } else if (value instanceof Num) {\n      if (value.isUint32()) {\n        return this.writeUint32(value.value, output);\n      } else if (value.isUint64()) {\n        return this.writeUint64(value.value, output);\n      } else {\n        return this.writeNum(value.value, output);\n      }\n    } else if (value instanceof Bool) {\n      return this.writeBool(value.value, output);\n    } else if (value instanceof Selector) {\n      return this.writeSelector(value, output);\n    } else if (value instanceof Operator) {\n      return this.writeOperator(value, output);\n    } else if (value instanceof Func) {\n      return this.writeFunc(value, output);\n    } else if (value instanceof Extant) {\n      return this.writeExtant(output);\n    } else if (value instanceof Absent) {\n      return this.writeAbsent(output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + value));\n  }\n\n  sizeOfSelector(selector: Selector): number {\n    if (selector instanceof IdentitySelector) {\n      return this.sizeOfIdentitySelector();\n    } else if (selector instanceof LiteralSelector) {\n      return this.sizeOfLiteralSelector(selector.item(), selector.then());\n    } else if (selector instanceof GetSelector) {\n      return this.sizeOfGetSelector(selector.accessor(), selector.then());\n    } else if (selector instanceof GetAttrSelector) {\n      return this.sizeOfGetAttrSelector(selector.accessor(), selector.then());\n    } else if (selector instanceof GetItemSelector) {\n      return this.sizeOfGetItemSelector(selector.accessor(), selector.then());\n    } else if (selector instanceof KeysSelector) {\n      return this.sizeOfKeysSelector(selector.then());\n    } else if (selector instanceof ValuesSelector) {\n      return this.sizeOfValuesSelector(selector.then());\n    } else if (selector instanceof ChildrenSelector) {\n      return this.sizeOfChildrenSelector(selector.then());\n    } else if (selector instanceof DescendantsSelector) {\n      return this.sizeOfDescendantsSelector(selector.then());\n    } else if (selector instanceof FilterSelector) {\n      return this.sizeOfFilterSelector(selector.predicate(), selector.then());\n    }\n    throw new WriterException(\"No Recon serialization for \" + selector);\n  }\n\n  writeSelector(selector: Selector, output: Output): Writer {\n    if (selector instanceof IdentitySelector) {\n      return this.writeIdentitySelector(output);\n    } else if (selector instanceof LiteralSelector) {\n      return this.writeLiteralSelector(selector.item(), selector.then(), output);\n    } else if (selector instanceof GetSelector) {\n      return this.writeGetSelector(selector.accessor(), selector.then(), output);\n    } else if (selector instanceof GetAttrSelector) {\n      return this.writeGetAttrSelector(selector.accessor(), selector.then(), output);\n    } else if (selector instanceof GetItemSelector) {\n      return this.writeGetItemSelector(selector.accessor(), selector.then(), output);\n    } else if (selector instanceof KeysSelector) {\n      return this.writeKeysSelector(selector.then(), output);\n    } else if (selector instanceof ValuesSelector) {\n      return this.writeValuesSelector(selector.then(), output);\n    } else if (selector instanceof ChildrenSelector) {\n      return this.writeChildrenSelector(selector.then(), output);\n    } else if (selector instanceof DescendantsSelector) {\n      return this.writeDescendantsSelector(selector.then(), output);\n    } else if (selector instanceof FilterSelector) {\n      return this.writeFilterSelector(selector.predicate(), selector.then(), output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + selector));\n  }\n\n  sizeOfOperator(operator: Operator): number {\n    if (operator instanceof BinaryOperator) {\n      return this.sizeOfInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence());\n    } else if (operator instanceof UnaryOperator) {\n      return this.sizeOfPrefixOperator(operator.operator(), operator.operand(), operator.precedence());\n    } else if (operator instanceof InvokeOperator) {\n      return this.sizeOfInvokeOperator(operator.func(), operator.args());\n    } else if (operator instanceof ConditionalOperator) {\n      return this.sizeOfConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence());\n    }\n    throw new WriterException(\"No Recon serialization for \" + operator);\n  }\n\n  writeOperator(operator: Operator, output: Output): Writer {\n    if (operator instanceof BinaryOperator) {\n      return this.writeInfixOperator(operator.operand1(), operator.operator(), operator.operand2(), operator.precedence(), output);\n    } else if (operator instanceof UnaryOperator) {\n      return this.writePrefixOperator(operator.operator(), operator.operand(), operator.precedence(), output);\n    } else if (operator instanceof InvokeOperator) {\n      return this.writeInvokeOperator(operator.func(), operator.args(), output);\n    } else if (operator instanceof ConditionalOperator) {\n      return this.writeConditionalOperator(operator.ifTerm(), operator.thenTerm(), operator.elseTerm(), operator.precedence(), output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + operator));\n  }\n\n  sizeOfFunc(func: Func): number {\n    if (func instanceof LambdaFunc) {\n      return this.sizeOfLambdaFunc(func.bindings(), func.template());\n    } else if (func instanceof BridgeFunc) {\n      return 0;\n    }\n    throw new WriterException(\"No Recon serialization for \" + func);\n  }\n\n  writeFunc(func: Func, output: Output): Writer {\n    if (func instanceof LambdaFunc) {\n      return this.writeLambdaFunc(func.bindings(), func.template(), output);\n    } else if (func instanceof BridgeFunc) {\n      return Writer.done();\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + func));\n  }\n\n  sizeOfBlockItem(item: Item): number {\n    if (item instanceof Field) {\n      return this.sizeOfItem(item);\n    } else if (item instanceof Value) {\n      return this.sizeOfBlockValue(item);\n    }\n    throw new WriterException(\"No Recon serialization for \" + item);\n  }\n\n  writeBlockItem(item: Item, output: Output): Writer {\n    if (item instanceof Field) {\n      return this.writeItem(item, output);\n    } else if (item instanceof Value) {\n      return this.writeBlockValue(item, output);\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + item));\n  }\n\n  sizeOfBlockValue(value: Value): number {\n    if (value instanceof Record) {\n      return this.sizeOfBlock(value);\n    }\n    return this.sizeOfValue(value);\n  }\n\n  writeBlockValue(value: Value, output: Output): Writer {\n    if (value instanceof Record) {\n      return this.writeBlock(value, output);\n    }\n    return this.writeValue(value, output);\n  }\n\n  sizeOfThen(then: Value): number {\n    if (then instanceof Selector) {\n      if (then instanceof IdentitySelector) {\n        return this.sizeOfThenIdentitySelector();\n      } else if (then instanceof LiteralSelector) {\n        return this.sizeOfThenLiteralSelector(then.item(), then.then());\n      } else if (then instanceof GetSelector) {\n        return this.sizeOfThenGetSelector(then.accessor(), then.then());\n      } else if (then instanceof GetAttrSelector) {\n        return this.sizeOfThenGetAttrSelector(then.accessor(), then.then());\n      } else if (then instanceof GetItemSelector) {\n        return this.sizeOfThenGetItemSelector(then.accessor(), then.then());\n      } else if (then instanceof KeysSelector) {\n        return this.sizeOfThenKeysSelector(then.then());\n      } else if (then instanceof ValuesSelector) {\n        return this.sizeOfThenValuesSelector(then.then());\n      } else if (then instanceof ChildrenSelector) {\n        return this.sizeOfThenChildrenSelector(then.then());\n      } else if (then instanceof DescendantsSelector) {\n        return this.sizeOfThenDescendantsSelector(then.then());\n      } else if (then instanceof FilterSelector) {\n        return this.sizeOfThenFilterSelector(then.predicate(), then.then());\n      }\n    }\n    throw new WriterException(\"No Recon serialization for \" + then);\n  }\n\n  writeThen(then: Value, output: Output): Writer {\n    if (then instanceof Selector) {\n      if (then instanceof IdentitySelector) {\n        return this.writeThenIdentitySelector(output);\n      } else if (then instanceof LiteralSelector) {\n        return this.writeThenLiteralSelector(then.item(), then.then(), output);\n      } else if (then instanceof GetSelector) {\n        return this.writeThenGetSelector(then.accessor(), then.then(), output);\n      } else if (then instanceof GetAttrSelector) {\n        return this.writeThenGetAttrSelector(then.accessor(), then.then(), output);\n      } else if (then instanceof GetItemSelector) {\n        return this.writeThenGetItemSelector(then.accessor(), then.then(), output);\n      } else if (then instanceof KeysSelector) {\n        return this.writeThenKeysSelector(then.then(), output);\n      } else if (then instanceof ValuesSelector) {\n        return this.writeThenValuesSelector(then.then(), output);\n      } else if (then instanceof ChildrenSelector) {\n        return this.writeThenChildrenSelector(then.then(), output);\n      } else if (then instanceof DescendantsSelector) {\n        return this.writeThenDescendantsSelector(then.then(), output);\n      } else if (then instanceof FilterSelector) {\n        return this.writeThenFilterSelector(then.predicate(), then.then(), output);\n      }\n    }\n    return Writer.error(new WriterException(\"No Recon serialization for \" + then));\n  }\n}\n","// Copyright 2015-2020 SWIM.AI inc.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nimport {Output, Parser, Writer, Unicode, Utf8} from \"@swim/codec\";\nimport {Item, Value, Data} from \"@swim/structure\";\nimport {ReconParser} from \"./ReconParser\";\nimport {ReconStructureParser} from \"./ReconStructureParser\";\nimport {ReconWriter} from \"./ReconWriter\";\nimport {ReconStructureWriter} from \"./ReconStructureWriter\";\n\n/**\n * Factory for constructing Recon parsers and writers.\n */\nexport class Recon {\n  private constructor() {\n    // stub\n  }\n\n  /** @hidden */\n  static isSpace(c: number): boolean {\n    return c === 0x20 || c === 0x9;\n  }\n\n  /** @hidden */\n  static isNewline(c: number): boolean {\n    return c === 0xa || c === 0xd;\n  }\n\n  /** @hidden */\n  static isWhitespace(c: number): boolean {\n    return Recon.isSpace(c) || Recon.isNewline(c);\n  }\n\n  /** @hidden */\n  static isIdentStartChar(c: number): boolean {\n    return c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x2ff\n        || c >= 0x370 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  }\n\n  /** @hidden */\n  static isIdentChar(c: number): boolean {\n    return c === 45/*'-'*/\n        || c >= 48/*'0'*/ && c <= 57/*'9'*/\n        || c >= 65/*'A'*/ && c <= 90/*'Z'*/\n        || c === 95/*'_'*/\n        || c >= 97/*'a'*/ && c <= 122/*'z'*/\n        || c === 0xb7\n        || c >= 0xc0 && c <= 0xd6\n        || c >= 0xd8 && c <= 0xf6\n        || c >= 0xf8 && c <= 0x37d\n        || c >= 0x37f && c <= 0x1fff\n        || c >= 0x200c && c <= 0x200d\n        || c >= 0x203f && c <= 0x2040\n        || c >= 0x2070 && c <= 0x218f\n        || c >= 0x2c00 && c <= 0x2fef\n        || c >= 0x3001 && c <= 0xd7ff\n        || c >= 0xf900 && c <= 0xfdcf\n        || c >= 0xfdf0 && c <= 0xfffd\n        || c >= 0x10000 && c <= 0xeffff;\n  }\n\n  private static _structureParser: ReconParser<Item, Value>;\n  private static _structureWriter: ReconWriter<Item, Value>;\n\n  static structureParser(): ReconParser<Item, Value> {\n    if (!Recon._structureParser) {\n      Recon._structureParser = new ReconStructureParser();\n    }\n    return Recon._structureParser;\n  }\n\n  static structureWriter(): ReconWriter<Item, Value> {\n    if (!Recon._structureWriter) {\n      Recon._structureWriter = new ReconStructureWriter();\n    }\n    return Recon._structureWriter;\n  }\n\n  static parse(recon: string): Value {\n    return Recon.structureParser().parseBlockString(recon);\n  }\n\n  static parser(): Parser<Value> {\n    return Recon.structureParser().blockParser();\n  }\n\n  static sizeOf(item: Item): number {\n    return Recon.structureWriter().sizeOfItem(item);\n  }\n\n  static sizeOfBlock(item: Item): number {\n    return Recon.structureWriter().sizeOfBlockItem(item);\n  }\n\n  static write(item: Item, output: Output): Writer {\n    return Recon.structureWriter().writeItem(item, output);\n  }\n\n  static writeBlock(item: Item, output: Output): Writer {\n    return Recon.structureWriter().writeBlockItem(item, output);\n  }\n\n  static toString(item: Item): string {\n    const output = Unicode.stringOutput();\n    Recon.write(item, output);\n    return output.bind();\n  }\n\n  static toBlockString(item: Item): string {\n    const output = Unicode.stringOutput();\n    Recon.writeBlock(item, output);\n    return output.bind();\n  }\n\n  static toData(item: Item): Data {\n    const output = Utf8.encodedOutput(Data.output());\n    Recon.write(item, output);\n    return output.bind();\n  }\n\n  static toBlockData(item: Item): Data {\n    const output = Utf8.encodedOutput(Data.output());\n    Recon.writeBlock(item, output);\n    return output.bind();\n  }\n}\n\nItem.prototype.toRecon = function (): string {\n  return Recon.toString(this);\n};\n\nItem.prototype.toReconBlock = function (): string {\n  return Recon.toBlockString(this);\n};\n\nValue.parseRecon = function (recon: string): Value {\n  return Recon.parse(recon);\n};\n"]}